{"version":3,"file":"photostructure.js","mappings":"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","sources":["webpack://@photostructure/library/../core/AppName.ts","webpack://@photostructure/library/../core/Array.ts","webpack://@photostructure/library/../core/BatchClusterObserver.ts","webpack://@photostructure/library/../core/BoundedList.ts","webpack://@photostructure/library/../core/Buffer.ts","webpack://@photostructure/library/../core/CaseInsensitiveMap.ts","webpack://@photostructure/library/../core/CaseInsensitiveValued.ts","webpack://@photostructure/library/../core/Chalk.ts","webpack://@photostructure/library/../core/CountingSet.ts","webpack://@photostructure/library/../core/DefaultSensitiveEnvRegexPattern.ts","webpack://@photostructure/library/../core/Elapsed.ts","webpack://@photostructure/library/../core/EnvTokens.ts","webpack://@photostructure/library/../core/ExtensibleFunction.ts","webpack://@photostructure/library/../core/FifoCache.ts","webpack://@photostructure/library/../core/FifoCacheAsync.ts","webpack://@photostructure/library/../core/FifoSet.ts","webpack://@photostructure/library/../core/Fixed.ts","webpack://@photostructure/library/../core/HashBits.ts","webpack://@photostructure/library/../core/JSON.ts","webpack://@photostructure/library/../core/Lazy.ts","webpack://@photostructure/library/../core/Locale.ts","webpack://@photostructure/library/../core/Logger.ts","webpack://@photostructure/library/../core/MemoizedFunc.ts","webpack://@photostructure/library/../core/NoColor.ts","webpack://@photostructure/library/../core/NodeEnv.ts","webpack://@photostructure/library/../core/Number.ts","webpack://@photostructure/library/../core/Object.ts","webpack://@photostructure/library/../core/PhotoStructureVersion.ts","webpack://@photostructure/library/../core/Pid.ts","webpack://@photostructure/library/../core/Pids.ts","webpack://@photostructure/library/../core/PriorityClass.ts","webpack://@photostructure/library/../core/Ps.ts","webpack://@photostructure/library/../core/RateLimited.ts","webpack://@photostructure/library/../core/RegExp.ts","webpack://@photostructure/library/../core/Renice.ts","webpack://@photostructure/library/../core/ServiceNames.ts","webpack://@photostructure/library/../core/Set.ts","webpack://@photostructure/library/../core/Shim1.ts","webpack://@photostructure/library/../core/ShortCommandTimeoutMs.ts","webpack://@photostructure/library/../core/SortedSet.ts","webpack://@photostructure/library/../core/StartTs.ts","webpack://@photostructure/library/../core/StdoutEnded.ts","webpack://@photostructure/library/../core/StdoutWrite.ts","webpack://@photostructure/library/../core/String.ts","webpack://@photostructure/library/../core/StringCase.ts","webpack://@photostructure/library/../core/StringHash.ts","webpack://@photostructure/library/../core/StringNormalizer.ts","webpack://@photostructure/library/../core/StringSimilarity.ts","webpack://@photostructure/library/../core/StringifySorted.ts","webpack://@photostructure/library/../core/TTLSet.ts","webpack://@photostructure/library/../core/UserInfo.ts","webpack://@photostructure/library/../core/Version.ts","webpack://@photostructure/library/../core/WinDate.ts","webpack://@photostructure/library/../core/async/AbortError.ts","webpack://@photostructure/library/../core/async/Deferred.ts","webpack://@photostructure/library/../core/async/Endable.ts","webpack://@photostructure/library/../core/async/EndableWrapper.ts","webpack://@photostructure/library/../core/async/Exit.ts","webpack://@photostructure/library/../core/async/LazyAsync.ts","webpack://@photostructure/library/../core/async/Promise.ts","webpack://@photostructure/library/../core/async/PromiseTimer.ts","webpack://@photostructure/library/../core/async/Promises.ts","webpack://@photostructure/library/../core/async/TimeoutHandler.ts","webpack://@photostructure/library/../core/async/Timers.ts","webpack://@photostructure/library/../core/async/until.ts","webpack://@photostructure/library/../core/child/ChildEnv.ts","webpack://@photostructure/library/../core/child/ChildProcess.ts","webpack://@photostructure/library/../core/cli/CliConstants.ts","webpack://@photostructure/library/../core/cli/CliWrap.ts","webpack://@photostructure/library/../core/cli/DescriptionFooter.ts","webpack://@photostructure/library/../core/cli/VerifyUidGid.ts","webpack://@photostructure/library/../core/date/Date.ts","webpack://@photostructure/library/../core/date/DefaultDateTimeFormats.ts","webpack://@photostructure/library/../core/date/DurationCodec.ts","webpack://@photostructure/library/../core/date/DurationFormat.ts","webpack://@photostructure/library/../core/date/Filestamp.ts","webpack://@photostructure/library/../core/db/AutoVacuumModes.ts","webpack://@photostructure/library/../core/db/CheckpointTypes.ts","webpack://@photostructure/library/../core/db/RepairModes.ts","webpack://@photostructure/library/../core/db/SynchronousModes.ts","webpack://@photostructure/library/../core/dir/CacheDir.ts","webpack://@photostructure/library/../core/dir/ConfigDir.ts","webpack://@photostructure/library/../core/dir/DefaultDockerLibraryDir.ts","webpack://@photostructure/library/../core/dir/DefaultLibraryDir.ts","webpack://@photostructure/library/../core/dir/DesktopConfigDir.ts","webpack://@photostructure/library/../core/dir/EnvConfigDir.ts","webpack://@photostructure/library/../core/dir/FirstDir.ts","webpack://@photostructure/library/../core/dir/HomeDir.ts","webpack://@photostructure/library/../core/dir/LogDir.ts","webpack://@photostructure/library/../core/dir/PicturesDir.ts","webpack://@photostructure/library/../core/env/DevEnvFlags.ts","webpack://@photostructure/library/../core/env/Env.ts","webpack://@photostructure/library/../core/env/EnvKeys.ts","webpack://@photostructure/library/../core/env/EnvName.ts","webpack://@photostructure/library/../core/env/GetEnv.ts","webpack://@photostructure/library/../core/error/Error.ts","webpack://@photostructure/library/../core/error/ErrorCodes.ts","webpack://@photostructure/library/../core/error/ErrorFlags.ts","webpack://@photostructure/library/../core/error/ErrorTypes.ts","webpack://@photostructure/library/../core/error/OnError.ts","webpack://@photostructure/library/../core/error/WrappedError.ts","webpack://@photostructure/library/../core/error/stack.ts","webpack://@photostructure/library/../core/event/CapturingEventEmitter.ts","webpack://@photostructure/library/../core/event/DefaultSharedStateDir.ts","webpack://@photostructure/library/../core/event/EventEmitter.ts","webpack://@photostructure/library/../core/fs/Access.ts","webpack://@photostructure/library/../core/fs/ActualPath.ts","webpack://@photostructure/library/../core/fs/Ancestors.ts","webpack://@photostructure/library/../core/fs/BaseFile.ts","webpack://@photostructure/library/../core/fs/CRLF.ts","webpack://@photostructure/library/../core/fs/DefaultPaths.ts","webpack://@photostructure/library/../core/fs/DirectoryEntry.ts","webpack://@photostructure/library/../core/fs/EnsureNew.ts","webpack://@photostructure/library/../core/fs/FileCache.ts","webpack://@photostructure/library/../core/fs/FileExt.ts","webpack://@photostructure/library/../core/fs/FileStats.ts","webpack://@photostructure/library/../core/fs/FuzzyNames.ts","webpack://@photostructure/library/../core/fs/Hash.ts","webpack://@photostructure/library/../core/fs/IgnorableMountpoint.ts","webpack://@photostructure/library/../core/fs/JpegExts.ts","webpack://@photostructure/library/../core/fs/LineReader.ts","webpack://@photostructure/library/../core/fs/MkNoMedia.ts","webpack://@photostructure/library/../core/fs/Path.ts","webpack://@photostructure/library/../core/fs/PathTo.ts","webpack://@photostructure/library/../core/fs/PosixNative.ts","webpack://@photostructure/library/../core/fs/ProjectPath.ts","webpack://@photostructure/library/../core/fs/ReadFile.ts","webpack://@photostructure/library/../core/fs/ReadableBuffer.ts","webpack://@photostructure/library/../core/fs/Readdir.ts","webpack://@photostructure/library/../core/fs/SimpleDirent.ts","webpack://@photostructure/library/../core/fs/SimpleFile.ts","webpack://@photostructure/library/../core/fs/Stat.ts","webpack://@photostructure/library/../core/fs/StatSync.ts","webpack://@photostructure/library/../core/fs/StatTimeout.ts","webpack://@photostructure/library/../core/fs/StreamChunker.ts","webpack://@photostructure/library/../core/fs/StreamEnded.ts","webpack://@photostructure/library/../core/fs/Streams.ts","webpack://@photostructure/library/../core/fs/Touch.ts","webpack://@photostructure/library/../core/fs/WritableToBuffer.ts","webpack://@photostructure/library/../core/fs/WriteFile.ts","webpack://@photostructure/library/../core/fs/zcat.ts","webpack://@photostructure/library/../core/health/HealthCheckIds.ts","webpack://@photostructure/library/../core/img/CropStrategies.ts","webpack://@photostructure/library/../core/img/SharpFailOn.ts","webpack://@photostructure/library/../core/log/ConsoleLogger.ts","webpack://@photostructure/library/../core/log/ContextualLogger.ts","webpack://@photostructure/library/../core/log/DefaultLogFormatter.ts","webpack://@photostructure/library/../core/log/LogCommon.ts","webpack://@photostructure/library/../core/log/LogEntry.ts","webpack://@photostructure/library/../core/log/LogFilter.ts","webpack://@photostructure/library/../core/log/LogLevel.ts","webpack://@photostructure/library/../core/log/LogTailEntries.ts","webpack://@photostructure/library/../core/log/PlaintextLogFormatter.ts","webpack://@photostructure/library/../core/math/Average.ts","webpack://@photostructure/library/../core/math/Bits.ts","webpack://@photostructure/library/../core/math/Lerp.ts","webpack://@photostructure/library/../core/math/Radix.ts","webpack://@photostructure/library/../core/math/Rate.ts","webpack://@photostructure/library/../core/math/Vector.ts","webpack://@photostructure/library/../core/platform/IsPacked.ts","webpack://@photostructure/library/../core/platform/Platform.ts","webpack://@photostructure/library/../core/platform/isDocker.ts","webpack://@photostructure/library/../core/platform/isRaspberryPi.ts","webpack://@photostructure/library/../core/pwsh/PowerShell.ts","webpack://@photostructure/library/../core/settings/AggregateTypes.ts","webpack://@photostructure/library/../core/settings/AssetFileSortCriteria.ts","webpack://@photostructure/library/../core/settings/BooleanSetting.ts","webpack://@photostructure/library/../core/settings/BoundedFloatSetting.ts","webpack://@photostructure/library/../core/settings/BoundedIntegerSetting.ts","webpack://@photostructure/library/../core/settings/ColorDistanceFunctions.ts","webpack://@photostructure/library/../core/settings/DominantColorKmeansRunsDefault.ts","webpack://@photostructure/library/../core/settings/DominantColorPixelsDefault.ts","webpack://@photostructure/library/../core/settings/DurationSetting.ts","webpack://@photostructure/library/../core/settings/FloatSetting.ts","webpack://@photostructure/library/../core/settings/IntegerSetting.ts","webpack://@photostructure/library/../core/settings/OptionalFileSetting.ts","webpack://@photostructure/library/../core/settings/OptionalFloatSetting.ts","webpack://@photostructure/library/../core/settings/OptionalIntegerSetting.ts","webpack://@photostructure/library/../core/settings/OptionalStringSetting.ts","webpack://@photostructure/library/../core/settings/PsEnvNames.ts","webpack://@photostructure/library/../core/settings/Setting.ts","webpack://@photostructure/library/../core/settings/Settings.ts","webpack://@photostructure/library/../core/settings/SettingsDefaults.ts","webpack://@photostructure/library/../core/settings/SettingsToml.ts","webpack://@photostructure/library/../core/settings/StringArraySetting.ts","webpack://@photostructure/library/../core/settings/StringEnumSetting.ts","webpack://@photostructure/library/../core/settings/StringEnumsSetting.ts","webpack://@photostructure/library/../core/settings/StringSetting.ts","webpack://@photostructure/library/../core/settings/SystemSettings.ts","webpack://@photostructure/library/../core/settings/TagInferenceSettingValues.ts","webpack://@photostructure/library/../core/settings/Toml.ts","webpack://@photostructure/library/../core/settings/TomlStringify.ts","webpack://@photostructure/library/../core/settings/UpgradeChannels.ts","webpack://@photostructure/library/../core/settings/WrapComments.ts","webpack://@photostructure/library/../core/tags/Bname.ts","webpack://@photostructure/library/../core/tags/DateTagFormats.ts","webpack://@photostructure/library/../core/tags/DefaultCapturedAtTags.ts","webpack://@photostructure/library/../core/tags/DefaultIncludedPreviewTags.ts","webpack://@photostructure/library/../core/tags/DefaultLensMakes.ts","webpack://@photostructure/library/../core/tags/KeywordReparentingStrategies.ts","webpack://@photostructure/library/../core/tags/NameTagFormats.ts","webpack://@photostructure/library/../core/tags/NameTagOrders.ts","webpack://@photostructure/library/../core/volumes/DefaultExcludedLinuxRoots.ts","webpack://@photostructure/library/../core/volumes/DefaultIgnorableFilesystemTypes.ts","webpack://@photostructure/library/../core/volumes/PosixVolumes.ts","webpack://@photostructure/library/../core/volumes/VolumeTtls.ts","webpack://@photostructure/library/../core/web/HelmetPlugins.ts","webpack://@photostructure/library/../core/work/CpuInfo.ts","webpack://@photostructure/library/../core/work/FreeMem.ts","webpack://@photostructure/library/../core/work/MaxCpus.ts","webpack://@photostructure/library/../core/work/WorkTimeout.ts","webpack://@photostructure/library/../fe/Array.ts","webpack://@photostructure/library/../fe/ArrayCopy.ts","webpack://@photostructure/library/../fe/ArraySort.ts","webpack://@photostructure/library/../fe/AsyncRetry.ts","webpack://@photostructure/library/../fe/At.ts","webpack://@photostructure/library/../fe/Blank.ts","webpack://@photostructure/library/../fe/Boolean.ts","webpack://@photostructure/library/../fe/Clone.ts","webpack://@photostructure/library/../fe/Date.ts","webpack://@photostructure/library/../fe/DeepEql.ts","webpack://@photostructure/library/../fe/Delay.ts","webpack://@photostructure/library/../fe/Eql.ts","webpack://@photostructure/library/../fe/Error.ts","webpack://@photostructure/library/../fe/Flatten.ts","webpack://@photostructure/library/../fe/FmtList.ts","webpack://@photostructure/library/../fe/ImageSizes.ts","webpack://@photostructure/library/../fe/Iterable.ts","webpack://@photostructure/library/../fe/JSON.ts","webpack://@photostructure/library/../fe/Latch.ts","webpack://@photostructure/library/../fe/Lazy.ts","webpack://@photostructure/library/../fe/Map.ts","webpack://@photostructure/library/../fe/Maybe.ts","webpack://@photostructure/library/../fe/MultiMap.ts","webpack://@photostructure/library/../fe/NodeOrBrowser.ts","webpack://@photostructure/library/../fe/Number.ts","webpack://@photostructure/library/../fe/Object.ts","webpack://@photostructure/library/../fe/Opt.ts","webpack://@photostructure/library/../fe/Pad.ts","webpack://@photostructure/library/../fe/Pluralize.ts","webpack://@photostructure/library/../fe/Primitive.ts","webpack://@photostructure/library/../fe/Promise.ts","webpack://@photostructure/library/../fe/PromiseState.ts","webpack://@photostructure/library/../fe/Random.ts","webpack://@photostructure/library/../fe/ServiceNames.ts","webpack://@photostructure/library/../fe/SplitFirst.ts","webpack://@photostructure/library/../fe/StrEnum.ts","webpack://@photostructure/library/../fe/String.ts","webpack://@photostructure/library/../fe/ThenOrTimeout.ts","webpack://@photostructure/library/../fe/Thunk.ts","webpack://@photostructure/library/../fe/TimeoutError.ts","webpack://@photostructure/library/../fe/Units.ts","webpack://@photostructure/library/../fe/UnrefTimeout.ts","webpack://@photostructure/library/../fe/isError.ts","webpack://@photostructure/library/../fe/isFunction.ts","webpack://@photostructure/library/../fe/toA.ts","webpack://@photostructure/library/../fe/toErr.ts","webpack://@photostructure/library/../fe/toS.ts","webpack://@photostructure/library/./photostructure.ts","webpack://@photostructure/library/external commonjs \"@iarna/toml\"","webpack://@photostructure/library/external commonjs \"batch-cluster\"","webpack://@photostructure/library/external commonjs \"commander\"","webpack://@photostructure/library/external commonjs \"events\"","webpack://@photostructure/library/external commonjs \"fs-extra\"","webpack://@photostructure/library/external commonjs \"he\"","webpack://@photostructure/library/external commonjs \"luxon\"","webpack://@photostructure/library/external commonjs \"process\"","webpack://@photostructure/library/external commonjs \"type-detect\"","webpack://@photostructure/library/external commonjs \"util\"","webpack://@photostructure/library/external commonjs \"utimes\"","webpack://@photostructure/library/external node-commonjs \"child_process\"","webpack://@photostructure/library/external node-commonjs \"crypto\"","webpack://@photostructure/library/external node-commonjs \"fs\"","webpack://@photostructure/library/external node-commonjs \"fs/promises\"","webpack://@photostructure/library/external node-commonjs \"node:os\"","webpack://@photostructure/library/external node-commonjs \"node:process\"","webpack://@photostructure/library/external node-commonjs \"os\"","webpack://@photostructure/library/external node-commonjs \"path\"","webpack://@photostructure/library/external node-commonjs \"stream\"","webpack://@photostructure/library/external node-commonjs \"stream/promises\"","webpack://@photostructure/library/external node-commonjs \"timers\"","webpack://@photostructure/library/external node-commonjs \"zlib\"","webpack://@photostructure/library/webpack/bootstrap","webpack://@photostructure/library/webpack/startup"],"sourcesContent":["import { lazy } from \"../core/Lazy\"\nimport { isProd, nodeEnv } from \"./NodeEnv\"\nimport { version } from \"./Version\"\n\nexport const SimpleAppName = \"PhotoStructure\"\nexport const SimpleShortAppName = \"phstr\" // < phstr.com redirects to photostructure.com\nexport const SimpleAppNameLC = SimpleAppName.toLowerCase()\n\nexport const AppName = lazy(() => SimpleAppName + (isProd ? \"\" : `-${nodeEnv}`))\nexport const AppNameVersion = lazy(() => AppName() + \" \" + version)\n","import {\n  compact,\n  isEmpty,\n  isNotEmpty,\n  primitiveValueOfOrElse,\n  remove,\n  stepRange,\n  uniqBy\n} from \"../fe/Array\"\nimport { copyArrayTo } from \"../fe/ArrayCopy\"\nimport { sortBy } from \"../fe/ArraySort\"\nimport { notBlank } from \"../fe/Blank\"\nimport { eql } from \"../fe/Eql\"\nimport { stringify } from \"../fe/JSON\"\nimport { Defined, defined, map, mapOr } from \"../fe/Maybe\"\nimport { Maybe, MaybeNull, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { times } from \"../fe/Number\"\nimport { tap } from \"../fe/Object\"\nimport { Comparable, Primitivable, Primitive, gt, lt } from \"../fe/Primitive\"\nimport { MaybeSyncOrAsync, SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { Thunk } from \"../fe/Thunk\"\nimport { toA } from \"../fe/toA\"\nimport { stringifySorted } from \"./StringifySorted\"\n\n// TODO: INLINE\nexport { diff, remove } from \"../fe/Array\"\n\n/**\n * `minuend - subtrahend`, using eql() to compare elements.\n *\n * @template T must have a .valueOf() implementation\n * @param {T[]} minuend (haystack)\n * @param {T[]} subtrahend (needles)\n * @returns {T[]} values in `minuend` that, according to `eql()`, are\n * not in `subtrahend`. Neither arg is mutated.\n */\nexport function diffEql<T>(minuend: T[], subtrahend: T[]): T[] {\n  return minuend.filter(ea => !subtrahend.some(eb => eql(ea, eb)))\n}\n\n// Extract the element type of an array:\nexport type ElementType<T extends readonly unknown[]> = T[number]\n// type T = ElementType<SomeArrayType[]>\n\n/**\n * @return true iff all `objects` are neither `undefined` nor `null`. Note\n * that `[]` returns true.\n */\nexport function allDefined<T>(\n  arr: MaybeNull<MaybeNull<T>[]>\n): arr is Defined<T>[] {\n  return defined(arr) && arr.every(defined)\n}\n\nexport function mapAllDefined<T, U>(\n  arr: MaybeNull<MaybeNull<T>[]>,\n  f: (t: T[]) => U\n): Maybe<U> {\n  return allDefined(arr) ? f(arr) : undefined\n}\n\nexport function mapAll<T, V>(\n  arr: MaybeNull<MaybeNull<T>[]>,\n  f: (ea: T[]) => V\n): Maybe<V> {\n  return allDefined(arr) ? f(arr) : undefined\n}\n\n/**\n * @return true iff all `objects` are `undefined` or `null`\n */\nexport function allNotDefined(objects: any[]): boolean {\n  return objects == null || objects.every(ea => ea == null)\n}\n\nexport function allNotBlank(...arr: MaybeNull<any>[]): boolean {\n  return arr != null && arr.every(notBlank)\n}\n\n/**\n * @return true iff any `objects` are `undefined` or `null`. Note that `[]`\n * returns false (as there aren't not-defined instances).\n */\nexport function anyNotDefined(objects: any[]): boolean {\n  return objects == null || objects.some(ea => ea == null)\n}\n\nexport function anyDefined(objects: any[]): boolean {\n  return objects != null && objects.some(ea => ea != null)\n}\n\nexport async function findAsync<T>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T) => MaybeSyncOrAsync<boolean>\n): PromiseMaybe<T> {\n  for (const ea of toA(arr)) {\n    if (ea != null && true === (await f(ea))) return ea\n  }\n  return\n}\n\nexport async function findLastAsync<T>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T) => MaybeSyncOrAsync<boolean>\n): PromiseMaybe<T> {\n  arr = toA(arr)\n  for (let i = arr.length - 1; i >= 0; i--) {\n    const ea = arr[i]\n    if (ea != null && true === (await f(ea))) return ea\n  }\n  return\n}\n\n/**\n * @return the first non-`null` result of `f`, or if `f` is omitted, the first\n * non-null value in `arr`.\n */\nexport function first<T, R>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T) => MaybeNull<R>\n): Maybe<R> {\n  // PERF: avoid compact() to avoid creating a new array\n  if (arr != null) {\n    for (const ea of toA(arr)) {\n      if (ea != null) {\n        const r = f(ea)\n        if (r != null) {\n          return r\n        }\n      }\n    }\n  }\n  return\n}\n\n/**\n * Return the first result from `f` that is defined.\n * @see Array#first\n * @see Later#firstDefinedLater\n */\nexport async function firstAsync<T, R>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T, index: number) => SyncOrAsync<MaybeNull<R>>\n): PromiseMaybe<R> {\n  if (arr != null) {\n    let index = -1\n    for (const t of arr) {\n      index++\n      try {\n        if (t != null) {\n          const r = await f(t, index)\n          if (r != null) {\n            return r\n          }\n        }\n      } catch (err) {\n        //\n      }\n    }\n  }\n  return undefined\n}\n\n/**\n * @see Later#firstDefinedLater\n */\nexport function firstNonEmptyThunk<T>(\n  ...thunks: Thunk<Maybe<T[]>>[]\n): Maybe<T[]> {\n  for (const t of thunks) {\n    const arr = t()\n    if (isNotEmpty(arr)) {\n      return arr\n    }\n  }\n  return\n}\n\n/**\n * @return the last value in the array that satisfies the predicate\n */\nexport function findFromIndex<T>(\n  arr: T[],\n  predicate: (t: T) => boolean,\n  fromIndex: number\n): Maybe<number> {\n  for (let i = fromIndex; i <= arr.length - 1; i++) {\n    if (predicate(arr[i])) return i\n  }\n  return\n}\n\n/**\n * @return the last value in the array that satisfies the predicate\n */\nexport function findLast<T>(arr: T[], predicate: (t: T) => boolean): Maybe<T> {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) return arr[i]\n  }\n  return\n}\n\n/**\n * @return the last index in the array that satisfies the predicate\n */\nexport function findLastIndex<T>(\n  arr: T[],\n  predicate: (t: T) => boolean\n): number {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) return i\n  }\n  return -1\n}\n\nexport function concat<T>(...arrs: (MaybeNull<T> | MaybeNull<T>[])[]): T[] {\n  const arr: T[] = []\n  for (const ea of arrs) {\n    if (Array.isArray(ea)) {\n      for (const elem of ea) {\n        if (elem != null) arr.push(elem)\n      }\n    } else if (ea != null) {\n      arr.push(ea)\n    }\n  }\n  return arr\n}\n\nexport function moveToEnd<T>(arr: T[], element: T): T[] {\n  remove(arr, element)\n  arr.push(element)\n  return arr\n}\n\nexport function moveIndexToEnd<T>(arr: T[], index: number): T[] {\n  const moved = arr[index]\n  if (moved == null) return arr\n  arr.push(moved)\n  for (let i = index; i < arr.length - 1; i++) {\n    arr[i] = arr[i + 1]\n  }\n  arr.length = arr.length - 1\n  return arr\n}\n\n/**\n * @template T must have a .valueOf() implementation\n * @return the values in both `a` and `b`\n */\nexport function intersection<T>(\n  a: T[],\n  b: T[],\n  valueOf: (t: T) => Primitive = primitiveValueOfOrElse\n): T[] {\n  const s = new Set(b.map(valueOf))\n  return a.filter(ea => s.has(valueOf(ea)))\n}\n\nexport function diceCoeff<T>(\n  a: T[],\n  b: T[],\n  valueOf: (t: T) => Primitive = primitiveValueOfOrElse\n): number {\n  if (isEmpty(a) && isEmpty(b)) return 1\n  return (intersection(a, b, valueOf).length * 2) / (a.length + b.length)\n}\n\n/**\n * @return true iff all elements in `a` are in `b` and all elements in `b` are\n * in `a`. Order is ignored. Elements must be sortable, however.\n */\nexport function eqlUnordered(a: Maybe<any[]>, b: Maybe<any[]>): boolean {\n  return a == null || b == null\n    ? false\n    : zip(sortBy(a, stringifySorted), sortBy(b, stringifySorted)).every(\n        ([x, y]) => eql(x, y)\n      )\n}\n\n/**\n * Remove the first item from `arr` where the `predicate` returns `true`.\n * @return the element removed from `arr`\n */\nexport function removeFirst<T>(\n  arr: T[],\n  predicate: (item: T, index: number, sourceArray: T[]) => boolean\n): Maybe<T> {\n  const idx = arr.findIndex(predicate)\n  return idx >= 0 ? arr.splice(idx, 1)[0] : undefined\n}\n\nexport function uniqInPlace<T>(\n  arr: T[],\n  f: (t: T) => Maybe<Primitive> = ea => stringify(ea)\n): void {\n  copyArrayTo(uniqBy(arr, f), arr)\n}\n\nexport function partition<T>(\n  arr: Iterable<T>,\n  filter: (t: T, index: number) => boolean\n): [T[], T[]] {\n  const accept: T[] = []\n  const reject: T[] = []\n  let i = 0\n  for (const ea of arr) {\n    ;(filter(ea, i++) ? accept : reject).push(ea)\n  }\n  return [accept, reject]\n}\n\nexport function isUniq<T extends Comparable>(t: T[]): boolean {\n  return t.every((ea, i) => t.indexOf(ea) === i)\n}\n\n/**\n * `Uniq -c`: return unique strings and their count\n */\nexport function uniqCount<T extends Primitive>(\n  arr: T[]\n): { t: T; count: number }[] {\n  return _uniqCount(arr.sort())\n}\n\nfunction _uniqCount<T extends Primitive>(\n  sortedArr: T[]\n): { t: T; count: number }[] {\n  if (sortedArr == null || sortedArr.length === 0) return []\n  const t = sortedArr[0]\n  const lastElem = sortedArr.lastIndexOf(t)\n  return [\n    { t, count: lastElem + 1 },\n    ..._uniqCount(sortedArr.slice(lastElem + 1))\n  ]\n}\n\nexport function mapCompact<T, R>(\n  arr: MaybeNull<T>[],\n  f: (t: T) => Maybe<R>\n): R[] {\n  return compact(compact(arr).map(f))\n}\n\nexport function toMapEntries<T, K, V>(\n  arr: T[],\n  f: (t: T) => MaybeNull<[K, V]>\n): Map<K, V> {\n  return new Map<K, V>(arr.map(f).filter(defined) as [K, V][])\n}\n\nexport function flatMap<T, U>(arr: T[], f: (t: T) => Maybe<Maybe<U>[]>): U[] {\n  return arr.reduce(\n    (prev: U[], curr: T) => prev.concat(...compact(f(curr))),\n    []\n  )\n}\n\nexport function retainLastN<T>(arr: T[], length: number): T[] {\n  if (arr.length > length) {\n    arr.splice(0, arr.length - length)\n  }\n  return arr\n}\n\nexport function retainFirstN<T>(arr: T[], length: number): T[] {\n  arr.length = Math.min(arr.length, length)\n  return arr\n}\n\nexport function zip<T1, T2>(arr1: T1[], arr2: T2[]): [T1, T2][]\nexport function zip<T1, T2, T3>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[]\n): [T1, T2, T3][]\nexport function zip<T1, T2, T3, T4>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[]\n): [T1, T2, T3, T4][]\nexport function zip<T1, T2, T3, T4, T5>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[]\n): [T1, T2, T3, T4, T5][]\nexport function zip<T1, T2, T3, T4, T5, T6>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[],\n  arr6: T6[]\n): [T1, T2, T3, T4, T5, T6][]\n// YAY TYPING IS FUN\nexport function zip<T1, T2, T3, T4, T5, T6, T7>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[],\n  arr6: T6[],\n  arr7: T7[]\n): [T1, T2, T3, T4, T5, T6, T7][]\nexport function zip<T1, T2, T3, T4, T5, T6, T7, T8>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[],\n  arr6: T6[],\n  arr7: T7[],\n  arr8: T8[]\n): [T1, T2, T3, T4, T5, T6, T7, T8][]\n\nexport function zip<T>(...arrarr: T[][]): Maybe<T>[][] {\n  const len = Math.max(...arrarr.map(ea => ea?.length ?? 0))\n  return times(len, i => arrarr.map(ea => ea?.[i]))\n}\n\nexport function flatZip<T>(...arrarr: T[][]): Maybe<T>[] {\n  const len = Math.max(...arrarr.map(ea => ea?.length ?? 0))\n  const r: T[] = []\n  times(len, i => arrarr.map(ea => r.push(ea?.[i])))\n  return r\n}\n\nexport function unFlatZip<T>(arr: T[] | Buffer, n: number): number[][] {\n  const len = arr.length / n\n  if (len !== Math.round(len))\n    throw new Error(\n      \"unFlatZip(): bad input array length \" +\n        stringify({ arr_length: arr.length, n })\n    )\n  const results = times(n, () => new Array(len))\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < n; j++) {\n      results[j][i] = arr[i * n + j]\n    }\n  }\n  return results\n}\n\n/**\n * Given [A,B,C], return [A], [A,B], [A,B,C]\n */\nexport function ancestry<T>(arr: T[]): T[][] {\n  return times(arr.length, i => arr.slice(0, i + 1))\n}\n\nexport function min<T extends Primitivable>(arr: MaybeNull<T>[]): Maybe<T> {\n  return arr[leastIndex(arr)] as Maybe<T>\n}\n\n/**\n * Return the first index into `arr` holding the least value (using `valueOf`\n * of T)\n */\nexport function leastIndex<T extends Primitivable>(\n  arr: MaybeNull<T>[]\n): number {\n  return leastIndexBy(arr, ea => ea.valueOf())\n}\n\nexport function max<T extends Primitivable>(arr: MaybeNull<T>[]): Maybe<T> {\n  return arr[greatestIndex(arr)] as Maybe<T>\n}\n\n/**\n * Return the first index into `arr` holding the largest value (using `valueOf`\n * of T)\n */\nexport function greatestIndex<T extends Primitivable>(\n  arr: MaybeNull<T>[]\n): number {\n  return greatestIndexBy(arr, ea => ea.valueOf())\n}\n\nexport function leastIndexBy<T>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<Comparable>\n): number {\n  return estIndex(arr, valueOf, (a, b) => lt(a, b))\n}\n\nexport function greatestIndexBy<T>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<Comparable>\n): number {\n  return estIndex(arr, valueOf, (a, b) => gt(a, b))\n}\n\nexport function leastBy<T>(\n  arr: Maybe<MaybeNull<T>[]>,\n  valueOf: (t: T) => Maybe<Comparable>\n): Maybe<T> {\n  return isEmpty(arr)\n    ? undefined\n    : (arr[leastIndexBy(arr, valueOf)] as Maybe<T>)\n}\n\nexport function least<T extends Comparable>(\n  arr: Maybe<MaybeNull<T>[]>\n): Maybe<T> {\n  return leastBy(arr, ea => ea)\n}\n\nexport function greatestBy<T>(\n  arr: Maybe<MaybeNull<T>[]>,\n  valueOf: (t: T) => Maybe<Comparable>\n): Maybe<T> {\n  return isEmpty(arr)\n    ? undefined\n    : (arr[greatestIndexBy(arr, valueOf)] as Maybe<T>)\n}\n\nfunction estIndex<T>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<Comparable>,\n  cmp: (a: Comparable, b: Comparable) => boolean\n): number {\n  return estIndexCtx(arr, valueOf, cmp).index\n}\n\nexport function leastByCtx<T, C extends Comparable>(\n  arr: Maybe<MaybeNull<T>[]>,\n  valueOf: (t: T) => Maybe<C>\n): Maybe<{ result: T; index: number; value: C }> {\n  const ctx = estIndexCtx(arr ?? [], valueOf, lt)\n  return arr == null || ctx == null || ctx.index < 0 || ctx.value == null\n    ? undefined\n    : { result: arr[ctx.index]!, index: ctx.index, value: ctx.value }\n}\n\nfunction estIndexCtx<T, C extends Comparable>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<C>,\n  cmp: (a: C, b: C) => boolean\n): { index: number; value: Maybe<C> } {\n  if (isEmpty(arr)) return { index: -1, value: undefined }\n\n  let result = -1\n  let value: Maybe<C>\n\n  for (let i = 0; i < arr.length; i++) {\n    const ea = arr[i]\n    if (ea != null) {\n      const v = valueOf(ea)\n      if (v != null) {\n        if (value == null || cmp(v, value) === true) {\n          result = i\n          value = v\n        }\n      }\n    }\n  }\n  return { index: result, value }\n}\n\nexport interface ArrayLike<T> {\n  length: number\n  [index: number]: Maybe<T>\n}\n\nexport function reverse<T extends ArrayLike<any>>(arr: T): T {\n  const r = []\n  for (let i = arr.length - 1; i >= 0; i--) {\n    r.push(arr[i])\n  }\n  return r as any\n}\n\nexport function batches<T>(arr: T[], batchsize: number): T[][] {\n  if (batchsize < 1) batchsize = 1\n  return stepRange(0, arr.length, Math.round(batchsize), i =>\n    arr.slice(i, i + batchsize)\n  )\n}\n\nexport function collectBatched<T1, T2>(\n  arr: T1[],\n  batchSize: number,\n  f: (batch: T1[]) => Maybe<Maybe<T2>[]>\n): T2[] {\n  const result: T2[] = []\n  for (const batchArr of batches(compact(toA(arr)), batchSize)) {\n    result.push(...compact(f(batchArr)))\n  }\n  return result\n}\n\nexport async function collectBatchedAsync<T1, T2>(\n  arr: T1[],\n  batchSize: number,\n  f: (batch: T1[]) => PromiseMaybe<Maybe<T2>[]>\n): Promise<T2[]> {\n  const result: T2[] = []\n  for (const batchArr of batches(compact(toA(arr)), batchSize)) {\n    result.push(...compact(await f(batchArr)))\n  }\n  return result\n}\n\nexport function contextFilter<T>(\n  arr: T[],\n  predicate: (t: T, idx: number, lastPass: Maybe<T>) => boolean\n): T[] {\n  let lastPass: Maybe<T>\n  return arr.filter((ea, idx) =>\n    tap(predicate(ea, idx, lastPass), result => {\n      if (result) lastPass = ea\n    })\n  )\n}\n\nexport function clusterSome<T>(arr: T[], cmp: (a: T, b: T) => boolean): T[][] {\n  const result: T[][] = []\n  for (const ea of arr) {\n    const prior = result.find(ea2 => ea2.some(ea3 => cmp(ea, ea3)))\n    if (prior) prior.push(ea)\n    else result.push([ea])\n  }\n  return result\n}\n\nexport function clusterEvery<T>(arr: T[], cmp: (a: T, b: T) => boolean): T[][] {\n  const result: T[][] = []\n  for (const ea of arr) {\n    const prior = result.find(ea2 => ea2.every(ea3 => cmp(ea, ea3)))\n    if (prior) prior.push(ea)\n    else result.push([ea])\n  }\n  return result\n}\n\nexport async function clusterAsync<T>(\n  arr: T[],\n  cmp: (a: T, b: T) => SyncOrAsync<boolean>\n): Promise<NonNullable<T>[][]> {\n  const result: NonNullable<T>[][] = []\n  outer: for (const ea of arr) {\n    for (const resultArr of result) {\n      if (\n        ea != null &&\n        (await everyAsync(resultArr, prior => cmp(ea, prior)))\n      ) {\n        resultArr.push(ea)\n        continue outer\n      }\n    }\n    if (ea != null) result.push([ea])\n  }\n  return result\n}\n\n/**\n * Return if any `f` returns true.\n * @see Array#some\n */\nexport async function someAsync<T>(\n  arr: T[],\n  f: (t: T, index: number) => SyncOrAsync<boolean>\n): Promise<boolean> {\n  if (arr != null) {\n    for (let i = 0; i < arr.length; i++) {\n      if (await f(arr[i], i)) return true\n    }\n  }\n  return false\n}\n\n/**\n * Return if every `f` returns true.\n * @see Array#every\n */\nexport async function everyAsync<T>(\n  arr: T[],\n  f: (t: T, index: number) => SyncOrAsync<boolean>\n): Promise<boolean> {\n  return isEmpty(arr) || (await Promise.all(arr.map(f))).every(ea => ea)\n}\n\nexport function firstIndexNearest<T>({\n  arr,\n  fromIndex,\n  pred,\n  maxDelta\n}: {\n  arr: T[]\n  fromIndex: number\n  pred: (t: T, index: number) => boolean\n  maxDelta: number\n}): Maybe<number> {\n  for (let i = 1; i < Math.min(maxDelta + 1, arr.length); i++) {\n    {\n      const before = fromIndex - i\n      if (before >= 0 && true === map(arr[before], ea => pred(ea, before))) {\n        return before\n      }\n    }\n    {\n      const after = fromIndex + i\n      if (after < arr.length && pred(arr[after]!, after)) return after\n    }\n  }\n  return\n}\n\nexport function dupes<T extends Primitive>(arr: Maybe<T>[]) {\n  const mm = new Map<T, number>()\n  for (const ea of arr) {\n    if (ea != null)\n      mm.set(\n        ea,\n        mapOr(mm.get(ea), i => i + 1, 1)\n      )\n  }\n  return toA(mm.entries()).filter(([, v]) => v > 1)\n}\n\nexport function leftPadArray<T>(arr: T[], minLength: number, pad: T) {\n  if (arr.length < minLength) {\n    arr.unshift(...times(minLength - arr.length, () => pad))\n  }\n  return arr\n}\n","import {\n  BatchCluster,\n  BatchClusterEmitter,\n  BatchClusterOptions\n} from \"batch-cluster\"\nimport { ExifTool } from \"exiftool-vendored\"\nimport process from \"process\"\nimport { lazy } from \"../core/Lazy\"\nimport { minuteMs, secondMs } from \"../fe/Date\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { gt0 } from \"../fe/Number\"\nimport { TimeoutError } from \"../fe/TimeoutError\"\nimport { toS } from \"../fe/toS\"\nimport { mkLogger } from \"./Logger\"\nimport { Pids, addPid } from \"./Pids\"\nimport { renice } from \"./Renice\"\nimport { ShortCommandTimeoutMs } from \"./ShortCommandTimeoutMs\"\nimport { EndableRank, EndableRanks, ending } from \"./async/Endable\"\nimport { EndableWrapper } from \"./async/EndableWrapper\"\nimport { onTimeout } from \"./async/TimeoutHandler\"\nimport { errorToS } from \"./error/Error\"\nimport { FatalErrorFlag } from \"./error/ErrorFlags\"\nimport { isIgnorableError } from \"./error/ErrorTypes\"\nimport { onError } from \"./error/OnError\"\nimport { isWin } from \"./platform/Platform\"\nimport { Settings } from \"./settings/Settings\"\nimport { commandTimeoutMs } from \"./volumes/VolumeTtls\"\n\n// TODO: move to ./proc/? ./bc/?\n/**\n * Rather than extend ExifTool or BatchCluster, just facade it to be an\n * Endable\n */\nexport class BatchClusterObserver<\n  T extends ExifTool | BatchCluster\n> extends EndableWrapper {\n  lastStartError: Maybe<Error>\n  lastInternalError: Maybe<Error>\n  lastTaskError: Maybe<Error>\n\n  constructor(\n    name: string,\n    readonly t: T,\n    rank: EndableRank = EndableRanks.service\n  ) {\n    super(\n      `proc.BatchClusterObserver(${name})`,\n      () => this.t.end(),\n      rank,\n      name === \"worker\" ? commandTimeoutMs() : ShortCommandTimeoutMs\n    )\n    // TODO: TYPESCRIPT SITS: this cast shouldn't be necessary\n    const bce: Pick<BatchClusterEmitter, \"on\"> = t\n    bce.on(\"childStart\", async bp => {\n      if (bp.pid == null) {\n        this.onError(\"No PID returned for \" + name, new TimeoutError())\n        return\n      }\n      this.logger.info(\"Started child process\", { pid: bp.pid })\n      renice(bp.pid).catch(err => this.onError(\"renice failed\", err))\n      addPid(\n        {\n          pid: bp.pid,\n          ppid: process.pid,\n          cmd: name,\n          maxAgeMs: t.options.maxProcAgeMillis + minuteMs\n        },\n        new Date()\n      )?.catch(err => this.onError(\"addPid failed for \" + name, err))\n    })\n    bce.on(\"startError\", error => {\n      this.lastStartError = error\n      this.onError(\"failed to start\", error)\n    })\n    bce.on(\"taskError\", (error, task) => {\n      if (errorToS(error).match(/timeout/) != null) onTimeout()\n      this.lastTaskError = error\n      this.onError(\"failed to run \" + map(task, ea => ea.command), error)\n    })\n    bce.on(\"fatalError\", error => {\n      this.onError(\"on(fatalError)\" + FatalErrorFlag, error)\n    })\n    bce.on(\"internalError\", error => {\n      this.lastInternalError = error\n      this.onError(\"internal error\", error)\n    })\n    bce.on(\"noTaskData\", (stdout, stderr, proc) => {\n      // This is probably due to streamFlushMillis being too aggressive.\n      const prior = t.options.streamFlushMillis\n      // Bump up the streamFlushMillis if it's not \"too big\" already, to try to\n      // avoid this in the future:\n      if (prior < secondMs) {\n        t.options.streamFlushMillis += 100\n        this.logger.warn(\"on(noTaskData): bumping up streamFlushMillis.\", {\n          prior,\n          new: t.options.streamFlushMillis,\n          stout: toS(stdout),\n          stderr: toS(stderr),\n          child_pid: proc?.pid\n        })\n      }\n    })\n    bce.on(\"endError\", err => {\n      this.logger.error(\"observeBatchCluster.endError()\", err)\n    })\n    bce.on(\"childEnd\", cp => {\n      if (gt0(cp?.pid)) {\n        this.logger.info(\"on(childExit)\", cp.pid)\n        void Pids.instance()?.onKill(cp.pid)\n      }\n    })\n  }\n\n  onError(reason: string, error: Error): void {\n    // Avoid stack overflow on end (where end error asks services to shut down,\n    // which causes an end error, which ...)\n    if (!this.t.ended && !ending() && isIgnorableError(error) === false) {\n      onError(this.name + \": \" + reason, error)\n    } else {\n      this.logger.warn(\"onError() (ending or ignorable): \" + reason, error)\n    }\n  }\n}\n\nexport function batchClusterOptions(\n  maxProcs: number,\n  loggerName: string\n): Partial<BatchClusterOptions> {\n  return {\n    maxProcs,\n    // Shut down idle procs after a minute or two (longer on Windows because\n    // forking is so expensive)\n    maxIdleMsPerProcess: (isWin ? 3 : 1) * minuteMs,\n    maxTasksPerProcess: Settings.maxTasksPerProcess.valueOrDefault,\n    // it shouldn't take longer than a second for node to spin up, but\n    // antivirus and slow external disks can cause huge latency:\n    spawnTimeoutMillis: commandTimeoutMs(),\n    // no fork-bombs\n    minDelayBetweenSpawnMillis: Settings.minDelayBetweenSpawnMs.valueOrDefault,\n    streamFlushMillis: Settings.streamFlushMs.valueOrDefault,\n    // We'll take care of it with the pid reaper:\n    cleanupChildProcs: false,\n    logger: lazy(() => mkLogger(loggerName))\n  }\n}\n","import { List } from \"../fe/List\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { clamp, times } from \"../fe/Number\"\n\nexport class BoundedList<T> implements Iterable<T>, List<T> {\n  // round-robin implementation:\n  private readonly store: T[]\n  private _length = 0\n  private _firstIndex = 0\n  constructor(readonly maxLength: number) {\n    if (maxLength > 1000)\n      throw new Error(\"BoundedList.maxLength of \" + maxLength)\n    this.store = new Array<T>(...(times(maxLength, () => null) as any))\n  }\n\n  /**\n   * @param index follows https://github.com/tc39/proposal-item-method\n   */\n  private mapIndex<U>(index: number, f: (storeIndex: number) => U): Maybe<U> {\n    index = Math.trunc(index) ?? 0\n    if (index < 0) {\n      index += this._length\n    }\n    return index < 0 || index >= this._length\n      ? undefined\n      : f((index + this._firstIndex + this.maxLength) % this.maxLength)\n  }\n\n  // [i: number]: T {\n  //   return this.get(i) as any\n  // }\n\n  /**\n   * @see https://github.com/tc39/proposal-item-method\n   */\n  at(n: number): T {\n    return this.mapIndex(n, idx => this.store[idx]) as T\n  }\n\n  /**\n   * @return the last value in this list\n   */\n  get last(): Maybe<T> {\n    return this.at(-1)\n  }\n\n  set(n: number, value: T) {\n    return this.mapIndex(n, idx => (this.store[idx] = value))\n  }\n\n  get length(): number {\n    return this._length\n  }\n\n  set length(l: number) {\n    this._length = clamp(0, this._length, l)\n  }\n\n  clear() {\n    this.length = 0\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<T> {\n      for (let i = 0; i < self.length; i++) {\n        yield self.mapIndex(i, ea => self.store[ea])!\n      }\n    }\n    return iter()\n  }\n\n  push(...items: T[]): number {\n    // Don't bother pushing more than the last maxLength items:\n    for (const item of items.slice(-this.maxLength)) {\n      if (this._length < this.maxLength) {\n        this._length++\n      } else {\n        // push 1 entry off the head:\n        this._firstIndex++\n        this._firstIndex = this._firstIndex % this.maxLength\n      }\n      this.mapIndex(this._length - 1, idx => {\n        this.store[idx] = item\n      })\n    }\n    return this._length\n  }\n\n  pop(): T | undefined {\n    return this.mapIndex(this._length - 1, idx => {\n      this._length--\n      return this.store[idx]\n    })\n  }\n\n  unshift(...items: T[]): number {\n    for (const item of items.reverse()) {\n      if (this._length < this.maxLength) {\n        this._length++\n      }\n      // push 1 entry off the head:\n      this._firstIndex--\n      this.mapIndex(0, idx => {\n        this.store[idx] = item\n        this._firstIndex = idx\n      })\n    }\n    return this._length\n  }\n\n  shift(): T | undefined {\n    return this.mapIndex(0, idx => {\n      this._firstIndex++\n      this._length--\n      return this.store[idx]\n    })\n  }\n\n  shiftOrFirst() {\n    return this.length > 1 ? this.shift() : this.at(0)\n  }\n\n  every(callbackfn: (value: T, index: number) => boolean): boolean {\n    for (let i = 0; i < this._length; i++) {\n      if (!callbackfn(this.at(i), i)) return false\n    }\n    return true\n  }\n\n  some(callbackfn: (value: T, index: number) => boolean): boolean {\n    for (let i = 0; i < this._length; i++) {\n      if (callbackfn(this.at(i), i)) return true\n    }\n    return false\n  }\n\n  forEach(callbackfn: (value: T, index: number) => void): void {\n    for (let i = 0; i < this._length; i++) {\n      callbackfn(this.at(i), i)\n    }\n  }\n\n  map<U>(callbackfn: (value: T, index: number) => U): U[] {\n    const arr = []\n    for (let i = 0; i < this._length; i++) {\n      arr.push(callbackfn(this.at(i), i))\n    }\n    return arr\n  }\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue\n    for (let i = 0; i < this._length; i++) {\n      acc = callbackfn(acc, this.at(i), i)\n    }\n    return acc\n  }\n\n  reverse(): this {\n    for (let i = 0; i < Math.floor(this._length / 2); i++) {\n      this.mapIndex(i, from => {\n        this.mapIndex(this._length - 1 - i, to => {\n          const swap = this.store[to]\n          this.store[to] = this.store[from]\n          this.store[from] = swap\n        })\n      })\n    }\n    return this\n  }\n\n  toA(): T[] {\n    return [...this]\n  }\n\n  slice(start?: number | undefined, end?: number | undefined): T[] {\n    return [...this].slice(start, end)\n  }\n\n  // sort(compareFn?: ((a: T, b: T) => number) | undefined): this {\n  //   throw new Error(\"Method not implemented.\")\n  // }\n  // indexOf(searchElement: T, fromIndex?: number | undefined): number {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // lastIndexOf(searchElement: T, fromIndex?: number | undefined): number {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];\n  // filter(callbackfn: (value: T, index: number, array: T[]) => , thisArg?: any): T[];\n  // filter(callbackfn: any, thisArg?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n  // reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n  // reduce(callbackfn: any, initialValue?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n  // reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n  // reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n  // reduceRight(callbackfn: any, initialValue?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;\n  // find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined;\n  // find(predicate: any, thisArg?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // fill(value: T, start?: number | undefined, end?: number | undefined): this {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // copyWithin(target: number, start: number, end?: number | undefined): this {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // entries(): IterableIterator<[number, T]> {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // keys(): IterableIterator<number> {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // values(): IterableIterator<T> {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // [Symbol.unscopables](): { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; } {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // includes(searchElement: T, fromIndex?: number | undefined): boolean {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n}\n","import { toS } from \"../fe/toS\"\n\nconst ByteOrderMarks: { bom: number[]; encoding: BufferEncoding }[] = [\n  { bom: [0xef, 0xbb, 0xbf], encoding: \"utf8\" },\n  { bom: [0xff, 0xfe], encoding: \"utf16le\" }\n]\n\n// tested by SettingsIO.spec.ts:\nexport function debom(b: Buffer): string {\n  for (const { bom, encoding } of ByteOrderMarks) {\n    if (bufferStartsWith(b, bom)) {\n      return b.subarray(bom.length).toString(encoding)\n    }\n  }\n  return b.toString()\n}\n\nexport function bufferToString(b: Buffer | string): string {\n  return Buffer.isBuffer(b) ? debom(b) : toS(b)\n}\n\nexport function bufferStartsWith(b: Buffer, prefix: number[]) {\n  return prefix.every((ea, idx) => b[idx] === ea)\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { DefaultNormalizer } from \"./StringNormalizer\"\n\nexport class CaseInsensitiveMap<V> implements Map<string, V> {\n  // the value contains the original-cased key\n  private readonly store = new Map<string, [string, V]>()\n\n  constructor(\n    initialContents: [string, V][] = [],\n    readonly normalizer = DefaultNormalizer\n  ) {\n    for (const [k, v] of initialContents) {\n      this.set(k, v)\n    }\n  }\n  get(key: string): Maybe<V> {\n    const k = this.normalizer(key)\n    return k == null ? undefined : this.store.get(k)?.[1]\n  }\n  lookup(key: Maybe<string>): Maybe<[string, V]> {\n    const k = this.normalizer(key)\n    return k == null ? undefined : this.store.get(k)\n  }\n  has(key: Maybe<string>): boolean {\n    const k = this.normalizer(key)\n    return k == null ? false : this.store.has(k)\n  }\n  set(key: Maybe<string>, value: V): this {\n    const k = this.normalizer(key)\n    if (key != null && k != null) this.store.set(k, [key, value])\n    return this\n  }\n  clear(): void {\n    this.store.clear()\n  }\n  delete(key: string): boolean {\n    const k = this.normalizer(key)\n    return k == null ? false : this.store.delete(k)\n  }\n  forEach(\n    callbackfn: (value: V, key: string, map: Map<string, V>) => void\n  ): void {\n    this.store.forEach(v => callbackfn(v[1], v[0], this))\n  }\n  get size(): number {\n    return this.store.size\n  }\n  entries(): IterableIterator<[string, V]> {\n    return this.store.values()\n  }\n  keys(): IterableIterator<string> {\n    return [...this.store.values()].map(ea => ea[0])[Symbol.iterator]()\n  }\n  values(): IterableIterator<V> {\n    return [...this.store.values()].map(ea => ea[1])[Symbol.iterator]()\n  }\n  [Symbol.iterator](): IterableIterator<[string, V]> {\n    return this.entries()\n  }\n  get [Symbol.toStringTag](): string {\n    return \"CaseInsensitiveMap\"\n  }\n\n  pick(...keys: string[]): Record<string, V> {\n    const result: Record<string, V> = {}\n    for (const key of keys) {\n      const l = this.lookup(key)\n      if (l != null) {\n        result[l[0]] = l[1]\n      }\n    }\n    return result\n  }\n}\n","import { uniq } from \"../fe/Array\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { MultiMap } from \"../fe/MultiMap\"\nimport * as o from \"../fe/Object\"\nimport { toA } from \"../fe/toA\"\nimport { diceCoeff } from \"./StringSimilarity\"\n\n/**\n * ONLY BASE-ASCII CASE-INSENSITIVE!\n */\nexport class CaseInsensitiveValued<V> {\n  private readonly m: MultiMap<string, string>\n  constructor(\n    readonly obj: o.Valued<V>,\n    readonly synonyms: (key: string, value: V) => Maybe<string[]> = () =>\n      undefined\n  ) {\n    this.m = new MultiMap()\n    this.vacuum()\n  }\n\n  vacuum() {\n    this.m.clear()\n    for (const [k, v] of o.entries(this.obj)) {\n      for (const key of uniq(\n        [k, ...toA(this.synonyms(k, v))].map(ea => ea.toLowerCase())\n      )) {\n        this.m.add(key, k)\n      }\n    }\n    this.m.vacuum()\n  }\n\n  lookup(key: string): Maybe<{ key: string; value: V }> {\n    if (key == null) return\n    const value = this.obj[key]\n    return value != null\n      ? { key, value }\n      : this.getFirst(this.m.get(key.toLowerCase()))\n  }\n\n  lookupNearest(key: string, minDiceCoeff = 0.4) {\n    const exact = this.lookup(key)\n    if (exact != null) return exact\n    let bestCoeff = -1\n    let best: Maybe<{ key: string; value: V }>\n    for (const [k, arr] of this.m.entries()) {\n      const coeff = diceCoeff(k, key)\n      if (coeff > minDiceCoeff && coeff > bestCoeff) {\n        const newBest = this.getFirst(arr)\n        if (newBest != null) {\n          best = newBest\n          bestCoeff = coeff\n        }\n      }\n    }\n\n    return best\n  }\n\n  get(key: string): Maybe<V> {\n    return this.lookup(key)?.value\n  }\n\n  getFirst(keys: Maybe<string[]>): Maybe<{ key: string; value: V }> {\n    if (keys == null) return\n    for (const k of keys) {\n      // return the first non-null value:\n      const value = this.obj[k]\n      if (value != null) return { key: k, value }\n    }\n    return\n  }\n\n  delete(key: string) {\n    const lc = key.toLowerCase()\n    const arr = this.m.get(lc)\n    if (arr != null) {\n      for (const k of arr) {\n        delete this.obj[k]\n      }\n      this.m.delete(lc)\n    }\n  }\n\n  pick(...keys: string[]): Record<string, V> {\n    const result: Record<string, V> = {}\n    for (const key of keys) {\n      const l = this.lookup(key)\n      if (l?.key != null) {\n        result[l.key] = l.value\n      }\n    }\n    return result\n  }\n}\n","import { noColor } from \"./NoColor\"\n\n// we're not referencing Setting.logColor here to break deploop:\nlet colorEnabled = !noColor()\n\nexport function setColorEnabled(on?: boolean) {\n  colorEnabled = on ?? !noColor()\n}\n\nfunction withAsciiEscape(on: number, off: number) {\n  return (msg: string) =>\n    colorEnabled ? `\\u001b[${on}m${msg}\\u001b[${off}m` : msg\n}\n\n// https://en.wikipedia.org/wiki/ANSI_escape_code#3/4_bit\n\nexport const reset = withAsciiEscape(0, 0)\nexport const bold = withAsciiEscape(1, 22)\nexport const dim = withAsciiEscape(2, 22)\nexport const italic = withAsciiEscape(3, 23)\nexport const underline = withAsciiEscape(4, 24)\nexport const overline = withAsciiEscape(53, 55)\nexport const inverse = withAsciiEscape(7, 27)\nexport const hidden = withAsciiEscape(8, 28)\nexport const strikethrough = withAsciiEscape(9, 29)\n\nexport const black = withAsciiEscape(30, 39)\nexport const red = withAsciiEscape(31, 39)\nexport const green = withAsciiEscape(32, 39)\nexport const yellow = withAsciiEscape(33, 39)\nexport const blue = withAsciiEscape(34, 39)\nexport const magenta = withAsciiEscape(35, 39)\nexport const cyan = withAsciiEscape(36, 39)\n\nexport const lightGrey = withAsciiEscape(37, 39)\nexport const darkGrey = withAsciiEscape(90, 39)\nexport const redBright = withAsciiEscape(91, 39)\nexport const greenBright = withAsciiEscape(92, 39)\nexport const yellowBright = withAsciiEscape(93, 39)\nexport const blueBright = withAsciiEscape(94, 39)\nexport const magentaBright = withAsciiEscape(95, 39)\nexport const cyanBright = withAsciiEscape(96, 39)\nexport const white = withAsciiEscape(97, 39)\n\nexport const bgBlack = withAsciiEscape(40, 49)\nexport const bgRed = withAsciiEscape(41, 49)\nexport const bgGreen = withAsciiEscape(42, 49)\nexport const bgYellow = withAsciiEscape(43, 49)\nexport const bgBlue = withAsciiEscape(44, 49)\nexport const bgMagenta = withAsciiEscape(45, 49)\nexport const bgCyan = withAsciiEscape(46, 49)\n\nexport const bgLightGrey = withAsciiEscape(47, 49)\nexport const bgDarkGrey = withAsciiEscape(100, 49)\nexport const bgRedBright = withAsciiEscape(101, 49)\nexport const bgGreenBright = withAsciiEscape(102, 49)\nexport const bgYellowBright = withAsciiEscape(103, 49)\nexport const bgBlueBright = withAsciiEscape(104, 49)\nexport const bgMagentaBright = withAsciiEscape(105, 49)\nexport const bgCyanBright = withAsciiEscape(106, 49)\nexport const bgWhite = withAsciiEscape(107, 49)\n\n// export function ansiColor(msg: string, rgb: Triplet) {\n//   const [r,g,b] = clampRGB(rgb)\n//   return `\\u001b[38;2;${r};${g};${b}m\"`\n// }\n","import { sort, sortBy } from \"../fe/ArraySort\"\nimport { isNumber, mapNumericOr } from \"../fe/Number\"\nimport { tap } from \"../fe/Object\"\nimport { toS } from \"../fe/toS\"\nimport { Average } from \"./math/Average\"\nimport { sum } from \"./math/Vector\"\n\nexport class CountingSet<K extends number | string> {\n  private readonly m = new Map<K, number>()\n\n  incr(key: K, count: number = 1): number {\n    const v = this.get(key) + count\n    if (v === 0) this.m.delete(key)\n    else this.m.set(key, v)\n    return v\n  }\n\n  get(key: K): number {\n    return this.m.get(key) ?? 0\n  }\n\n  /**\n   * If no keys are provided, return the max value\n   */\n  max(...arr: K[]): number {\n    return Math.max(\n      ...(arr.length === 0 ? this.m.values() : arr.map(ea => this.get(ea)))\n    )\n  }\n\n  has(key: K): boolean {\n    return this.m.has(key)\n  }\n\n  delete(key: K): boolean {\n    return this.m.delete(key)\n  }\n\n  /**\n   * Return the number of unique non-zero `incr`emented keys\n   */\n  get size(): number {\n    return this.m.size\n  }\n\n  /**\n   * Return the sum of all counts\n   */\n  get countSum(): number {\n    return sum(this.m.values())\n  }\n\n  keys(): IterableIterator<K> {\n    return this.m.keys()\n  }\n\n  /**\n   * @return if all keys are numeric, the average value of keys, otherwise, `undefined`.\n   */\n  keyAvg() {\n    const avg = new Average(0)\n    for (const k of this.keys()) {\n      if (isNumber(k)) {\n        avg.push(k)\n      } else {\n        return\n      }\n    }\n    return avg.avg\n  }\n\n  entries(): IterableIterator<[K, number]> {\n    return this.m.entries()\n  }\n\n  toJSON() {\n    return this.toRecord()\n  }\n\n  toRecord(): Record<string, number> {\n    const obj: any = {}\n    for (const [k, v] of this.m.entries()) {\n      obj[toS(k)] = v\n    }\n    return obj\n  }\n\n  /** Multimodal ties are solved by proximity to mean */\n  entriesByCountDesc(): [K, number][] {\n    const keyAvg = this.keyAvg()\n    return sortBy([...this.entries()], ([k, v]) => [\n      -v,\n      mapNumericOr(keyAvg, ea => Math.abs((k as number) - ea), 0)\n    ])\n  }\n\n  top(n = 1): [K, number][] {\n    return this.entriesByCountDesc().slice(0, n)\n  }\n\n  topKeys(n = 1): K[] {\n    return this.top(n).map(ea => ea[0])\n  }\n\n  get averageCounts(): Average {\n    return tap(new Average(this.size), a =>\n      [...this.m.values()].forEach(ea => a.push(ea))\n    )\n  }\n\n  forEach(callbackfn: (count: number, key: K) => void): void {\n    this.m.forEach(callbackfn)\n  }\n\n  clear(): void {\n    this.m.clear()\n  }\n\n  addAll(s: this) {\n    for (const [k, i] of s.entries()) {\n      this.incr(k, i)\n    }\n    return this\n  }\n\n  get toS() {\n    return sort([...this.keys()])\n      .map(key => key + \" \" + this.get(key))\n      .join(\"\\n\")\n  }\n\n  valuesToA<T>(f: (k: K) => T): T[] {\n    const arr: T[] = []\n    // pre-allocate:\n    arr.length = sum(this.m.values())\n    let idx = 0\n    for (const [k, count] of this.m.entries()) {\n      const value = f(k)\n      arr.fill(value, idx, idx + count)\n      idx += count\n    }\n    return arr\n  }\n}\n","export const DefaultSensitiveEnvRegexPattern = [\n  \"key(?!word)\",\n  \"aws_\",\n  \"npm_\",\n  \"pass\",\n  \"private\",\n  \"secret\",\n  \"token\"\n].join(\"|\")\n","import { map } from \"../fe/Maybe\"\nimport { SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { Thunk } from \"../fe/Thunk\"\nimport { Logger } from \"./Logger\"\n\nexport class Elapsed {\n  private ts = Date.now()\n  constructor(\n    readonly l: Logger,\n    readonly listener?: (name: string, elapsedMs: number) => any\n  ) {}\n\n  elapsed(msg: string) {\n    const now = Date.now()\n    const diff = now - this.ts\n    this.ts = now\n    map(this.listener, ea => ea(msg, diff))\n    if (diff > 2) {\n      this.l.log(diff > 500 ? \"warn\" : diff > 100 ? \"info\" : \"debug\", msg, {\n        elapsedMs: diff\n      })\n    }\n  }\n}\n\nexport function elapsed<T>(t: Thunk<T>): { elapsedMs: number; result: T } {\n  const start = Date.now()\n  const result = t()\n  return { elapsedMs: Date.now() - start, result }\n}\n\nexport async function thenElapsed<T>(\n  t: SyncOrAsync<T>\n): Promise<{ elapsedMs: number; result: T }> {\n  const start = Date.now()\n  const result = await t\n  return { elapsedMs: Date.now() - start, result }\n}\n","import { blank } from \"../fe/Blank\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { StringValued } from \"../fe/Object\"\nimport { splitCompactLines } from \"./fs/CRLF\"\n\n/**\n * Parser for sh environment variable assignments, like `FOO=\"bar\"`.\n *\n * NO, WE DON'T SUPPORT NEWLINES IN VALUES. Use `\\n` like a reasonable person.\n *\n * Pairs may be one per line or joined on a single line.\n *\n * \\# Comments are removed.\n */\nexport function parseEnvTokens({\n  input,\n  lowerCaseKeys\n}: {\n  input: Maybe<string>\n  lowerCaseKeys: boolean\n}): StringValued {\n  const result: StringValued = {}\n  if (blank(input)) return result\n  let m\n  for (const line of splitCompactLines(input)) {\n    const re =\n      /(?:\\s*#.*$)|\\s*(?:export\\s+)?(?<key>[a-z_]+)\\s*=\\s*([\"'])?(?<val>(?:\\\\[\"']|.)*?)(\\2)(?:$|\\s+|#.*?)\\s*/gim\n\n    while ((m = re.exec(line)) != null) {\n      if (m.groups == null) continue\n      const { key, val } = m.groups\n      if (blank(key) || val == null) continue\n      const str = val.replace(/\\\\n/g, \"\\n\").replace(/\\\\([\"'])/g, \"$1\") // unescape escaped quotes\n      // DON'T DO THIS: it makes values like \"20.10\" turn into 20.1\n      // const val = blank(quot) && isNumeric(v) ? toFloat(v) : v\n      result[lowerCaseKeys ? key.toLowerCase() : key] = str\n    }\n  }\n  return result\n}\n","export abstract class ExtensibleFunction<T> extends Function {\n  readonly _self: ExtensibleFunction<T>\n  constructor() {\n    super(\"...args\", \"return this._self._call(...args)\")\n    const self = this.bind(this)\n    this._self = self\n    return self\n  }\n  abstract _call(): T\n}\n","import { inspect } from \"util\"\nimport { isNotEmpty, uniq } from \"../fe/Array\"\nimport { GetOrSet } from \"../fe/GetOrSet\"\nimport { orElse } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { gt0, isNumber, round } from \"../fe/Number\"\nimport { toS } from \"../fe/toS\"\nimport { union } from \"./Set\"\nimport { setUnrefInterval } from \"./async/Timers\"\n\n// simple null-safe keys()\nfunction keys(o: any): string[] {\n  return o == null ? [] : Object.keys(o)\n}\n\n/**\n * First-in-first-out cache. Implementation inspired by\n * https://github.com/dominictarr/hashlru.\n *\n * https://en.wikipedia.org/wiki/Cache_replacement_policies\n */\nexport class FifoCache<V> implements GetOrSet<string, V> {\n  private currentCache!: Record<string, V>\n  private setsSinceLastSpill: number = 0\n  private priorCache!: Record<string, V>\n  private clearInterval?: NodeJS.Timeout\n\n  private readonly expireListeners: ((k: string, v: V) => void)[] = []\n\n  constructor(\n    readonly maxSize: number,\n    readonly clearEveryMs?: number\n  ) {\n    if (maxSize < 1) {\n      throw new Error(\"maxSize must be positive\")\n    }\n    if (maxSize > 30_000) {\n      // 30 seconds\n      throw new Error(\"maxSize is too big\")\n    }\n    // Set up _size and caches:\n    this.clear()\n    if (gt0(clearEveryMs)) {\n      this.clearInterval = setUnrefInterval(\n        () => {\n          this.spill()\n        },\n        round(clearEveryMs / 2)\n      )\n    }\n  }\n\n  private spill() {\n    if (\n      this.priorCache != null &&\n      this.currentCache != null &&\n      isNotEmpty(this.expireListeners)\n    ) {\n      for (const k in this.priorCache) {\n        if (this.currentCache[k] == null) {\n          const v = this.priorCache[k]\n          if (v != null) {\n            for (const el of this.expireListeners) {\n              el(k, v)\n            }\n          }\n        }\n      }\n    }\n    this.priorCache = this.currentCache ?? Object.create(null)\n    this.currentCache = Object.create(null)\n    this.setsSinceLastSpill = 0\n  }\n\n  [inspect.custom]() {\n    return {\n      ...this.priorCache,\n      ...this.currentCache\n    }\n  }\n\n  end() {\n    if (this.clearInterval != null) clearInterval(this.clearInterval)\n  }\n\n  clear(): this {\n    this.visit((k, v) => {\n      for (const el of this.expireListeners) {\n        el(k, v)\n      }\n    })\n    this.currentCache = Object.create(null)\n    this.priorCache = Object.create(null)\n    this.setsSinceLastSpill = 0\n    return this\n  }\n\n  get size(): number {\n    if (this.currentCache == null || this.priorCache == null) return 0\n    let sum = 0\n    for (const k of union(keys(this.priorCache), keys(this.currentCache))) {\n      if (this.has(k)) sum++\n    }\n    return sum\n  }\n\n  has(key: string): boolean {\n    return this.currentCache[key] != null || this.priorCache[key] != null\n  }\n\n  keys(): string[] {\n    return uniq([...keys(this.priorCache), ...keys(this.currentCache)]).filter(\n      k => null != this.currentCache[k] ?? this.priorCache[k]\n    )\n  }\n\n  delete(key: string) {\n    // We don't decrement size here, because we don't use `delete\n    // this.currentCache[key]` (because delete is slow (!!))\n    const v = this.currentCache[key]\n    if (v != null) {\n      this.currentCache[key] = undefined as any\n      for (const el of this.expireListeners) {\n        el(key, v)\n      }\n    }\n    const v2 = this.priorCache[key]\n    if (v2 != null) {\n      this.priorCache[key] = undefined as any\n      if (v == null) {\n        for (const el of this.expireListeners) {\n          el(key, v2)\n        }\n      }\n    }\n  }\n\n  visit(visitor: (key: string, value: V) => any) {\n    for (const k of union(keys(this.priorCache), keys(this.currentCache))) {\n      const v = this.currentCache[k] ?? this.priorCache[k]\n      if (v != null) visitor(k, v)\n    }\n  }\n\n  deleteIf(predicate: (key: string, value: V) => boolean) {\n    for (const k of this.keys()) {\n      const v = orElse(this.currentCache[k], this.priorCache[k])\n      if (v != null) {\n        if (predicate(k, v)) {\n          this.delete(k)\n        }\n      }\n    }\n  }\n\n  get(key: string | number): Maybe<V> {\n    key = toS(key)\n    return this.currentCache[key] ?? this.priorCache[key]\n  }\n\n  set(key: string | number, value: V) {\n    key = toS(key)\n    if (this.currentCache[key] == null) {\n      if (this.setsSinceLastSpill >= this.maxSize) this.spill()\n      this.setsSinceLastSpill++\n    }\n    this.currentCache[key] = value\n  }\n\n  getOrSet(key: string | number, valueThunk: () => V): V {\n    key = toS(key)\n    const prior = this.get(key)\n    if (prior != null) return prior\n\n    const v = valueThunk()\n    this.set(key, v)\n    return v\n  }\n\n  on(_event: \"expire\", listener: (k: string, v: V) => void) {\n    this.expireListeners.push(listener)\n  }\n}\n\nexport interface Placeholder {\n  __uid: number\n  __start: number\n}\n\nexport function isPlaceholder(s: any): s is Placeholder {\n  return s != null && isNumber(s.__uid) && isNumber(s.__start)\n}\n","import {\n  moveSync,\n  outputFile,\n  readFileSync,\n  unlink,\n  unlinkSync\n} from \"fs-extra\"\nimport { rm } from \"fs/promises\"\nimport { join } from \"path\"\nimport { lazy } from \"../core/Lazy\"\nimport { secondMs } from \"../fe/Date\"\nimport { stringify } from \"../fe/JSON\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { gt0, gte } from \"../fe/Number\"\nimport { MaybeSyncOrAsync, SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { TimeoutError } from \"../fe/TimeoutError\"\nimport { toS } from \"../fe/toS\"\nimport { bufferToString } from \"./Buffer\"\nimport { FifoCache } from \"./FifoCache\"\nimport { parseJSON } from \"./JSON\"\nimport { mkLogger } from \"./Logger\"\nimport { shortFsStringSha } from \"./StringHash\"\nimport { Deferred } from \"./async/Deferred\"\nimport { filestamp } from \"./date/Filestamp\"\nimport { isMtimeRecentSync } from \"./fs/StatSync\"\nimport { Settings } from \"./settings/Settings\"\n\n// NOTE: this is used statically by Shim, so BE CAREFUL WITH NEW CORE IMPORTS:\n// they will probably cause a dependency loop.\n\nexport type FifoCacheAsyncOpts = ConstructorParameters<typeof FifoCacheAsync>[0]\n\nexport class FifoCacheAsync<V = any> {\n  readonly #logger = lazy(() => mkLogger(this.opts.name))\n  static cacheDir: Maybe<string> // < set by configDir()\n  private cacheHitsSync = 0\n  private cacheHitsAsync = 0\n  private cacheMisses = 0\n  private rejections = 0\n  private timeouts = 0\n  readFsCache = false\n  writeFsCache = false\n  readonly cache: FifoCache<Deferred<V> | V>\n  constructor(\n    readonly opts: {\n      name: string\n      maxSize: number\n      timeoutMs: number\n      clearEveryMs?: number\n      /** does fs cache make sense for this instance? Used by shim to set the read and write flags properly */\n      useFsCache?: boolean\n      fsCacheTtlMs?: number\n      /** explicit setting only for tests: */\n      readFsCache?: boolean\n      /** explicit setting only for tests: */\n      writeFsCache?: boolean\n    }\n  ) {\n    this.cache = new FifoCache(opts.maxSize, opts.clearEveryMs)\n    this.readFsCache = opts.readFsCache ?? this.readFsCache\n    this.writeFsCache = opts.writeFsCache ?? this.writeFsCache\n  }\n\n  get name() {\n    return this.opts.name\n  }\n\n  get size() {\n    return this.cache.size\n  }\n\n  get fsCacheTtlMs() {\n    return (\n      this.opts.fsCacheTtlMs ??\n      this.opts.clearEveryMs ??\n      this.opts.timeoutMs * 5\n    )\n  }\n\n  mergeStats(stats: ReturnType<FifoCacheAsync[\"stats\"]>) {\n    this.cacheHitsSync += stats.cacheHitsSync\n    this.cacheHitsAsync += stats.cacheHitsAsync\n    this.cacheMisses += stats.cacheMisses\n    this.rejections += stats.rejections\n    this.timeouts += stats.timeouts\n  }\n\n  stats() {\n    return {\n      size: this.size,\n      cacheHitsSync: this.cacheHitsSync,\n      cacheHitsAsync: this.cacheHitsAsync,\n      cacheMisses: this.cacheMisses,\n      rejections: this.rejections,\n      timeouts: this.timeouts\n    }\n  }\n\n  has(key: string) {\n    return this.cache.has(key)\n  }\n\n  #fsCacheForKey(key: string) {\n    if (FifoCacheAsync.cacheDir == null) return\n    const sha = shortFsStringSha(key)\n    return join(\n      FifoCacheAsync.cacheDir,\n      this.name,\n      sha.slice(0, 2),\n      sha.slice(2) + \".json\"\n    )\n  }\n\n  hasFsCacheSync(key: string, fsCachePath?: string) {\n    return isMtimeRecentSync(\n      fsCachePath ?? this.#fsCacheForKey(key),\n      this.fsCacheTtlMs\n    )\n  }\n\n  #readFsCacheSync(key: string): Maybe<V> {\n    if (!this.readFsCache) return\n    const fsCachePath = this.#fsCacheForKey(key)\n    if (fsCachePath != null && this.hasFsCacheSync(key, fsCachePath)) {\n      try {\n        const result = parseJSON<V>(bufferToString(readFileSync(fsCachePath)))\n        this.cache.set(key, result!)\n        return this.#logger().tap({\n          msg: \"#readFsCacheSync(): hit\",\n          result,\n          meta: { key }\n        })\n      } catch {\n        //\n      }\n    }\n    if (fsCachePath != null) {\n      void unlink(fsCachePath).catch(() => null)\n    }\n    this.#logger().debug(\"#readFsCacheSync(): miss\", { key })\n    return\n  }\n\n  #writeFsCache(key: string, v: V) {\n    if (this.writeFsCache) {\n      const fsCachePath = this.#fsCacheForKey(key)\n      if (fsCachePath != null) {\n        this.#logger().debug(\"#writeFsCache()\", { key })\n        return outputFile(fsCachePath, stringify(v)).catch(async error => {\n          this.#logger().error(\"#writeFsCache() failed\", { error })\n          await unlink(fsCachePath)\n        })\n      }\n    }\n    return\n  }\n\n  /**\n   * If the prior getOrSetAsync() threw an error, this method will also.\n   */\n  get_(key: string): MaybeSyncOrAsync<V> {\n    if (!this.cache.has(key)) {\n      this.cacheMisses++\n      return\n    }\n    const v = this.cache.get(key) ?? this.#readFsCacheSync(key)\n    if (v instanceof Deferred) {\n      if (v.isRejected) {\n        throw v.error\n      } else if (v.isPending) {\n        this.cacheHitsAsync++\n        return v.promise\n      } else {\n        this.cacheHitsSync++\n        return v.value\n      }\n    } else if (v instanceof Error) {\n      throw v\n    } else {\n      this.cacheHitsSync++\n      return v\n    }\n  }\n\n  /**\n   * @return a value if the key was in cache and the promise was resolved.\n   */\n  get(key: string): Maybe<V> {\n    const v = this.cache.get(key) ?? this.#readFsCacheSync(key)\n    if (v == null || (v instanceof Deferred && v.isPending)) {\n      this.cacheMisses++\n    } else {\n      this.cacheHitsSync++\n    }\n    return v instanceof Deferred ? v.value : v\n  }\n\n  clear() {\n    this.cache.clear()\n    this.cacheHitsSync = 0\n    this.cacheHitsAsync = 0\n    this.cacheMisses = 0\n    this.rejections = 0\n    this.timeouts = 0\n    if (FifoCacheAsync.cacheDir != null) {\n      try {\n        const d = join(FifoCacheAsync.cacheDir, this.name)\n        const victim = d + \".trash-\" + filestamp()\n        moveSync(d, victim)\n        return rm(victim, {\n          recursive: true,\n          maxRetries: 3,\n          retryDelay: secondMs,\n          force: true\n        }).catch()\n      } catch {\n        // ignore\n      }\n    }\n    return\n  }\n\n  delete(key: string, deleteFsCache = true) {\n    if (deleteFsCache) {\n      map(this.#fsCacheForKey(key), ea => {\n        try {\n          unlinkSync(ea)\n        } catch {\n          //\n        }\n      })\n    }\n    return this.cache.delete(key)\n  }\n\n  deleteIf(predicate: (key: string) => boolean) {\n    for (const k of this.cache.keys()) {\n      if (predicate(k)) {\n        this.delete(k)\n      }\n    }\n  }\n\n  set(key: string, value: V): V {\n    this.cache.set(key, value)\n    return value\n  }\n\n  getOrSet(key: string, valueThunk: () => V): V {\n    const prior = this.get(key)\n    if (prior != null) {\n      if (prior instanceof Error) {\n        throw prior\n      } else {\n        return prior\n      }\n    }\n    return this.set(key, valueThunk())\n  }\n\n  // THIS METHOD IS NOT ASYNC: it relies on stable internal state!\n  getOrSetAsync(key: number | string, later: () => Promise<V>): SyncOrAsync<V> {\n    const start = Date.now()\n    const k = toS(key)\n    {\n      const prior = this.get_(k)\n      if (prior != null) {\n        return prior instanceof Deferred ? prior.promise : prior\n      }\n    }\n\n    const d = new Deferred<V>(this.opts.name).observe(later())\n    // Add the deferred to the cache ASAP:\n    this.cache.set(k, d)\n\n    if (gt0(this.opts.timeoutMs)) {\n      void d.setTimeout(this.opts.timeoutMs)\n    }\n\n    void d.promise.then(\n      result => {\n        // remove the Deferred and release the scoped memory:\n        this.set(k, result)\n        if (\n          gt0(Settings.fsCacheSlowMs.valueOrDefault) &&\n          gte(Date.now() - start, Settings.fsCacheSlowMs.valueOrDefault - 1)\n        ) {\n          return this.#writeFsCache(k, result)\n        }\n        return\n      },\n      error => {\n        this.cache.set(k, error)\n        this.rejections++\n        if (error instanceof TimeoutError) {\n          this.timeouts++\n        }\n      }\n    )\n    return d.promise\n  }\n}\n","export class FifoSet<T> implements Set<T> {\n  readonly [Symbol.toStringTag] = \"FifoSet\"\n  readonly values = (): IterableIterator<T> => this.delegate.values()\n  readonly keys = this.values\n\n  private readonly delegate = new Set<T>()\n\n  constructor(readonly maxSize: number) {}\n\n  get size(): number {\n    return this.delegate.size\n  }\n\n  add(value: T): this {\n    this.delegate.add(value)\n    this.vacuum()\n    return this\n  }\n\n  clear(): this {\n    this.delegate.clear()\n    return this\n  }\n\n  delete(value: T): boolean {\n    return this.delegate.delete(value)\n  }\n\n  forEach(callbackfn: (value: T, index: T, set: Set<T>) => void): void {\n    this.delegate.forEach(callbackfn)\n  }\n\n  has(value: T): boolean {\n    return this.delegate.has(value)\n  }\n\n  entries(): IterableIterator<[T, T]> {\n    return this.delegate.entries()\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values()\n  }\n\n  /**\n   * remove all expired entries\n   */\n  private vacuum() {\n    if (this.size > this.maxSize) {\n      const iter = this.delegate.entries()\n      while (this.size > this.maxSize) {\n        this.delete(iter.next().value[0])\n      }\n    }\n  }\n}\n","import { lazy } from \"../core/Lazy\"\nimport { last, range } from \"../fe/Array\"\nimport { blank, notBlank } from \"../fe/Blank\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { max_ } from \"../fe/Number\"\nimport { fromEntries, values } from \"../fe/Object\"\nimport { mkLogger } from \"./Logger\"\nimport { escapeRegExp } from \"./RegExp\"\nimport { indexOfNonSpace, isString, lastIndexOfNonSpace } from \"./String\"\nimport { splitLines } from \"./fs/CRLF\"\n\nexport interface Header<T> {\n  text: string & keyof T\n  greedyLeft?: boolean\n  greedyRight?: boolean\n}\n\nclass IndexedHeader<T> {\n  readonly text: string\n  readonly greedyLeft: boolean\n  indexOf?: number\n  leftIdx?: number\n  rightIdx?: number\n  constructor(h: Header<T> | string) {\n    this.text = isString(h) ? h : h.text\n    this.greedyLeft = isString(h) ? false : h[\"greedyLeft\"] ?? false\n  }\n\n  toEntry(row: string): [string, string] {\n    return [this.text, row.substring(this.leftIdx!, this.rightIdx).trim()]\n  }\n}\n\nconst logger = lazy(() => mkLogger(\"Fixed\"))\n\nexport type Headers<T> = (Header<T> | string)[]\n\n/**\n * Parse fixed-width input into an array of objects\n */\nexport function parseFixed<T>(\n  headers: Headers<T>,\n  table: string,\n  warnIfMissingHeaders = true\n): T[] {\n  return new Fixed(headers, table, warnIfMissingHeaders).entries\n}\n\n/**\n * Support for parsing fixed-width tabular data\n */\nexport class Fixed<T> {\n  readonly headers: IndexedHeader<T>[]\n  readonly headerRow: string\n  readonly skippedHeaders: string[] = []\n  readonly rows: string[] // doesn't include the header row!\n  readonly entries: T[]\n  readonly blankColumns: Set<number>\n\n  constructor(\n    headers: Headers<T>,\n    table: string,\n    readonly warnIfMissingHeaders = true\n  ) {\n    this.rows = splitLines(table)\n    this.headerRow = this.rows.shift()!\n    const maxLen = max_(...this.rows.map(ea => ea.length))\n    this.blankColumns = new Set(\n      range(0, maxLen).filter(idx => this.rows.every(ea => blank(ea[idx])))\n    )\n\n    this.headers = this.extractHeaders(headers.map(ea => new IndexedHeader(ea)))\n    this.entries = this.rows\n      .map(row => this.headers.map(h => h.toEntry(row)))\n      .map(arr => fromEntries(arr))\n      // Remove rows that have all blank values:\n      .filter(row => values(row).some(notBlank))\n  }\n\n  /**\n   * @param fromIdx inclusive\n   * @param toIdx inclusive\n   */\n  private firstBlankColumn(fromIdx: number, toIdx: number): Maybe<number> {\n    for (let idx = fromIdx; idx !== toIdx; toIdx > fromIdx ? idx++ : idx--) {\n      if (this.blankColumns.has(idx)) return idx\n    }\n    if (this.blankColumns.has(toIdx)) return toIdx\n    if (fromIdx === 0 || toIdx === 0) {\n      return 0\n    }\n    return undefined\n  }\n\n  private extractHeaders(headers: IndexedHeader<T>[]): IndexedHeader<T>[] {\n    // For every column, determine which header it belongs to.\n\n    // First parse headers columns\n    const re = new RegExp(\n      headers\n        .map(\n          ea => (ea.greedyLeft ? \"\\\\s+\" : \"\\\\b\") + escapeRegExp(ea.text) + \"\\\\b\"\n        )\n        .join(\"|\"),\n      \"ig\"\n    )\n    const result: IndexedHeader<T>[] = []\n\n    // basically String.splitKeep\n    // we're looking for tokens at or right of pos\n    let m: RegExpExecArray | null\n\n    // this is the \"re.lastIndex\" from the prior match\n    let priorLastIndex = 0\n\n    while ((m = re.exec(this.headerRow)) != null) {\n      const skippedOver = this.headerRow.substring(priorLastIndex, m.index)\n      if (!blank(skippedOver)) {\n        logger().debug(\"extractHeaders: skipping over unknown header\", {\n          skippedOver,\n          m_index: m.index\n        })\n        this.skippedHeaders.push(skippedOver.trim())\n      }\n\n      const matched = this.headerRow.substring(m.index, re.lastIndex)\n      // this is the leftmost non-whitespace index of the current header\n      const left = m.index + (indexOfNonSpace(matched) ?? 0)\n      // this is the rightmost non-whitespace index of the current header\n      const right = m.index + (lastIndexOfNonSpace(matched) ?? matched.length)\n      const text = matched.trim()\n      const h = headers.find(ea => ea.text === text)\n      if (h == null || left == null || right == null) {\n        this.skippedHeaders.push(text)\n        logger().debug(\"extractHeaders: internal error\", {\n          matched,\n          match: m,\n          left,\n          right\n        })\n      } else {\n        const prior = last(result)\n        result.push(h)\n\n        if (prior != null) {\n          const priorRightBoundary =\n            prior.rightIdx! +\n            (indexOfNonSpace(skippedOver) ?? skippedOver.length) +\n            1\n          prior.rightIdx = h.greedyLeft\n            ? this.firstBlankColumn(prior.rightIdx!, priorRightBoundary)\n            : this.firstBlankColumn(priorRightBoundary, prior.rightIdx!)\n        }\n        const leftmost = max_(\n          prior?.rightIdx,\n          m.index - (lastIndexOfNonSpace(skippedOver) ?? skippedOver.length)\n        )\n        h.leftIdx = h.greedyLeft\n          ? this.firstBlankColumn(leftmost, left)\n          : this.firstBlankColumn(left, leftmost)\n        h.rightIdx = right // < temporary!\n      }\n      priorLastIndex = re.lastIndex\n    }\n    // expand the right header... but how much?\n    const lastHeader = last(result)\n    if (lastHeader != null) {\n      if (!blank(this.headerRow.slice(priorLastIndex))) {\n        lastHeader.rightIdx = priorLastIndex\n      } else {\n        // If the remainder of the header is whitespace, just expand to the end:\n        lastHeader.rightIdx = max_(...this.rows.map(ea => ea.length))\n      }\n    }\n    return result\n  }\n}\n","// Secure hash research:\n\n// SHA1 has known collisions. It should be expected for a nerd to have sample\n// images that have colliding SHA1 hashes on their laptop.\n\n// I don't see why these SHA values would need to be externally consumed, so\n// people shouldn't care if the SHA in the db isn't a FIPS standard. I don't\n// want to pull in another native library dependency if I can help it.\n\n// ALSO: I don't need that many bits to ensure uniqueness! 160 was enough for\n// SHA1, 192 should be plenty, and only takes 32 base64 characters (and doesn't\n// waste chars on padding).\n\n// HOWEVER: versions pre-v0.3.5 used the most significant 224 bits, so when we\n// build SHAs of strings (like for volume UIDs), we maintain backward\n// compatibility by slicing MSB 224 bits. If we slice 192 bits and we use a\n// non-8-bit-divisible radix, the values change.\n\n// See https://news.ycombinator.com/item?id=10011472\n// https://en.wikipedia.org/wiki/Secure_Hash_Algorithms\n\n// `shasum -a 512224` implements SHA-512/224.\n// `shasum -a 512256` implements SHA-512/256.\n\nexport const HashBits = 192\n","import { parseJSON } from \"../fe/JSON\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { Obj } from \"../fe/Object\"\n\n// TODO: inline\nexport { parseJSON } from \"../fe/JSON\"\n\nexport function mapParsed<T>(s: string, f: (o: Obj) => T): Maybe<T> {\n  const j = parseJSON(s)\n  return j == null ? undefined : f(j)\n}\n","import { inspect } from \"util\"\nimport { isEmpty } from \"../fe/Array\"\nimport { ChangeListener } from \"../fe/ChangeListener\"\nimport { eql } from \"../fe/Eql\"\nimport { MemoizedLazy, MemoizedThunk } from \"../fe/Lazy\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { gt0 } from \"../fe/Number\"\nimport { setUnrefTimeout } from \"../fe/UnrefTimeout\"\nimport { ExtensibleFunction } from \"./ExtensibleFunction\"\n\n// USED BY LOG: DON'T DEPEND ON ANYTHING (much)\n\n// TODO: INLINE\nexport { MemoizedLazy, MemoizedThunk, UnwrapLazy } from \"../fe/Lazy\"\n\nexport function lazy<T>(thunk: () => T, ttlMs?: number): MemoizedThunk<T> {\n  return new LazyClass(thunk, ttlMs) as any\n}\n\nclass LazyClass<T> extends ExtensibleFunction<T> implements MemoizedLazy<T> {\n  private lastSetTs?: number\n  private result?: T\n  readonly watchers: ChangeListener<T>[] = []\n\n  constructor(\n    private readonly thunk: () => T,\n    private ttlMs?: number\n  ) {\n    super()\n  }\n\n  override _call() {\n    if (this.isStale()) {\n      // NO PROMISE AWAITING HERE. Otherwise N calls would go through while we\n      // wait for the promise to resolve.\n      this.#setResult(this.thunk())\n    }\n    return this.result!\n  }\n\n  private async onSetResult(priorP: Maybe<T>, currentP: T) {\n    if (isEmpty(this.watchers)) return\n    // prior and current could be a promise!\n\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const _prior = await priorP\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const current = await currentP\n    if (!eql(_prior, current)) {\n      for (const ea of this.watchers) ea(current)\n    }\n    // We're interpreting undefined as unset, and `null` as a valid set value.\n    if (this.ttlMs != null && this.ttlMs > 0 && current !== undefined) {\n      // help the garbage collector:\n      setUnrefTimeout(() => this.vacuum(), this.ttlMs)\n    }\n  }\n\n  vacuum() {\n    if (this.isStale()) this.unset()\n  }\n\n  #setResult(t: T) {\n    this.lastSetTs = Date.now()\n    void this.onSetResult(this.result, t)\n    return (this.result = t)\n  }\n\n  isStale() {\n    return (\n      this.lastSetTs == null ||\n      (gt0(this.ttlMs) && this.lastSetTs + this.ttlMs < Date.now())\n    )\n  }\n\n  set(t: T) {\n    this.#setResult(t)\n  }\n\n  unset() {\n    this.#setResult(undefined as any)\n    this.lastSetTs = undefined\n  }\n\n  clear() {\n    const _prior = this.result\n    this.unset()\n    return _prior\n  }\n\n  prior() {\n    this.vacuum()\n    return this.result\n  }\n\n  refresh() {\n    return this.#setResult(this.thunk())\n  }\n\n  ttl() {\n    return this.ttlMs\n  }\n\n  setTTL(ttl: number | undefined) {\n    this.ttlMs = gt0(ttl) ? ttl : undefined\n  }\n\n  watchLater(watcher: ChangeListener<T>) {\n    this.watchers.push(watcher)\n  }\n\n  watch(watcher: ChangeListener<T>) {\n    watcher(this())\n    this.watchLater(watcher)\n  }\n\n  toString() {\n    return \"[Lazy]\"\n  }\n\n  // If you move this back to fe, you'll need to switch this with something\n  // like `const inspect_custom = isNode ? require(\"util\").inspect.custom :\n  // Symbol.for(\"inspect.custom\")`\n  [inspect.custom]() {\n    return \"[Lazy]\"\n  }\n\n  lastSetAgoMs() {\n    return this.lastSetTs == null ? undefined : Date.now() - this.lastSetTs\n  }\n\n  hasPrior() {\n    return this.lastSetTs != null\n  }\n}\n\nclass ROLazy<T> extends LazyClass<T> {\n  override set(_: T) {}\n}\n\nexport function rolazy<T>(thunk: () => T, ttlMs?: number): MemoizedThunk<T> {\n  return new ROLazy(thunk, ttlMs) as any\n}\n","import { lazy } from \"../core/Lazy\"\nimport { compact } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { secondMs } from \"../fe/Date\"\nimport { Maybe, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { Obj } from \"../fe/Object\"\nimport { parseEnvTokens } from \"./EnvTokens\"\nimport { mkLogger } from \"./Logger\"\nimport { equalsIgnoreCase } from \"./String\"\nimport { lazyAsync } from \"./async/LazyAsync\"\nimport { thenMap } from \"./async/Promise\"\nimport { StdoutOpts, stdout_ } from \"./child/ChildProcess\"\nimport { env } from \"./env/Env\"\nimport { isMac, isWin } from \"./platform/Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\nimport { commandTimeoutMs } from \"./volumes/VolumeTtls\"\n\nexport const DefaultLocale = \"en\"\n\nconst logger = lazy(() => mkLogger(\"Locale\"))\n\nexport function localeSync() {\n  return locale.lastValue() ?? envLocale() ?? DefaultLocale\n}\n\n/**\n * @see https://en.wikipedia.org/wiki/ISO_639\n */\nexport const locale = lazyAsync<string>({\n  desc: \"locale\",\n  later: async () =>\n    lc2locale(\n      extractLocale() ??\n        (await (isWin\n          ? localeWin()\n          : isMac\n          ? localeMac()\n          : localePosix()\n        ).catch(error => {\n          logger().warn(\"Failed to get locale\", { error })\n          return DefaultLocale\n        }))\n    ),\n  timeoutMs: commandTimeoutMs()\n})\n\nexport const envLocale = lazy(extractLocale)\n\n// See https://wiki.archlinux.org/index.php/Locale\nfunction extractLocale(e: Obj = env()) {\n  for (const ea of [e.LC_ALL, e.LC_MESSAGES, e.LANG, e.LANGUAGE]) {\n    const lc = toLocale(ea)\n    if (lc != null) return lc\n  }\n  return\n}\n\n// Like \"en_US.UTF-8\"\nconst regex = /^(?<lang>[a-z]{2,3})(?:[_-](?<country>[a-z]{2,3}))?\\b/i\n\nfunction toLocale(str: Maybe<string>) {\n  if (blank(str)) return\n  // Some people set their locale to \"C\":\n  if (\n    str === DefaultLocale ||\n    equalsIgnoreCase(\"c\", str) ||\n    equalsIgnoreCase(\"posix\", str)\n  ) {\n    return DefaultLocale\n  }\n  const g = regex.exec(str.trim())?.groups\n  return g == null ? undefined : compact([g.lang, g.country]).join(\"-\")\n}\n\nexport function lc2locale(lc: Maybe<string>): string {\n  return toLocale(lc) ?? DefaultLocale\n}\n\nexport function localeWin(): PromiseMaybe<string> {\n  return thenMap(\n    PowerShell.instance().executeJson(\n      \"Get-WinSystemLocale | Select-Object -Property Name\"\n    ),\n    ea => ea.Name as string\n  )\n}\n\nconst opts: StdoutOpts = {\n  timeoutMs: 10 * secondMs\n}\n\nexport async function localeMac(): PromiseMaybe<string> {\n  return toLocale(\n    await stdout_(\"defaults\", [\"read\", \"-globalDomain\", \"AppleLocale\"], opts)\n  )\n}\n\nexport async function localePosix() {\n  return lc2locale(\n    extractLocale(\n      parseEnvTokens({\n        lowerCaseKeys: false,\n        input: await stdout_(\"locale\", [], opts)\n      })\n    )\n  )\n}\n\nexport function childProcLocale() {\n  return {\n    LANG: \"C\",\n    LC_ALL: \"C\"\n  }\n}\n","import { lazy } from \"../core/Lazy\"\nimport { ConsoleLogger } from \"./log/ConsoleLogger\"\nimport { ContextualLogger } from \"./log/ContextualLogger\"\nimport { SimpleLogger } from \"./log/Logger\"\n\nexport const rootLoggers = lazy<SimpleLogger[]>(() => [\n  ConsoleLogger.instance()\n])\n\nconst consoleLogger = lazy(() => [ConsoleLogger.instance()])\n\nexport type Logger = ContextualLogger // TODO: inline?\n\nexport function mkLogger(context: string): ContextualLogger {\n  return new ContextualLogger(context, rootLoggers)\n}\n\nexport function mkConsoleLogger(context: string): ContextualLogger {\n  return new ContextualLogger(context, consoleLogger)\n}\n","import { stringify } from \"../fe/JSON\"\nimport { FifoCache } from \"./FifoCache\"\n\nexport interface MemoizedFunc<A, R> {\n  (a: A): R\n  clear(a?: A): void\n  size(): number\n  callCount(): number\n}\n\nexport function memoize<A, R>(\n  f: (a: A) => R,\n  opts: { maxSize: number; ttlMs?: number }\n): MemoizedFunc<A, R> {\n  let callCount = 0\n  const store = new FifoCache<R>(opts.maxSize, opts.ttlMs)\n  const r: any = (a: A) => {\n    if (a == null) return\n    callCount++\n    return store.getOrSet(stringify(a), () => f(a))\n  }\n  r.clear = (a?: A) => (a == null ? store.clear() : store.delete(stringify(a)))\n  r.size = () => store.size\n  r.callCount = () => callCount\n  return r\n}\n","import { isTrue, toBoolean } from \"../fe/Boolean\"\n\n/**\n * @see https://no-color.org/\n */\nexport function noColor(): boolean {\n  // force color if PS_LOG_COLOR is true\n  return (\n    toBoolean(process.env.PS_LOG_COLOR) ??\n    (isTrue(process.env.NO_COLOR) ||\n      [\"dumb\", \"unknown\"].includes(process.env.TERM as string))\n  )\n}\n","import process from \"process\"\nimport { isTrue } from \"../fe/Boolean\"\nimport { toS } from \"../fe/toS\"\nimport { isPacked } from \"./platform/IsPacked\"\n\n// new mocha 10 uses \"mocha.js\"\nconst MaybeTestArgRe = /mocha(?:\\.js)$|\\.spec\\.js$/\n\nexport function _nodeEnv() {\n  switch (toS(process.env.NODE_ENV).toLowerCase()) {\n    case \"test\":\n    case \"testing\":\n      return \"test\"\n    case \"dev\":\n    case \"development\":\n      return \"development\"\n    case \"prod\":\n    case \"production\":\n      return \"production\"\n    default:\n      if (\n        !isPacked() &&\n        process.argv.some(ea => MaybeTestArgRe.exec(ea) != null)\n      ) {\n        return \"test\"\n      } else {\n        return \"production\"\n      }\n  }\n}\n\n// Make sure NODE_ENV gets the final value. If not, stuff like Pug stays in\n// dev mode: https://pugjs.org/api/express.html\nexport const nodeEnv = (process.env.NODE_ENV = _nodeEnv())\n\nexport const isDev = nodeEnv === \"development\"\nexport const isTest = nodeEnv === \"test\"\nexport const isProd = nodeEnv === \"production\"\n\nexport function isSingleSpecTests() {\n  return isTest && isTrue(process.env.SINGLE_SPEC_TESTS)\n}\n\nexport function setSingleSpecTests(b: boolean) {\n  process.env.SINGLE_SPEC_TESTS = b ? \"true\" : \"false\"\n}\n","import { count, isEmpty } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { flatten } from \"../fe/Flatten\"\nimport { map, orElse } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport {\n  clamp,\n  gt0,\n  isNumber,\n  map2Numeric,\n  mapInt,\n  mapNumeric,\n  toFloat,\n  toInt\n} from \"../fe/Number\"\nimport { leftPad } from \"../fe/Pad\"\nimport { toS } from \"../fe/toS\"\nimport { pop } from \"./math/Bits\"\n\n// TODO: INLINE\nexport { within } from \"../fe/Number\"\n\nexport function firstGt0(...objects: any[]): Maybe<number> {\n  return objects.find(gt0)\n}\n\n/**\n * @return the first element in `objects` that can be parsed into a number and is\n * greater than zero.\n */\nexport function firstNonZero(...objects: any[]): Maybe<number> {\n  for (const ea of flatten(objects)) {\n    const f = toFloat(ea)\n    if (f != null && f !== 0) return f\n  }\n  return undefined\n}\n\nexport function mapGte0<T>(n: any, f: (i: number) => T): Maybe<T> {\n  return mapInt(n, i => (i >= 0 ? f(i) : undefined))\n}\n\nexport function mapGte0Or<T>(\n  n: any,\n  f: (i: number) => T,\n  defaultValue: T | (() => T)\n): T {\n  return orElse(mapGte0(n, f), defaultValue)\n}\n\nexport function mapGte0f<T>(n: any, f: (i: number) => T): Maybe<T> {\n  return mapNumeric(n, i => (i >= 0 ? f(i) : undefined))\n}\n\nexport function mapGt0<T>(n: any, f: (i: number) => T): Maybe<T> {\n  const ea = toInt(n)\n  return ea != null && ea > 0 ? f(ea) : undefined\n}\n\nexport function map2Gt0<T>(\n  a: any,\n  b: any,\n  f: (i: number, j: number) => T\n): Maybe<T> {\n  const i = toInt(a)\n  const j = toInt(b)\n  return i != null && i > 0 && j != null && j > 0 ? f(i, j) : undefined\n}\n\nexport function mapGt0f<T>(n: any, f: (i: number) => T): Maybe<T> {\n  const ea = toFloat(n)\n  return ea != null && ea > 0 ? f(ea) : undefined\n}\n\nexport function mapGt0Or<T>(\n  n: any,\n  f: (i: number) => T,\n  defaultValue: T | (() => T)\n): T {\n  return orElse(mapGt0(n, f), defaultValue)\n}\n\n// WAT WAT WAAAAAT? (this is the simplest regex I could come up with that\n// supported both \"-123\", \"+123.\", \"-123.456\" and \"-.789\") \\\n\n// I could do this:\n// const validFloatRe = /((?:[+-]?[0-9]+(?:\\.[0-9]*)?)|(?:[+-]?[0-9]*(?:\\.[0-9]+)))/\n\n// but that sort of rigor isn't necessary. parseFloat is fine with parsing\n// \"-123.456GUACAMOLE\".\nconst numstartRe = /[+-]?[0-9\\,\\.]+/\n\n/**\n * Pull out the first float from `value`.\n *\n * This method ignores any non-numeric characters that prefix or suffix the\n * first number (as opposed to `toFloat`, which ignores only non-numeric\n * suffixes)\n */\nexport function extractFloat(value: any): Maybe<number> {\n  if (isNumber(value)) return value\n  if (blank(value)) return undefined\n  const s = String(value)\n  return map(numstartRe.exec(s), m => toFloat(s.substr(m.index)))\n}\n\n/**\n * Pull out the first integer from `value`.\n *\n * This method ignores any non-numeric characters that prefix or suffix the\n * first number (as opposed to `toInt`, which ignores only non-numeric suffixes)\n */\nexport function extractInt(value: any): Maybe<number> {\n  return toInt(extractFloat(value))\n}\n\nexport function extractFraction(value: any): Maybe<number> {\n  if (isNumber(value)) return value\n  const s = toS(value)\n  if (s.includes(\"/\")) {\n    const arr = s.split(\"/\", 2)\n    return map2Numeric(extractInt(arr[0]), extractInt(arr[1]), (i, j) => i / j)\n  } else {\n    return extractFloat(s)\n  }\n}\n\nexport function assertPositive(name: string, value?: number) {\n  if (value == null || value <= 0) {\n    throw new Error(name + \" must be positive\")\n  }\n}\n\nexport class Array2D {\n  private readonly store: number[] = []\n  constructor(readonly columns: number) {}\n  get(row: number, col: number): number {\n    return row < 0 || col < 0\n      ? 0\n      : orElse(this.store[row * this.columns + col], () => 0)\n  }\n  set(row: number, col: number, value: number) {\n    this.store[row * this.columns + col] = value\n  }\n}\n\nfunction prepHammBigInts(\n  a: number | bigint,\n  b: number | bigint\n): Maybe<[string, string]> {\n  if (a == null || b == null) return\n  const arr = [a, b].map(ea => ea.toString(2))\n  const maxLen = Math.max(...arr.map(ea => ea.length))\n  return arr.map(ea => leftPad(ea, maxLen, \"0\")) as [string, string]\n}\n\n/**\n * @return the number of bits not matching between a and b\n */\nexport function hammingDistanceBigInt(\n  a: number | bigint,\n  b: number | bigint\n): Maybe<number> {\n  return map(prepHammBigInts(a, b), ([s1, s2]) =>\n    count([...s1], (ea, idx) => ea !== s2.charAt(idx))\n  )\n}\n\n/**\n * @return `matching bits / total bits`. 1 == complete match.\n */\nexport function hammRatioBigInt(\n  a: Maybe<number | bigint>,\n  b: Maybe<number | bigint>\n): Maybe<number> {\n  if (a == null || b == null) return 0\n  return map(prepHammBigInts(a, b), ([i, j]) => hammRatioBinaryString(i, j))\n}\n\nexport function hammRatioBinaryString(a: string, b: string) {\n  if (a === b) return 1\n  if (a.length !== b.length)\n    throw new Error(`hammRatioBinaryString(${a}, ${b}): invalid lengths`)\n  let matching = 0\n  // console.log(\"hammRatioBinaryString a\")\n  // console.log(splitEvery(a, 24).join(\"\\n\"))\n  // console.log(\"hammRatioBinaryString b\")\n  // console.log(splitEvery(b, 24).join(\"\\n\"))\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === b[i]) matching++\n  }\n  // console.log(\"matching: \" + matching)\n  // 50% match is random. Scale that to 0.\n  return clamp(0, 1, (2 * matching) / a.length - 1)\n}\n\nexport function valuesToBigInt(arr: number[], bitsPerValue: number): bigint {\n  if (isEmpty(arr)) return BigInt(0)\n  return BigInt(\n    \"0b0\" +\n      arr.map(ea => leftPad(ea.toString(2), bitsPerValue - 1, \"0\")).join(\"\")\n  )\n}\n\nexport function hammRatioIntArrays(\n  a: number[],\n  b: number[],\n  bitsPerCell: number\n) {\n  if (a.length !== b.length)\n    throw new Error(\"hammRatioIntArrays(): inequal arrays\")\n  let diff = 0\n  const total = bitsPerCell * a.length\n  for (let i = 0; i < a.length; i++) {\n    diff += pop(a[i] ^ b[i])\n  }\n\n  // 50% match is random. Scale that to 0:\n  return clamp(0, 1, (2 * (total - diff)) / total - 1)\n}\n\n/**\n * \"safe\" square-root\n *\n * @return 0 if i is not a number or is negative\n */\nexport function sqrt(i: number): number {\n  return gt0(i) ? Math.sqrt(i) : 0\n}\n","import { compact, uniq } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { isDate } from \"../fe/Date\"\nimport { eql } from \"../fe/Eql\"\nimport { flatten } from \"../fe/Flatten\"\nimport { defined, map } from \"../fe/Maybe\"\nimport { Maybe, MaybeNull } from \"../fe/MaybeTypes\"\nimport { gt } from \"../fe/Number\"\nimport { Obj, entries, keys } from \"../fe/Object\"\nimport { Primitive, isPrimitive } from \"../fe/Primitive\"\nimport { Thunk } from \"../fe/Thunk\"\nimport { toErr } from \"../fe/toErr\"\nimport { first } from \"./Array\"\nimport { equalsIgnoreCase, sortIgnoreCase } from \"./String\"\n\n// \"{ new(): T }\"\n// is from https://www.typescriptlang.org/docs/handbook/generics.html#using-class-types-in-generics\nexport interface Constructor<M> {\n  new (...args: any[]): M\n}\n\nexport function definedThunks(...thunks: Thunk<any>[]): boolean {\n  return thunks.every(ea => defined(ea()))\n}\n\nexport function firstThunk<T>(...thunks: Thunk<Maybe<T>>[]): Maybe<T> {\n  for (const t of thunks) {\n    const r = t()\n    if (r != null) {\n      return r\n    }\n  }\n  return\n}\n\nexport function firstTrueThunk<T>(\n  thunks: Thunk<Maybe<T>>[],\n  predicate?: (t: T) => boolean\n): Maybe<T> {\n  for (const t of thunks) {\n    const r = t()\n    if (r != null && (predicate == null || predicate(r))) {\n      return r\n    }\n  }\n  return\n}\n\nexport function firstDefined<T>(...objects: MaybeNull<T>[]): Maybe<T> {\n  return objects.find(defined)\n}\n\nexport function firstDefinedField<T, K extends keyof T>(\n  obj: T,\n  ...fieldNames: K[]\n): Maybe<T[K]> {\n  return map(\n    fieldNames.find(field => null != obj[field]),\n    fieldName => obj[fieldName]\n  )\n}\n\nexport function firstFieldLike<T extends Obj, K extends keyof T>(\n  obj: T,\n  predicate: (key: K, value: T[K]) => boolean\n): Maybe<T[K]> {\n  return first(\n    keys(obj) as K[], // SITS: why is this cast needed?\n    key => (predicate(key, obj[key]) ? obj[key] : undefined)\n  )\n}\n\n// knex interprets undefined parameters as runtime mistakes, so use null:\nexport function ornull<T>(a?: T): T | null {\n  return a === undefined ? null : a\n}\n\nexport function mapAnd<T>(obj: MaybeNull<T>, f: (t: T) => boolean): boolean {\n  return obj != null ? f(obj) : false\n}\n\nexport function mapOrThrow<T, R>(\n  obj: MaybeNull<T>,\n  f: (t: T) => R,\n  errIfMissing: string\n): R {\n  if (obj != null) {\n    return f(obj)\n  } else {\n    throw new Error(errIfMissing)\n  }\n}\n\nexport function Try<T>(\n  f: () => T,\n  onError?: (error: Error) => Maybe<T>\n): Maybe<T> {\n  try {\n    return f()\n  } catch (err) {\n    return onError?.(toErr(err)!)\n  }\n}\n\nexport function tryEach<T>(iter: Iterable<T>, f: (t: T) => any): void {\n  ;[...iter].forEach(ea => Try(() => f(ea)))\n}\n\nexport function identity<T>(t: T) {\n  return t\n}\n\nexport function ctor(obj: any): Maybe<string> {\n  return map(obj.constructor, ea => ea.name)\n}\n\nexport function hasKeys(obj: any): boolean {\n  return Object.keys(obj).some(\n    k => typeof k === \"string\" && obj.propertyIsEnumerable(k)\n  )\n}\n\n/**\n * primitive and Dates\n */\nexport function primitiveEntries<T extends Obj>(o: T): [keyof T, Primitive][] {\n  return keys(o)\n    .filter(k => isPrimitive(o[k]) || isDate(o[k]))\n    .map(k => [k, o[k]] as [string, Primitive])\n}\n\nexport function spread<T extends Obj>(\n  defaults: T,\n  ...sources: MaybeNull<Partial<T>>[]\n): T {\n  return Object.assign({} as T, defaults, ...compact(sources))\n}\n\n/**\n * Assign fields from src that have Primitive value types\n */\nexport function assignMissingPrimitives<T>(dest: T, src: Maybe<Partial<T>>): T {\n  if (src == null) {\n    return dest\n  }\n  for (const [k, v] of primitiveEntries(src)) {\n    if (dest[k] == null) {\n      dest[k] = v as any\n    }\n  }\n  return dest\n}\n\n/**\n * Only assign fields that are missing or nullish\n */\nexport function assignNullishFields<T>(dest: T, src: Maybe<Partial<T>>): T {\n  if (src == null) {\n    return dest\n  }\n  for (const [k, v] of entries(src)) {\n    if (dest[k] == null) {\n      ;(dest[k] as any) = v\n    }\n  }\n  return dest\n}\n\nexport function pickMap<K extends string, V, U>(\n  obj: Record<K, V>,\n  keysToRetain: K[],\n  f: (key: K, value: V) => U\n): Record<K, U> {\n  const r = {} as Record<K, U>\n  for (const k of keysToRetain) {\n    r[k] = f(k, obj[k])\n  }\n  return r\n}\n\nexport function mapEntries<T extends Obj, U>(\n  obj: T,\n  f: (key: keyof T & string, value: T[keyof T]) => Maybe<U>\n): Record<keyof T, U> {\n  const r = {} as Record<keyof T, U>\n  for (const [k, v] of entries(obj)) {\n    // PERF: UNROLL\n    const val = f(k, v)\n    if (val != null) r[k] = val\n  }\n  return r\n}\n\nexport function mapNullEntries<T extends Obj, U>(\n  obj: T,\n  f: (key: keyof T & string, value: T[keyof T]) => MaybeNull<U>,\n  maxKeys?: number\n): Record<keyof T, U> {\n  const r = {} as Record<keyof T, U>\n  let keyCount = 0\n  for (const k of keys(obj)) {\n    r[k] = f(k, obj[k])!\n    keyCount++\n    if (gt(keyCount, maxKeys)) break\n  }\n  return r\n}\n\n/**\n * Do all fields in `a` match `b`?\n */\nexport function eqlSubset<T>(a: Maybe<Pick<T, any>>, b: T): boolean {\n  return a == null ? false : keys(a).every((ea: keyof T) => eql(a[ea], b[ea]))\n}\n\n/**\n * For a given field name, what's o[fieldpath]?\n *\n * If fieldpath includes \".\", those will be used to find sub-objects.\n */\nexport function valpath(o: any, ciFieldPath: string): any {\n  if (ciFieldPath == null || o == null || blank(ciFieldPath)) return o\n  if (Array.isArray(o)) return compact(o.map(ea => valpath(ea, ciFieldPath)))\n  const nextDot = ciFieldPath.indexOf(\".\")\n  const field = nextDot < 0 ? ciFieldPath : ciFieldPath.slice(0, nextDot)\n  const fieldRemains = nextDot < 0 ? undefined : ciFieldPath.slice(nextDot + 1)\n  const k = keys(o)\n  if (k.includes(field)) return valpath(o[field], fieldRemains!)\n  const ciField = k.find(ea => equalsIgnoreCase(ea, field))\n  if (ciField != null) {\n    return valpath(o[ciField], fieldRemains!)\n  }\n  return\n}\n\nexport function sortedKeys(o: any): any {\n  if (o == null || isPrimitive(o)) return o\n  if (Array.isArray(o)) {\n    return o.map(ea => sortedKeys(ea))\n  }\n  if (typeof o === \"object\") {\n    const a: any = {}\n    for (const k of sortIgnoreCase(keys(o))) {\n      a[k] = sortedKeys(o[k])\n    }\n    return a\n  }\n  return o\n}\n\nexport function deepDelete(o: any, ...keysToDelete: string[]): any {\n  if (o == null || typeof o !== \"object\") return o\n  if (Array.isArray(o)) return o.map(ea => deepDelete(ea, ...keysToDelete))\n  return mapEntries(o, (k, v) =>\n    keysToDelete.includes(k) ? undefined : deepDelete(v, ...keysToDelete)\n  )\n}\n\n/**\n * @return the value associated to `caseInsensitiveKeyName`\n */\nexport function pluckCaseInsensitive(\n  o: any,\n  caseInsensitiveKeyName: string\n): any {\n  if (typeof o !== \"object\") return\n  if (o[caseInsensitiveKeyName] !== undefined) return o[caseInsensitiveKeyName]\n  for (const ea of keys(o).filter(s =>\n    equalsIgnoreCase(s, caseInsensitiveKeyName)\n  )) {\n    if (o[ea] !== undefined) return o[ea]\n  }\n  return\n}\n\nexport function pairToObject(key: string, value: any) {\n  const o: any = {}\n  o[key] = value\n  return o\n}\n\nexport function mergeObjects(...arr: Maybe<object>[]) {\n  const o: any = {}\n  for (const obj of compact(arr)) {\n    for (const k of keys(obj)) {\n      o[k] = obj[k]\n    }\n  }\n  return o\n}\n\nexport function zipPojos(...arr: Maybe<Obj>[]): Obj {\n  const result: Obj = {}\n  for (const key of uniq(flatten(arr.map(keys)))) {\n    result[key] = arr.map(obj => obj?.[key])\n  }\n  return result\n}\n","import { Thunk } from \"../fe/Thunk\"\nimport { UpgradeChannel } from \"./settings/UpgradeChannels\"\nimport { version, versionMajor, versionMinor, versionPatch } from \"./Version\"\n\nexport const isPreAlphaVersion = () => version.includes(\"-prealpha\")\nexport const isAlphaVersion = () => version.includes(\"-alpha\")\nexport const isBetaVersion = () => version.includes(\"-beta\")\nexport const isStableVersion = () => !isAlphaVersion() && !isBetaVersion()\n\nexport const channel: Thunk<UpgradeChannel> = () =>\n  isPreAlphaVersion()\n    ? \"prealpha\"\n    : isAlphaVersion()\n    ? \"alpha\"\n    : isBetaVersion()\n    ? \"beta\"\n    : \"stable\"\n\n/**\n * @return \"1.2.3\", even if `version` is \"1.2.3-alpha.0\" or \"1.2.3-beta.32\"\n */\nexport const baseVersion = () =>\n  [versionMajor, versionMinor, versionPatch].join(\".\")\n\nexport const versionMajorMinor = versionMajor + \".\" + versionMinor\n","import { pidExists } from \"batch-cluster\"\nimport { toA } from \"../fe/toA\"\nimport { untilTrue } from \"./async/until\"\n\nexport function existingPids(pids: number[]): number[] {\n  return toA(pids).filter(pidExists)\n}\n\nexport function waitForPidExit(\n  pid: number,\n  timeoutMs: number\n): Promise<boolean> {\n  return untilTrue(() => !pidExists(pid), { timeoutMs, intervalMs: 250 })\n}\n","import child_process from \"child_process\"\nimport process from \"process\"\nimport { lazy } from \"../core/Lazy\"\nimport { compact, isEmpty } from \"../fe/Array\"\nimport { notBlank } from \"../fe/Blank\"\nimport { ago, minuteMs, secondMs } from \"../fe/Date\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { gt, gt0, lt, toInt } from \"../fe/Number\"\nimport { opt } from \"../fe/Opt\"\nimport { MaybeSyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { toA } from \"../fe/toA\"\nimport { toS } from \"../fe/toS\"\nimport { FifoCache } from \"./FifoCache\"\nimport { mkLogger } from \"./Logger\"\nimport { Try, identity } from \"./Object\"\nimport { ProcEntry, pidInfos } from \"./Ps\"\nimport { rateLimited } from \"./RateLimited\"\nimport { Endable, EndableRanks, ending } from \"./async/Endable\"\nimport { EndableWrapper } from \"./async/EndableWrapper\"\nimport { thenMap } from \"./async/Promise\"\nimport { setUnrefInterval } from \"./async/Timers\"\nimport { configDir } from \"./dir/ConfigDir\"\nimport { onError } from \"./error/OnError\"\nimport { BaseFile } from \"./fs/BaseFile\"\nimport { isJsonExt } from \"./fs/FileExt\"\nimport { isHiddenBasename, parseNativePath } from \"./fs/Path\"\nimport { isWin } from \"./platform/Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\n\n// TODO: move to ./proc/Pids.ts\nconst logger = lazy(() => mkLogger(\"proc.Pids\"))\n\nexport interface PidfileInfo {\n  pid: number\n  cmd: string // < only for debugging\n  ppid: number // < if ppid is gone, reap.\n  /**\n   * If <= 0, the process can run indefinitely (like web or sync)\n   */\n  maxAgeMs: number\n}\n\nexport interface PidfileJson extends PidfileInfo {\n  startTime: number\n  timeoutTime?: number\n}\n\n// yeah, it's a lot of slop, but addPid() is called after a timeout, so start\n// isn't really the start time.\nconst AllowableStartSlopMs = 10 * secondMs\n\nfunction matchesPidfileInfo(\n  info: Maybe<PidfileJson>,\n  entry: Maybe<ProcEntry>\n): boolean {\n  if (info == null || entry == null || info.pid !== entry.pid) return false\n\n  // The start times need to match, ish:\n  const entryStartTime = map(entry.start, ea => ea.getTime())\n  const fileStartTime = info.startTime\n  return (\n    gt0(entryStartTime) &&\n    gt0(fileStartTime) &&\n    Math.abs(entryStartTime - fileStartTime) < AllowableStartSlopMs\n  )\n\n  // Command names can change, so we just use the start time to match PIDs.\n}\n\nfunction killPidWinTaskkill(pid: number, force = false) {\n  const args = [\"/PID\", toS(toInt(pid)), \"/T\"]\n  if (force) {\n    args.push(\"/F\")\n  }\n  child_process.execFile(\"taskkill\", args)\n}\n\nasync function killPidWin(pid: number, force = false) {\n  if (ending() || PowerShell.instance().ended) {\n    killPidWinTaskkill(pid, force)\n  } else {\n    try {\n      // https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/stop-process?view=powershell-6\n      const cmd = compact([\n        \"Stop-Process\",\n        \"-Id\",\n        toInt(pid),\n        force ? \"-Force\" : undefined\n      ]).join(\" \")\n      await PowerShell.instance().execute(cmd, identity)\n    } catch (err) {\n      logger().warn(\"killWin(): pwsh error, using TASKKILL: \" + err)\n      killPidWinTaskkill(pid, force)\n    }\n  }\n}\n\nasync function killPidWithNode(pid: number, force = false) {\n  try {\n    process.kill(pid, force ? \"SIGKILL\" : \"SIGTERM\")\n  } catch (err) {\n    if (!String(err).includes(\"ESRCH\")) throw err\n  }\n}\n\n/**\n * Send a signal to the given process id.\n *\n * @param {number} pid the process id. Required.\n * @param {boolean} [force=false] if true, and the current user has\n * permissions to send the signal, the pid will be forced to shut down.\n */\nexport function killPid(\n  pid: number,\n  force = false,\n  rewritePidfileOnForce = true\n) {\n  logger().log(force ? \"warn\" : \"debug\", \"killPid\", { pid, force })\n  if (pid === process.pid || pid === process.ppid) {\n    throw new Error(\"cannot self-terminate\")\n  }\n  if (force && rewritePidfileOnForce) {\n    void Pids.instance()?.onKill(pid)\n  }\n  return isWin ? killPidWin(pid, force) : killPidWithNode(pid, force)\n}\n\nexport class Pids {\n  static readonly instance = lazy(() =>\n    map(configDir(), dir => new Pids(BaseFile.for(dir).join(\"pids\")))\n  )\n  private readonly recentPids = new FifoCache<Promise<BaseFile>>(10 * secondMs)\n  constructor(readonly pidsDir: BaseFile) {\n    //\n  }\n\n  async addPid(\n    info: PidfileInfo,\n    start: Date,\n    force = false\n  ): Promise<BaseFile> {\n    if (info == null) {\n      throw new Error(\"undefined info\")\n    }\n    const pid = info.pid\n    if (!gt0(pid)) {\n      throw new Error(\"undefined pid\")\n    }\n    const key = info.ppid + \":\" + info.pid\n    if (force) this.recentPids.delete(key)\n    return this.recentPids.getOrSet(key, async () => {\n      const f = this.pidsDir.join(info.pid + \".json\")\n      const cmd = opt(Try(() => parseNativePath(info.cmd).base))\n        .filter(notBlank)\n        .getOrElse(() => info.cmd)\n\n      const startTime = start.getTime()\n      const json: PidfileJson = {\n        ...info,\n        cmd,\n        startTime\n      }\n      // no need to fslock for pidfiles\n      await f.writeJson_(json)\n      logger().debug(\"addPid() wrote \" + f, json)\n      return f\n    })\n  }\n\n  pidfiles() {\n    return this.pidsDir.clear().children(ea => {\n      const pid = toInt(ea.name)\n      return ea.ext === \".json\" && pid != null && pid !== process.pid\n    })\n  }\n\n  async pids(pidfiles: MaybeSyncOrAsync<BaseFile[]> = this.pidfiles()) {\n    return compact(toA(await pidfiles).map(ea => toInt(ea.name)))\n  }\n\n  async onKill(pid: number): PromiseMaybe<BaseFile> {\n    const pidfile = this.pidsDir.join(pid + \".json\")\n    return thenMap(pidfile.clear().readJson<PidfileJson>(), priorInfo =>\n      this.addPid({ ...priorInfo, maxAgeMs: 1 }, ago(minuteMs), true).catch(\n        err => {\n          logger().info(\"onKill(): failed to rewrite pidfile: \" + err, { pid })\n          return undefined\n        }\n      )\n    )\n  }\n\n  readonly vacuumOldWip = rateLimited({\n    name: \"Pids.vacuumOldWip()\",\n    minCallDelayMs: minuteMs,\n    f: async () => {\n      // look for and delete old WIPs\n      const minMtime = Date.now() - 2 * minuteMs\n      const old = await this.pidsDir.childFiles(\n        async ea =>\n          isJsonExt(ea) &&\n          isHiddenBasename(ea.base) &&\n          lt(await ea.mtimeMs(), minMtime)\n      )\n      for (const ea of toA(old)) {\n        logger().warn(\"killOldProcs(): deleting old pid WIP, \" + ea.base)\n        await ea.unlink(\"debug\")\n      }\n    }\n  })\n\n  /**\n   * @param everything if `true`, ignore pidfile maxAgeMs.\n   * @param force given to `kill`.\n   */\n  readonly killOldProcs = rateLimited({\n    name: \"Pids.killOldProcs()\",\n    minCallDelayMs: minuteMs,\n    f: async (\n      opts: {\n        everything?: boolean\n        force?: boolean\n        everythingBefore?: number\n      } = {}\n    ) => {\n      await this.vacuumOldWip()\n      const everything = opts.everything ?? false\n      const force = opts.force ?? isWin\n      const pidfiles = await this.pidfiles()\n      const pids = await this.pids(pidfiles ?? [])\n      if (isEmpty(pids)) {\n        logger().info(\"killOldProcs(): no pidfiles\")\n        return []\n      }\n      const killed: (PidfileJson & Partial<ProcEntry>)[] = []\n\n      const endPromises: Promise<void>[] = []\n\n      const pidEntries = await pidInfos(pids)\n      if (pidEntries == null) {\n        onError(\"Pids.killOldProcs(): failed to get process information\")\n        return\n      }\n\n      for (const pidfile of pidfiles!) {\n        const pid = toInt(pidfile.name)\n        if (pid == null) {\n          logger().warn(\"killOldProcs(): null pid from \" + pidfile.base)\n          await pidfile.unlink(\"debug\")\n          continue\n        }\n\n        const json = await pidfile.readJson<PidfileJson>()\n        if (json == null) {\n          logger().warn(\n            \"killOldProcs(): failed to read pidfile \" + pidfile.base\n          )\n          await pidfile.unlink(\"debug\")\n          continue\n        }\n        if (json.pid !== pid) {\n          // WHAT?\n          logger().warn(\n            \"killOldProcs(): json.pid != name: unlinking invalid pidfile \" +\n              pidfile.base,\n            { json, pid }\n          )\n          await pidfile.unlink(\"debug\")\n          continue\n        }\n\n        const pidEntry = pidEntries.find(ea => ea.pid === pid)\n        if (pidEntry == null || !matchesPidfileInfo(json, pidEntry)) {\n          logger().debug(\n            \"killOldProcs(): pid no longer present: unlinking \" + pidfile.base,\n            { json, pidEntry }\n          )\n          await pidfile.unlink(\"debug\")\n          killed.push(json)\n          continue\n        }\n\n        const timeoutAt = gt0(json.maxAgeMs)\n          ? json.startTime + json.maxAgeMs\n          : undefined\n\n        const reason = everything\n          ? \"all pids are being shut down\"\n          : gt(Date.now(), timeoutAt)\n          ? `timed out ${Date.now() - timeoutAt!} ms ago`\n          : lt(json.startTime, opts.everythingBefore)\n          ? \"cleanup everything before \" +\n            new Date(opts.everythingBefore!).toISOString()\n          : undefined\n\n        if (reason != null) {\n          logger().info(\"killOldProcs(): killing\", {\n            reason,\n            json\n          })\n          endPromises.push(killPid(pid, force, false))\n          killed.push({ ...json, ...pidEntry })\n          // ... we'll remove the pidfile once the process exits ...\n        }\n      }\n      if (endPromises.length > 0) {\n        await Promise.allSettled(endPromises)\n      }\n\n      return killed\n    }\n  })\n}\n\nexport function addPid(\n  info: PidfileInfo,\n  start: Date\n): Maybe<Promise<BaseFile>> {\n  return Pids.instance()?.addPid(info, start)\n}\n\n// Should only be invoked by MainService\nexport const ProcCleaner = lazy<Endable>(() => {\n  const timers = [\n    // TCBH: prime intervals so they don't collide unnecessarily:\n    { everything: false, force: false, intervalMs: 5 * minuteMs },\n    { everything: false, force: true, intervalMs: 17 * minuteMs }\n  ].map(ea =>\n    setUnrefInterval(() => Pids.instance()?.killOldProcs(ea), ea.intervalMs)\n  )\n  return new EndableWrapper(\n    \"ProcCleaner\",\n    () => {\n      timers.map(clearInterval)\n      return Pids.instance()?.killOldProcs()\n    },\n    EndableRanks.predb\n  )\n})\n","import os from \"os\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { strEnum, StrEnumKeys } from \"../fe/StrEnum\"\n\n// From https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.processpriorityclass?view=netframework-4.8\n\n// AboveNormal Specifies that the process has priority higher than Normal but\n// lower than High.\n\n// BelowNormal Specifies that the process has priority above Idle but below\n// Normal.\n\n// High Specifies that the process performs time-critical tasks that must be\n// executed immediately, such as the Task List dialog, which must respond\n// quickly when called by the user, regardless of the load on the operating\n// system. The threads of the process preempt the threads of normal or idle\n// priority class processes. Use extreme care when specifying High for the\n// process's priority class, because a high priority class application can use\n// nearly all available processor time.\n\n// Idle Specifies that the threads of this process run only when the system is\n// idle, such as a screen saver. The threads of the process are preempted by the\n// threads of any process running in a higher priority class. This priority\n// class is inherited by child processes.\n\n// Normal Specifies that the process has no special scheduling needs.\n\nexport const PriorityClasses = strEnum(\"Normal\", \"BelowNormal\", \"Idle\", \"Low\")\n\nexport type PriorityClass = StrEnumKeys<typeof PriorityClasses>\n\n// PRIORITY_LOW: 19,\n// PRIORITY_BELOW_NORMAL: 10,\n// PRIORITY_NORMAL: 0,\n// PRIORITY_ABOVE_NORMAL: -7,\n// PRIORITY_HIGH: -14,\n// PRIORITY_HIGHEST: -20\n\nexport const PriorityClassToPosix = Object.freeze({\n  Normal: 0,\n  BelowNormal: 10,\n  Low: 19,\n  Idle: 19\n}) satisfies Record<PriorityClass, number>\n\nexport const PriorityClassToNode = Object.freeze({\n  AboveNormal: os.constants.priority.PRIORITY_ABOVE_NORMAL,\n  Normal: os.constants.priority.PRIORITY_NORMAL,\n  BelowNormal: os.constants.priority.PRIORITY_BELOW_NORMAL,\n  Idle: os.constants.priority.PRIORITY_LOW,\n  Low: os.constants.priority.PRIORITY_LOW\n}) satisfies Record<PriorityClass, number>\n\nexport function priorityPosixToClass(\n  priority: Maybe<number>\n): Maybe<PriorityClass> {\n  if (priority == null || !isFinite(priority)) {\n    return\n  } else if (priority < PriorityClassToPosix.BelowNormal) {\n    return PriorityClasses.Normal\n  } else if (priority < PriorityClassToPosix.Idle) {\n    return PriorityClasses.BelowNormal\n  } else {\n    return PriorityClasses.Idle\n  }\n}\n","import process from \"process\"\nimport { lazy } from \"../core/Lazy\"\nimport { isEmpty, isNotEmpty, uniq } from \"../fe/Array\"\nimport { sortBy } from \"../fe/ArraySort\"\nimport { blank, notBlank } from \"../fe/Blank\"\nimport { secondMs } from \"../fe/Date\"\nimport { orElse } from \"../fe/Maybe\"\nimport { PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { gt0, toInt } from \"../fe/Number\"\nimport { onlyReqValued } from \"../fe/Object\"\nimport { toA } from \"../fe/toA\"\nimport { toS } from \"../fe/toS\"\nimport { collectBatchedAsync } from \"./Array\"\nimport { parseFixed } from \"./Fixed\"\nimport { mkLogger } from \"./Logger\"\nimport { existingPids } from \"./Pid\"\nimport { StartTs } from \"./StartTs\"\nimport { pwshJsonDate, wmiDate } from \"./WinDate\"\nimport { thenMap } from \"./async/Promise\"\nimport { StdoutOpts, stdoutResult_, stdout_ } from \"./child/ChildProcess\"\nimport { wmic } from \"./fs/PathTo\"\nimport { isWin } from \"./platform/Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\n\nexport interface ProcEntry {\n  pid: number\n  start: Date\n  cmd: string\n}\n\n// TODO: move to ./proc/Ps.ts\nconst logger = lazy(() => mkLogger(\"proc.ps\"))\n\nexport function isProcEntry(pe: any): pe is ProcEntry {\n  return pe != null && gt0(pe.pid) && pe.start != null && notBlank(pe.cmd)\n}\n\nexport async function ps(): Promise<ProcEntry[]> {\n  const procs = await (isWin ? psWin() : psPosix())\n  return orElse(\n    sortBy(procs.filter(isProcEntry), ea => ea.pid),\n    []\n  )\n}\n\nexport async function pidInfo(pid: number): PromiseMaybe<ProcEntry> {\n  return thenMap(pidInfos([pid]), arr => toA(arr).find(ea => ea.pid === pid))\n}\n\nexport async function notExistingPids(pids: number[]): PromiseMaybe<number[]> {\n  if (isEmpty(pids)) return []\n  return thenMap(existingPids(pids), arr => {\n    const alive = [process.pid, ...arr]\n    return pids.filter(ea => !alive.includes(ea))\n  })\n}\n\nexport async function pidInfos(pids: number[]): PromiseMaybe<ProcEntry[]> {\n  const arr = existingPids(pids)\n\n  const arr2 = await collectBatchedAsync<number, ProcEntry>(\n    arr,\n    20,\n    isWin ? pidInfoWin : pidInfoPosix\n  )\n  const result = arr2.filter(ea => isProcEntry(ea) && arr.includes(ea.pid))\n  return logger().tap({ msg: \"pidInfos()\", result, meta: { pids } })\n}\n\nfunction win2pe(arr: any[]): ProcEntry[] {\n  return arr.map((entry: any) => ({\n    pid: entry.Id,\n    start: pwshJsonDate(entry.StartTime),\n    cmd: entry.ProcessName\n  })) as ProcEntry[]\n}\n\nconst PsWinCmd = \"Get-Process\"\nconst PsWinSelectObj = \"| Select-Object -Property Id,ProcessName,StartTime\"\n\nasync function psWin(): Promise<ProcEntry[]> {\n  if (PowerShell.instance().ended) return psWinWmic()\n  const result = await PowerShell.instance().executeJsonToA(\n    [PsWinCmd, PsWinSelectObj].join(\" \")\n  )\n  return result == null ? psWinWmic() : win2pe(result)\n}\n\nfunction pidToS(pids: number[]): string {\n  return uniq([...pids.filter(gt0), process.pid]).join(\",\")\n}\n\nasync function pidInfoWin(pids: number[]): PromiseMaybe<ProcEntry[]> {\n  if (PowerShell.instance().ended) return psWinWmic(pids)\n  const cmd = [\n    PsWinCmd,\n    \"-Id\",\n    // PowerShell wants the IDs joined by comma:\n    pidToS(pids),\n    \"-ErrorAction SilentlyContinue\", // I expect it not to find some pids\n    PsWinSelectObj\n  ].join(\" \")\n  return thenMap(PowerShell.instance().executeJsonToA(cmd), ea => win2pe(ea))\n}\n\nconst stdoutOpts: StdoutOpts = {\n  maxBuffer: 1024 * 1024, // windows process lists can be enormous\n  timeoutMs: 15 * secondMs, // ps sometimes takes a long time\n  ignoreExitCode: true,\n  ignoreStderr: true\n}\n\nconst headers: (\"CommandLine\" | \"CreationDate\" | \"ProcessId\")[] = [\n  \"CommandLine\",\n  \"CreationDate\",\n  \"ProcessId\"\n]\n\n// NOTE: only used if powershell is shut down\nexport async function psWinWmic(pids?: number[]): Promise<ProcEntry[]> {\n  const args = [\"process\"]\n  if (isNotEmpty(pids)) {\n    // wmic wants multiple PIDs as or clauses, like\n    // wmic process where \"ProcessId=11308 or ProcessId=9416\"\n    const processIdClause = uniq([...pids.filter(gt0), process.pid])\n      .map(ea => `ProcessId=${ea}`)\n      .join(\" or \")\n    args.push(\"where\", processIdClause)\n  }\n  args.push(\"get\", headers.join(\",\"))\n  const result = await stdoutResult_(wmic(), args, stdoutOpts)\n  const results = onlyReqValued(\n    parseFixed(headers, result.result).map((ea: any) => ({\n      pid: toInt(ea.ProcessId, { defaultValue: -1 })!,\n      start: wmiDate(ea.CreationDate),\n      cmd: toS(ea.CommandLine)\n    }))\n  )\n  if (!results.find(ea => ea.pid === process.pid)) {\n    results.push({\n      pid: process.pid,\n      start: new Date(StartTs),\n      cmd: \"node \" + process.title\n    })\n  }\n  return results\n}\n\nfunction psStdout2ProcEntry(result: string): ProcEntry[] {\n  if (blank(result)) return []\n  return parseFixed(\n    [\"PID\", { text: \"STARTED\", greedyLeft: true }, \"COMMAND\"],\n    result\n  ).map((ea: any) => ({\n    pid: toInt(ea.PID, { defaultValue: -1 })!,\n    start: new Date(ea.STARTED),\n    cmd: toS(ea.COMMAND)\n  }))\n}\n\nasync function psPosix(): Promise<ProcEntry[]> {\n  return psStdout2ProcEntry(\n    await stdout_(\"ps\", [\"-ewwwo\", \"pid,lstart,command\"], stdoutOpts)\n  )\n}\n\n/**\n * @param pid the pid to look for\n * @return an array of either just this process, or the process and the requested pid.\n */\nasync function pidInfoPosix(pids: number[]): Promise<ProcEntry[]> {\n  const r = await stdoutResult_(\n    \"ps\",\n    // we include the current pid to prevent either `ps` or the fixed parser\n    // from grumping at us:\n    [\"-p\", pidToS(pids), \"-wwwo\", \"pid,lstart,command\"],\n    {\n      ...stdoutOpts,\n      ignoreExitCode: true\n    }\n  )\n  return psStdout2ProcEntry(r.result)\n}\n","import { delay } from \"../fe/Delay\"\nimport { Latch } from \"../fe/Latch\"\nimport { Maybe, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { gt0, max_ } from \"../fe/Number\"\nimport { SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { Deferred } from \"./async/Deferred\"\nimport { setUnrefTimeout } from \"./async/Timers\"\nimport { WrappedError } from \"./error/WrappedError\"\n\nexport interface RateLimited<T> {\n  (...args: any[]): PromiseMaybe<T>\n  // unschedule any pending future calls\n  clear(): void\n  isRateLimited(): boolean\n  minCallDelayMs(): number\n  setMinCallDelayMs(millis: number): void\n  donePromise(): Promise<void>\n  force(...args: any[]): PromiseMaybe<T>\n  status(): {\n    running: boolean\n    needToDelay: boolean\n    delayNextRunUntil: number\n  }\n}\n\n/**\n * Ensures no concurrent invocations, and a delay between method calls to be at\n * least `minCallDelayMs`.\n *\n * As opposed to debounce, this implementation will only postpone a\n * call to f() at most every timeoutMs, rather than postponing forever.\n */\nexport function rateLimited<T>({\n  f,\n  minCallDelayMs,\n  timeoutMs = undefined,\n  nullOnBusy,\n  name\n}: {\n  f: (...args: any[]) => SyncOrAsync<T>\n  minCallDelayMs: number\n  timeoutMs?: number\n  nullOnBusy?: boolean\n  name: string\n}): RateLimited<T> {\n  let running = false\n  let delayNextRunUntil: number = 0\n  let priorResult: Maybe<Deferred<T>>\n  let nextArgs: Maybe<any[]>\n  minCallDelayMs = Math.ceil(minCallDelayMs)\n\n  const doneLatches: Latch[] = []\n\n  function isRateLimited() {\n    return running || delayNextRunUntil > Date.now()\n  }\n\n  function afterRunDelay() {\n    if (nextArgs != null) {\n      const arr = nextArgs\n      nextArgs = undefined\n      void r(...arr)\n    }\n  }\n\n  async function postRun() {\n    running = false\n    delayNextRunUntil = Date.now() + minCallDelayMs\n\n    setUnrefTimeout(afterRunDelay, minCallDelayMs + 1)\n\n    // only release latches _after_ we've marked ourselves as not running:\n    doneLatches.forEach(ea => ea.resolve())\n    doneLatches.length = 0\n  }\n\n  async function run(...args: any[]) {\n    running = true\n    delayNextRunUntil = Date.now() + max_(minCallDelayMs, timeoutMs)\n\n    // We get to run!\n    const d = (priorResult = new Deferred<T>(name))\n    if (gt0(timeoutMs)) void d.setTimeout(timeoutMs)\n    try {\n      void d.resolve(await f(...args))\n    } catch (cause) {\n      void d.reject(\n        new WrappedError(\"RateLimited(\" + name + \") failed\", { cause })\n      )\n    } finally {\n      void postRun()\n    }\n    return d.promise\n  }\n\n  const r: any = (...args: any[]) => {\n    if (isRateLimited()) {\n      if (nullOnBusy === true) {\n        return null\n      }\n      const result = priorResult?.promise\n      nextArgs = args\n      // the delay breaks hard loops:\n      return delay(1).then(() => result)\n    } else {\n      return run(...args)\n    }\n  }\n  r.clear = () => {\n    nextArgs = undefined\n  }\n\n  r.donePromise = () => {\n    if (!running) return Promise.resolve()\n    const l = new Latch()\n    doneLatches.push(l)\n    return l\n  }\n\n  r.force = async (...args: any[]) => {\n    // unschedule any other runs\n    nextArgs = undefined\n    // wait for the prior run:\n    if (running) await r.donePromise()\n    running = false\n    delayNextRunUntil = 0\n    return r(...args)\n  }\n\n  r.isRateLimited = () => isRateLimited()\n  r.status = () => {\n    return {\n      running,\n      needToDelay: delayNextRunUntil > Date.now(),\n      minNextDelayMs: Math.max(0, Date.now() - delayNextRunUntil)\n    }\n  }\n  r.minCallDelayMs = () => minCallDelayMs\n  r.setMinCallDelayMs = (ms: number) => {\n    minCallDelayMs = ms\n  }\n  return r\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { pick } from \"../fe/Object\"\nimport { toS } from \"../fe/toS\"\n\nexport type IndexedString = [string, number]\n\n/**\n * Given a RegExp and string, return all captured groups and their starting\n * index.\n */\nexport function captures(\n  regex: RegExp,\n  str: string\n): Pick<RegExpExecArray, \"index\" | \"groups\">[] {\n  const result = []\n  if (!regex.global) throw new Error(\"must provide global regex\")\n  let m: RegExpExecArray | null\n  while ((m = regex.exec(str)) != null) {\n    // This is necessary to avoid infinite loops with zero-width matches\n    if (m.index === regex.lastIndex) {\n      regex.lastIndex++\n    } else {\n      result.push(pick(m, \"index\", \"groups\"))\n    }\n  }\n  return result\n}\n\nexport function escapeRegExp(s: string | RegExpEscaped): string {\n  return s instanceof RegExpEscaped\n    ? s.source\n    : toS(s).replace(/[-.,\\\\^$*+?()|[\\]{}]/g, \"\\\\$&\")\n}\n\nexport function matchQuotes(s: string) {\n  return s.replace(/[‘’']/g, \"[‘’']\").replace(/[“”„”«»〃\"]/g, `[“”„”«»〃\"]`)\n}\n\nexport function joinPatterns(arr: string[], flags?: string): RegExp {\n  const result = []\n  for (const ea of arr) {\n    try {\n      new RegExp(ea)\n      result.push(ea)\n    } catch {\n      result.push(escapeRegExp(ea))\n    }\n  }\n  return new RegExp(result.join(\"|\"), flags)\n}\n\n/**\n * When provided to `concatRegexp()`, this `source` won't be further\n * escaped.\n *\n * This is only useful if a snippet of a regular expression is not valid by\n * itself (as it doesn't include balanced parenthesis or other grouping\n * constructs).\n */\nexport class RegExpEscaped {\n  constructor(\n    readonly source: string,\n    readonly flags?: string\n  ) {}\n\n  get global() {\n    return this.flags?.includes(\"g\") ?? false\n  }\n  get ignoreCase() {\n    return this.flags?.includes(\"m\") ?? false\n  }\n  get multiline() {\n    return this.flags?.includes(\"i\") ?? false\n  }\n}\n\nexport class RegExpOptional extends RegExpEscaped {\n  static from(...arr: Maybe<RegExp | string | RegExpEscaped>[]) {\n    const re = concatRegexp(arr)\n    return new RegExpOptional(\"(?:\" + re.source + \")?\", re.flags)\n  }\n}\n\nexport function concatRegexp(\n  arr: Maybe<RegExp | string | RegExpEscaped>[],\n  flags?: string\n): RegExp {\n  let re = \"\"\n  let global = flags?.includes(\"g\") ?? false\n  let ignoreCase = flags?.includes(\"i\") ?? false\n  let multiline = flags?.includes(\"m\") ?? false\n  for (const ea of arr) {\n    if (ea instanceof RegExpEscaped || ea instanceof RegExp) {\n      re += ea.source\n      global ||= ea.global\n      ignoreCase ||= ea.ignoreCase\n      multiline ||= ea.multiline\n    } else {\n      re += escapeRegExp(toS(ea))\n    }\n  }\n  return new RegExp(\n    re,\n    flags ??\n      (global ? \"g\" : \"\") + (ignoreCase ? \"i\" : \"\") + (multiline ? \"m\" : \"\")\n  )\n}\n","import os from \"os\"\nimport path from \"path\"\nimport { lazy } from \"../core/Lazy\"\nimport { compactBlanks } from \"../fe/Array\"\nimport { minuteMs, secondMs } from \"../fe/Date\"\nimport { later } from \"../fe/Delay\"\nimport { flatten } from \"../fe/Flatten\"\nimport { gt0 } from \"../fe/Number\"\nimport { ensureSuffix } from \"../fe/String\"\nimport { toS } from \"../fe/toS\"\nimport { mkLogger } from \"./Logger\"\nimport {\n  PriorityClass,\n  PriorityClassToNode,\n  PriorityClassToPosix,\n  PriorityClasses,\n  priorityPosixToClass\n} from \"./PriorityClass\"\nimport { TTLSet } from \"./TTLSet\"\nimport { stdoutResult_ } from \"./child/ChildProcess\"\nimport { ee } from \"./event/EventEmitter\"\nimport { isWin } from \"./platform/Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\nimport { Settings } from \"./settings/Settings\"\n\nconst logger = lazy(() => mkLogger(\"Renice\"))\n\n// HEY FUTURE ME: reniced.prior()?.clear() is NOT THE SAME as reniced.unset()\n// -- we want to keep the prior TTLSet to avoid creating more memory garbage.\nlater(() => ee().on(\"clearCache\", () => reniced.prior()?.clear()))\n\n// 20220215: changed to a include-list, because we really only care to nice\n// sync, worker, ffmpeg, and vlc.\n\n// Don't renice web, renice, ps, df, ...\n\nconst niceableCmds = lazy(() => [\n  \"sync.js\",\n  \"worker.js\",\n  ...flatten(\n    [\n      \"dcraw_emu\",\n      path.basename(Settings.ffmpegPath.valueOrDefault),\n      path.basename(Settings.vlcPath.valueOrDefault)\n    ].map(ea => (isWin ? [ea, ensureSuffix(ea, \".exe\")] : ea))\n  )\n])\n\nexport function niceable(\n  cmd: string,\n  args: string[] | readonly string[]\n): boolean {\n  return compactBlanks([\n    path.basename(cmd),\n    ...args.map(ea => path.basename(ea))\n  ]).some(ea => niceableCmds().includes(ea.toLowerCase()))\n}\n\nlet nodeReniceWorks = true\n\nconst reniced = lazy(() => new TTLSet<number>(minuteMs))\n\n// both the batch cluster observer and child services renice, which makes sync-file get\n// double-renice-d.\nexport async function renice(pid: number | undefined, priority?: number) {\n  if (!gt0(pid) || reniced().has(pid)) return\n  reniced().add(pid)\n\n  const priorityClass: PriorityClass =\n    priorityPosixToClass(priority) ??\n    (Settings.processPriority.valueOrDefault as PriorityClass)\n\n  priority ??= PriorityClassToNode[priorityClass]\n\n  if (nodeReniceWorks) {\n    try {\n      os.setPriority(pid, priority)\n      return priority\n    } catch (error: any) {\n      // if it's a permission issue, don't try other methods.\n      const permissionDenied =\n        error?.errno === -13 || error?.info?.code === \"EACCES\"\n\n      logger().warn(\"Failed to renice using node:os\", {\n        pid,\n        priority,\n        permissionDenied,\n        error\n      })\n\n      if (permissionDenied) {\n        // it's not node's fault!\n        return\n      }\n      nodeReniceWorks = false\n      // try os-specific methods below:\n    }\n  }\n\n  try {\n    await (isWin\n      ? reniceWin(pid, priorityClass)\n      : renicePosix(\n          pid,\n          PriorityClassToPosix[priorityClass] ??\n            PriorityClassToPosix.BelowNormal\n        ))\n    logger().info(\"Renice pid \" + pid + \" to \" + priorityClass)\n    return priority\n  } catch (err) {\n    // Probably because the process already ended:\n    logger().info(\"Failed to renice pid \" + pid, err)\n    return\n  }\n}\n\nasync function reniceWin(pid: number, pc: PriorityClass) {\n  if (gt0(pid) && PriorityClasses.includes(pc)) {\n    await PowerShell.instance()\n      .execute(`(Get-Process -Id ${pid}).PriorityClass = \"${pc}\"`, ea => ea)\n      .catch(error => logger().info(\"reniceWin() failed\", error))\n  }\n}\n\nasync function renicePosix(pid: number, nice = 19) {\n  await stdoutResult_(\"renice\", [nice, \"-p\", pid].map(toS), {\n    timeoutMs: 10 * secondMs,\n    isIgnorableError: () => true,\n    ignoreExitCode: true\n  }).catch(error => logger().info(\"renicePosix() failed\", error))\n}\n","import process from \"process\"\nimport { lazy } from \"../core/Lazy\"\nimport { compactBlanks } from \"../fe/Array\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { ServiceName, ServiceNames } from \"../fe/ServiceNames\"\nimport { toS } from \"../fe/toS\"\nimport { isTest } from \"./NodeEnv\"\nimport { isPacked } from \"./platform/IsPacked\"\n\nexport const serviceName = lazy<ServiceName>(() => {\n  if (isPacked()) {\n    throw Error(\"serviceName() is unset\")\n  } else {\n    return \"\" as any\n  }\n})\n\nexport const processName = lazy(() =>\n  compactBlanks([serviceName.prior(), toS(process.pid)]).join(\"-\")\n)\n\nserviceName.watchLater(() => {\n  processName.unset()\n})\n\nexport function serviceNameIndex(s: Maybe<ServiceName>): number {\n  return ServiceNames.indexOf(s) ?? ServiceNames.length + 1\n}\n\nexport const MainServices: ServiceName[] = [\n  ServiceNames.main,\n  ServiceNames.desktop\n]\n\n/**\n * If a database isn't available, these services can't run\n */\nexport const DbServices: ServiceName[] = [\n  ServiceNames.sync,\n  ServiceNames.info,\n  ServiceNames.web,\n  ServiceNames.list,\n  ServiceNames.test\n]\n\nexport function isDbService() {\n  return DbServices.includes(serviceName())\n}\n\nexport function isLibraryRequiredService() {\n  return [ServiceNames.sync, ServiceNames.list].includes(serviceName() as any)\n}\n\nexport function isServiceThatAcceptsFatalErrors() {\n  return !isMainService() && !isWebService()\n}\n\nexport function isMainService(name?: ServiceName) {\n  // \"main\" and \"desktop\" are both \"main services\". We only discriminate between\n  // them when the CLI is rendered.\n  return MainServices.includes(name ?? serviceName())\n}\n\nexport function isWebService(name?: ServiceName) {\n  return (name ?? serviceName()) === ServiceNames.web\n}\n\nexport function isBillingService(name?: ServiceName) {\n  return (name ?? serviceName()) === ServiceNames.billing\n}\n\nexport function isWorkerService(name?: ServiceName) {\n  return (name ?? serviceName()) === ServiceNames.worker\n}\n\nexport function isSyncService(name?: ServiceName) {\n  return (name ?? serviceName()) === ServiceNames.sync\n}\n\nexport function isInfoService() {\n  return serviceName() === ServiceNames.info\n}\n\nexport function isTestService() {\n  return serviceName() === ServiceNames.test\n}\n\nfunction isTestNotWorker() {\n  return (isTest || isTestService()) && !isWorkerService()\n}\n\nexport const StatsDbServices: ServiceName[] = [ServiceNames.sync]\n\nexport function isStatsDbService() {\n  return isSyncService()\n}\n\nexport function isStatsDbMigrator() {\n  return isStatsDbService() || isTestNotWorker()\n}\n\nexport function isModelDbMigrator() {\n  // Normally the web service is doing the migrations -- it's first to set up\n  // a library.\n  return isSyncService() || isWebService() || isTestNotWorker()\n}\n\n// Lazy so info can force --cleanup to run a backup:\nexport const isDbJanitorService = lazy(() => isSyncService() || isTestService())\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { Primitive } from \"../fe/Primitive\"\nimport { toA } from \"../fe/toA\"\n\nexport function asSet<T>(s: Maybe<Iterable<T>>): Set<T> {\n  return s instanceof Set ? s : new Set(toA(s))\n}\n\nexport function setEql<T>(a: Set<T>, b: Set<T>): boolean {\n  return (\n    toA(a.keys()).every(ea => b.has(ea)) && toA(b.keys()).every(ea => a.has(ea))\n  )\n}\n\nexport function getOrAdd<K, V>(s: Set<K>, k: K, onAdd: () => V): Maybe<V> {\n  if (k == null) throw new Error(\"null key\")\n  if (s.has(k)) {\n    return undefined\n  } else {\n    s.add(k)\n    return onAdd()\n  }\n}\n\n//\n// These only support primitives, as comparison is done with ==\n//\n\n/**\n * @return unique elements in a or b\n */\nexport function union<T extends Primitive>(\n  a: Iterable<T>,\n  b: Iterable<T>\n): Set<T> {\n  return new Set([...a, ...b])\n}\n\n/**\n * @return elements in a that are also in b\n */\nexport function intersection<T extends Primitive>(\n  a: Iterable<T>,\n  b: Iterable<T>\n): Set<T> {\n  const s = asSet(b)\n  return new Set([...a].filter(ea => s.has(ea)))\n}\n\n/**\n * @return elements in `a` that are not in `b`\n */\nexport function diff<T extends Primitive>(\n  a: Iterable<T>,\n  b: Iterable<T>\n): Set<T> {\n  const s = asSet(b)\n  return new Set([...a].filter(ea => !s.has(ea)))\n}\n","import { later } from \"../fe/Delay\"\nimport { stringify } from \"../fe/JSON\"\nimport { MemoizedThunk } from \"../fe/Lazy\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { gt0 } from \"../fe/Number\"\nimport { isString } from \"../fe/String\"\nimport { SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { FifoCacheAsync } from \"./FifoCacheAsync\"\nimport { Shim0 } from \"./Shim0\"\nimport { ee } from \"./event/EventEmitter\"\nimport { Settings } from \"./settings/Settings\"\n\n// NOTE: this is used statically, so BE CAREFUL WITH NEW CORE IMPORTS: they will\n// probably cause a dependency loop.\n\nexport interface Shim1<I, O> {\n  (input: I): Promise<O>\n  setShim(f: Maybe<(input: I) => SyncOrAsync<O>>): void\n  hasShim(): boolean\n  cache?: MemoizedThunk<FifoCacheAsync<O>>\n  cacheDelete(input: I): void\n}\n\nexport function shim1<I, R>({\n  name,\n  impl,\n  cache,\n  toKey = ea => (isString(ea) ? ea : stringify(ea))\n}: {\n  name: string\n  impl: (input: I) => SyncOrAsync<R>\n  cache?: MemoizedThunk<FifoCacheAsync<R>>\n  toKey?: (input: I) => string\n}): Shim1<I, R> {\n  let shim: Maybe<(input: I) => SyncOrAsync<R>>\n\n  const f = async (input: I) => {\n    const start = Date.now()\n    const result = await (shim != null ? shim(input) : impl(input))\n    ee().emit(\n      \"timing\",\n      name + (shim == null ? \"(local)\" : \"(remote)\"),\n      Date.now() - start\n    )\n    return result\n  }\n\n  const result: Shim1<I, R> = async (input: I) => {\n    if (cache == null) return f(input)\n    return cache().getOrSetAsync(toKey(input), async () => f(input))\n  }\n\n  result.setShim = (i: Maybe<(input: I) => Promise<R>>) => {\n    shim = i\n\n    if (cache != null && gt0(Settings.fsCacheSlowMs.valueOrDefault)) {\n      const c = cache()\n      const useFsCache = c.opts.useFsCache ?? false\n      c.readFsCache = useFsCache\n      c.writeFsCache = useFsCache && shim == null\n    }\n  }\n\n  later(() => {\n    // Make sure changes to useFsCache are reflected in the cache:\n    Settings.fsCacheSlowMs.watchLater(() => {\n      result.setShim(shim)\n    })\n  })\n\n  result.hasShim = () => shim != null\n\n  result.cache = cache\n\n  result.cacheDelete = (input: I) => cache?.().delete(toKey(input))\n\n  return result\n}\n\nexport type ShimReturnType<\n  T extends Shim0<any> | Shim1<any, any> | ((...args: any) => any)\n> = T extends Shim0<infer R>\n  ? Promise<R>\n  : T extends Shim1<any, infer R>\n  ? Promise<R>\n  : T extends (...args: any) => infer R\n  ? R\n  : any\n","import { secondMs } from \"../fe/Date\"\n\n/**\n * For commands that don't need to wait for a disk to spin up, and only return\n * something like --version\n *\n * Note that this is considered the longest time a human can wait before\n * overwhelmed by WTF IS GOING ON.\n */\nexport const ShortCommandTimeoutMs = 7 * secondMs\n","import { at } from \"../fe/At\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { Comparable } from \"../fe/Primitive\"\n\nexport class SortedSet<T> {\n  readonly store: T[] = []\n\n  constructor(readonly valueOf: (t: T) => Maybe<Comparable>) {}\n\n  get length() {\n    return this.store.length\n  }\n\n  addAll(...t: Maybe<T>[]) {\n    return t.map(ea => this.add(ea))\n  }\n\n  findIndex(t: Maybe<T>) {\n    return this.findValueIndex(t == null ? undefined : this.valueOf(t))\n  }\n\n  findValueIndex(v: Maybe<Comparable>) {\n    if (v == null) return\n\n    let low = 0,\n      high = this.store.length - 1\n\n    while (low <= high) {\n      const mid = low + Math.floor((high - low) / 2)\n      const midV = this.valueOf(this.store[mid])!\n      if (v === midV) return { found: true, index: mid }\n      else if (v > midV) low = mid + 1\n      else high = mid - 1\n    }\n    return { found: false, index: low }\n  }\n\n  add(t: Maybe<T>) {\n    const idx = this.findIndex(t)\n    if (idx?.found === false) {\n      this.store.splice(idx.index, 0, t!)\n    }\n    return idx\n  }\n\n  /**\n   * @see https://github.com/tc39/proposal-relative-indexing-method#polyfill\n   */\n  at(idx: number) {\n    return at(this.store, idx)\n  }\n\n  toA() {\n    return [...this.store]\n  }\n\n  /**\n   * Remove all the entries less than the given entry\n   */\n  shiftLte(c: Comparable): T[] {\n    const idx = this.findValueIndex(c)\n    if (idx == null || (idx.index === 0 && !idx.found)) return []\n    if (idx.index === this.store.length - 1) {\n      const result = [...this.store]\n      this.store.length = 0\n      return result\n    } else {\n      return this.store.splice(0, idx.index + (idx.found ? 1 : 0))\n    }\n  }\n\n  /**\n   * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n   * @param start The zero-based location in the array from which to start removing elements.\n   * @param deleteCount The number of elements to remove.\n   */\n  splice(start: number, deleteCount?: number): T[] {\n    const result = this.store.splice(start, deleteCount)\n    return result\n  }\n\n  retainLastN(n: number) {\n    if (n < this.length) {\n      this.splice(0, this.store.length - n)\n    }\n    return this.store\n  }\n}\n","export const StartTs = Date.now()\n\nexport function runtimeMs() {\n  return Date.now() - StartTs\n}\n","import { stdout } from \"process\"\nimport { streamEnded } from \"./fs/StreamEnded\"\n\nexport function stdoutEnded() {\n  return streamEnded(stdout)\n}\n","import process from \"process\"\nimport { WriteStream } from \"tty\"\nimport { notBlank } from \"../fe/Blank\"\nimport { stringify } from \"../fe/JSON\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { isWorkerService } from \"./ServiceNames\"\nimport { stdoutEnded } from \"./StdoutEnded\"\nimport { FailStr } from \"./error/ErrorFlags\"\nimport { isFatalError, isHealthCheckError } from \"./error/ErrorTypes\"\nimport { BaseFile } from \"./fs/BaseFile\"\nimport { streamEnded } from \"./fs/StreamEnded\"\nimport { Setting } from \"./settings/Setting\"\n\nexport const ReadyStr = JSON.stringify({ ready: true })\n\nexport function stdoutWriteReady(ready: boolean = true) {\n  if (!stdoutEnded()) {\n    process.stdout.write(JSON.stringify({ ready }) + \"\\n\")\n  }\n}\n\nexport function stdoutWrite(obj: any, ready?: boolean) {\n  return writeTTY({ obj, ready, stream: process.stdout })\n}\n\nexport function stderrWrite(obj: any) {\n  return writeTTY({ obj, stream: process.stdout })\n}\n\nexport function writeTTY({\n  obj,\n  ready,\n  stream\n}: {\n  obj: any\n  ready?: boolean\n  stream: Maybe<WriteStream>\n}) {\n  const ttyEnded = stream == null || streamEnded(stream)\n  // if (obj != null) {\n  //   try {\n  //     mkLogger(\"writeTTY\").debug(\"()\", { obj, ready, ttyEnded })\n  //   } catch {\n  //     // don't care if I can't log\n  //   }\n  // }\n\n  if (ttyEnded) return\n\n  const str = stringify(obj)\n  stream.write(str + \"\\n\")\n\n  // Only the worker service runs under batch-cluster\n  if (isWorkerService() && ready != null) {\n    if (str.includes(FailStr) || isFatalError(str) || isHealthCheckError(str)) {\n      stream.write(FailStr + \"\\n\")\n    } else {\n      stream.write(ReadyStr + \"\\n\")\n    }\n  }\n}\n\nexport function stdoutWriteSettings(...arr: Setting<any>[]) {\n  const o = {}\n  for (const ea of arr) {\n    ea.addToEnv(o)\n  }\n  stdoutWrite(o)\n}\n\nexport function stdoutWriteMigration(migrationFile: BaseFile) {\n  return stdoutWrite({ migration: migrationFile.name })\n}\n\nexport interface MigrationEvent {\n  migration: string\n}\n\nexport function isMigrationEvent(o: any): o is MigrationEvent {\n  return o != null && notBlank(o.migration)\n}\n\nexport const StdoutWrite = {\n  shutdownSync: () => stdoutWrite({ shutdownSync: true }),\n  restartSync: () => stdoutWrite({ restartSync: true }),\n  forceRestartSync: () => stdoutWrite({ forceRestartSync: true }),\n  rebuildLibrary: () => stdoutWrite({ rebuildLibrary: true }),\n  shutdown: () => stdoutWrite({ shutdown: true })\n}\n","import { compactBlanks, isEmpty, uniq, uniqBy2 } from \"../fe/Array\"\nimport { sortBy } from \"../fe/ArraySort\"\nimport { blank, notBlank } from \"../fe/Blank\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe, MaybeNull } from \"../fe/MaybeTypes\"\nimport { mapNumeric, times, toFloat } from \"../fe/Number\"\nimport { padding } from \"../fe/Pad\"\nimport { cmp } from \"../fe/Primitive\"\nimport { strslice } from \"../fe/String\"\nimport { toA } from \"../fe/toA\"\nimport { toS } from \"../fe/toS\"\nimport { flatZip, greatestBy } from \"./Array\"\nimport { escapeRegExp } from \"./RegExp\"\nimport { NonRetriableErrorFlag } from \"./error/ErrorFlags\"\n\n// TODO: inline\nexport { splitFirst } from \"../fe/SplitFirst\"\nexport {\n  ellipsize,\n  ensurePrefix,\n  ensureSuffix,\n  isString,\n  stripPrefix,\n  stripSuffix,\n  wrap\n} from \"../fe/String\"\n\nconst he = require(\"he\")\n\nexport function rightPad(s: any, minLength: number, padChar: string): string {\n  if (padChar.length === 0) throw new Error(\"rightPad() given empty pad\")\n  const str = String(s)\n  return str + padding(padChar, minLength - str.length)\n}\n\nexport function padReplace(\n  s: string,\n  fromIdx: number,\n  length: number,\n  padChar: string\n) {\n  return (\n    strslice(s, 0, fromIdx) +\n    padding(padChar, length) +\n    strslice(s, fromIdx + length)\n  )\n}\n\nexport function contains(\n  haystack: string,\n  needle: string,\n  fromPosition?: number\n): boolean {\n  return toS(haystack).indexOf(toS(needle), fromPosition) > -1\n}\n\nexport function countChars(\n  haystack: string,\n  needle: string,\n  fromPosition = 0\n): number {\n  if (needle == null || needle.length === 0) return 0\n  // NOTE: this assumes .indexOf is going to be quick native code, and\n  // recursion will be faster than a simple for loop over ths string\n  // characters.\n  const idx = haystack.indexOf(needle, fromPosition)\n  return idx === -1 ? 0 : 1 + countChars(haystack, needle, idx + needle.length)\n}\n\nexport function maybeToS(a?: any): Maybe<string> {\n  return a == null ? undefined : String(a)\n}\n\nexport function trim(arr: any[]): string[] {\n  return arr.map(toS).filter(ea => notBlank(ea))\n}\n\nexport function splitEvery(s: string, n: number, maxSplits?: number): string[] {\n  const sliceTimes =\n    Math.min(Math.ceil(s.length / n), maxSplits ?? s.length) - 1\n  if (sliceTimes <= 0) return [s]\n  return [\n    ...times(sliceTimes, i => s.slice(i * n, (i + 1) * n)),\n    s.slice(sliceTimes * n)\n  ]\n}\n\n/**\n * Removes the first capture group defined by `re` found in `s`.\n */\nexport function spliceCapture(\n  s: string,\n  re: RegExp\n): Maybe<{\n  captured: string\n  uncaptured: string\n  unmatched: string\n  matchedIndex: number\n}> {\n  const m = re.exec(s)\n  if (m == null || m[1] == null) return\n  const matchedIndex = m[0].indexOf(m[1]) + m.index\n  return {\n    captured: m[1],\n    uncaptured:\n      s.substring(0, matchedIndex) + s.substring(matchedIndex + m[1].length),\n    unmatched: s.substring(0, m.index) + s.substring(m.index + m[0].length),\n    matchedIndex\n  }\n}\n\nexport function stripPrefixIgnoreCase(s: string, prefix: string): string {\n  s = toS(s)\n  prefix = toS(prefix)\n  return startsWithIgnoreCase(s, prefix) ? s.slice(prefix.length) : s\n}\n\nexport function stripSuffixIgnoreCase(\n  s: string,\n  suffix: string,\n  opts: { normalize?: boolean } = {}\n): string {\n  if (suffix == null) return s\n  const str = toS(s)\n  const sfx = toS(suffix)\n\n  return sfx.length > 0 && equalsIgnoreCase(str.slice(-sfx.length), sfx, opts)\n    ? str.slice(0, -sfx.length)\n    : str\n}\n\nexport function gist(a: string, maxPre = 80, maxPost = 80): string {\n  const s = toS(a)\n  const charsOmitted = s.length - (maxPre + maxPost)\n  return charsOmitted <= 0\n    ? s\n    : s.slice(0, maxPre).trim() +\n        \" …(+\" +\n        charsOmitted +\n        \" chars)…\" +\n        s.slice(-maxPost).trim()\n}\n\nexport function isLowerCase(s: Maybe<string>): boolean {\n  return toS(s).toLocaleLowerCase() === s\n}\n\nexport function isUpperCase(s: Maybe<string>): boolean {\n  return toS(s).toLocaleUpperCase() === s\n}\nconst CapRE = /^[A-Z]/\n\n/**\n * Is the first character in `s` `[A-Z]`?\n */\nexport function isFirstCharAZ(s: Maybe<string>): boolean {\n  return CapRE.test(toS(s))\n}\n\nexport function capitalize(s: Maybe<string>): string {\n  s = toS(s)\n  return blank(s) ? s : strslice(s, 0, 1).toLocaleUpperCase() + strslice(s, 1)\n}\n\nexport function compareIgnoreCase(a: string, b: string) {\n  const result = a.localeCompare(b, undefined, { sensitivity: \"base\" })\n  return result === 0\n    ? // for determinism:\n      a.localeCompare(b)\n    : result\n}\n\nexport function equalsIgnoreCase(\n  a: MaybeNull<string | Buffer>,\n  b: MaybeNull<string | Buffer>,\n  { normalize = true }: { normalize?: boolean } = {}\n): boolean {\n  if (a == null || b == null) return false\n  const as = toS(a)\n  const bs = toS(b)\n  if (as.length !== bs.length) return false\n  if (as === bs) return true\n  // cheap, but false is sometimes wrong (like in Turkish):\n  if (as.toLowerCase() === bs.toLowerCase()) return true\n  return (\n    (normalize ? as.normalize() : as).localeCompare(\n      normalize ? bs.normalize() : bs,\n      undefined,\n      { sensitivity: \"base\" }\n    ) === 0\n  )\n}\n\nexport function uniqIgnoreCase(arr: string[]): string[] {\n  return uniqBy2(arr, equalsIgnoreCase)\n}\n\nexport function sortIgnoreCase(arr: Iterable<string>): string[] {\n  return toA(arr).sort(compareIgnoreCase)\n}\n\nexport function sortByCaseInsensitive<T>(\n  arr: Iterable<T> | T[],\n  f: (t: T, index: number) => Maybe<string>\n): T[] {\n  return toA(arr)\n    .filter(ea => ea != null)\n    .map((item, idx) => ({\n      item,\n      cmp: map(f(item, idx), ea => [ea, idx]) as [string, number]\n    }))\n    .filter(ea => ea.cmp != null)\n    .sort((a, b) => {\n      const ea = compareIgnoreCase(a.cmp[0], b.cmp[0])\n      return ea !== 0 ? ea : cmp(a.cmp[1], b.cmp[1])\n    })\n    .map(ea => ea.item)\n}\n\n/** TODO DELETE IF UNUSED\n * @return true iff `haystack` starts with `needle`\n */\nexport function startsWithIgnoreCase(\n  haystack: string,\n  needle: string\n): boolean {\n  return haystack == null ||\n    needle == null ||\n    needle.length === 0 ||\n    haystack.length === 0\n    ? false\n    : equalsIgnoreCase(haystack.substring(0, needle.length), needle)\n}\n\n/**\n * @return the first item in `haystack` that is a case-insensitive substring of\n * `needle`.\n */\nexport function firstSubstringIgnoreCase(\n  haystack: string[],\n  needle: string\n): Maybe<{ index: number; match: string }> {\n  if (isEmpty(haystack) || blank(needle)) return\n  for (const ea of haystack) {\n    if (equalsIgnoreCase(ea, needle)) return { index: 0, match: ea }\n  }\n  for (const ea of haystack) {\n    const index = needle.indexOf(ea)\n    if (index >= 0) return { index, match: ea }\n  }\n  const nn = needle.normalize()\n  for (const ea of haystack) {\n    {\n      const index = nn.indexOf(ea)\n      if (index >= 0) return { index, match: ea }\n    }\n    const hn = ea.normalize()\n    {\n      const index = nn.indexOf(hn)\n      if (index >= 0) return { index, match: hn }\n    }\n    {\n      const nl = nn.toLowerCase()\n      const hl = hn.toLowerCase()\n      const index = nl.indexOf(hl)\n      if (index >= 0) return { index, match: hl }\n    }\n  }\n  return\n}\n\n/**\n * Is any item in `haystack` included in `needle`?\n */\nexport function includesIgnoreCase(\n  haystack: string[],\n  needle: string\n): boolean {\n  return isEmpty(haystack) || blank(needle)\n    ? false\n    : haystack.some(ea => equalsIgnoreCase(needle, ea))\n}\n\nexport function reverse(s: string): string {\n  return s == null ? s : [...s].reverse().join(\"\")\n}\n\nexport type Stringable = { valueOf(): string }\n\n/**\n * Return the longest-matching prefix pattern from `patterns` that needle\n * startsWith.\n */\nexport function longestPrefix(\n  needle: string,\n  patterns: string[]\n): Maybe<string> {\n  return greatestBy(\n    patterns.filter(ea => needle.startsWith(ea)),\n    ea => ea.length\n  )\n}\n\n// \\u001b[90m\nexport function stripAnsiEsc(s: string): string {\n  // DON'T REPLACE WITH https://github.com/chalk/ansi-regex/blob/main/index.js :: that shite doesn't work.\n\n  return toS(s).replace(/\\u001b\\[[0-9;]+[a-z]/gi, \"\")\n}\n\nconst Smart2Dumb: [RegExp, string][] = [\n  [/[‘’]/g, `'`],\n  [/[“”„«»”〃]/g, `\"`]\n]\n\nexport function dumbquote(s: string): string {\n  return Smart2Dumb.reduce(\n    (acc, [smart, dumb]) => acc.replace(smart, dumb),\n    s\n  ).normalize()\n}\n\nconst quoted = /^(['\"]).+\\1$/\n\nexport function stripQuotes(s: string): string {\n  if (blank(s)) return s\n  // Some Vivitar cameras have numeric models (!!) so we need to toS().\n  s = toS(s).trim()\n  if (quoted.exec(dumbquote(s)) != null) {\n    s = s.slice(1, -1).trim()\n  }\n  return s\n}\n\nexport function wbrPath(s: string): string {\n  return s\n    .split(/(?<=[\\\\/_,:=-]+)/)\n    .map(ea => he.escape(ea.normalize()) as string)\n    .join(\"<wbr>\")\n}\n\nexport function zipStrings(...arr: string[]): string {\n  let s = \"\"\n  const cb = compactBlanks(arr)\n  const maxLen = Math.max(...cb.map(ea => ea.length))\n  for (let j = 0; j < maxLen; j++) {\n    for (let i = 0; i < cb.length; i++) {\n      map(cb[i], str => map(str[j], ea => (s += ea)))\n    }\n  }\n  return s\n}\n\nexport function splitKeep(s: string, re: RegExp): string[] {\n  const result = splitUp(s, re)\n  return flatZip(result.nonSeparators, result.separators).filter(\n    ea => ea != null && ea.length > 0\n  ) as string[]\n}\n\n/**\n * @return (nonSeparator + separator)*\n */\nexport function splitUp(\n  s: string,\n  re: RegExp\n): { nonSeparators: string[]; separators: string[] } {\n  if (!re.global)\n    throw new Error(\"bad regex (missing global flag)\" + NonRetriableErrorFlag)\n  const nonSeparators: string[] = []\n  const separators: string[] = []\n  let pos = 0\n  let m: RegExpExecArray | null\n  while ((m = re.exec(s)) != null) {\n    // This is necessary to avoid infinite loops with zero-width matches\n    if (m.index === re.lastIndex) {\n      re.lastIndex++\n    } else {\n      re.lastIndex = m[0].length + m.index\n      nonSeparators.push(s.substring(pos, m.index))\n      separators.push(s.substring(m.index, re.lastIndex))\n      pos = re.lastIndex\n    }\n  }\n  if (pos < s.length) {\n    nonSeparators.push(s.substring(pos))\n  }\n  return { nonSeparators, separators }\n}\n\nexport function sortNaturalBy(line: string) {\n  return splitKeep(toS(line), /\\d+(?:\\.\\d+)?/g).map(\n    ea => toFloat(ea.trim()) ?? ea\n  )\n}\n\nexport function sortNatural(lines: string[]): string[] {\n  return sortBy(lines, line => sortNaturalBy(line))\n}\n\nexport function stripDiacritics(s: string): string {\n  // see https://stackoverflow.com/a/37511463/1268016\n  return toS(s)\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\")\n}\n\nexport function stripEmoji(s: string): string {\n  // see https://stackoverflow.com/a/38987183/1268016\n  return toS(s).replace(\n    /\\ud83c[\\udf00-\\udfff]|\\ud83d[\\udc00-\\ude4f]|\\ud83d[\\ude80-\\udeff]/g,\n    \"\"\n  )\n}\n\n/**\n * Remove strings that are prefixes to longer strings in `arr`, ignoring case\n * differences\n * @example ([\"abc\", \"bcd\", \"a\", \"ab\", \"b\"]) -> [\"abc\", \"bcd\"]\n */\nexport function uniqSubstr(arr: string[]): string[] {\n  const rev = sortIgnoreCase(compactBlanks(arr))\n  const result = rev.filter(\n    (ea, idx) => !startsWithIgnoreCase(rev[idx + 1], ea)\n  )\n  return sortBy(result, ea => arr.indexOf(ea))\n}\n\nexport function commonPrefix(a: Maybe<string>, b: Maybe<string>) {\n  if (blank(a) || blank(b)) return \"\"\n  const max = Math.min(a.length, b.length)\n  for (let i = 0; i < max; i++) {\n    if (a[i] !== b[i]) {\n      return a.slice(0, i)\n    }\n  }\n  return a.slice(0, max)\n}\n\nexport function commonPrefixIgnoreCase(\n  a: Maybe<string>,\n  b: Maybe<string>,\n  opts: { normalize?: boolean } = {}\n) {\n  if (blank(a) || blank(b)) return \"\"\n  const max = Math.min(a.length, b.length)\n  for (let i = 0; i < max; i++) {\n    if (!equalsIgnoreCase(a[i], b[i], opts)) {\n      return a.slice(0, i)\n    }\n  }\n  return a.slice(0, max)\n}\n\nexport function commonPrefixLengthIgnoreCase(\n  a: Maybe<string>,\n  b: Maybe<string>,\n  opts: { normalize?: boolean } = {}\n): number {\n  if (blank(a) || blank(b)) return 0\n  const max = Math.min(a.length, b.length)\n  for (let i = 0; i < max; i++) {\n    if (!equalsIgnoreCase(a[i], b[i], opts)) {\n      return i\n    }\n  }\n  return max\n}\n\nexport function indexOfNonSpace(s: string): Maybe<number> {\n  return s.match(/\\S/)?.index\n}\n\nexport function lastIndexOfNonSpace(s: string): Maybe<number> {\n  return s.match(/\\S\\s*$/)?.index\n}\n\nexport function trimLeftPadding(s: string): string {\n  return s.replace(/^[-0_\\s]+/, \"\")\n}\n\n/**\n * Convert \"hello\\040world\" to \"hello world\"\n */\nexport function unoctal(s: string): string {\n  const o = splitUp(s, /\\\\\\d\\d\\d/g)\n\n  return flatZip(\n    o.nonSeparators,\n    o.separators.map(ea =>\n      ea?.length === 4\n        ? mapNumeric(parseInt(ea.slice(1), 8), String.fromCharCode)\n        : undefined\n    )\n  )\n    .map(toS)\n    .join(\"\")\n}\n\nconst CommentRE = /#.*$/gm\n\nexport function stripComments(s: string): string {\n  return s.replace(CommentRE, \"\")\n}\n\nexport function uniqPath(s: MaybeNull<string>[], sep = \":\"): string {\n  // This impl may be easier to follow than 2 compactBlanks() and a uniq()\n  const set = new Set<string>()\n  for (const ea of toA(s)) {\n    if (ea != null && !blank(ea)) {\n      for (const ea2 of ea.split(sep)) {\n        if (!blank(ea2)) set.add(ea2)\n      }\n    }\n  }\n  return [...set].join(sep)\n}\n\n/**\n * First needle wins, all other needles are replaced with `replacement`. Used\n * to make error messages a bit shorter.\n */\nexport function dedupeNeedle(\n  arr: string[],\n  needle: string,\n  replacement: string\n) {\n  if (blank(needle)) return arr\n  const re = new RegExp(\n    // `(?<quot>['\"]?)` + escapeRegExp(needle) + `$<quot>`,\n    `(['\"]?)` + escapeRegExp(needle) + `\\\\1`,\n    \"mg\"\n  )\n  const idx = arr.findIndex(ea => re.test(ea))\n  const dedupeRe = new RegExp(\n    \"(\" + escapeRegExp(replacement) + \"[,:\\\\s]*){2,}\",\n    \"gmi\"\n  )\n  const trimRe = /(^\\s+)|(\\s+$)/gm\n  if (idx < 0) return arr\n  for (let i = idx + 1; i < arr.length; i++) {\n    arr[i] = arr[i]\n      .replace(re, replacement)\n      .replace(/(\\s)\\s+/gm, \" \")\n      // de-stutter:\n      .replace(dedupeRe, replacement)\n      .replace(trimRe, \"\")\n  }\n  return arr\n}\n\nexport function splitUniq(arr: Maybe<string>[], delim: string): string[] {\n  return uniq(\n    compactBlanks(\n      arr\n        .join(delim)\n        .split(delim)\n        .map(ea => ea.trim())\n    )\n  )\n}\n","import { toS } from \"../fe/toS\"\n\nexport function camel2snake(s: string): string {\n  return toS(s)\n    .replace(/([A-Z])([a-z])/g, (_, a, b) => \"_\" + a.toLowerCase() + b)\n    .replace(/[A-Z]+|[0-9]+/g, ea => \"_\" + ea)\n    .replace(/^_/, \"\")\n    .replace(/_+/g, \"_\")\n}\n\nexport function camel2words(s: string): string {\n  return toS(s)\n    .replace(/([A-Z])([a-z])/g, (_, a, b) => \" \" + a.toLowerCase() + b)\n    .replace(/[A-Z]+|[0-9]+/g, ea => \" \" + ea)\n    .trim()\n}\n\nexport function snake2camel(s: string): string {\n  return toS(s).replace(/_([A-Z])/gi, (_, a) => a.toUpperCase())\n}\n\nexport function asObjectKey(s: string) {\n  return snake2camel(\n    s.replace(/^[A-Z]+/, ea => ea.toLowerCase()).replace(/[^a-z]+/gi, \"_\")\n  )\n}\n","import crypto from \"crypto\"\nimport { HashBits } from \"./HashBits\"\nimport { GeoRadix, Radix58 } from \"./math/Radix\"\n\nexport function stringShaToBuffer(input: string, msbits = HashBits): Buffer {\n  return crypto\n    .createHash(\"sha512\")\n    .update(input)\n    .digest()\n    .subarray(0, msbits / 8)\n}\n/**\n * Encoding of the SHA of `input`.\n */\n\nexport function shortStringSha(\n  input: string,\n  len = 9,\n  radix = Radix58,\n  msbits = 224 // < pre-v0.3.5 used 224 bits, so this keeps those SHAs stable\n): string {\n  return radix.encodeBuffer(stringShaToBuffer(input, msbits)).substring(0, len)\n}\n// filesystem-safe short shas\n\nexport function shortFsStringSha(\n  input: string,\n  len = 24,\n  radix = GeoRadix,\n  msbits = 224 // < pre-v0.3.5 used 224 bits, so this keeps those SHAs stable\n): string {\n  return shortStringSha(input, len, radix, msbits)\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { toS } from \"../fe/toS\"\n\nexport function DefaultNormalizer(ea: Maybe<string>): Maybe<string> {\n  return ea == null || ea === \"\" ? undefined : toS(ea).toLowerCase().normalize()\n}\n","import { commonPrefixLength, compactBlanks, count } from \"../fe/Array\"\nimport { sortBy } from \"../fe/ArraySort\"\nimport { blank } from \"../fe/Blank\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { clamp, mapNumericOr, times, toInt } from \"../fe/Number\"\nimport { leftPad } from \"../fe/Pad\"\nimport { Primitive } from \"../fe/Primitive\"\nimport { strslice, substr } from \"../fe/String\"\nimport { toS } from \"../fe/toS\"\nimport { RadixAlphaNum } from \"./math/Radix\"\nimport { Array2D } from \"./Number\"\nimport { firstThunk } from \"./Object\"\nimport { intersection } from \"./Set\"\nimport { stripDiacritics } from \"./String\"\n\n/**\n * @return [0,1], where 0 means no common string, and 1 is equality\n */\nexport function commonSubstringRatio(a: string, b: string): number {\n  return [a, b].some(blank)\n    ? 0\n    : lcs(a, b).length / Math.max(a.length, b.length)\n}\n\n/**\n * @see https://en.wikipedia.org/wiki/Longest_common_substring_problem\n */\nexport function lcs(a: string, b: string): string {\n  if (a == null) return b\n  if (b == null) return a\n  a = a.normalize()\n  b = b.normalize()\n  if (a === b || b.includes(a)) return a\n  if (a.includes(b)) return b\n  const m = new Array2D(a.length)\n  let z = 0\n  let ret = \"\"\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i] === b[j]) {\n        if (i === 0 || j === 0) {\n          m.set(i, j, 1)\n        } else {\n          m.set(i, j, m.get(i - 1, j - 1) + 1)\n        }\n        if (m.get(i, j) >= z) {\n          z = m.get(i, j)\n          ret = substr(a, i - z + 1, z)\n        }\n      }\n    }\n  }\n  return ret\n}\n\n/**\n * Hamming distance. Note that `a` and `b` (before or after normalization) must\n * be the same length, or `undefined` will be returned.\n *\n * Note that this is case-sensitive!\n *\n * @see https://en.wikipedia.org/wiki/Hamming_distance\n */\nexport function hamming(a: string, b: string): Maybe<number> {\n  if (a == null || b == null) return undefined\n  if (a === b) return 0\n  const r = _hamming(a, b)\n  if (r != null) return r\n  const an = a.normalize()\n  const bn = b.normalize()\n  return a !== an || b !== bn ? _hamming(an, bn) : undefined\n}\n\nfunction _hamming(a: string, b: string): Maybe<number> {\n  return a.length !== b.length\n    ? undefined\n    : [...a].reduce((acc, ea, idx) => (ea === b.charAt(idx) ? acc : acc + 1), 0)\n}\n\n/**\n * Return the Sørensen–Dice similarity index between two strings.\n * @see https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient\n * @return [0,1]. O for no match, 1 for full, case-insensitive match.\n */\nexport function diceCoeff(a: string, b: string): number {\n  const A = a.toUpperCase().normalize()\n  const B = b.toUpperCase().normalize()\n  return firstThunk<number>(\n    () => (A === B ? 1 : undefined),\n    () => (blank(a) !== blank(b) ? 0 : undefined),\n    () => (a.length === 1 && b.length === 1 ? 0 : undefined),\n    () => {\n      const aGrams = bigrams(A)\n      const bGrams = bigrams(B)\n      const intersections = nonUniqIntersection(aGrams, bGrams).length\n      return (2 * intersections) / (aGrams.length + bGrams.length)\n    }\n  )!\n}\n\n/**\n * Convert \"abcd\" to [\"ab\", \"bc\", \"cd\"]\n */\nexport function bigrams(s: string): string[] {\n  if (s == null || s.length === 0) return []\n  const arr = [...s]\n  return arr.slice(0, -1).map((ea, i) => ea + arr[i + 1])\n}\n\nexport function nonUniqIntersection<T extends Primitive>(a: T[], b: T[]): T[] {\n  const uniqIntersections = intersection(a, b)\n  const i: T[] = []\n  uniqIntersections.forEach(ea => {\n    const n = Math.min(\n      count(a, s => s === ea),\n      count(b, s => s === ea)\n    )\n    times(n, () => i.push(ea))\n  })\n  return i\n}\n\n/**\n * Tries to prevent numeric overflow:\n */\nfunction diffWithoutCommonPrefix(\n  a: string,\n  b: string,\n  f: (s: string) => number\n): number {\n  const cpc = commonPrefixLength(a, b)\n  return f(strslice(a, cpc)) - f(strslice(b, cpc))\n}\n\n/**\n * Return the value of the longest string of digits in `s`\n */\nfunction longestNumericString(s: string): Maybe<string> {\n  const digits = compactBlanks(toS(s).split(/[^\\d]+/))\n  return sortBy(digits, ea => -ea.length)[0]\n}\n\nexport function lnsDiff(a: string, b: string): number {\n  const [a1, b1] = [a, b]\n    .map(longestNumericString)\n    .map(ea => (blank(ea) ? \"\" : ea))\n  return diffWithoutCommonPrefix(a1, b1, s => toInt(s, { defaultValue: 0 })!)\n}\n\nconst notAlphaNumRe = /[^0-9a-z]+/gi\nexport function radixDiff(a: string, b: string): number {\n  const [a1, b1] = [a, b].map(s =>\n    stripDiacritics(s).replace(notAlphaNumRe, \"\").toLowerCase()\n  )\n  return diffWithoutCommonPrefix(a1, b1, s => RadixAlphaNum.decode(s)!)\n}\n\nexport function str(a: string, b: string) {\n  return {\n    pref: commonPrefixLength(a, b),\n    ham: hamming(a, b),\n    dice: diceCoeff(a, b),\n    lns: lnsDiff(a, b),\n    radixDiff: radixDiff(a, b)\n  }\n}\n\n/**\n * @return the number of non-lower-case characters in `s`\n */\nexport function lcdiff(s: string): number {\n  return count(\n    [...s.normalize()],\n    ea => ea.toLowerCase().localeCompare(ea) !== 0\n  )\n}\n\n/**\n * @return the weighted average of the character differences per character index\n */\nexport function positionalDiff(a: string, b: string) {\n  let result: Maybe<number>\n  for (let i = Math.max(a.length, b.length); i >= 0; i--) {\n    const aChar = mapNumericOr(a.charCodeAt(i), ea => ea, 256)\n    const bChar = mapNumericOr(b.charCodeAt(i), ea => ea, 256)\n    const diff = clamp(-256, 256, aChar - bChar)\n    if (result == null) result = diff\n    else result = (result + diff) / 2\n  }\n  return result\n}\n\nexport function paddedPositionalDiff(a: string, b: string, minLen = 8) {\n  return positionalDiff(leftPad(a, minLen, \" \"), leftPad(b, minLen, \" \"))\n}\n","import { stringify } from \"../fe/JSON\"\nimport { sortedKeys } from \"./Object\"\n\n/**\n * Returns JSON.stringify with keys in sorted order (if `o` is a Record)\n */\nexport function stringifySorted(o: any): string {\n  return stringify(sortedKeys(o))\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { setUnrefTimeout } from \"./async/Timers\"\n\nexport class TTLSet<T> implements Set<T> {\n  readonly [Symbol.toStringTag] = \"TTLSet\"\n  private readonly expireListeners: ((k: T) => void)[] = []\n\n  // Maps entries to insertion time values. Entries should expire after value + this.ttlMs.\n  private readonly delegate = new Map<T, number>()\n\n  /**\n   * @param ttlMs if external consumers change this public value, we won't\n   * auto-re-vacuum existing values, but the new ttl will be correct for new\n   * values.\n   */\n  constructor(\n    public ttlMs: number,\n    readonly scheduleExpirationTimers = false\n  ) {}\n\n  get size(): number {\n    this.#vacuum()\n    return this.delegate.size\n  }\n\n  add(value: T): this {\n    this.delegate.set(value, Date.now())\n    if (this.scheduleExpirationTimers)\n      setUnrefTimeout(() => this.#vacuum(), this.ttlMs + 1)\n    return this\n  }\n\n  addAll(values: T[]) {\n    for (const ea of values) {\n      this.add(ea)\n    }\n    return\n  }\n\n  addIfMissing<R>(value: T, onMissing: () => R): Maybe<R> {\n    const prior = this.delegate.get(value)\n    if (prior == null || this.#isEntryExpired(value, prior)) {\n      this.add(value)\n      return onMissing()\n    } else {\n      return\n    }\n  }\n\n  clear(): this {\n    this.delegate.clear()\n    return this\n  }\n\n  delete(value: T): boolean {\n    return this.delegate.delete(value)\n  }\n\n  forEach(callbackfn: (value: T, index: T, set: Set<T>) => void): void {\n    for (const [value, ctime] of this.delegate) {\n      if (!this.#isEntryExpired(value, ctime)) {\n        callbackfn(value, value, this)\n      }\n    }\n  }\n\n  has(value: Maybe<T>): boolean {\n    return value != null && !this.#isEntryExpired(value)\n  }\n\n  values(): IterableIterator<T> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<T> {\n      for (const [k, v] of self.delegate) {\n        if (!self.#isEntryExpired(k, v)) {\n          yield k\n        }\n      }\n    }\n    return iter()\n  }\n\n  readonly keys = this.values.bind(this)\n\n  entries(): IterableIterator<[T, T]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<[T, T]> {\n      for (const [k, v] of self.delegate) {\n        if (!self.#isEntryExpired(k, v)) {\n          yield [k, k]\n        }\n      }\n    }\n    return iter()\n  }\n\n  toA(): T[] {\n    this.#vacuum()\n    return [...this.delegate.keys()]\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values()\n  }\n\n  on(_event: \"expire\", listener: (k: T) => void) {\n    this.expireListeners.push(listener)\n  }\n\n  /**\n   * @param ctime is the last-set time associated to the key.\n   */\n  #isEntryExpired(key: T, ctime?: number): boolean {\n    ctime ??= this.delegate.get(key)\n    if (ctime == null || !this.delegate.has(key)) return true\n\n    const expired = ctime <= Date.now() - this.ttlMs\n    if (expired) {\n      // delete the key before we tell the listerners\n      this.delegate.delete(key)\n      for (const ea of this.expireListeners) {\n        ea(key)\n      }\n    }\n    return expired\n  }\n\n  /**\n   * remove all expired entries\n   */\n  #vacuum() {\n    for (const [k, v] of this.delegate) {\n      this.#isEntryExpired(k, v)\n    }\n  }\n}\n","import os from \"node:os\"\nimport process from \"node:process\"\nimport { lazy } from \"../core/Lazy\"\nimport { uniq } from \"../fe/Array\"\nimport { blank, toNotBlank } from \"../fe/Blank\"\nimport { toBoolean } from \"../fe/Boolean\"\nimport { PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { gte0 } from \"../fe/Number\"\nimport { mkLogger } from \"./Logger\"\nimport { ShortCommandTimeoutMs } from \"./ShortCommandTimeoutMs\"\nimport { stdout_ } from \"./child/ChildProcess\"\nimport { getEnv } from \"./env/GetEnv\"\nimport { isWin } from \"./platform/Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\n\nconst logger = lazy(() => mkLogger(\"UserInfo\"))\n\nexport async function userDesc() {\n  let result = \"user \" + (await username())\n  if (gte0(userid())) {\n    result += \" (userid \" + userid() + \")\"\n  }\n  return result\n}\n\nexport const userids = lazy<number[]>(() =>\n  // we prefer the effective id, but use getgid and userInfo to backfill.\n  // uniq also compacts\n  uniq([process.geteuid?.(), process.getuid?.(), os.userInfo().uid])\n)\n\nexport const userid = lazy<number>(() => userids()[0])\n\nexport const groupids = lazy<number[]>(() =>\n  // we prefer the effective id, but use getgid and userInfo to backfill:\n  uniq([process.getegid?.(), process.getgid?.(), os.userInfo().gid])\n)\n\nexport const groupid = lazy<number>(() => groupids()[0])\n\nexport const usernameFromEnv = lazy(() => {\n  for (const ea of [\n    // https://github.com/sindresorhus/username/blob/f4a47485fcdf3bafee221cf5e6d6180344020d08/index.js#L9\n    \"SUDO_USER\",\n    \"C9_USER\", // Cloud9\n    \"LOGNAME\",\n    \"USER\",\n    \"LNAME\",\n    \"USERNAME\" // windows calls this UserName, so we're using getEnv() (which is case-insensitive)\n  ]) {\n    const v = getEnv(ea as any)\n    if (!blank(v)) return v\n  }\n  return\n})\n\nexport const usernameFromUserInfo = lazy(() =>\n  toNotBlank(os.userInfo()?.username)\n)\n\nexport const userNameFromWhoami = lazy(async () =>\n  stdout_(\"whoami\", [], {\n    ignoreExitCode: true,\n    timeoutMs: ShortCommandTimeoutMs,\n    isIgnorableError: () => true\n  })\n    .then(toNotBlank)\n    .catch(error => logger().warn(\"$(whoami) failed\", { error }))\n)\n\nexport const userNameFromWindowsAccessToken = lazy(async () =>\n  !isWin\n    ? undefined\n    : PowerShell.instance().execute(\n        // https://stackoverflow.com/a/29955210\n        \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\",\n        toNotBlank\n      )\n)\n\nexport const username = lazy<PromiseMaybe<string>>(\n  async () =>\n    usernameFromEnv() ??\n    usernameFromUserInfo() ??\n    (await userNameFromWhoami()) ??\n    (await userNameFromWindowsAccessToken())\n)\n\nfunction pwshIsAdmin() {\n  return isWin\n    ? PowerShell.instance().execute(\n        // https://serverfault.com/a/95464\n        \"(New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\",\n        toBoolean\n      )\n    : undefined\n}\n\nexport const isRootUser = lazy<PromiseMaybe<boolean>>(async () =>\n  isWin ? pwshIsAdmin() : userids().includes(0)\n)\n","export const version = \"2023.8.0-prealpha.8\";\nexport const versionMajor = 2023;\nexport const versionMinor = 8;\nexport const versionPatch = 0;\nexport const versionPrerelease = [\"prealpha\",8];\nexport const release = \"2023.8.0-prealpha.8+20230828132545\";\nexport const gitSha = \"8a4010c1e417c9e84ff705589e547827b8d6dcbb\";\nexport const gitDate = new Date(1693254345000);\nexport default {version,versionMajor,versionMinor,versionPatch,versionPrerelease,release,gitSha,gitDate};\n","import { dayMs, minuteMs } from \"../fe/Date\"\nimport { allDefined } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { toInt } from \"../fe/Number\"\nimport { opt } from \"../fe/Opt\"\nimport { within } from \"./Number\"\n\nconst wmi =\n  /((?:19|20)\\d\\d)([01]\\d)([0123]\\d)([012]\\d)([012345]\\d)([012345]\\d)\\.(\\d{6})([+-]\\d{3})?/\n/**\n * yyyymmddHHMMSS.mmmmmmsUUU or 20190415124112.947119-420\n *\n * @see https://msdn.microsoft.com/en-us/library/aa387237(v=vs.85).aspx\n */\nexport function wmiDate(s: string): Maybe<Date> {\n  const m = wmi.exec(s)\n  if (m == null) return\n  const arr = m.slice(1, 8).map(ea => toInt(ea))\n  if (!allDefined(arr)) return undefined\n  const [year, mon, day, hour, min, sec, micros] = arr as number[]\n  const offset = toInt(m[8], { defaultValue: 0 })!\n\n  // console.dir({ s, m, year, mon, day, hour, min, sec, micros, offset })\n  return new Date(\n    Date.UTC(year, mon - 1, day, hour, min, sec, micros / 1000) -\n      offset * minuteMs\n  )\n}\n\nconst WinDateRe = /Date\\((\\d+)\\)/\n\n/**\n * PowerShell renders Dates in JSON structures as \"/Date(1552014999676)/\"\n */\nexport function pwshJsonDate(s: string): Maybe<Date> {\n  return opt(s)\n    .flatMap(ea => WinDateRe.exec(ea))\n    .flatMap(ea => ea[1])\n    .flatMap(toInt)\n    .filter(ea => within(0, Date.now() + dayMs, ea))\n    .map(ea => new Date(ea))\n    .get()\n}\n","/**\n * @see AbortController\n * @see AbortSignal\n */\nexport class AbortError extends Error {}\n","import timers from \"timers\"\nimport util from \"util\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { asError } from \"../../fe/Error\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { omit } from \"../../fe/Object\"\nimport { Comparable } from \"../../fe/Primitive\"\nimport { isPromise } from \"../../fe/Promise\"\nimport { PromiseState, PromiseStates } from \"../../fe/PromiseState\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { TimeoutError } from \"../../fe/TimeoutError\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { isIgnorableError } from \"../error/ErrorTypes\"\nimport { onTimeout } from \"./TimeoutHandler\"\n\n/**\n * Deferred resolution of a promise with synchronous state\n */\nexport class Deferred<T, P = any> implements Promise<T> {\n  static async *toAsyncIterable<I, O>(arr: Deferred<I, O>[]) {\n    while (!isEmpty(arr)) {\n      // Yield the first completed value:\n      const idx = arr.findIndex(ea => !ea.isPending)\n      if (idx >= 0) {\n        const result = arr[idx]\n        arr.splice(idx, 1)\n        yield result\n      } else {\n        try {\n          // Wait for the next one to complete, and run the loop again:\n          await Promise.race(arr)\n        } catch {\n          // if the next promise raises, we still want to return that Deferred\n          // (the caller can check on the rejected status)\n        }\n      }\n    }\n  }\n\n  static #id = 0\n\n  static resolve<I, O = any>(\n    t: I,\n    opts?: { payload?: O; serialId?: Comparable }\n  ): Deferred<I, O> {\n    const d = new Deferred<I>(\".resolved()\", opts)\n    return d.resolve(t)\n  }\n\n  readonly id: number\n  readonly payload?: P\n  /**\n   * If this is defined, Promises should prevent concurrent execution of other\n   * Deferred instances with the same serialId.\n   */\n  readonly serialId?: Comparable\n  readonly startedAt = Date.now()\n  #settledAt?: number\n  #state: PromiseState = PromiseStates.pending\n  #value?: T\n  readonly promise: Promise<T>\n  #resolve!: (value: T) => void\n  #reject!: (reason?: any) => void\n  #error: Maybe<Error>\n  #priorTimeout: Maybe<NodeJS.Timeout>\n  #logger: Maybe<Logger>\n\n  /**\n   * @param name can be either a string or a data payload to associate with the\n   * promise.\n   */\n  constructor(\n    readonly name: string,\n    opts?: { payload?: P; serialId?: Comparable }\n  ) {\n    this.id = Deferred.#id++\n    this.promise = new Promise<T>((resolve, reject) => {\n      this.#resolve = resolve\n      this.#reject = reject\n    })\n    this.payload = opts?.payload\n    this.serialId = opts?.serialId\n  }\n\n  private get logger() {\n    return this.#logger ?? mkLogger(\"async.Deferred(\" + this.name + \")\")\n  }\n\n  // Only true for the same instance\n  eql(d: Deferred<T>): boolean {\n    return d instanceof Deferred && d.id === this.id\n  }\n\n  // This is used by LogMeta for logging:\n  toLogJSON() {\n    return {\n      _ctor: \"Deferred\",\n      name: this.name,\n      state: this.#state,\n      value: this.value,\n      serialId: this.serialId,\n      payload: this.payload,\n      elapsedMs: this.elapsedMs\n    }\n  }\n\n  toJSON() {\n    return omit(this.toLogJSON(), \"value\", \"elapsedMs\")\n  }\n\n  get settledAt() {\n    return this.#settledAt\n  }\n\n  get elapsedMs() {\n    return (this.#settledAt ?? Date.now()) - this.startedAt\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"async.Deferred(\" + this.name + \")\"\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON()\n  }\n\n  observeQuietly(p: Promise<T>): Deferred<Maybe<T>> {\n    if (isPromise(p)) {\n      p.then(resolution => {\n        void this.maybeResolve(resolution)\n      }).catch(err => {\n        this.logger.warn(\"observeQuietly.reject()\", err)\n        void this.maybeResolve(undefined as any)\n      })\n    } else {\n      void this.maybeResolve(p)\n    }\n    return this as any\n  }\n\n  observe(p: SyncOrAsync<T>): this {\n    if (isPromise(p)) {\n      p.then(resolution => {\n        void this.maybeResolve(resolution)\n      }).catch(err => {\n        void this.maybeReject(err)\n      })\n    } else {\n      void this.maybeResolve(p)\n    }\n    return this\n  }\n\n  /**\n   * Reject the promise if it hasn't been resolved or rejected within\n   * `timeoutMs`\n   */\n  setTimeout(timeoutMs: number, unref: boolean = true): this {\n    if (this.#priorTimeout != null) {\n      timers.clearTimeout(this.#priorTimeout)\n      this.#priorTimeout = undefined\n    }\n\n    if (gt0(timeoutMs)) {\n      // unref so it doesn't prevent node from exiting:\n      this.#priorTimeout = timers.setTimeout(() => {\n        if (this.isPending) {\n          void this.reject(\n            new TimeoutError(\n              \"Timeout \" +\n                this.name +\n                \" after \" +\n                (Date.now() - this.startedAt) +\n                \"ms\"\n            )\n          )\n          onTimeout()\n        }\n      }, timeoutMs)\n      if (unref) {\n        this.#priorTimeout.unref()\n      }\n    }\n    return this\n  }\n\n  get stateStr(): PromiseState {\n    return this.isPending\n      ? \"pending\"\n      : this.isResolved\n      ? \"resolved\"\n      : \"rejected\"\n  }\n\n  get isPending() {\n    return this.#state === PromiseStates.pending\n  }\n\n  /**\n   * @return the resolved value for this Deferred, or `undefined` if this\n   * is either still pending or rejected.\n   */\n  get value(): Maybe<T> {\n    return this.isResolved ? this.#value : undefined\n  }\n\n  get error(): Maybe<Error> {\n    return this.#error\n  }\n\n  /**\n   * true iff either resolved or rejected.\n   */\n  get isSettled() {\n    return this.#state !== PromiseStates.pending\n  }\n\n  get isResolved() {\n    return this.#state === PromiseStates.resolved\n  }\n\n  get isRejected() {\n    return this.#state === PromiseStates.rejected\n  }\n\n  get settledMs(): number | undefined {\n    return this.#settledAt == null\n      ? undefined\n      : this.#settledAt - this.startedAt\n  }\n\n  /**\n   * Resolves the internal promise. Cannot be invoked more than once.\n   */\n  resolve(value: T): this {\n    return this.#settle(() => {\n      this.#state = PromiseStates.resolved\n      this.#value = value\n      this.#resolve(value)\n    })\n  }\n\n  maybeResolve(value: T): this {\n    return this.isPending ? this.resolve(value) : this\n  }\n\n  reject(reason?: any): this {\n    this.logger.log(\n      isIgnorableError(reason) === true ? \"info\" : \"warn\",\n      \".reject()\",\n      reason\n    )\n    const err = asError(reason)\n    return this.#settle(() => {\n      this.#error = err\n      this.#state = PromiseStates.rejected\n      this.#reject(err)\n    })\n  }\n\n  maybeReject(reason?: any): this {\n    return this.isPending ? this.reject(reason) : this\n  }\n\n  finally(f: () => any): this {\n    // don't create a new promise chain that may have an unhandled error!\n    void this.promise.finally(f).catch(() => undefined)\n    return this\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): Promise<TResult1 | TResult2> {\n    return this.promise.then(onfulfilled, onrejected)\n  }\n\n  catch<U>(onrejected: (reason: any) => U | PromiseLike<U>): Promise<T | U> {\n    return this.promise.catch(err => onrejected(err))\n  }\n\n  #settle(firstback: () => void): this {\n    if (this.#state === PromiseStates.pending) {\n      map(this.#priorTimeout, timers.clearTimeout)\n      firstback()\n      this.#settledAt = Date.now()\n      const ms = this.settledMs!\n      if (this.isResolved && ms > 5000) {\n        this.logger.info(\"Completed in \" + ms + \"ms\")\n      }\n    } else {\n      this.logger.warn(\n        \"settled multiple times (already \" + this.stateStr + \")\",\n        { value: this.#value }\n      )\n    }\n    return this\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { MultiMap } from \"../../fe/MultiMap\"\nimport { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\nimport { MaybeSyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { mkLogger } from \"../Logger\"\nimport { isSingleSpecTests, isTest } from \"../NodeEnv\"\nimport { firstGt0 } from \"../Number\"\nimport { getDevEnvFlag } from \"../env/DevEnvFlags\"\nimport { setUnrefInterval } from \"./Timers\"\n\nconst logger = lazy(() => mkLogger(\"async.Endable\"))\n\nexport interface Endable {\n  readonly name: string\n  readonly ended: boolean\n  readonly endTimeoutMs?: number\n  end(): Promise<any> | any\n}\n\nconst endablesByRank = new MultiMap<EndableRank, Endable>()\n\nsetUnrefInterval(() => vacuumEndables(), 1 * minuteMs)\n\nconst DefaultTimeoutMs = 5 * secondMs\n\nexport const EndableRanks = strEnum(\n  \"first\",\n  \"stats\",\n  \"service\",\n  \"predb\",\n  \"db\",\n  \"postdb\",\n  \"logger\",\n  \"logtail\"\n)\nexport type EndableRank = StrEnumKeys<typeof EndableRanks>\n\n/**\n * Add an endable with an arbitrary end rank\n */\nexport function addEndable<T extends Endable>(\n  rank: EndableRank,\n  endable: T\n): T {\n  EndableRanks.validOrElse(rank, () => {\n    throw new Error(\"internal error: invalid rank \" + rank)\n  })\n  endablesByRank.add(rank, endable)\n  return endable\n}\n\nlet _ending = false\n\nexport function ending(): boolean {\n  return _ending\n}\n\nexport function setEnding(value: boolean) {\n  if (isTest) {\n    _ending = value\n  } else {\n    throw new Error(\"cannot set ending\")\n  }\n}\n\nexport function endAll(...arr: Maybe<Endable>[]) {\n  return Promise.all(arr.map(ea => end(ea)))\n}\n\nexport async function end(e: MaybeSyncOrAsync<Endable>, endTimeoutMs?: number) {\n  const endable = await e\n  if (endable == null || true === endable?.ended) return\n  const timeoutMs =\n    isTest && getDevEnvFlag(\"PS_SINGLE_SPEC_TESTS\")\n      ? 100\n      : firstGt0(endTimeoutMs, endable.endTimeoutMs, DefaultTimeoutMs)!\n  logger().trace(endable.name + \" ending...\", { timeoutMs })\n  try {\n    await thenOrTimeoutError(endable.end(), timeoutMs, false)\n  } catch (err) {\n    try {\n      // the logger might throw errors at the very end:\n      logger().warn(endable.name + \".end() failed\", err)\n    } catch {\n      //\n    }\n  }\n}\n\nfunction vacuumEndables() {\n  endablesByRank.filterInPlace((_, v) => v.ended !== true)\n  logger().debug(\n    \"vacuumEndables()\",\n    endablesByRank.entriesArray().map(([k, v]) => [k, v.map(ea => ea.name)])\n  )\n}\n\nexport const endEndables = lazy(async () => {\n  const endTimeoutMs = isSingleSpecTests() ? 500 : undefined\n  logger().info(\"endEndables()\", {\n    isTest,\n    isSingleSpecTests: isSingleSpecTests()\n  })\n  if (!isTest) _ending = true\n  vacuumEndables()\n  for (const rank of EndableRanks.values) {\n    const arr = endablesByRank.get(rank) ?? []\n    if (isNotEmpty(arr)) {\n      logger().debug(\"endEndables(): ending \" + rank)\n      await Promise.allSettled(arr.map(ea => end(ea, endTimeoutMs)))\n    }\n  }\n})\n\nexport function endablesStats() {\n  const result: any = {}\n  for (const rank of EndableRanks.values) {\n    const arr = endablesByRank.get(rank) ?? []\n    result[rank] = arr.map(ea => ({ name: ea.name, ended: ea.ended }))\n  }\n  return result\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { Latch } from \"../../fe/Latch\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { Endable, EndableRank, EndableRanks, addEndable } from \"./Endable\"\nimport { awaitSettled } from \"./Promise\"\n\n/**\n * Base class for Endables.\n */\nexport class EndableWrapper implements Endable {\n  #name!: string\n  logger!: Logger\n\n  protected readonly onEnds: (() => any)[] = []\n  readonly #endPromise = lazy(() => new Latch())\n  /**\n   * @param name for logging\n   * @param onEnd called by `this.end()`. May return a promise.\n   * @param _isEnded if the wrapped instance can end from other state mutations,\n   * providing this method will allow this wrapper to be garbage collected.\n   */\n  constructor(\n    name: string,\n    onEnd?: () => Promise<any> | any,\n    rank: EndableRank = EndableRanks.first,\n    readonly endTimeoutMs?: number\n  ) {\n    this.name = name\n    if (onEnd != null) this.onEnds.push(onEnd)\n    addEndable(rank, this)\n  }\n\n  get name() {\n    return this.#name\n  }\n\n  set name(n: string) {\n    this.#name = n\n    this.logger = mkLogger(n)\n  }\n\n  get ended() {\n    return this.end.hasPrior()\n  }\n\n  end = lazy(async () => {\n    await awaitSettled(this.onEnds.map(ea => ea()))\n    void this.#endPromise().resolve()\n  })\n\n  awaitEnd(): Promise<void> {\n    return this.#endPromise()\n  }\n}\n","import process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { toNotBlank } from \"../../fe/Blank\"\nimport { magenta } from \"../Chalk\"\nimport { mkLogger } from \"../Logger\"\nimport { stderrWrite } from \"../StdoutWrite\"\nimport { toWrappedError } from \"../error/WrappedError\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { endEndables, ending } from \"./Endable\"\n\nconst logger = lazy(() => mkLogger(magenta(\"Exit\")))\n\nexport const onFatalHandlers: ((reason: string) => any)[] = []\n\nexport async function exit(args: {\n  reason?: string\n  status?: number\n  error?: any\n}) {\n  logger().log(args.status === 0 ? LogLevels.info : LogLevels.warn, \"exit()\", {\n    ...args,\n    ending: ending()\n  })\n  const error = toWrappedError(args.error, {\n    message: args.reason,\n    errno: args.status\n  })\n  if (error.errno !== 0 || error.fatal === true) {\n    stderrWrite({ fatal: true, ...args })\n    const reason = toNotBlank(args?.reason) ?? error.toString()\n    for (const ea of onFatalHandlers) {\n      await ea(reason)\n    }\n  }\n\n  if (!ending()) {\n    await endEndables()\n    process.exit(args.status)\n  }\n}\n\nexport const exitOnStdStream = lazy(() => {\n  for (const streamName of [\"stdin\", \"stdout\", \"stderr\"] as const) {\n    for (const eventName of [\"close\", \"error\", \"disconnect\", \"end\"] as const) {\n      process[streamName].on(eventName, (error: any) => {\n        void exit({\n          reason: `${streamName}:${eventName}`,\n          status: 0,\n          error\n        })\n      })\n    }\n  }\n})\n","import { eql } from \"../../fe/Eql\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { toErr } from \"../../fe/toErr\"\nimport { Deferred } from \"./Deferred\"\n\nexport type MemoizedDeferredListener<T> = {\n  onChange(newResult: T): any\n  onError(error: Error): any\n}\n\nexport interface MemoizedDeferred<T> {\n  (): Deferred<T>\n\n  /**\n   * Clears the prior value but doesn't return it (so we don't have to\n   * explicitly ignore unawaited promises)\n   */\n  unset(): void\n\n  /**\n   * Force the prior value to be `t`\n   */\n  set(t: T): void\n\n  /**\n   * Forces the underlying thunk or later to be applied\n   */\n  refresh(): Deferred<T>\n\n  /**\n   * @return the milliseconds a prior result may be returned by `apply`, or\n   * undefined if no TTL is set\n   */\n  ttl(): Maybe<number>\n\n  /**\n   * @param ttl undefined to remove TTL expirations\n   */\n  setTTL(ttl: Maybe<number>): void\n\n  /**\n   * Calls the listener if the result changes later. The underlying thunk is\n   * not applied now (like with {@link MemoizedThunk.watch}).\n   */\n  watchLater(watcher: MemoizedDeferredListener<T>): void\n\n  /**\n   * @return undefined if unset\n   */\n  lastSetAgoMs(): Maybe<number>\n\n  /**\n   * @return the previously-memoized Deferred, if it isn't stale (according to\n   * `ttl()`)\n   */\n  prior(): Maybe<Deferred<T>>\n\n  /**\n   * @return the last memoized awaited result (even if it's stale!).\n   */\n  lastValue(): Maybe<T>\n\n  /**\n   * @return the number of times the underlying thunk has been applied\n   */\n  settledCount(): number\n\n  /**\n   * Has a result not been calculated, or was calculated more than `ttl()` ms\n   * ago?\n   */\n  isStale(): boolean\n\n  /**\n   * How long did the last fulfilled result take to calculate?\n   */\n  elapsedMs(): Maybe<number>\n\n  toString(): string\n}\n\n/**\n * @param ttlMs if 0 or null, the result of `later` will be cached forever.\n */\nexport function lazyAsync<T>({\n  later,\n  desc,\n  ttlMs,\n  timeoutMs\n}: {\n  later: () => Promise<T>\n  desc?: string\n  ttlMs?: number\n  timeoutMs?: number\n}): MemoizedDeferred<T> {\n  let lastSetTs: number | undefined\n  let settledCount = 0\n  let lastValue: T | undefined\n  let result: Deferred<T> | undefined\n  const watchers: MemoizedDeferredListener<T>[] = []\n\n  async function onSetResult(\n    priorD: Deferred<T> | undefined,\n    resultD: Deferred<T>\n  ) {\n    const resultIdAtStart = result?.id\n    try {\n      // There's a chance that the prior or current result has already\n      // changed. Don't submit onChanges or change priorValue if the current\n      // Deferred result has changed.\n\n      const current = await resultD\n      if (result?.id === resultIdAtStart) {\n        lastValue = current\n      }\n\n      if (\n        result?.id === resultIdAtStart &&\n        !eql(priorD?.value ?? (await priorD?.promise), current)\n      ) {\n        for (const ea of watchers) {\n          await ea.onChange(current)\n        }\n      }\n    } catch (err) {\n      const error = toErr(err)\n      if (error != null) for (const ea of watchers) ea.onError(error)\n    } finally {\n      settledCount++\n    }\n  }\n\n  function setResult(t: Promise<T>): Deferred<T> {\n    lastSetTs = Date.now()\n    const priorResult = result\n    result =\n      t instanceof Deferred\n        ? t\n        : new Deferred<T>(desc ?? \"lazyAsync\").observe(t)\n    if (gt0(timeoutMs)) {\n      void result.setTimeout(timeoutMs)\n    }\n    void onSetResult(priorResult, result)\n    return result\n  }\n\n  function isStale() {\n    return lastSetTs == null || (gt0(ttlMs) && lastSetTs + ttlMs < Date.now())\n  }\n\n  const f = (() =>\n    // NO PROMISE AWAITING HERE. Otherwise N calls would go through while we\n    // wait for the promise to resolve.\n    result == null || isStale() ? setResult(later()) : result) as any\n\n  f.unset = () => {\n    settledCount = 0\n    lastSetTs = undefined\n    lastValue = undefined\n    result = undefined\n  }\n\n  f.set = (t: T) => setResult(Deferred.resolve(t))\n\n  f.isStale = isStale\n\n  f.settledCount = () => settledCount\n\n  f.prior = () => {\n    if (isStale()) f.unset()\n    return result\n  }\n\n  f.lastValue = () => {\n    return result?.value ?? lastValue\n  }\n\n  f.refresh = () => setResult(later())\n\n  f.ttl = () => ttlMs\n\n  f.setTTL = (ttl: Maybe<number>) => {\n    ttlMs = gt0(ttl) ? ttl : undefined\n  }\n\n  f.watchLater = (watcher: MemoizedDeferredListener<T>) => {\n    watchers.push(watcher)\n  }\n\n  f.toString = f.toLogJSON = f.toJSON = () => desc ?? \"[LazyAsync]\"\n\n  f.lastSetAgoMs = () =>\n    lastSetTs == null ? undefined : Date.now() - lastSetTs\n\n  f.elapsedMs = () => result?.settledMs ?? result?.elapsedMs\n\n  return f\n}\n","import { compact, isEmpty, uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { isFalse, isTrue } from \"../../fe/Boolean\"\nimport { secondMs } from \"../../fe/Date\"\nimport { delay } from \"../../fe/Delay\"\nimport { orElse } from \"../../fe/Maybe\"\nimport {\n  Maybe,\n  MaybeNull,\n  MaybePromiseMaybe,\n  PromiseMaybe\n} from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { Primitive } from \"../../fe/Primitive\"\nimport { thenMap } from \"../../fe/Promise\"\nimport { MaybeSyncOrAsync, SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { thenOrTimeout, thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { Thunk, ThunkOrLater, tol } from \"../../fe/Thunk\"\nimport { TimeoutError } from \"../../fe/TimeoutError\"\nimport { isFunction } from \"../../fe/isFunction\"\nimport { toA } from \"../../fe/toA\"\nimport { toErr } from \"../../fe/toErr\"\nimport { Arg0 } from \"../Args\"\nimport { batches } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { identity } from \"../Object\"\nimport { Predicate } from \"../predicates/Predicates\"\nimport { maxCpus } from \"../work/MaxCpus\"\nimport { PermissivePromises, Promises } from \"./Promises\"\n\n// TODO: INLINE\nexport { thenMap } from \"../../fe/Promise\"\n\nexport async function someOrTimeout<T>(\n  arr: ThunkOrLater<T>[],\n  opts: { timeoutMs: number }\n): Promise<(T | TimeoutError | Error)[]> {\n  return Promise.all(\n    arr.map(ea => thenOrTimeoutError(tol(ea), opts.timeoutMs).catch(err => err))\n  )\n}\n\nexport async function thenCompact<T>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T>[]>\n): Promise<T[]> {\n  if (arr == null) return []\n  const c = compact(await arr)\n  return isEmpty(c) ? [] : compact(await Promise.all(c))\n}\n\nexport async function thenCollectBatched<T1, T2>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T1>[]>,\n  batchSize: number,\n  f: (batch: T1[]) => MaybeSyncOrAsync<T2[]>\n) {\n  const result: T2[] = []\n  for (const batchArr of batches(toA(await arr), batchSize)) {\n    const batchInput: T1[] = await thenCompact(batchArr)\n    result.push(...(await thenCompact(f(batchInput))))\n  }\n  return result\n}\n\nexport async function thenMapResolved<T1, T2>(\n  objP: MaybeSyncOrAsync<T1>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>\n): PromiseMaybe<T2> {\n  if (objP == null) return Promise.resolve(undefined)\n  try {\n    return await thenMap(objP, f)\n  } catch (e) {\n    return undefined\n  }\n}\n\nexport function resolvedWithin<T>(\n  p: Promise<T>,\n  withinMs: number\n): Promise<boolean> {\n  return Promise.race([\n    p.then(() => true),\n    delay(withinMs).then(() => false)\n  ]).catch(() => false)\n}\n\nexport async function resolved(p: Promise<any>): Promise<boolean> {\n  try {\n    await p\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nexport async function rejected(p: Promise<any>): Promise<boolean> {\n  return !(await resolved(p))\n}\n\nexport async function thenDefined(p: Promise<any>): Promise<boolean> {\n  return (await p) != null\n}\n\nexport async function allSerial<T>(\n  arr: Maybe<() => MaybeSyncOrAsync<T>>[]\n): Promise<T[]> {\n  const result: T[] = []\n  for (const ea of compact(arr)) {\n    const v = await ea()\n    if (v != null) result.push(v)\n  }\n  return result\n}\n\nexport async function awaitAll(\n  arr: Maybe<(PromiseMaybe<any> | any)[]>\n): Promise<void> {\n  for (const ea of toA(arr)) {\n    if (ea != null) await ea\n  }\n}\n\nexport async function awaitSettled(\n  arr: Maybe<(PromiseMaybe<any> | any)[]>\n): Promise<void> {\n  for (const ea of toA(arr)) {\n    try {\n      if (ea != null) await ea\n    } catch {\n      //\n    }\n  }\n}\n\n// maybeist champion:\nexport async function thenFlatten<T>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T | MaybeSyncOrAsync<T>[]>[]>\n): Promise<T[]> {\n  const result: T[] = []\n  for (const ea of toA(await arr)) {\n    const v = await ea\n    if (v != null) {\n      if (Array.isArray(v)) {\n        for (const ea2 of v) {\n          const v2 = await ea2\n          if (v2 != null) result.push(v2)\n        }\n      } else {\n        result.push(v)\n      }\n    }\n  }\n  return result\n}\n\nexport async function thenUniq<T>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T>[]>\n): Promise<T[]> {\n  const result: T[] = []\n  for (const ea of toA(await arr)) {\n    const v = await ea\n    if (v != null) {\n      result.push(v)\n    }\n  }\n  return uniq(result)\n}\n\nexport async function asyncFind<T>(\n  arr: T[],\n  f: (t: T) => Promise<boolean>\n): PromiseMaybe<T> {\n  for (const ea of arr) {\n    if (await f(ea)) return ea\n  }\n  return\n}\n\n/**\n * @see thenCollect in fe -- which doesn't have logging or timeout support\n */\nexport async function thenCollectSerial<T, V>({\n  name,\n  arr,\n  f,\n  timeoutMs\n}: {\n  name: string\n  arr: Maybe<MaybeSyncOrAsync<Maybe<T>[]>>\n  f: (t: T) => SyncOrAsync<Maybe<V>>\n  timeoutMs?: number\n}): Promise<[V, T][]> {\n  const result: [V, T][] = []\n  for (const ea of compact(await arr)) {\n    try {\n      const v = await (gt0(timeoutMs)\n        ? thenOrTimeoutError(f(ea), timeoutMs)\n        : f(ea))\n      if (v != null) result.push([v, ea])\n    } catch (error) {\n      mkLogger(name).warn(\"failed to apply\", {\n        ea,\n        error\n      })\n    }\n  }\n  return result\n}\n\nexport async function mapAsyncSerial<T, V>(\n  args: Arg0<typeof thenCollectSerial<T, V>>\n): Promise<V[]> {\n  return (await thenCollectSerial(args)).map(ea => ea[0])\n}\n\n/**\n * For each in `V[]`, apply `f(v)` concurrently, returning `[v, await f(v)]`\n * @see thenCollect\n */\nexport async function thenCollectParallel<T, V>({\n  arr,\n  f,\n  name,\n  maxConcurrent,\n  timeoutMs,\n  promises\n}: {\n  arr: Maybe<MaybeSyncOrAsync<Maybe<T>[]>>\n  f: (t: T) => SyncOrAsync<Maybe<V>>\n  name: string\n  maxConcurrent?: number\n  timeoutMs?: number\n  promises?: Promises\n}): Promise<[V, T][]> {\n  if (arr == null) return []\n  const array = compact(await arr)\n  if (isEmpty(array)) return []\n  maxConcurrent = Math.round(maxConcurrent ?? maxCpus())\n  if (maxConcurrent <= 1) return thenCollectSerial({ arr, f, name, timeoutMs })\n  const p =\n    promises ??\n    (array.length <= maxConcurrent\n      ? PermissivePromises\n      : new Promises(name, () => maxConcurrent))\n  // ^ creating new Promises() is expensive\n  const func = gt0(timeoutMs)\n    ? (t: T) => thenOrTimeoutError(f(t), timeoutMs)\n    : f\n  const t = await p.enqueueAll(\n    name,\n    array.map(ea => async () => {\n      try {\n        return [await func(ea), ea] as [V, T]\n      } catch (error) {\n        mkLogger(name).warn(\"failed to apply\", {\n          ea,\n          error\n        })\n        return\n      }\n    })\n  )\n  // compact prevents TypeError: undefined is not iterable:\n  return compact(t).filter(([k, v]) => k != null && v != null)\n}\n\n/**\n * Apply `f` to each element of `arr` concurrently, returning the results\n */\nexport async function mapAsync<T, V>({\n  arr,\n  f,\n  name,\n  maxConcurrent,\n  timeoutMs,\n  promises\n}: {\n  arr: Maybe<MaybeSyncOrAsync<Maybe<T>[]>>\n  f: (t: T) => SyncOrAsync<Maybe<V>>\n  name: string\n  maxConcurrent?: number\n  timeoutMs?: number\n  promises?: Promises\n}): Promise<V[]> {\n  return (\n    await thenCollectParallel({\n      arr,\n      f,\n      name,\n      maxConcurrent,\n      timeoutMs,\n      promises\n    })\n  ).map(ea => ea[0])\n}\n\n/**\n * @return all items in `arr` that `f` doesn't reject and returns true or\n * Promise<true>\n */\nexport async function filterAsync<T>({\n  name,\n  arr,\n  f,\n  maxConcurrent,\n  timeoutMs\n}: {\n  name: string\n  arr: Maybe<T>[]\n  f: Predicate<T>\n  maxConcurrent?: number\n  timeoutMs?: number\n}): Promise<T[]> {\n  const t = await thenCollectParallel({\n    name,\n    arr: compact(arr),\n    f,\n    maxConcurrent,\n    timeoutMs\n  })\n  return t.filter(([b]) => b).map(([, v]) => v)\n}\n\nexport async function partitionAsync<T>(\n  arr: T[],\n  filter: (t: T) => MaybeSyncOrAsync<boolean>\n): Promise<[T[], T[]]> {\n  const t = await thenCollectParallel({\n    name: \"partitionAsync\",\n    arr,\n    f: filter\n  })\n  return [\n    t.filter(([ea]) => isTrue(ea)).map(([, ea]) => ea),\n    t.filter(([ea]) => isFalse(ea)).map(([, ea]) => ea)\n  ]\n}\n\nexport async function tryAsync<T>(f: () => T | Promise<T>) {\n  try {\n    return await f()\n  } catch {\n    return\n  }\n}\n\nexport const DefaultTryAllTimeoutMs = 30 * secondMs\n\nexport async function tryAll(\n  arr: (any | (() => any))[],\n  onError = (err: Error) => console.error(err),\n  timeoutMs = DefaultTryAllTimeoutMs\n): Promise<void> {\n  for (const ea of arr) {\n    try {\n      await thenOrTimeout(ea, timeoutMs)\n    } catch (err) {\n      onError(toErr(err)!)\n    }\n  }\n  return\n}\n\nexport async function thenFinally<T>(\n  p: SyncOrAsync<T> | (() => SyncOrAsync<T>),\n  err_: (err: Error | any) => any = () => {\n    // no-op\n  },\n  finally_: (r: T | Error) => any = () => {\n    // no-op\n  }\n): Promise<T> {\n  let result: T\n  let caught = null\n  try {\n    result = await (isFunction(p) ? p() : p)\n  } catch (err) {\n    caught = toErr(err)\n    try {\n      await err_(err)\n    } catch {\n      // no-op\n    }\n  }\n  try {\n    await finally_(caught ?? result!)\n  } catch {\n    // no-op\n  }\n  if (caught != null) {\n    throw caught\n  } else {\n    return result!\n  }\n}\n\nexport async function thenNot(\n  p: Maybe<boolean> | MaybePromiseMaybe<boolean>,\n  defaultIfNull = true\n): Promise<boolean> {\n  if (p == null) return defaultIfNull\n  const r = await p\n  return r == null ? defaultIfNull : !isTrue(r)\n}\n\nexport async function thenMap2<T1, T2, T3>(\n  objP1: MaybeSyncOrAsync<T1>,\n  objP2: MaybeSyncOrAsync<T2>,\n  f: (t1: T1, t2: T2) => MaybeSyncOrAsync<T3>\n): PromiseMaybe<T3> {\n  const o1 = await objP1\n  if (o1 == null) return\n  const o2 = await objP2\n  if (o2 == null) return\n  return f(o1, o2)\n}\n\n/**\n * Safe calls for Optional promises, with default\n */\nexport async function thenMapOr<T1, T2, T3>(\n  objP: MaybeSyncOrAsync<T1>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>,\n  ifUndefined: () => SyncOrAsync<T3>\n): Promise<T2 | T3> {\n  const obj = await objP\n  if (obj == null) return ifUndefined()\n  const result = await f(obj)\n  return result == null ? ifUndefined() : result\n}\n/**\n * Safe calls for Optional promises, with default\n */\nexport async function thenMap2Or<A1, A2, R1, R2>(\n  objP1: MaybeSyncOrAsync<A1>,\n  objP2: MaybeSyncOrAsync<A2>,\n  f: (t1: A1, t2: A2) => MaybeSyncOrAsync<R1>,\n  ifUndefined: () => SyncOrAsync<R2>\n): Promise<R1 | R2> {\n  const o1 = await objP1\n  if (o1 == null) return ifUndefined()\n  const o2 = await objP2\n  if (o2 == null) return ifUndefined()\n  const result = await f(o1, o2)\n  return result == null ? ifUndefined() : result\n}\n\n/**\n * Only call f if the promise resolves to truthy\n */\nexport async function thenAnd<T>(\n  predicatePromise: MaybeNull<Promise<true | any>>,\n  f: () => SyncOrAsync<T>\n): PromiseMaybe<T> {\n  return predicatePromise != null && isTrue(await predicatePromise)\n    ? f()\n    : undefined\n}\n\nexport async function thenOrElse<T>(\n  objP: Promise<MaybeNull<T>> | MaybeNull<T>,\n  f: () => SyncOrAsync<T>\n): Promise<T> {\n  return orElse(await objP, f)\n}\n\n/**\n * Just like `firstDefinedPromise` but applies a function to all defined\n * elements in `arr`.\n */\nexport async function first<T, R>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T, index: number) => SyncOrAsync<MaybeNull<R>>\n): PromiseMaybe<R> {\n  if (arr != null) {\n    let index = -1\n    for (const t of arr) {\n      index++\n      try {\n        if (t == null) continue\n        const r = await f(t, index)\n        if (r != null) {\n          return r\n        }\n      } catch {\n        // no-op\n      }\n    }\n  }\n  return undefined\n}\n\n/**\n * @see #firstDefinedLater\n */\nexport async function firstDefinedPromise<T, U = T>(\n  promiseThunks: Thunk<MaybeSyncOrAsync<T>>[],\n  filter: (t: T) => SyncOrAsync<Maybe<U>> = identity as any\n): PromiseMaybe<U> {\n  for (const ea of promiseThunks) {\n    const o = await ea()\n    if (o != null) {\n      const result = await filter(o)\n      if (result != null) {\n        return result\n      }\n    }\n  }\n  return\n}\n\nexport async function firstResolvedDefinedPromise<T>(\n  promiseThunks: Thunk<MaybeSyncOrAsync<T>>[],\n  onError: (err: Error) => void\n): PromiseMaybe<T> {\n  for (const t of promiseThunks) {\n    try {\n      const result = await t()\n      if (result != null) {\n        return result\n      }\n    } catch (err) {\n      onError(toErr(err)!)\n    }\n  }\n  return\n}\n\nexport async function firstTruePromise<T>(\n  predicate: (t: T) => Maybe<boolean> | PromiseMaybe<boolean>,\n  ...promiseThunks: (() => MaybeSyncOrAsync<T>)[]\n): PromiseMaybe<T> {\n  for (const thunk of promiseThunks) {\n    try {\n      const ea = await thunk()\n      if (ea != null && (await predicate(ea)) === true) {\n        return ea\n      }\n    } catch (_) {\n      //\n    }\n  }\n  return\n}\n\n/**\n * @return `arr` sorted by the tuples in f. elements that `f` returns undefined\n * will be removed from the returned array.\n * @see https://en.wikipedia.org/wiki/Schwartzian_transform\n */\nexport async function sortByAsync<T, V extends Primitive | Primitive[]>({\n  name,\n  arr,\n  f\n}: {\n  name: string\n  arr: Maybe<MaybeSyncOrAsync<Maybe<T>[]>>\n  f: (t: T) => PromiseMaybe<V>\n}): Promise<T[]> {\n  const unsorted: [V, T][] = await thenCollectParallel({ name, arr, f })\n  return sortBy(unsorted, ea => ea[0]).map(ea => ea[1])\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mapNotEmpty } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, mapFinite, round, sigFigs } from \"../../fe/Number\"\nimport {\n  Obj,\n  compactValues,\n  fromEntries,\n  mapCompactObj,\n  omit\n} from \"../../fe/Object\"\nimport { opt } from \"../../fe/Opt\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { Thunk, tot } from \"../../fe/Thunk\"\nimport { toErr } from \"../../fe/toErr\"\nimport { CountingSet } from \"../CountingSet\"\nimport { Elapsed } from \"../Elapsed\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { ee } from \"../event/EventEmitter\"\nimport { Average, AverageStats } from \"../math/Average\"\nimport { EndableRanks } from \"./Endable\"\nimport { EndableWrapper } from \"./EndableWrapper\"\nimport { setUnrefTimeout } from \"./Timers\"\n\nconst MinMs = 15\n\n// by undocumented convention, names are\n// ${section}.${filename}.${function?}?:${context?}\n\nfunction normalizeName(name: string) {\n  return name.split(\":\")[0].trim()\n}\n\nexport class PromiseTimer {\n  static readonly instance = lazy(() => {\n    const pt = new PromiseTimer()\n    new EndableWrapper(\n      \"PromiseTimer\",\n      () => {\n        const logger = mkLogger(\"async.PromiseTimer\")\n        mapCompactObj(pt.report(), ea => logger.info(\"timings:\", ea))\n        mapNotEmpty(pt.errorCounts(), err =>\n          logger.warn(\"error counts:\", fromEntries(err))\n        )\n      },\n      EndableRanks.stats\n    )\n    ee().on(\"timing\", (name: string, elapsedMs: number) =>\n      pt.push(name, elapsedMs)\n    )\n    // no need to clear stats except in tests:\n    if (isTest) ee().on(\"clearCache\", () => pt.clear())\n    return pt\n  })\n  private readonly errors = new CountingSet<string>()\n  private readonly times = new Map<string, Average>()\n\n  clear() {\n    this.errors.clear()\n    this.times.clear()\n  }\n\n  async time<T>(\n    desc: string,\n    p: Promise<T> | (() => SyncOrAsync<T>),\n    post?: (result: T | Error, elapsed: number) => void\n  ): Promise<T> {\n    const start = Date.now()\n    const expectedTime = clamp(\n      10 * secondMs,\n      minuteMs,\n      Math.round(this.times.get(desc)?.p98 ?? 0)\n    )\n    const slowTimer = setUnrefTimeout(\n      () =>\n        mkLogger(\"time(\" + desc + \")\").warn(\n          \"unsettled for \" + (Date.now() - start) + \"ms\"\n        ),\n      expectedTime\n    )\n\n    try {\n      const result = await tot(p)\n      const elapsed = Date.now() - start\n      post?.(result, elapsed)\n      this.push(desc, elapsed)\n      return result\n    } catch (err) {\n      this.errors.incr(desc)\n      post?.(toErr(err)!, Date.now() - start)\n      throw err\n    } finally {\n      clearTimeout(slowTimer)\n    }\n  }\n\n  get entriesBySumDesc() {\n    return sortBy([...this.times.entries()], ([, v]) => -v.sum)\n  }\n\n  stats(namePrefix: string) {\n    const arr = this.entriesBySumDesc.filter(([k]) => k.startsWith(namePrefix))\n    const merged = arr.reduce(\n      (agg, ea) => Average.merge(ea[1], agg),\n      new Average()\n    )\n    const stats = arr.map(\n      ([name, avg]) => [name, avg.stats()] as [string, AverageStats]\n    )\n    return fromEntries([[\"merged\", merged.stats()], ...stats])\n  }\n\n  mkElapsed(l: Logger) {\n    return new Elapsed(l, (s, ts) => this.push(s, ts))\n  }\n\n  push(name: string, elapsedMs: number) {\n    if (elapsedMs > MinMs) {\n      getOrSet(this.times, normalizeName(name), () => new Average()).push(\n        elapsedMs\n      )\n    }\n  }\n\n  weightedAvg(name: string): Maybe<number> {\n    return opt(this.times.get(normalizeName(name)))\n      .map(avg => avg.weightedSampleAvg)\n      .get()\n  }\n\n  errorCounts() {\n    return this.errors.top(10)\n  }\n\n  callCounts(): { [name: string]: number } {\n    return [...this.times.entries()].reduce(\n      (o, [k, v]) => ({ ...o, [k]: v.n }),\n      {}\n    )\n  }\n\n  weightedAvgs(): { [name: string]: number } {\n    return compactValues(\n      [...this.times.entries()].reduce(\n        (o, [k, v]) => ({ ...o, [k]: mapFinite(v.weightedSampleAvg, round) }),\n        {}\n      )\n    ) as any\n  }\n\n  toJSON() {\n    return this.entriesBySumDesc.reduce(\n      (o, [k, v]) => ({\n        ...o,\n        [k]: v.toJSON()\n      }),\n      {}\n    )\n  }\n\n  report(): { [name: string]: Obj } {\n    // Sort by most time first:\n    return this.entriesBySumDesc.reduce(\n      (o, [k, v]) => ({\n        ...o,\n        [k]: {\n          sumSec: sigFigs(v.sum / secondMs, 3),\n          ...omit(v.stats(), \"sum\")\n        }\n      }),\n      {}\n    )\n  }\n}\n\nexport function mkElapsed(name: string) {\n  return PromiseTimer.instance().mkElapsed(mkLogger(name))\n}\n\nexport function time<T>(\n  name: string,\n  p: Promise<T> | (() => SyncOrAsync<T>),\n  post?: (result: T | Error, elapsed: number) => void\n): Promise<T> {\n  return PromiseTimer.instance().time(name, p, post)\n}\n\nexport function timeSync<T>(name: string, t: Thunk<T>): T {\n  const start = Date.now()\n  const result = t()\n  pushTime(name, Date.now() - start)\n  return result\n}\n\nexport function pushTime(name: string, elapsedMs: number) {\n  PromiseTimer.instance().push(name, elapsedMs)\n}\n\nexport function timeStats(namePrefix: string) {\n  return PromiseTimer.instance().stats(namePrefix)\n}\n\nexport function timedLazy<T>(\n  name: string,\n  thunk: () => SyncOrAsync<T>,\n  ttlMs?: number\n) {\n  return lazy(async () => time(name, thunk), ttlMs)\n}\n","import events from \"events\"\nimport { compact, count, filterInPlace, isEmpty, remove } from \"../../fe/Array\"\nimport { Later } from \"../../fe/Later\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { Comparable } from \"../../fe/Primitive\"\nimport { Thunk, tot } from \"../../fe/Thunk\"\nimport { toS } from \"../../fe/toS\"\nimport { BoundedList } from \"../BoundedList\"\nimport { TypedEventEmitter } from \"../event/TypedEventEmitter\"\nimport { Average } from \"../math/Average\"\nimport { maxCpus } from \"../work/MaxCpus\"\nimport { Deferred } from \"./Deferred\"\n\nexport type NamedObject = Record<string, any> & { name: string }\n\nexport function toName(o: string | NamedObject) {\n  return (o as any)?.name ?? toS(o)\n}\n\nexport interface PromisesEvents {\n  vacancy: () => void\n  drain: () => void\n}\n\n/**\n * Aggregate promises efficiently\n *\n * Note that `N` is either a descriptive name for the promise, or can be a data\n * payload associated to the promise.\n */\nexport class Promises {\n  readonly ee = new events.EventEmitter() as TypedEventEmitter<PromisesEvents>\n\n  #maxConcurrency: Maybe<Thunk<Maybe<number>>>\n  lastWorkTs = 0\n  settleMsAvg = new Average()\n\n  #settledCount = 0\n  readonly #running: Deferred<any>[] = []\n  readonly #pending: {\n    d: Deferred<any>\n    l: Later<any>\n  }[] = []\n\n  readonly lastPushedNames = new BoundedList<string>(16)\n\n  constructor(\n    readonly name: string,\n    maxConcurrency?: Thunk<Maybe<number>>\n  ) {\n    this.#maxConcurrency = maxConcurrency\n  }\n\n  get maxConcurrency(): number {\n    return Math.floor(\n      clamp(1, maxCpus(), this.#maxConcurrency?.() ?? maxCpus())\n    )\n  }\n\n  end() {\n    this.#pending.length = 0\n    return this.awaitAll()\n  }\n\n  vacuum() {\n    filterInPlace(this.#running, ea => ea.isPending)\n  }\n\n  private get running() {\n    this.vacuum()\n    return this.#running\n  }\n\n  /**\n   * @return the total number of promises that have settled\n   */\n  get settledCount() {\n    return this.#settledCount\n  }\n\n  stats() {\n    return {\n      maxConcurrency: this.maxConcurrency,\n      lastPushMsAgo: Date.now() - this.lastWorkTs,\n      freeSlots: this.freeSlots(),\n      unsettledCount: this.unsettledCount(),\n      runningNames: this.#running.map(ea => ea.name),\n      pendingNames: this.#pending.map(ea => ea.d.name),\n      totalWorkCount: this.#settledCount\n    }\n  }\n\n  #enqueue<T>({\n    name,\n    l,\n    payload,\n    serialId\n  }: {\n    name: string\n    l: Later<T>\n    payload?: any\n    serialId?: Comparable\n  }) {\n    const d = new Deferred<T>(name, { payload, serialId })\n    this.#pending.push({ d, l })\n    return d\n  }\n\n  /**\n   * Start the given promise once concurrency is below\n   */\n  enqueue<T>({\n    name,\n    l,\n    payload,\n    serialId\n  }: {\n    name: string\n    l: Later<T>\n    payload?: any\n    serialId?: Comparable\n  }): Deferred<T> {\n    const d = this.#enqueue({ name, l, payload, serialId })\n    this.laterPop()\n    return d\n  }\n\n  enqueueAll<T>(name: string, laters: Later<T>[]): Promise<T[]> {\n    const p = laters.map(l => this.#enqueue({ name, l }).promise)\n    this.laterPop()\n    return Promise.all(p)\n  }\n\n  /**\n   * Run f() after all prior-enqueued promises with the same name have resolved.\n   */\n  serial<T>(name: string, f: () => Promise<T>): Promise<T> {\n    return this.enqueue({ name, l: f, serialId: name })\n  }\n\n  /**\n   * Immediately run the given promise\n   */\n  push<T>(\n    name: string,\n    promiseOrLater: Promise<T> | Later<T>,\n    payload?: any\n  ): Promise<T> {\n    return this.#pushDeferred(\n      new Deferred<T>(name, { payload }),\n      promiseOrLater\n    ).promise\n  }\n\n  #pushDeferred<T>(d: Deferred<T>, promiseOrLater: Promise<T> | Later<T>) {\n    const start = Date.now()\n    this.lastWorkTs = start\n\n    void d.observe(tot(promiseOrLater)).finally(() => {\n      this.#settledCount++\n      remove(this.#running, d)\n      this.settleMsAvg.push(Date.now() - start)\n      this.laterPop()\n    })\n    this.lastPushedNames.push(d.name)\n    this.#running.push(d)\n    return d\n  }\n\n  /**\n   * If there are any free slots and pending work, this may enqueue pending\n   * work.\n   */\n  laterPop() {\n    setImmediate(() => this.maybePopPendingWork())\n  }\n\n  // this doesn't need a mutex (like oneAtATime) because it's not async:\n  maybePopPendingWork() {\n    this.vacuum()\n    const maxJobsToStart = this.maxConcurrency - this.#running.length\n    if (maxJobsToStart === 0) {\n      return\n    }\n    // vacancy AND drain TESTS MUST BE DONE IN THIS ORDER:\n    if (isEmpty(this.#pending) && maxJobsToStart > 0) {\n      // listeners may add pending work, so this should be first:\n      this.ee.emit(\"vacancy\")\n    }\n    // If we're still empty after emitting vacancy, we're drained:\n    if (this.isIdle()) {\n      this.ee.emit(\"drain\")\n    }\n    const jobsToStart = Math.min(this.#pending.length, maxJobsToStart)\n    const runningSerialIds = compact(this.#running.map(ea => ea.serialId))\n    const blockedBySerialId = []\n    for (let i = 0; i < jobsToStart; i++) {\n      const pending = this.#pending.shift()!\n      if (pending == null) break // < shouldn't happen, but it's a backstop for Later Me to hit.\n      if (\n        pending.d.serialId != null &&\n        runningSerialIds.includes(pending.d.serialId)\n      ) {\n        // Nope, shove it to the back of the queue.\n        blockedBySerialId.push(pending)\n        // But keep going: other pending tasks may be eligible to run now!\n      } else {\n        if (pending.d.serialId != null) {\n          // Don't push another of these!\n          runningSerialIds.push(pending.d.serialId)\n        }\n        void this.#pushDeferred(pending.d, pending.l)\n      }\n    }\n    this.#pending.push(...blockedBySerialId)\n  }\n\n  isTaskRunning(taskName: string) {\n    return this.#running.some(ea => ea.name === taskName)\n  }\n\n  /**\n   * If you don't care about the returned promise: only run f() if all prior\n   * with the same name have finished, and return no-op otherwise\n   */\n  maybeRun<T>(name: string, f: () => Promise<T>): Maybe<Promise<T>> {\n    return this.freeSlots() > 0 && !this.isTaskRunning(name)\n      ? this.push(name, f)\n      : undefined\n  }\n\n  runningCount() {\n    return count(this.#running, ea => ea.isPending)\n  }\n\n  /**\n   * @return the count of both currently-running *and* enqueued jobs.\n   */\n  unsettledCount() {\n    // We don't want to muck with _arr state, so use this._arr directly:\n    return this.runningCount() + this.#pending.length\n  }\n\n  /**\n   * @return true if there are jobs that are running or enqueued.\n   */\n  hasPending() {\n    return this.#pending.length > 0 || this.running.length > 0\n  }\n\n  isIdle() {\n    return !this.hasPending()\n  }\n\n  freeSlots() {\n    return clamp(\n      0,\n      this.maxConcurrency,\n      this.maxConcurrency - this.unsettledCount()\n    )\n  }\n\n  isFull() {\n    return this.freeSlots() === 0\n  }\n\n  pendingNames(): string[] {\n    return [\n      ...this.#pending.map(ea => ea.d.name),\n      ...this.running.map(ea => ea.name)\n    ]\n  }\n\n  get deferreds() {\n    return [...this.running, ...this.#pending.map(ea => ea.d)]\n  }\n\n  pendingWithName(name: string) {\n    return this.deferreds.filter(ea => ea.name === name)\n  }\n\n  payloadsWithName(name: string) {\n    return this.pendingWithName(name)\n      .filter(ea => ea.payload != null)\n      .map(ea => ea.payload!)\n  }\n\n  get pendingPromises() {\n    return this.deferreds.map(ea => ea.promise)\n  }\n\n  /**\n   * @return a promise that will be resolved when all previously pushed and\n   * enqueued Promises are resolved. Rejections are swallowed.\n   * @see Promise.allSettled\n   */\n  async awaitSettled() {\n    await Promise.allSettled(this.pendingPromises)\n  }\n\n  /**\n   * @return a promise that will be resolved when all previously pushed and\n   * enqueued Promises are resolved, or any promises are rejected.\n   * @see Promise.all\n   */\n  async awaitAll() {\n    await Promise.all(this.pendingPromises)\n  }\n\n  async awaitAllByName(name: string) {\n    await Promise.all(\n      this.deferreds.filter(ea => ea.name === name).map(ea => ea.promise)\n    )\n  }\n}\n\n/**\n * Run the given thunk never more than once concurrently. Invocations while\n * prior runs were invoked will return after prior runs have completed but will\n * be no-ops.\n */\nexport function maybeRun<T>(\n  name: string,\n  l: Later<T>\n): () => Maybe<Promise<T>> {\n  const p = new Promises(name)\n  return () => p.maybeRun(name, l)\n}\n\nexport async function withBoundedConcurrency<T>({\n  name,\n  laters,\n  maxConcurrent\n}: {\n  name: string\n  laters: Later<T>[]\n  maxConcurrent?: number\n}): Promise<T[]> {\n  // SITS: NOTE: if we share the same Promises instance, and a code block within\n  // withBoundedConcurrency calls withBoundedConcurrency, we'll starve.\n  return new Promises(\n    name,\n    map(maxConcurrent, ea => () => ea)\n  ).enqueueAll(name, laters)\n}\n\nexport const PermissivePromises: Pick<Promises, \"enqueueAll\"> = {\n  enqueueAll<T>(_name: string, laters: Later<T>[]): Promise<T[]> {\n    return Promise.all(laters.map(f => f()))\n  }\n}\n","// no-dependency onTimeout, to be set to ../work/WorkTimeout.onTimeout by\n// SyncService to avoid dependency loops\n\nlet timeoutHandler = (_soft?: boolean) => null\n\nexport function setTimeoutHandler(f: typeof timeoutHandler) {\n  timeoutHandler = f\n}\n\nexport function onTimeout({ soft }: { soft?: boolean } = {}) {\n  timeoutHandler(soft)\n}\n","import { setInterval, setTimeout } from \"timers\"\n\nexport function setUnrefTimeout(\n  callback: (...ea: any[]) => void,\n  ms: number,\n  ...args: any[]\n): NodeJS.Timeout {\n  return setTimeout(callback, Math.round(ms), ...args).unref()\n}\n\nexport function setUnrefInterval(\n  callback: (...ea: any[]) => void,\n  ms: number,\n  ...args: any[]\n): NodeJS.Timeout {\n  return setInterval(callback, Math.round(ms), ...args).unref()\n}\n","import { isTrue } from \"../../fe/Boolean\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { delay } from \"../../fe/Delay\"\nimport { isFunction } from \"../../fe/isFunction\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { MaybeSyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { onTimeout } from \"./TimeoutHandler\"\n\nexport type UntilOpts<T> = {\n  timeoutMs?: number\n  intervalMs?: number\n  acceptable?: (t: Maybe<T>) => boolean\n  timeoutResult?: T\n  unref?: boolean\n}\n\n/**\n * Run `f()` until the result either passes `acceptable`, or is not `null`,\n * `undefined` or `false`.\n */\nexport async function until<T>(\n  f: () => MaybeSyncOrAsync<T>,\n  { timeoutMs, intervalMs, acceptable, timeoutResult, unref }: UntilOpts<T> = {}\n): PromiseMaybe<T> {\n  let sentSoftTimeout = false\n  const timeoutAt = timeoutMs == null ? undefined : timeoutMs + Date.now()\n  let delayCount = 1\n  while (timeoutAt == null || Date.now() < timeoutAt) {\n    const start = Date.now()\n    const result = await f()\n    const accept =\n      result != null &&\n      (isFunction(acceptable) ? acceptable(result) : (result as any) !== false)\n\n    if (accept) {\n      return result\n    } else {\n      const elapsedMs = Date.now() - start\n      if (timeoutMs != null && elapsedMs > timeoutMs / 2 && !sentSoftTimeout) {\n        sentSoftTimeout = true\n        onTimeout({ soft: true })\n      }\n      const delayMs =\n        intervalMs ??\n        clamp(\n          10 * delayCount, // < wait longer for subsequent delays.\n          ShortCommandTimeoutMs,\n          (timeoutMs ?? minuteMs) / 5\n        )\n      await delay(delayMs, unref)\n      delayCount++\n    }\n  }\n  if (!sentSoftTimeout) onTimeout({ soft: false })\n  return timeoutResult\n}\n\n/**\n * Run the given thunk until the promise is resolved to true, or the timeout\n * passes.\n * @return false on timeout, or true when the the given Later returned true.\n */\nexport async function untilTrue(\n  f: () => MaybeSyncOrAsync<boolean>,\n  opts: Omit<UntilOpts<boolean>, \"acceptable\" | \"timeoutResult\"> = {}\n): Promise<boolean> {\n  return until(f, {\n    ...opts,\n    acceptable: isTrue,\n    timeoutResult: false\n  }) as Promise<boolean>\n}\n","import child_process from \"child_process\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport {\n  compactValues,\n  entries,\n  filter,\n  fromEntries,\n  omit,\n  StringValued,\n  values\n} from \"../../fe/Object\"\nimport { partition } from \"../Array\"\nimport { env } from \"../env/Env\"\nimport {\n  ELECTRON_RUN_AS_NODE,\n  PS_IS_CHILD_PROCESS,\n  PS_IS_DOCKER\n} from \"../env/EnvKeys\"\nimport { caseInsensitiveEnv } from \"../env/GetEnv\"\nimport { ee } from \"../event/EventEmitter\"\nimport { childProcLocale } from \"../Locale\"\nimport { isLogged } from \"../log/LogFilter\"\nimport { mkLogger } from \"../Logger\"\nimport { nodeEnv } from \"../NodeEnv\"\nimport { mapEntries, sortedKeys } from \"../Object\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { isElectron, isPosix } from \"../platform/Platform\"\nimport {\n  allSettings,\n  getSettingByNameOrKey,\n  pathWithDefaults,\n  persistedSettings,\n  Settings,\n  transientSettings\n} from \"../settings/Settings\"\n\nconst SettingsKeys = lazy(() => new Set(values(Settings).map(ea => ea.key)))\n\nexport function psenv(): StringValued {\n  const set = SettingsKeys()\n  return sortedKeys(filter(env(), k => k === \"NODE_ENV\" || set.has(k)))\n}\n\nconst sensitiveEnvRE = lazy(() => {\n  try {\n    return new RegExp(Settings.sensitiveEnvRegExp.valueOrDefault, \"i\")\n  } catch (err) {\n    console.error(\n      `Invalid setting for \"sensitiveEnvRegExp\": ${err}. Using default value.`\n    )\n    return new RegExp(Settings.sensitiveEnvRegExp.defaultValue, \"i\")\n  }\n})\n\nlater(() => {\n  function unset() {\n    sensitiveEnvRE.unset()\n    sanitizedEnv.unset()\n  }\n  ee().on(\"clearCache\", unset)\n  ee().on(\"settingsChanged\", unset)\n  for (const ea of allSettings()) {\n    // allSettings because anything might need to be included in the child env!\n    ea.watchLater(unset)\n  }\n})\n\nconst RequiredPosixEnv = [\"HOME\", \"LANG\", \"USER\"]\nconst RequiredWindowsEnv = [\n  \"APPDATA\",\n  \"HOME\",\n  \"HOMEDRIVE\",\n  \"LOCALAPPDATA\",\n  \"SYSTEMDRIVE\",\n  \"SYSTEMROOT\",\n  \"TEMP\"\n]\n\nconst requiredEnv = lazy(() => {\n  const result = caseInsensitiveEnv().pick(\n    ...(isPosix ? RequiredPosixEnv : RequiredWindowsEnv)\n  )\n  // set PATH, and respect prior case:\n  const p = caseInsensitiveEnv().lookup(\"PATH\")\n  result[p?.key ?? \"PATH\"] = pathWithDefaults()\n  return result\n})\n\nexport const sanitizedEnv = lazy(() => {\n  const re = sensitiveEnvRE()\n  return mapEntries(process.env, (k, v) => (re.exec(k) == null ? v : undefined))\n})\n\nexport function childProcEnvSettings(forWorker: boolean) {\n  const result: StringValued = {\n    NODE_ENV: nodeEnv,\n    NO_COLOR: \"1\" // children shouldn't be rendering anything to the terminal\n  }\n  result[PS_IS_CHILD_PROCESS] = \"1\"\n\n  if (isDocker()) {\n    result[PS_IS_DOCKER] = \"1\"\n  }\n  if (isElectron) {\n    result[ELECTRON_RUN_AS_NODE] = \"1\"\n  }\n\n  for (const s of persistedSettings().filter(ea => ea.hasValue())) {\n    forWorker ? s.addToEnv(result) : s.addToEnvMaybe(result)\n  }\n  return result\n}\n\nexport type SpawnOptionsWithLocale = child_process.SpawnOptions & {\n  forceCLocale?: boolean\n  forThread?: boolean\n}\n\nexport function spawnOptions(\n  maybeOpts?: SpawnOptionsWithLocale\n): child_process.SpawnOptions {\n  const opts: SpawnOptionsWithLocale = maybeOpts ?? {}\n  return {\n    ...omit(opts, \"forceCLocale\"),\n    env: childEnv({\n      overrides: opts.env,\n      forceCLocale: opts.forceCLocale\n    }),\n    detached: false,\n    shell: false\n    // NOTE: don't use `windowsHide: true`, it doesn't work!\n  }\n}\n\nlet childEnvLogged = false\n\nexport function childEnv({\n  overrides,\n  forceCLocale = true,\n  forWorker = false\n}: {\n  overrides?: Maybe<StringValued>\n  forceCLocale?: boolean\n  forWorker?: boolean\n} = {}) {\n  const e: StringValued = compactValues({\n    // Include all (non-sensitive) env values, because things like `gio` need\n    // GNOME* and DBUS* variables set:\n    ...sanitizedEnv(),\n    ...requiredEnv(),\n    ...(forceCLocale ? childProcLocale() : {}),\n    ...childProcEnvSettings(forWorker),\n    ...(overrides ?? {}) // < env param wins\n  })!\n\n  // Don't let parent ENV set transients:\n  for (const s of transientSettings()) {\n    s.deleteFromEnv(e)\n  }\n\n  if (isLogged(\"debug\") && !childEnvLogged) {\n    childEnvLogged = true\n    const logger = mkLogger(\"child.ChildEnv\")\n    const arr = entries(e)\n    const [ps, nonPs] = partition(\n      arr,\n      ([k]) =>\n        k === \"TZ\" ||\n        k === \"NODE_ENV\" ||\n        k.startsWith(\"LC_\") ||\n        // we have some env that aren't settings (like PS_KEEP_LIBRARY):\n        k.startsWith(\"PS_\") ||\n        getSettingByNameOrKey(k) != null\n    )\n    logger.debug(\"PS env:\", fromEntries(ps))\n    logger.debug(\"non PS env:\", fromEntries(nonPs))\n  }\n\n  return sortedKeys(e)\n}\n","import child_process from \"child_process\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Latch } from \"../../fe/Latch\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt, gt0, isNumber } from \"../../fe/Number\"\nimport { omit, pick } from \"../../fe/Object\"\nimport { trimLastNewline } from \"../../fe/String\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { mkLogger } from \"../Logger\"\nimport { isSingleSpecTests } from \"../NodeEnv\"\nimport { Try } from \"../Object\"\nimport { waitForPidExit } from \"../Pid\"\nimport { Pids, addPid, killPid } from \"../Pids\"\nimport { niceable, renice } from \"../Renice\"\nimport { Deferred } from \"../async/Deferred\"\nimport { setUnrefTimeout } from \"../async/Timers\"\nimport { isIgnorableError } from \"../error/ErrorTypes\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { closeStreams, endStream } from \"../fs/Streams\"\nimport { isLogged } from \"../log/LogFilter\"\nimport { spawnOptions } from \"./ChildEnv\"\n\nconst logger = lazy(() => mkLogger(\"child.ChildProcess\"))\n\nfunction cp2log(cp: child_process.ChildProcess) {\n  return pick(\n    cp as any,\n    \"pid\",\n    \"killed\",\n    \"connected\",\n    \"exitCode\",\n    \"signalCode\",\n    \"spawnfile\",\n    \"spawnargs\"\n  )\n}\n\nexport async function endProcess(\n  cp: Maybe<child_process.ChildProcess>,\n  timeoutMs = 30 * secondMs\n): Promise<boolean> {\n  if (cp == null) return false\n  logger().debug(\"endProcess()\", cp2log(cp))\n\n  const pid = cp.pid\n\n  if (pid == null || pid <= 0) {\n    logger().warn(\"endProcess(): asked to end invalid pid\", cp2log(cp))\n    return false\n  }\n  if (pid === process.pid) {\n    logger().warn(\"endProcess(): asked to end MY pid\", cp2log(cp))\n    return false\n  }\n  if (pid === process.ppid) {\n    logger().warn(\"endProcess(): asked to end my parent pid\", cp2log(cp))\n    return false\n  }\n\n  closeStreams(cp)\n\n  {\n    // Send a SIGTERM\n    const killResult = cp.kill()\n    logger().debug(\"endProcess(\" + pid + \")\", {\n      killResult,\n      childGotSigterm: cp.killed\n    })\n    if (!killResult) {\n      await killPid(pid).catch(err => {\n        logger().warn(\"endProcess(): kill(\" + pid + \",false) failed: \" + err)\n      })\n    }\n  }\n\n  // We don't use messaging, but in case we do later:\n  // TODO: do we need to do this?\n  // if (cp.connected) Try(() => cp.disconnect())\n\n  // We can exit even if this child is still running:\n  Try(() => cp.unref())\n\n  // don't wait for cleanup if we're running tests:\n  if (isSingleSpecTests()) return true\n\n  if (await waitForPidExit(pid, timeoutMs)) {\n    logger().debug(\"endProcess(): exitted\", cp2log(cp))\n    return true\n  }\n\n  {\n    // OK, shite got real. time for kill -9.\n    void Pids.instance()?.onKill(pid)\n    const killResult = cp.kill(\"SIGKILL\")\n    logger().warn(\"endProcess(\" + pid + \") had to resort to SIGKILL\", {\n      killResult\n    })\n    if (!killResult) {\n      await killPid(pid, true).catch(err => {\n        logger().warn(\"endProcess(): kill(\" + pid + \",true) failed: \" + err)\n      })\n    }\n  }\n\n  // Give the OS some time to clean up:\n  return waitForPidExit(pid, 5000)\n}\n\nexport const ReniceAfterMs = lazy(() => 15 * secondMs)\nexport const AddPidAfterMs = lazy(() => 30 * secondMs)\n\n// NOTE: MUST NOT BE ASYNC\nfunction newProc(\n  cp: child_process.ChildProcess,\n  cmd: string,\n  args: ReadonlyArray<string>,\n  maxAgeMs = 0\n) {\n  const start = new Date()\n  // If we write the pidfile now and hold up processing, `cp.stderr` and\n  // `cp.stdout` event listeners will miss initial data, so we put this in a\n  // timeout for later.\n\n  // Note that THIS IS NOT UNREF'ed! We want pids to be cleaned up!\n\n  const timeouts: NodeJS.Timeout[] = []\n\n  // Renice after a second\n  if (niceable(cmd, args)) {\n    timeouts.push(\n      setUnrefTimeout(\n        () => {\n          if (gt0(cp.pid)) {\n            void renice(cp.pid)\n          }\n        },\n        ReniceAfterMs() // only track and renice processes that run for a while\n      )\n    )\n  }\n\n  // Force-end processes after maxAgeMs\n  if (gt(maxAgeMs, secondMs)) {\n    timeouts.push(\n      setUnrefTimeout(() => {\n        if (gt0(cp.pid)) {\n          void endProcess(cp)\n        }\n      }, maxAgeMs - 250)\n    )\n  }\n\n  // Track long-lived processes:\n  timeouts.push(\n    setUnrefTimeout(\n      () => {\n        if (gt0(cp.pid)) {\n          return addPid(\n            { pid: cp.pid, cmd, maxAgeMs, ppid: process.pid },\n            start\n          )\n        }\n        return\n      },\n      AddPidAfterMs() // only track and renice processes that run for a while\n    )\n  )\n  // This allows cp resources to be GC'ed:\n  cp.on(\"exit\", () => timeouts.forEach(clearTimeout))\n\n  return cp\n}\n\nexport function spawn(\n  command: string,\n  args: ReadonlyArray<string>,\n  maxAgeMs: number,\n  options?: child_process.SpawnOptions\n): child_process.ChildProcess {\n  const opts = spawnOptions(options)\n  logger().debug(\"spawn()\", { command, args, maxAgeMs })\n  return newProc(\n    child_process.spawn(command, args, opts),\n    command,\n    args,\n    maxAgeMs\n  )\n}\n\nexport type ExecFileOptions =\n  | child_process.ExecFileOptions\n  | child_process.ExecFileOptionsWithBufferEncoding\n  | child_process.ExecFileOptionsWithStringEncoding\n\nexport function execFile(\n  command: string,\n  args: ReadonlyArray<string>,\n  maxAgeMs?: number,\n  options?: ExecFileOptions\n): child_process.ChildProcess {\n  const opts = spawnOptions(options)\n  // Only log the opts (which are long: they include ENV!) if we're tracing:\n  if (isLogged(\"trace\", logger().context)) {\n    logger().debug(\"execFile()\", { command, args, maxAgeMs, opts })\n  } else {\n    logger().debug(\"execFile()\", { command, args, maxAgeMs })\n  }\n\n  return newProc(\n    child_process.execFile(command, args, opts),\n    command,\n    args,\n    maxAgeMs\n  )\n}\n\nexport type StdoutOpts = {\n  timeoutMs: number\n  quiet?: boolean\n  disconnect?: boolean\n  ignoreStderr?: boolean\n  ignoreExitCode?: boolean\n  isIgnorableError?: (err: any) => boolean\n} & child_process.ExecFileOptions\n\nexport type StdoutResult = {\n  result: string\n  pid?: number\n  code?: number\n  signal?: string\n}\n\nexport async function stdoutResult_(\n  cmd: string,\n  args: string[],\n  opts: StdoutOpts\n): Promise<StdoutResult> {\n  const quiet = opts.quiet ?? false\n  const ignoreStderr = opts.ignoreStderr ?? false\n  const ignoreExitCode = opts.ignoreExitCode ?? false\n  const proc: child_process.ChildProcess = execFile(\n    cmd,\n    args,\n    opts.timeoutMs,\n    omit(opts, \"timeout\", \"quiet\", \"ignoreStderr\", \"ignoreExitCode\")\n  )\n\n  if (opts.disconnect === true) {\n    try {\n      // disconnect may not exist!\n      proc.disconnect?.()\n    } catch {\n      //\n    }\n    return { result: \"\", pid: proc.pid! }\n  }\n\n  const pid = proc.pid\n  // don't panic if we don't have a pid yet: this happens on Windows!\n\n  const name = stringify({ pid, cmd, args })\n  const stdoutChunks: (Buffer | string)[] = []\n  const stderrChonks: (Buffer | string)[] = []\n  const errors: Error[] = []\n  const exitCode = new Deferred<number>(name)\n\n  proc.on(\"error\", err => errors.push(err))\n  proc.on(\"exit\", e => {\n    if (isNumber(e) && exitCode.isPending) void exitCode.resolve(e)\n  })\n  proc.on(\"close\", e => {\n    if (isNumber(e) && exitCode.isPending) void exitCode.resolve(e)\n  })\n\n  void endStream(proc.stdin)\n\n  const stdoutEnded = new Latch()\n\n  if (proc.stdout == null) {\n    void stdoutEnded.resolve()\n  } else {\n    proc.stdout.on(\"error\", err => errors.push(err))\n    proc.stdout.on(\"data\", data => stdoutChunks.push(data))\n    proc.stdout.on(\"end\", () => stdoutEnded.resolve())\n  }\n\n  const stderrEnded = new Latch()\n\n  if (proc.stderr == null || ignoreStderr) {\n    void stderrEnded.resolve()\n  } else {\n    proc.stderr?.on(\"error\", err => errors.push(err))\n    proc.stderr?.on(\"data\", err => stderrChonks.push(err))\n    proc.stderr?.on(\"end\", () => stderrEnded.resolve())\n  }\n\n  // Wait for the process to finish...\n  await thenOrTimeoutError(exitCode.promise, opts.timeoutMs)\n\n  // Wait for chonks (which may show up AFTER the process exits). It shouldn't\n  // take long to flush these streams.\n  await thenOrTimeoutError(stdoutEnded.promise, 2 * secondMs)\n  await thenOrTimeoutError(stderrEnded.promise, 2 * secondMs)\n\n  // Add stderr chunks to errors:\n  const stderr = stderrChonks.join(\"\")\n  if (notBlank(stderr)) errors.push(new Error(stderr))\n  if (!quiet && isNotEmpty(errors)) {\n    logger().warn(name + \" resulted in errors:\", errors)\n  }\n\n  // Any errors that we can't ignore?\n  const isIgnorableFunc = opts.isIgnorableError ?? isIgnorableError\n  const causes = errors.filter(ea => isIgnorableFunc(ea) !== true)\n  if (causes.length > 0) {\n    throw causes.length === 1\n      ? causes[0]\n      : new WrappedError(\"Failed to run \" + cmd + \" \" + args.join(\" \"), {\n          causes\n        })\n  }\n\n  // Was the exit code sad?\n  if (!ignoreExitCode && exitCode.value !== 0) {\n    throw new Error(name + \": exit code \" + exitCode.value)\n  }\n\n  const result = stdoutChunks.join(\"\")\n\n  return {\n    result,\n    pid,\n    code: exitCode.value\n  }\n}\n\n/**\n * @return just the stdout stream\n * @see stdoutResult_ if you need more information about the command.\n */\nexport async function stdout_(\n  cmd: string,\n  args: string[],\n  opts: StdoutOpts\n): Promise<string> {\n  const result = await stdoutResult_(cmd, args, opts)\n  return logger().tap({\n    level: \"trace\",\n    msg: \"stdout_()\",\n    result: trimLastNewline(result.result),\n    meta: { cmd, args, opts, result }\n  })\n}\n","import { Command } from \"commander\"\nimport { joinLines } from \"../fs/CRLF\"\nimport { cliWrap } from \"./CliWrap\"\nimport { DescriptionFooter } from \"./DescriptionFooter\"\n\nexport const CliDesc = {\n  main: \"PhotoStructure's main process manager. Runs and manages web and sync services.\",\n  desktop: \"PhotoStructure for Desktops. Manages web and sync services.\",\n  info: \"Configuration, file metadata and import diagnostics tool.\",\n  list: \"List paths in a PhotoStructure Library.\",\n  logcat: \"Chronologically sort and pretty-print PhotoStructure logfiles.\",\n  logtail:\n    \"View the log messages of currently-running PhotoStructure processes as they are emitted. (Like `tail -f`).\",\n  web: \"PhotoStructure's web service. Automatically started by main.\",\n  sync: \"PhotoStructure's directory synchronization service. Automatically started by main.\"\n  // worker doesn't have a CLI.\n}\n\nexport function addFooter(c: Command): Command {\n  return c.on(\"--help\", () => {\n    console.log(joinLines(...cliWrap(DescriptionFooter)))\n  })\n}\n","import { env, stdout } from \"process\"\nimport { toInt } from \"../../fe/Number\"\nimport { wrap } from \"../../fe/String\"\n\nexport function cliWrap(\n  s: string,\n  opts?: { maxLineLen?: number; prefix?: string }\n) {\n  const maxLineLen =\n    opts?.maxLineLen ?? toInt(env.maxLineLen) ?? stdout.columns ?? 75\n  return wrap(s, { maxLineLen, prefix: opts?.prefix ?? \"\" })\n}\n","export const DescriptionFooter = [\n  \"\",\n  `Copyright © 2017-${new Date().getFullYear()}, PhotoStructure Inc.`,\n  \"\",\n  \"BY USING THIS SOFTWARE, YOU ARE ACCEPTING ALL THE TERMS AND CONDITIONS OF THIS LICENSE: https://photostructure.com/eula/\",\n  \"\",\n  \"User guide: https://photostructure.com/user-guide/\",\n  \"\",\n  \"Questions, bug reports, and feature requests: https://forum.photostructure.com/\",\n  \"\"\n].join(\"\\n\")\n","import { lazy } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toGt0 } from \"../../fe/Number\"\nimport { groupids, userids } from \"../UserInfo\"\nimport { env } from \"../env/Env\"\nimport { isDocker } from \"../platform/isDocker\"\n\nfunction whyMismatched(\n  desc: string,\n  envKey: string,\n  actual: number[]\n): Maybe<string> {\n  const val = toGt0(env()[envKey])\n  return val != null && !actual.includes(val)\n    ? `WARNING: ${desc} is running as ${actual} but $${envKey}=${val}`\n    : undefined\n}\n\nexport function whyUidGidMismatched(): Maybe<string[]> {\n  const arr = compactBlanks([\n    whyMismatched(\"user id\", \"PUID\", userids()),\n    whyMismatched(\"group id\", \"PGID\", groupids())\n  ])\n  return arr.length === 0 ? undefined : arr\n}\n\nexport const verifyUidGid = lazy(() => {\n  if (isDocker()) {\n    map(whyUidGidMismatched(), why =>\n      console.log(\n        [\n          \"\",\n          ...why,\n          \"This may result in file permission issues!\",\n          // Angle-bracket-surrounded URLs may be included in the URL (!!) by UnRAID. BOO\n          \"See https://forum.photostructure.com/t/1597/2 for details.\",\n          \"\"\n        ].join(\"\\n\")\n      )\n    )\n  }\n})\n","import { DateObjectUnits, DateTime, Duration, Zone } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { hourMs, isDate, secondMs } from \"../../fe/Date\"\nimport { mapOr } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { closeTo as closeToNumber, gt0, round } from \"../../fe/Number\"\nimport { isObject, omit } from \"../../fe/Object\"\nimport { cmp } from \"../../fe/Primitive\"\nimport { mkLogger } from \"../Logger\"\n\nconst logger = lazy(() => mkLogger(\"date.Date\"))\n\n// WHAT THE ACTUAL FLYING F luxon 2 removed zone from DateObject.\n\n// SITS: Luxon considers 0 to be INVALID for month, day, and hour, so these\n// are all optional.\nexport interface DateObject\n  extends Pick<\n      DateObjectUnits,\n      \"year\" | \"month\" | \"day\" | \"hour\" | \"minute\" | \"second\"\n    >,\n    Pick<DateObjectUnits, \"millisecond\"> {\n  zone?: string | Zone | undefined\n  rawValue?: string\n  tzoffsetMinutes?: number | undefined\n}\n\nexport function isDateObject(a: any): a is DateObject {\n  return isObject(a) && [\"year\", \"month\", \"day\"].every(k => k in a)\n}\n\nexport function cmpDate(a?: Date, b?: Date): number {\n  const aTime = mapOr(\n    a,\n    d => d.getTime(),\n    () => 0\n  )\n  const bTime = mapOr(\n    b,\n    d => d.getTime(),\n    () => 0\n  )\n  return cmp(aTime, bTime)\n}\n\nexport function msUntil(d?: Date): number {\n  if (d == null) return 0\n  const ts = d.getTime()\n  const n = Date.now()\n  return ts <= n ? 0 : ts - n\n}\n\nexport function closeTo(a: Maybe<Date>, b: Maybe<Date>, maxMsDelta: number) {\n  return (\n    a != null && b != null && Math.abs(a.getTime() - b.getTime()) <= maxMsDelta\n  )\n}\n\nexport function nowish(d: Maybe<number | Date>, maxMsDelta = 2500): boolean {\n  return d == null\n    ? false\n    : isDate(d)\n    ? closeTo(d, new Date(), maxMsDelta)\n    : Math.abs(d - Date.now()) < maxMsDelta\n}\n\nexport function isRecentMs(timeMs: Maybe<number>, deltaMs: number): boolean {\n  return closeToNumber(Date.now(), timeMs, deltaMs)\n}\n\nexport function fmtMs(ms: number): string {\n  return Duration.fromMillis(ms).toFormat(\"m:ss.SSS\")\n}\n\nexport function durationToPaddedHMS(ms: number): string {\n  return Duration.fromMillis(ms).toFormat(\"hhhh:mm:ss.SSS\")\n}\n\nexport function durationHMS(ms: number): string {\n  return Duration.fromMillis(round(ms / secondMs) * secondMs).toFormat(\n    ms < hourMs ? \"m:ss\" : \"h:mm:ss\"\n  )\n}\n\nexport function isoNow() {\n  return new Date().toISOString()\n}\n\nexport function utcIsoToTs(iso: Maybe<string>): Maybe<number> {\n  if (blank(iso)) return\n  const dt = DateTime.fromISO(iso, { zone: \"utc\" })\n  return dt.isValid ? dt.toMillis() : undefined\n}\n\nexport function dateObjectToDateTime(obj: Maybe<DateObject>): Maybe<DateTime> {\n  if (obj == null) return\n  try {\n    const dou: DateObjectUnits = omit(\n      obj,\n      \"zone\",\n      \"rawValue\",\n      \"tzoffsetMinutes\"\n    )\n    for (const k of [\"month\", \"day\", \"hour\"] as const) {\n      if (!gt0(dou[k])) {\n        delete dou[k]\n      }\n    }\n    const d = DateTime.fromObject(dou, { zone: obj.zone })\n    if (d != null && !d.isValid) {\n      logger().debug(\"dateObjectToDateTime() invalid\", {\n        obj,\n        why: d.invalidExplanation\n      })\n    }\n    return d?.isValid ? d : undefined\n  } catch (error) {\n    logger().debug(\"dateObjectToDateTime() failed\", { obj, error })\n    return\n  }\n}\n\n// DON'T USE JS DATE TO PARSE! js date parsing erases timezones and forces\n// everything to local or UTC.\n","// See https://moment.github.io/luxon/docs/manual/parsing.html#table-of-tokens\n// and https://en.wikipedia.org/wiki/Date_format_by_country\nexport const DefaultDateTimeFormats = [\n  \"y-M-d 'at' H.m.s\", // macOS screenshots\n  \"y-M-d H-m-s\", // gnome screenshots\n  \"y-MMM-d H-m-s\", // reasonable timestamp with short month name\n  \"y-MMMM-d H-m-s\", // reasonable timestamp with full month name\n  \"y-MM-dd HHmmss\", // windows screenshots\n  \"yMMdd_HHmmss\", // smartphone camera filenames\n  \"yMMdd-HHmmss\", // smartphone camera filenames\n  // \"MM.dd.yyyy HH:mm:ss\", // old LG datestamps\n  \"F\", // short localized date and time with seconds, may have slashes\n  \"FF\" // less short localized date and time with seconds\n\n  // We don't need to add y-m-d parsers here--those are handled automatically\n  // by FuzzyDateParser.\n]\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isNumber } from \"../../fe/Number\"\nimport { FifoCache } from \"../FifoCache\"\nimport { fmtFullDuration, parseDuration } from \"./DurationFormat\"\n\nconst decCache = new FifoCache<Maybe<number>>(512)\n\n/**\n * @param s either number in milliseconds or an ISO 8601 duration string\n * @return milliseconds encoded by `s`\n */\nexport function decodeDuration(s: Maybe<string | number>): Maybe<number> {\n  return isNumber(s)\n    ? s\n    : blank(s)\n    ? undefined\n    : decCache.getOrSet(s, () => parseDuration(s))\n}\n\nconst encCache = new FifoCache<Maybe<string>>(512)\n\n/**\n * @param value either number in milliseconds or an ISO 8601 duration string\n * @return ISO 8601 duration string\n */\nexport function encodeDuration(value: Maybe<number | string>): Maybe<string> {\n  return blank(value)\n    ? undefined\n    : encCache.getOrSet(value, () =>\n        fmtFullDuration(isNumber(value) ? value : decodeDuration(value))\n      )\n}\n","import { Duration } from \"luxon\"\nimport { compact } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport {\n  dayMs,\n  hourMs,\n  minuteMs,\n  secondMs,\n  weekMs,\n  yearMs\n} from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gte0, isDigits, isNumber, lt0, toFloat, toInt } from \"../../fe/Number\"\nimport { isString } from \"../../fe/String\"\nimport { captures } from \"../RegExp\"\nimport { sum } from \"../math/Vector\"\n\nexport function parseDuration(str: number | string): Maybe<number> {\n  try {\n    if (str == null || (!isString(str) && !isNumber(str))) return\n\n    // Assume milliseconds if the string is just a number.\n    if (isNumber(str)) return str\n    if (isDigits(str)) return toInt(str)\n\n    str = str.trim().toUpperCase()\n    if (str.length === 0) return\n\n    // Is it ISO formatted?\n    const d = Duration.fromISO(str)\n    if (d.isValid) return d.toMillis()\n\n    // Nope, not ISO. Maybe something like \"1d 2h 3m 4s 5ms\"?\n\n    const re =\n      /[\\s,]*?(?<value>-?(?:\\d+)?\\.?\\d+)\\s*(?<type>milliseconds?|msecs?|millis|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?[\\s,]*?/gim\n\n    const groups = captures(re, str)\n    if (groups.length === 0) return\n\n    const units = compact(\n      groups.map(ea => parseUnit(ea.groups?.value, ea.groups?.type))\n    )\n\n    // if the first value is negative, flip the sign of the remainder of the values.\n    const values = lt0(units[0])\n      ? [units[0], ...units.slice(1).map(ea => -ea)]\n      : units\n\n    return sum(values)\n  } catch {\n    return\n  }\n}\n\nfunction parseUnit(value?: string, type?: string): Maybe<number> {\n  const n = toFloat(value)\n  if (n == null) return\n  if (blank(type)) {\n    // assume milliseconds\n    return n\n  }\n  switch (type.toLowerCase()) {\n    case \"years\":\n    case \"year\":\n    case \"yrs\":\n    case \"yr\":\n    case \"y\":\n      return n * yearMs\n    case \"weeks\":\n    case \"week\":\n    case \"w\":\n      return n * weekMs\n    case \"days\":\n    case \"day\":\n    case \"d\":\n      return n * dayMs\n    case \"hours\":\n    case \"hour\":\n    case \"hrs\":\n    case \"hr\":\n    case \"h\":\n      return n * hourMs\n    case \"minutes\":\n    case \"minute\":\n    case \"mins\":\n    case \"min\":\n    case \"m\":\n      return n * minuteMs\n    case \"seconds\":\n    case \"second\":\n    case \"secs\":\n    case \"sec\":\n    case \"s\":\n      return n * secondMs\n    case \"milliseconds\":\n    case \"millisecond\":\n    case \"millis\":\n    case \"msecs\":\n    case \"msec\":\n    case \"ms\":\n      return n\n    default:\n      // This should never occur.\n      throw new Error(\n        `parseDuration(): unit ${type} was matched, but no matching case exists.`\n      )\n  }\n}\n\nconst Units = [\n  { ms: yearMs, s: \"y\" },\n  { ms: weekMs, s: \"w\" },\n  { ms: dayMs, s: \"d\" },\n  { ms: hourMs, s: \"h\" },\n  { ms: minuteMs, s: \"m\" },\n  { ms: secondMs, s: \"s\" },\n  { ms: 1, s: \"ms\" }\n]\n\nexport function fmtFullDuration(\n  ms: Maybe<number>,\n  sep: \"\" | \" \" | \",\" = \"\"\n): Maybe<string> {\n  if (!isNumber(ms)) return\n  if (ms === 0) return \"0\"\n  if (!gte0(ms)) {\n    return !isNumber(ms) ? undefined : \"-\" + fmtFullDuration(Math.abs(ms))\n  }\n  const result = []\n  for (const unit of Units.slice(Units.findIndex(ea => ea.ms <= ms!))) {\n    const i = Math.floor(ms / unit.ms)\n    ms -= i * unit.ms\n    if (i > 0) result.push(i + unit.s)\n  }\n  return result.join(sep)\n}\n","import { pad2 } from \"../../fe/Pad\"\n\n/**\n * Filesystem-character-safe date and timestamp\n */\n\nexport function filestamp(d: Date = new Date()): string {\n  return [\n    d.getFullYear(),\n    pad2(d.getMonth() + 1),\n    pad2(d.getDate()),\n    \"-\",\n    pad2(d.getHours()),\n    pad2(d.getMinutes()),\n    pad2(d.getSeconds())\n  ].join(\"\")\n}\n\nexport function filestampUTC(d: Date = new Date()): string {\n  return [\n    d.getUTCFullYear(),\n    pad2(d.getUTCMonth() + 1),\n    pad2(d.getUTCDate()),\n    \"-\",\n    pad2(d.getUTCHours()),\n    pad2(d.getUTCMinutes()),\n    pad2(d.getUTCSeconds())\n  ].join(\"\")\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\n/**\n * @see https://sqlite.org/pragma.html#pragma_auto_vacuum\n */\nexport const AutoVacuumModes = strEnum(\"NONE\", \"FULL\", \"INCREMENTAL\")\nexport type AutoVacuumMode = StrEnumKeys<typeof AutoVacuumModes>\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const CheckpointTypes = strEnum(\n  \"AUTO\",\n  \"PASSIVE\",\n  \"FULL\",\n  \"RESTART\",\n  \"TRUNCATE\"\n)\nexport type CheckpointType = StrEnumKeys<typeof CheckpointTypes>\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const RepairModes = strEnum(\"dump\", \"recover\")\nexport type RepairMode = StrEnumKeys<typeof RepairModes>\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const SynchronousModes = strEnum(\"OFF\", \"NORMAL\", \"FULL\", \"EXTRA\")\nexport type SynchronousMode = StrEnumKeys<typeof SynchronousModes>\n","import _path, { join } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact, compactBlanks } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { SimpleAppName, SimpleAppNameLC } from \"../AppName\"\nimport { FifoCacheAsync } from \"../FifoCacheAsync\"\nimport { userid } from \"../UserInfo\"\nimport { env } from \"../env/Env\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { onError } from \"../error/OnError\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { mkNoMedia_ } from \"../fs/MkNoMedia\"\nimport { mkdirpSync_ } from \"../fs/Path\"\nimport { isLinux, isMac, isWin } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { Settings } from \"../settings/Settings\"\nimport { setSettingsDefaults } from \"../settings/SettingsDefaults\"\nimport { DefaultDockerLibraryDir } from \"./DefaultDockerLibraryDir\"\nimport { FirstDirArg, filterDirs, firstDir } from \"./FirstDir\"\nimport { homeDir } from \"./HomeDir\"\n\nconst uidSuffix = lazy(() => map(userid(), ea => \"-\" + ea) ?? \"\")\n\nexport function tmpCacheDirs(): FirstDirArg[] {\n  if (isDocker()) {\n    return [\n      {\n        dir: \"/tmp/.photostructure-cache\" + uidSuffix(),\n        preexistingDir: \"/tmp\"\n      }\n    ]\n  } else {\n    // Fallback to /tmp and /var/tmp on Linux and macOS, and %TEMP% on Windows:\n    const result: FirstDirArg[] = []\n    const dirs = isWin ? [getEnv(\"TEMP\"), getEnv(\"TMP\")] : [\"/tmp\", \"/var/tmp\"]\n    for (const tmpDir of dirs) {\n      if (!blank(tmpDir)) {\n        result.push({\n          dir: join(tmpDir, \".photostructure-cache\" + uidSuffix()),\n          preexistingDir: tmpDir\n        })\n      }\n    }\n    return result\n  }\n}\n\nexport function tmpDirs(): string[] {\n  return filterDirs({ dirs: tmpCacheDirs(), desc: \"tmp\" })\n}\n\nexport function cacheDirs(): FirstDirArg[] {\n  if (isDocker()) {\n    return compact([\n      map(env().XDG_CACHE_HOME, ea => ({\n        dir: join(ea, SimpleAppNameLC),\n        preexistingDir: ea\n      })),\n      // these should be mountpoints. We shouldn't make them.\n      { dir: \"/ps/tmp\", preexistingDir: \"/ps/tmp\" },\n      { dir: \"/ps/cache\", preexistingDir: \"/ps/cache\" },\n      {\n        dir: DefaultDockerLibraryDir + \"/.photostructure/cache\" + uidSuffix(),\n        preexistingDir: DefaultDockerLibraryDir\n      },\n      ...tmpCacheDirs()\n    ])\n  }\n\n  const dirs = compactBlanks(\n    isWin\n      ? [getEnv(\"LOCALAPPDATA\"), _path.resolve(homeDir(), \"AppData\", \"Local\")]\n      : isMac\n      ? [_path.resolve(homeDir(), \"Library\", \"Caches\")]\n      : // see https://forum.photostructure.com/t/1471/6\n        [env().XDG_CACHE_HOME, join(homeDir(), \".cache\")]\n  )\n\n  // .cache directories on linux seem to be uniformly lowercase, and uniformly\n  // UpperCased on macOS and Windows.\n  const cacheSubDir = isLinux ? SimpleAppNameLC : SimpleAppName\n\n  // These directories should exist already:\n  const result: FirstDirArg[] = dirs.map(ea => ({\n    dir: join(ea, cacheSubDir),\n    preexistingDir: ea\n  }))\n  result.push(...tmpCacheDirs())\n  return result\n}\n\n/**\n * Should only be used by Settings.cacheDir.defaultValue\n */\n// lazy for tests\nexport const defaultCacheDir = lazy<string>(() => {\n  return firstDir({ dirs: cacheDirs(), desc: \"cache\" })!\n})\n\nconst addSettingsListener = lazy(() => {\n  // make sure the config dir setting has the default wired up:\n  setSettingsDefaults()\n  Settings.cacheDir.watchLater(resetCacheDir)\n})\n\nexport const cacheDir = lazy<Maybe<string>>(() => {\n  try {\n    const result = cacheDir_()\n    // this is a hack to get around a deploop:\n    FifoCacheAsync.cacheDir = result\n    return result\n  } catch (error) {\n    onError(\"cacheDir_() failed\", { error })\n    return undefined\n  }\n})\n\nexport const cacheDir_ = lazy<string>(() => {\n  addSettingsListener()\n  const nativePath = Settings.cacheDir.valueOrDefault\n  try {\n    mkdirpSync_(nativePath) // < throw if we can't mkdirp\n    void mkNoMedia_(nativePath)\n    return nativePath\n  } catch (cause) {\n    throw new WrappedError(\"Failed to set up cacheDir, \" + nativePath, {\n      path: nativePath,\n      fatal: true,\n      cause\n    })\n  }\n})\n\nexport function resetCacheDir() {\n  Settings.cacheDir.refreshEnvValue({ broadcastChange: false })\n  defaultCacheDir.unset()\n  cacheDir.unset()\n  cacheDir_.unset()\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { setSettingsDefaults } from \"../settings/SettingsDefaults\"\nimport { DefaultDockerLibraryDir } from \"./DefaultDockerLibraryDir\"\nimport { desktopConfigDir, desktopConfigDirs } from \"./DesktopConfigDir\"\nimport { envConfigDir } from \"./EnvConfigDir\"\nimport { firstDir } from \"./FirstDir\"\n\n// PhotoStructure's \"system\" config dir is not backed by a Setting, but will\n// respect customizations via env.PS_CONFIG_DIR (but not configDir, because that\n// may not be photostructure-specific)\n\nexport const configDir = lazy(() => {\n  setSettingsDefaults()\n  return envConfigDir() ?? (isDocker() ? dockerConfigDir() : desktopConfigDir())\n})\n\nconst dockerConfigDirs = [\n  {\n    dir: \"/ps/config\",\n    preexistingDir: \"/ps/config\"\n  },\n  {\n    dir: DefaultDockerLibraryDir + \"/.photostructure/docker-config\",\n    preexistingDir: DefaultDockerLibraryDir\n  }\n]\n\nfunction dockerConfigDir() {\n  return firstDir({\n    dirs: dockerConfigDirs,\n    desc: \"config\"\n  })\n}\n\nexport function resetConfigDir() {\n  configDir.unset()\n  configDir.unset()\n}\n\nexport function osConfigDirs() {\n  return (isDocker() ? dockerConfigDirs : desktopConfigDirs()).map(ea => ea.dir)\n}\n","export const DefaultDockerLibraryDir = \"/ps/library\"\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { isReadWriteableDirectorySync } from \"../fs/StatSync\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { DefaultDockerLibraryDir } from \"./DefaultDockerLibraryDir\"\n\n// This was extracted from LibraryDir to break a deploop with PosixFile\n\nexport function defaultLibraryDir(): Maybe<string> {\n  return isDocker() ? DefaultDockerLibraryDir : undefined\n}\n\nexport function defaultOriginalsDir(): string {\n  return isDocker() && isReadWriteableDirectorySync(\"/ps/originals\")\n    ? \"/ps/originals\"\n    : \".\" // < relative to $PS_LIBRARY\n}\n","import path from \"path\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { AppName } from \"../AppName\"\nimport { env } from \"../env/Env\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { isMac, isWin } from \"../platform/Platform\"\nimport { FirstDirArg, firstDir } from \"./FirstDir\"\nimport { homeDir } from \"./HomeDir\"\n\nexport function desktopConfigDir() {\n  return firstDir({\n    dirs: desktopConfigDirs(),\n    desc: \"config\"\n  })!\n}\n\nexport function desktopConfigDirs(): FirstDirArg[] {\n  const dirs: Maybe<string>[] = []\n\n  // Note that process.env.PS_CONFIG_DIR is examined before this method is invoked.\n\n  if (isWin) {\n    dirs.push(getEnv(\"APPDATA\"), path.resolve(homeDir(), \"AppData\", \"Roaming\"))\n  } else if (isMac) {\n    dirs.push(path.resolve(homeDir(), \"Library\", \"Application Support\"))\n  } else {\n    dirs.push(\n      env().XDG_DATA_HOME,\n      env().XDG_CONFIG_HOME,\n      path.resolve(homeDir(), \".config\")\n    )\n  }\n\n  return compactBlanks(dirs).map(ea => ({\n    dir: path.join(ea, AppName()),\n    preexistingDir: ea\n  }))\n}\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { mkdirpSync_ } from \"../fs/Path\"\n\nexport function envConfigDir(): Maybe<string> {\n  // not \"configDir\", because that could be something else:\n  const fromEnv = getEnv(\"PS_CONFIG_DIR\")\n  if (!blank(fromEnv)) {\n    try {\n      mkdirpSync_(fromEnv)\n      return fromEnv\n    } catch (cause) {\n      console.error(\n        \"The environment variable PS_CONFIG_DIR is set to \" +\n          fromEnv +\n          \", but mkdir failed.\",\n        cause\n      )\n    }\n  }\n  return\n}\n","import { mkdirpSync } from \"fs-extra\"\nimport { compact } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isReadWriteableDirectorySync } from \"../fs/StatSync\"\n\nexport interface FirstDirArg {\n  dir: Maybe<string>\n  /**\n   * If set, and this dir does not exist, don't mkdirp `dir`.\n   */\n  preexistingDir?: Maybe<string>\n}\n\n/**\n * Return the first directory that exists (or whose required parent exists), and\n * that can be `mkdir -p`'ed with sufficient permissions.\n */\nexport function firstDir({\n  dirs,\n  desc\n}: {\n  dirs: Maybe<FirstDirArg>[]\n  desc: string\n}): Maybe<string> {\n  for (const { dir, preexistingDir } of compact(dirs)) {\n    if (blank(dir)) continue\n    if (isReadWriteableDirectorySync(dir)) return dir\n    if (blank(preexistingDir) || isReadWriteableDirectorySync(preexistingDir)) {\n      try {\n        mkdirpSync(dir)\n        return dir\n      } catch (err) {\n        console.error(\"Failed to mkdir for \" + desc, err)\n      }\n    }\n  }\n  return\n}\n\nexport function filterDirs({\n  dirs,\n  desc\n}: {\n  dirs: Maybe<FirstDirArg>[]\n  desc: string\n}): string[] {\n  return compact(dirs.map(dir => firstDir({ dirs: [dir], desc })))\n}\n","import { homedir } from \"os\"\nimport { resolve } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { isDirectorySync } from \"../fs/StatSync\"\nimport { isWin } from \"../platform/Platform\"\n\nexport const homeDir = lazy(() => {\n  const paths = []\n  if (isWin) {\n    // cygwin may mess with HOMEPATH and HOME. Only trust USERPROFILE.\n    paths.push(getEnv(\"USERPROFILE\"))\n  } else {\n    paths.push(getEnv(\"HOME\"))\n  }\n  for (const ea of compactBlanks(paths)) {\n    const d = resolve(ea)\n    if (isDirectorySync(d)) return d\n  }\n  return homedir()\n})\n","import _path from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { toS } from \"../../fe/toS\"\nimport { SimpleAppName } from \"../AppName\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { isMac } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { systemSettingsFile } from \"../settings/SystemSettings\"\nimport { readTomlFileSync } from \"../settings/Toml\"\nimport { cacheDirs } from \"./CacheDir\"\nimport { DefaultDockerLibraryDir } from \"./DefaultDockerLibraryDir\"\nimport { firstDir } from \"./FirstDir\"\nimport { homeDir } from \"./HomeDir\"\n\nexport function defaultLogDirs() {\n  if (isDocker()) {\n    return [\n      {\n        dir: \"/ps/logs\",\n        preexistingDir: \"/ps/logs\"\n      },\n      {\n        dir: DefaultDockerLibraryDir + \"/.photostructure/logs\",\n        preexistingDir: \"/ps/library\"\n      },\n      {\n        dir: \"/tmp/photostructure-logs\",\n        preexistingDir: \"/tmp\" // this will certainly exist, but not be persistent. It's only here as a backstop.\n      }\n    ]\n  } else if (isMac) {\n    return [\n      {\n        dir: _path.resolve(homeDir(), \"Library\", \"Logs\", SimpleAppName),\n        preexistingDir: homeDir()\n      }\n    ]\n  } else {\n    // Windows and Linux puts logs into the cache dir:\n    return compact(cacheDirs()).map(ea => ({\n      dir: map(ea.dir, dir => _path.resolve(dir, \"logs\")),\n      preexistingDir: ea.preexistingDir\n    }))\n  }\n}\n\nexport function defaultLogDir_() {\n  return firstDir({ dirs: defaultLogDirs(), desc: \"logs\" })!\n}\n\n// this bare-bones implementation means we can set up the logger without pulling\n// in Settings, SettingsIO and all those dependencies:\n\nexport const logDir = lazy(() => {\n  try {\n    const e = getEnv(\"logDir\") // < this will check logDir and PS_LOG_DIR\n    if (notBlank(e)) return e\n\n    const s = readTomlFileSync(systemSettingsFile())\n    const ld = toS(s?.logDir)\n    if (notBlank(ld)) return ld\n\n    return defaultLogDir_()\n  } catch (error) {\n    console.error(\"defaultLogDir_() failed\", error)\n    return _path.resolve(homeDir(), \"logs\")\n  }\n})\n","import { resolve } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { env } from \"../env/Env\"\nimport { isWin } from \"../platform/Platform\"\nimport { PowerShell } from \"../pwsh/PowerShell\"\nimport { homeDir } from \"./HomeDir\"\n\nexport async function picturesDirWindows() {\n  return isWin\n    ? (PowerShell.instance().executeJson(\n        `Get-ItemPropertyValue \"Registry::HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\" -name \"My Pictures\"`\n      ) as Promise<string>)\n    : undefined\n}\n\nexport const picturesDir = lazy<Promise<string>>(async () => {\n  if (isWin) {\n    const result = await picturesDirWindows()\n    if (notBlank(result)) return result\n    // else fall through and return default\n  }\n  return defaultPicturesDir()\n})\n\nexport const defaultPicturesDir = lazy<string>(\n  // See https://wiki.archlinux.org/title/XDG_user_directories\n  () => env().XDG_PICTURES_DIR ?? resolve(homeDir(), \"Pictures\")\n)\n","import { isTrue } from \"../../fe/Boolean\"\nimport { StrEnumKeys } from \"../../fe/StrEnum\"\nimport { isProd } from \"../NodeEnv\"\nimport { DevEnvFlags } from \"../env/EnvKeys\"\nimport { isPacked } from \"../platform/IsPacked\"\nimport { env } from \"./Env\"\n\nexport type DevFlag = StrEnumKeys<typeof DevEnvFlags>\n\nexport function getDevEnvFlag(key: DevFlag): boolean {\n  return !isProd && !isPacked() && isTrue(env()[key])\n}\n\nexport function setDevEnvFlag(key: DevFlag, b: boolean) {\n  if (b) {\n    env()[key] = \"true\"\n  } else {\n    delete env()[key]\n  }\n}\n","import fs from \"fs\"\nimport { delimiter } from \"path\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { uniq } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { later } from \"../../fe/Delay\"\nimport { entries, StringValued } from \"../../fe/Object\"\nimport { debom } from \"../Buffer\"\nimport { parseEnvTokens } from \"../EnvTokens\"\nimport { ee } from \"../event/EventEmitter\"\nimport { PS_ENV_KEYS } from \"./EnvKeys\"\nimport { SensitiveEnvRE } from \"./GetEnv\"\n\nexport const env = lazy<StringValued>(() => {\n  const paths = uniq(\n    PS_ENV_KEYS.map(k => process.env[k])\n      // handle FILE and PATH values:\n      .join(delimiter)\n      .split(delimiter)\n      .filter(notBlank)\n  )\n\n  const re = SensitiveEnvRE()\n  const result = { ...process.env }\n  for (const file of paths) {\n    try {\n      const input = debom(fs.readFileSync(file))\n      const tokens = parseEnvTokens({ input, lowerCaseKeys: false })\n      for (const [k, v] of entries(tokens)) {\n        if (!re.test(k)) {\n          result[k] = v\n        }\n      }\n    } catch (error) {\n      // not logger, as we may not have the logger up and running yet.\n      console.warn(\"env(): failed to read .env file, \" + file, error)\n    }\n  }\n  return result\n})\n\nlater(() => {\n  ee().on(\"clearCache\", () => env.unset())\n})\n","import { strEnum } from \"../../fe/StrEnum\"\n\nexport const PS_ENV_KEYS = [\"PS_ENV\", \"PS_ENV_FILE\", \"PS_ENV_PATH\"]\nexport const PS_IS_CHILD_PROCESS = \"PS_IS_CHILD_PROCESS\"\nexport const PS_IS_DOCKER = \"PS_IS_DOCKER\"\nexport const ELECTRON_RUN_AS_NODE = \"ELECTRON_RUN_AS_NODE\"\n\nexport const DevEnvFlags = strEnum(\n  \"PS_KEEP_ENV\",\n  \"PS_SKIP_CLEANUP\",\n  \"PS_SKIP_ALL_TESTS\",\n  \"PS_FORCE_LITE\",\n  \"PS_FORCE_TRIAL\",\n  \"PS_NO_RANDOM_IMAGE_CACHE\",\n  \"PS_FORCE_FULLDISK\",\n  \"PS_SLOMO\",\n  \"PS_BAIL_ON_ERROR\",\n  \"PS_FAIL_VOLUMES\",\n  \"PS_FAIL_DB_HEALTH_CHECK\",\n  \"PS_FAIL_SECURITY_HEALTH_CHECK\",\n  \"PS_TEST_HEALTH_CHECK_LEVEL\",\n  \"PS_SINGLE_SPEC_TESTS\"\n)\n\nexport const DevEnvKeys = [\"PS_NO_PUID_CHOWN\", \"PS_TEST_VOLUME_UUIDS\"]\n\nexport const IgnorableEnvKeys = [\n  \"PS_CONFIG_DIR\",\n  PS_IS_DOCKER,\n  PS_IS_CHILD_PROCESS,\n  ...DevEnvKeys,\n  ...PS_ENV_KEYS,\n  ...DevEnvFlags.values\n]\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\nimport { SettingsName } from \"../settings/SettingsName\"\n\n// We don't need to check for PS_APP_DATA or PS_PATH:\n\nexport const EnvKeys = strEnum(\n  \"HOME\",\n  \"NO_COLOR\",\n  \"PATH\",\n  \"PS_CONFIG_DIR\",\n  \"TMP\",\n  \"TEMP\",\n  \"XDG_CACHE_HOME\",\n\n  // Windows ENV keys: inconsistent casing here matches windows 10 box via\n  // `node -e \"console.log(process.env)\"`:\n  \"APPDATA\",\n  \"LOCALAPPDATA\",\n  \"ProgramData\",\n  \"ProgramFiles\",\n  \"ProgramFiles(x86)\",\n  \"ProgramW6432\",\n  \"SystemDrive\",\n  \"SystemRoot\",\n  \"USERPROFILE\",\n  \"windir\" // < \"C:\\Windows\"\n)\nexport type EnvKey = StrEnumKeys<typeof EnvKeys>\n\nexport type EnvName = SettingsName | EnvKey\n","import process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { firstNotBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { CaseInsensitiveValued } from \"../CaseInsensitiveValued\"\nimport { DefaultSensitiveEnvRegexPattern } from \"../DefaultSensitiveEnvRegexPattern\"\nimport { camel2snake } from \"../StringCase\"\nimport { env } from \"./Env\"\nimport { EnvKeys, EnvName } from \"./EnvName\"\n\n// !!!!!!!!!!!!!!!!!!!\n// IMPORTANT: To avoid deploops: `Settings` can be referenced ONLY by TypeScript\n// types, BUT NOT ACTUAL FUNCTIONALITY.\n// !!!!!!!!!!!!!!!!!!!\n\nexport const SensitiveEnvRegexPattern = lazy(\n  () =>\n    firstNotBlank(\n      process.env.PS_SENSITIVE_ENV_REGEX_PATTERN,\n      process.env.sensitiveEnvRegexPattern,\n      DefaultSensitiveEnvRegexPattern\n    )!\n)\n\nexport const SensitiveEnvRE = lazy(() => {\n  try {\n    return new RegExp(SensitiveEnvRegexPattern(), \"i\")\n  } catch (err) {\n    console.error(\n      `Invalid setting for \"sensitiveEnvRegExp\": ${err}. Using default value.`\n    )\n    return new RegExp(DefaultSensitiveEnvRegexPattern, \"i\")\n  }\n})\n\nexport const caseInsensitiveEnv = lazy(() => {\n  return new CaseInsensitiveValued(env())\n})\n\nexport function onEnvChange() {\n  caseInsensitiveEnv.unset()\n  SensitiveEnvRegexPattern.unset()\n  SensitiveEnvRE.unset()\n}\n\nlater(() => {\n  env.watchLater(onEnvChange)\n})\n\n/**\n * Case-insensitive search for a given ENV key\n *\n * @param key either XDG_CACHE_HOME for non-settings, or camelCaseSettingsName\n */\nexport function getEnv(key: EnvName): Maybe<string> {\n  return (\n    caseInsensitiveEnv().get(key) ??\n    (EnvKeys.includes(key)\n      ? undefined // < no need to search for PS_windir\n      : caseInsensitiveEnv().get(\"PS_\" + camel2snake(key)))\n  )\n}\n\nexport function isEnvTrue(key: EnvName): boolean {\n  return isTrue(getEnv(key))\n}\n","import { Rate } from \"batch-cluster\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact, compactBlanks, isEmpty, uniqSubstrings } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport {\n  ErrorDelimiter,\n  IgnoredErrorNames,\n  errorCode,\n  errorName,\n  shortStack\n} from \"../../fe/Error\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isBuffer } from \"../../fe/String\"\nimport { isError } from \"../../fe/isError\"\nimport { toS } from \"../../fe/toS\"\nimport { BoundedList } from \"../BoundedList\"\nimport { mkLogger } from \"../Logger\"\nimport { ellipsize, isString, stripAnsiEsc } from \"../String\"\nimport { splitCompactLines } from \"../fs/CRLF\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { getErrorDescriptions } from \"./ErrorCodes\"\nimport { ErrorFlag, sortErrorFlags } from \"./ErrorFlags\"\nimport { extractErrorFlags, stripErrorFlags } from \"./ErrorTypes\"\n\nexport const StartTs = Date.now()\n\nexport const logger = lazy(() => mkLogger(\"Error\"))\n\nexport const errorRate = new Rate()\nexport const fatalErrorRate = new Rate()\nexport const internalErrorRate = new Rate()\nexport const lastInternalErrors = new BoundedList(10)\n\nexport function mapError<T>(obj: any, f: (error: Error) => T): Maybe<T> {\n  return obj instanceof Error ? f(obj) : undefined\n}\n\nexport function errorContains(err: any, re: RegExp): boolean {\n  return re.test(errorToS(err))\n}\n\nexport function throws(f: () => any): boolean {\n  try {\n    f()\n    return false\n  } catch {\n    return true\n  }\n}\n\nexport function addMessage(error: Maybe<Error>, message: Maybe<string>) {\n  if (error == null) return new Error(message)\n\n  if (notBlank(message)) {\n    if (!error.message.toLowerCase().includes(message.toLowerCase())) {\n      error.message += \": \" + message\n    }\n  }\n  return error\n}\n\nexport function errorsToPath(\n  ...errs: Maybe<Error | SimpleFile | { path: string }>[]\n): Maybe<string> {\n  for (const ea of errs as any[]) {\n    for (const k of [\"nativePath\", \"path\"]) {\n      const s = toS(ea?.[k])\n      if (notBlank(s)) return s\n    }\n  }\n  return\n}\n\n/**\n * Errors can contain a \"name\", a \"code\", and a \"message\". Wrapped Errors may\n * contain a concatenated set of errors (\"Error: failed to import foo: missing\n * database entry\")\n */\nexport function splitErrorMessage(...errs: Maybe<Error | string>[]): string[] {\n  if (isEmpty(errs)) return []\n\n  const messages: string[] = errs.map((ea: any) =>\n    isString(ea) ? ea : isBuffer(ea) ? ea.toString() : toS(ea?.message ?? ea)\n  )\n\n  messages.push(...getErrorDescriptions(errs))\n\n  const arr = [\n    ...errs.filter(isError).map(errorName),\n    ...errs.map(errorCode),\n    // only split(\": \") on message and strings to avoid URL splitting\n    ...compactBlanks(messages)\n      .map(stripAnsiEsc)\n      .flatMap(ea => splitCompactLines(ea))\n      .flatMap(ea => ea.split(ErrorDelimiter))\n  ]\n  return uniqSubstrings(normalizeErrorMessages(flatten(arr)))\n}\n\nexport function normalizeErrorMessages(arr: Maybe<string>[]): string[] {\n  return compact(arr)\n    .filter(ea => !IgnoredErrorNames.includes(ea))\n    .map(ea =>\n      ea\n        .replace(/\\s+/gm, \" \")\n        .trim()\n        .replace(/^code ([A-Z]+)$/i, \"$1\")\n        .trim()\n    )\n    .filter(notBlank)\n}\n\nexport function joinErrorMessages(\n  arr: Maybe<string>[],\n  opts?: { maxLen?: number; trailingChars?: number; flags?: ErrorFlag[] }\n): string {\n  const trimmed = uniqSubstrings(normalizeErrorMessages(arr))\n  const maxLen = opts?.maxLen ?? 400\n  const trailingChars = opts?.trailingChars ?? 64\n  const flags = sortErrorFlags([\n    ...(opts?.flags ?? []),\n    ...extractErrorFlags(arr.join(\"\"))\n  ])\n  return (\n    ellipsize(\n      stripErrorFlags(trimmed.join(ErrorDelimiter)),\n      maxLen - flags.length,\n      trailingChars\n    ) + flags.sort().join(\"\")\n  )\n}\n\nexport function errorToS(\n  err: any,\n  opts?: { maxLen?: number; trailingChars?: number }\n): string {\n  if (blank(err)) {\n    return \"\"\n  }\n  const arr = splitErrorMessage(err)\n  return joinErrorMessages(arr, opts)\n}\n\nexport const MissingError = \"(missing error)\"\n\nexport function errorToVerbose(\n  err: any,\n  maxMsgLen = 256,\n  maxStackLines = 5\n): string {\n  if (blank(err)) err = MissingError // < if blank, at least fill in a stacktrace...\n  return (\n    ellipsize(errorToS(err), maxMsgLen) +\n    \" at \" +\n    shortStack(err?.stack, maxStackLines).join(\"; \")\n  )\n}\n","import { uniq } from \"../../fe/Array\"\nimport { errorCode, errorErrno } from \"../../fe/Error\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { stripSuffix } from \"../String\"\n\nexport function describeError(ea: string) {\n  const key = stripSuffix(toS(ea).trim().toUpperCase(), \":\")\n  return (ErrorCodes as any)[key]?.description ?? ea\n}\n\nexport function getErrorDescriptions(...arr: (Error | any)[]) {\n  const result: Maybe<string>[] = []\n  for (const err of arr) {\n    map(errorErrno(err), ea => result.push(err2desc.get(ea)))\n    map(errorCode(err), ea => result.push((ErrorCodes as any)[ea]?.description))\n  }\n  return uniq(result)\n}\n\nconst ErrorCodes = {\n  UNKNOWN: { errno: -1, description: \"unknown error\" },\n  OK: { errno: 0, description: \"success\" },\n  EOF: { errno: 1, description: \"end of file\" },\n  EADDRINFO: { errno: 2, description: \"getaddrinfo error\" },\n  EACCES: { errno: 3, description: \"permission denied\" },\n  EAGAIN: { errno: 4, description: \"resource temporarily unavailable\" },\n  EADDRINUSE: { errno: 5, description: \"address already in use\" },\n  EADDRNOTAVAIL: { errno: 6, description: \"address not available\" },\n  EAFNOSUPPORT: { errno: 7, description: \"address family not supported\" },\n  EALREADY: { errno: 8, description: \"connection already in progress\" },\n  EBADF: { errno: 9, description: \"bad file descriptor\" },\n  EBUSY: { errno: 10, description: \"resource busy or locked\" },\n  ECONNABORTED: { errno: 11, description: \"software caused connection abort\" },\n  ECONNREFUSED: { errno: 12, description: \"connection refused\" },\n  ECONNRESET: { errno: 13, description: \"connection reset by peer\" },\n  EDESTADDRREQ: { errno: 14, description: \"destination address required\" },\n  EFAULT: { errno: 15, description: \"bad address in system call argument\" },\n  EHOSTUNREACH: { errno: 16, description: \"host is unreachable\" },\n  EINTR: { errno: 17, description: \"interrupted system call\" },\n  EINVAL: { errno: 18, description: \"invalid argument\" },\n  EISCONN: { errno: 19, description: \"socket is already connected\" },\n  EMFILE: { errno: 20, description: \"too many open files\" },\n  EMSGSIZE: { errno: 21, description: \"message too long\" },\n  ENETDOWN: { errno: 22, description: \"network is down\" },\n  ENETUNREACH: { errno: 23, description: \"network is unreachable\" },\n  ENFILE: { errno: 24, description: \"file table overflow\" },\n  ENOBUFS: { errno: 25, description: \"no buffer space available\" },\n  ENOMEM: { errno: 26, description: \"not enough memory\" },\n  ENOTDIR: { errno: 27, description: \"not a directory\" },\n  EISDIR: { errno: 28, description: \"illegal operation on a directory\" },\n  ENONET: { errno: 29, description: \"machine is not on the network\" },\n  ENOTCONN: { errno: 31, description: \"socket is not connected\" },\n  ENOTSOCK: { errno: 32, description: \"socket operation on non-socket\" },\n  ENOTSUP: { errno: 33, description: \"operation not supported on socket\" },\n  ENOENT: { errno: 34, description: \"no such file or directory\" },\n  ENOSYS: { errno: 35, description: \"function not implemented\" },\n  EPIPE: { errno: 36, description: \"broken pipe\" },\n  EPROTO: { errno: 37, description: \"protocol error\" },\n  EPROTONOSUPPORT: { errno: 38, description: \"protocol not supported\" },\n  EPROTOTYPE: { errno: 39, description: \"protocol wrong type for socket\" },\n  ETIMEDOUT: { errno: 40, description: \"connection timed out\" },\n  ECHARSET: { errno: 41, description: \"invalid Unicode character\" },\n  EAIFAMNOSUPPORT: {\n    errno: 42,\n    description: \"address family for hostname not supported\"\n  },\n  EAISERVICE: {\n    errno: 44,\n    description: \"servname not supported for ai_socktype\"\n  },\n  EAISOCKTYPE: { errno: 45, description: \"ai_socktype not supported\" },\n  ESHUTDOWN: {\n    errno: 46,\n    description: \"cannot send after transport endpoint shutdown\"\n  },\n  EEXIST: { errno: 47, description: \"file already exists\" },\n  ESRCH: { errno: 48, description: \"no such process\" },\n  ENAMETOOLONG: { errno: 49, description: \"name too long\" },\n  EPERM: { errno: 50, description: \"operation not permitted\" },\n  ELOOP: { errno: 51, description: \"too many symbolic links encountered\" },\n  EXDEV: { errno: 52, description: \"cross-device link not permitted\" },\n  ENOTEMPTY: { errno: 53, description: \"directory not empty\" },\n  ENOSPC: { errno: 54, description: \"no space left on device\" },\n  EIO: { errno: 55, description: \"i/o error\" },\n  EROFS: { errno: 56, description: \"read-only file system\" },\n  ENODEV: { errno: 57, description: \"no such device\" },\n  ESPIPE: { errno: 58, description: \"invalid seek\" },\n  ECANCELED: { errno: 59, description: \"operation canceled\" }\n} as const\n\nconst err2desc = new Map<number, string>(\n  Object.values(ErrorCodes).map(ea => [ea.errno, ea.description])\n)\n","import { uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\nimport { escapeRegExp } from \"../RegExp\"\n\nexport const ErrorFlags = strEnum(\n  \"⁰\",\n  \"¹\",\n  \"²\",\n  \"³\",\n  \"⁴\",\n  \"⁵\",\n  \"⁶\",\n  \"⁷\",\n  \"⁸\",\n  \"⁹\",\n  \"₀\",\n  \"₁\",\n  \"₂\"\n  // \"₃\",\n  // \"₄\",\n  // \"₅\",\n  // \"₆\",\n  // \"₇\",\n  // \"₈\",\n  // \"₉\"\n)\nexport type ErrorFlag = StrEnumKeys<typeof ErrorFlags>\n// I could also go with a ⚠️🛑💥 or \"🔁⏹⏏️\" ️but these seem less cutesy:\n\nexport function sortErrorFlags(arr: Maybe<ErrorFlag>[]): ErrorFlag[] {\n  return sortBy(uniq(arr), ea => ErrorFlags.indexOf(ea))\n}\n\nexport const FatalErrorFlag = ErrorFlags[\"¹\"]\nexport const NonRetriableErrorFlag = ErrorFlags[\"²\"]\nexport const IgnorableErrorFlag = ErrorFlags[\"³\"]\nexport const PleaseSendErrorFlag = ErrorFlags[\"⁴\"]\nexport const HealthCheckErrorFlag = ErrorFlags[\"⁵\"]\nexport const DoNotSendErrorFlag = ErrorFlags[\"⁶\"]\nexport const RetriableErrorFlag = ErrorFlags[\"⁷\"]\nexport const HealthCheckWarningFlag = ErrorFlags[\"⁸\"]\nexport const InternalErrorFlag = ErrorFlags[\"⁹\"]\nexport const NoLibraryErrorFlag = ErrorFlags[\"₀\"]\nexport const DbSetupErrorFlag = ErrorFlags[\"₁\"]\nexport const NonFatalErrorFlag = ErrorFlags[\"₂\"]\n\nexport const ErrorFlagsRE = new RegExp(\n  \"(\" + ErrorFlags.values.join(\"|\") + \")\",\n  \"g\"\n)\n\nexport const FailStr = JSON.stringify({ fatal: true })\n\nexport const FatalErrorPatterns = [\n  \"SQLITE_FULL\",\n  \"SQLITE_CORRUPT\",\n  \"SQLITE_IOERR\", // there are a ton with this prefix, like SQLITE_IOERR_TRUNCATE\n  \"SQLITE_NOMEM\",\n  \"SQLITE_NOTADB\",\n  \"ON CONFLICT\",\n  \"SQLITE_CONSTRAINT_NOTNULL\",\n  \"Error: Cannot find module\",\n  FatalErrorFlag,\n  FailStr\n]\n\n/**\n * Default errors that indicate serious problems\n */\nexport const FatalErrorRe = new RegExp(\n  FatalErrorPatterns.map(escapeRegExp).join(\"|\"),\n  \"i\"\n)\n\nexport const InternalErrorRe = /⁹|internal ?error/i\n","import { compact } from \"../../fe/Array\"\nimport { isFalse, isTrue } from \"../../fe/Boolean\"\nimport { errorCode } from \"../../fe/Error\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { errorToS } from \"../error/Error\"\nimport {\n  DoNotSendErrorFlag,\n  ErrorFlag,\n  ErrorFlags,\n  ErrorFlagsRE,\n  FatalErrorFlag,\n  FatalErrorRe,\n  HealthCheckErrorFlag,\n  IgnorableErrorFlag,\n  InternalErrorRe,\n  NonFatalErrorFlag,\n  NonRetriableErrorFlag,\n  PleaseSendErrorFlag,\n  RetriableErrorFlag\n} from \"./ErrorFlags\"\n\n/**\n * @param msg may contain error flags\n * @return `msg` with any included error flags, and all\n * non-null `flags`, sorted, at the end of the string.\n */\nexport function addErrorFlags(msg: string, ...flags: Maybe<ErrorFlag>[]) {\n  const s = toS(msg) + compact(flags).join(\"\")\n  return stripErrorFlags(s) + extractErrorFlags(s).join(\"\")\n}\n\nexport function stripErrorFlags(err: Maybe<string>): string {\n  return toS(err).replace(ErrorFlagsRE, \"\").trim()\n}\n\n/**\n * @return ordered and uniq'ed flags found in `err`\n */\nexport function extractErrorFlags(err: string): ErrorFlag[] {\n  return ErrorFlags.values.filter(ea => err.includes(ea))\n}\n\nexport function hasErrorFlag(err: string): boolean {\n  return ErrorFlags.values.some(ea => err.includes(ea))\n}\n\n// FUTURE ME: OMG, aren't all these errorToS calls inefficient?\n\n// NOW ME: WHY YES, future me, they are.\n\n// FUTURE ME: SWEET IMMA REFACTOR THIS\n\n// NOW ME: Dude, if error parsing is your big performance issue, you've got\n// bigger issues.\n\n// FUTURE ME: AW YOU RIGHT\n\nexport function isHealthCheckError(err: any): boolean {\n  return errorToS(err).includes(HealthCheckErrorFlag)\n}\n\nexport function isPleaseSendError(err: any): boolean {\n  return errorToS(err).includes(PleaseSendErrorFlag)\n}\n\nconst notIgnorablePatterns = [/Can't write [a-z0-9]+ files/i]\n\nconst ignorablePatterns = [\n  IgnorableErrorFlag,\n  \"0 output files created\", // From exiftool\n  \"debugger attached\", //nodeJS inspector issues\n  \"debugger listening on\", //nodeJS inspector issues\n  \"diskutil: interrupted\", // dang flaky macOS tool\n  \"ECONNRESET\", // read ECONNRESET from broken socket\n  \"EPIPE\", // meh whatev\n  \"for help\", //nodeJS inspector issues\n  \"Format error in file\", // from exiftool\n  \"https://nodejs.org/en/docs/inspector\", //nodeJS inspector issues\n  \"Missing expected status message\", // From exiftool\n  \"net::ERR_\", //See https://cs.chromium.org/codesearch/f/chromium/src/net/base/net_error_list.h  like net::ERR_TIMED_OUT\n  \"This socket has been ended by the other party\", // so rude\n  \"Unexpected error while trimming\", // From sharp\n  \"Warning\" // I mean, it's _a warning_\n].map(ea => ea.toLowerCase())\n\n/**\n * Ignorable errors are expected, and not even important enough to log.\n */\nexport function isIgnorableError(err: any): Maybe<boolean> {\n  if (err == null) return true\n\n  const b = err?.ignorable\n  if (typeof b === \"boolean\") return b\n\n  const msg = errorToS(err).toLowerCase()\n\n  return notIgnorablePatterns.some(ea => ea.test(msg))\n    ? false\n    : ignorablePatterns.some(ea => msg.includes(ea))\n    ? true\n    : undefined\n}\n\nconst BusyErrorRe = /SQLITE_BUSY|database is locked/i\n\nexport function isSqliteBusyError(err: any): boolean {\n  return err.code === \"SQLITE_BUSY\" || null != errorToS(err).match(BusyErrorRe)\n}\n\nexport function isSqliteDisconnectedError(err: any): boolean {\n  return null != errorToS(err).match(/database .+ not open/i)\n}\n\nexport function isSqliteConstraintError(err: any): boolean {\n  return null != errorToS(err).match(/SQLITE_CONSTRAINT|constraint failed/i)\n}\n\nexport function isRetriableError(err: any): Maybe<boolean> {\n  // NOTE: this certainly isn't the most efficient boolean logic.\n\n  // It's structured this way to be the easiest to read and be correct.\n\n  if (err == null) return\n\n  if (isNonRetriableError(err) === true) {\n    return false\n  }\n\n  const b = err?.retriable\n  if (typeof b === \"boolean\") {\n    return b\n  }\n\n  if (\n    errorCode(err) === \"EBUSY\" ||\n    isSqliteBusyError(err) ||\n    isSqliteDisconnectedError(err)\n  ) {\n    return true\n  }\n\n  const str = errorToS(err)\n\n  return str.includes(\"EBUSY\") || str.includes(RetriableErrorFlag)\n    ? true\n    : undefined\n}\n\nexport function isNonRetriableError(err: any): Maybe<boolean> {\n  return isFalse(err.retriable) ||\n    errorToS(err).includes(NonRetriableErrorFlag) ||\n    isSqliteConstraintError(err)\n    ? true\n    : undefined\n}\n\nconst doNotSendPatterns = [\n  // everything here isn't worth sending to Sentry\n  DoNotSendErrorFlag,\n  \"Corrupt JPEG data\", // invalid jpeg\n  \"ENOSPC\", // I can't help with that...\n  \"Invalid data found when processing input\", // from invalid ffmpeg file\n  \"premature end of data segment\", // invalid jpeg\n  \"VipsJpeg\" // invalid jpeg\n]\n\n/**\n * These may be fatal errors (like loss of library lock), and the user will care\n * about them, but we don't need to tell Sentry about them.\n */\nexport function isDoNotSendError(err: any): Maybe<boolean> {\n  const b = err?.doNotSend\n  if (typeof b === \"boolean\") return b\n\n  if (isPleaseSendError(err)) return false\n\n  const msg = errorToS(err).toLowerCase()\n  if (doNotSendPatterns.some(ea => msg.includes(ea))) return true\n  return // we don't know, AND THAT'S OK\n}\n\n/**\n * Does `err` represent a \"fatal\" error?\n */\nexport function isFatalError(err: any): boolean {\n  if (err == null) return false\n  if (isTrue(err.fatal)) return true\n  const s = errorToS(err)\n  return s.includes(FatalErrorFlag)\n    ? true\n    : s.includes(NonFatalErrorFlag)\n    ? false\n    : FatalErrorRe.test(s)\n}\n\nexport function isInternalError(err: any): boolean {\n  return err == null\n    ? false\n    : isTrue(err.internalError) || InternalErrorRe.test(errorToS(err))\n}\n","import { blank } from \"../../fe/Blank\"\nimport { lt, sigFigs } from \"../../fe/Number\"\nimport { isEmptyObj } from \"../../fe/Object\"\nimport { isTest } from \"../NodeEnv\"\nimport { isServiceThatAcceptsFatalErrors, isWebService } from \"../ServiceNames\"\nimport { exit } from \"../async/Exit\"\nimport { ee } from \"../event/EventEmitter\"\nimport { Settings } from \"../settings/Settings\"\nimport {\n  StartTs,\n  errorRate,\n  fatalErrorRate,\n  internalErrorRate,\n  lastInternalErrors,\n  logger\n} from \"./Error\"\nimport { InternalErrorFlag } from \"./ErrorFlags\"\nimport { isInternalError } from \"./ErrorTypes\"\nimport { NewWrappedError, toWrappedError } from \"./WrappedError\"\nimport { stack } from \"./stack\"\n\n/**\n * Got an error? Give it here, please!\n *\n * @return true iff fatal\n */\n\nexport function onError(\n  err: string | Error,\n  meta?: unknown | Error | (NewWrappedError & { error?: Error | unknown })\n): boolean {\n  try {\n    if (blank(err) && isEmptyObj(meta)) {\n      logger().warn(\"onError() with no args\", stack())\n      return false\n    }\n    const error = toWrappedError(err, meta)\n\n    const internalError = isInternalError(err)\n    if (internalError) {\n      internalErrorRate.onEvent()\n      lastInternalErrors.push(err)\n    }\n    const fatal = error.fatal === true\n    const ignorable = error.ignorable === true\n\n    if (!fatal && ignorable) {\n      logger().info(\"onError(): (ignorable)\", { error: err })\n      return false\n    }\n\n    errorRate.onEvent()\n    if (fatal) {\n      fatalErrorRate.onEvent()\n      ee().emit(\"fatal\", error)\n    }\n    const event = !fatal || isFatalErrorAllowed() ? \"nonFatal\" : \"fatal\"\n    logger().log(event === \"fatal\" ? \"error\" : \"warn\", \"onError()\", {\n      event,\n      error\n    })\n    if (fatal && !isTest && !isWebService()) {\n      void exit({ reason: error.toString(), status: error.errno ?? 13 })\n    }\n    return fatal\n  } catch {\n    // woof, something's really wrong\n    console.error(\"onError() threw an error!\", { err, meta })\n    return false\n  }\n}\n/**\n * Should this error be considered fatal to this process?\n */\n\nexport function isFatalErrorAllowed(): boolean {\n  const postProbation =\n    Date.now() > StartTs + Settings.probationMs.valueOrDefault\n\n  const lowErrorRate = lt(\n    fatalErrorRate.eventsPerMinute,\n    Settings.fatalErrorRatePerMinute.valueOrDefault\n  )\n\n  const acceptsFatalErrors = isServiceThatAcceptsFatalErrors()\n\n  // The only time a fatal error should not be considered fatal is by the main\n  // service, after passing probation, and the error rate is not too high:\n  return logger().tap({\n    level: \"info\",\n    msg: \"isFatalErrorAllowed()\",\n    result: acceptsFatalErrors && postProbation && lowErrorRate,\n    meta: {\n      acceptsFatalErrors,\n      postProbation,\n      lowErrorRate,\n      fatalErrorRatePerMin: sigFigs(fatalErrorRate.eventsPerMinute, 2),\n      errorRatePerMin: sigFigs(errorRate.eventsPerMinute, 2),\n      fatalErrorRatePerMinuteSetting:\n        Settings.fatalErrorRatePerMinute.valueOrDefault\n    }\n  })\n}\n\n/**\n * These should never happen!\n */\nexport function onInternalError(\n  message: string,\n  cause?: Error | unknown,\n  context?: any\n): boolean {\n  return onError(message + InternalErrorFlag, { cause, ...context })\n}\n","import { uniqBy } from \"../../fe/Array\"\nimport { blank, firstNotBlank, toNotBlank } from \"../../fe/Blank\"\nimport { maybeAnd } from \"../../fe/Boolean\"\nimport {\n  ErrorDelimiter,\n  errorCode,\n  errorErrno,\n  errorName\n} from \"../../fe/Error\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Obj, isEmptyObj, omit } from \"../../fe/Object\"\nimport { toA } from \"../../fe/toA\"\nimport { toErrs } from \"../../fe/toErr\"\nimport { first } from \"../Array\"\nimport { dedupeNeedle, ellipsize, isString, splitUniq } from \"../String\"\nimport { joinErrorMessages, splitErrorMessage } from \"./Error\"\nimport {\n  DoNotSendErrorFlag,\n  ErrorFlag,\n  FatalErrorFlag,\n  IgnorableErrorFlag,\n  NonRetriableErrorFlag,\n  PleaseSendErrorFlag,\n  RetriableErrorFlag,\n  sortErrorFlags\n} from \"./ErrorFlags\"\nimport {\n  extractErrorFlags,\n  isDoNotSendError,\n  isFatalError,\n  isIgnorableError,\n  isRetriableError,\n  stripErrorFlags\n} from \"./ErrorTypes\"\n\nexport function toWrappedError(\n  error: string | Error | unknown,\n  meta?: unknown | Error | (NewWrappedError & { error?: Error | unknown })\n): WrappedError {\n  const args: NewWrappedError =\n    meta == null\n      ? {}\n      : meta instanceof Error\n      ? { cause: meta }\n      : { cause: (meta as any)?.error, ...meta }\n\n  if (error instanceof WrappedError) {\n    // if meta doesn't do anything, don't re-wrap.\n    if (\n      meta == null ||\n      blank(args.message) ||\n      error.message.includes(args.message)\n    ) {\n      return error\n    }\n  }\n  const message = firstNotBlank(\n    isString(error) ? error : undefined,\n    (error as any)?.message,\n    args?.message\n  )\n\n  return new WrappedError(message ?? \"(missing error message)\", args)\n}\n\nexport interface NewWrappedError {\n  name?: string\n  message?: string\n  stack?: string\n  code?: string\n  codes?: string[]\n  errno?: number\n  syscall?: string\n  path?: string // this isn't \"nativePath\" because native Node errors may include a `path` field that we want to capture.\n  cause?: any // because catch(err) is `unknown`\n  causes?: (Error | string)[]\n  retriable?: boolean\n  ignorable?: boolean\n  fatal?: boolean\n  doNotSend?: boolean\n  flags?: ErrorFlag[]\n  meta?: Obj\n}\n\nfunction mkCtx(opts?: NewWrappedError) {\n  if (opts == null) return\n\n  const ctx = omit(\n    opts as any,\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\",\n    \"codes\",\n    \"errno\",\n    \"syscall\",\n    \"path\",\n    \"cause\",\n    \"causes\",\n    \"retriable\",\n    \"ignorable\",\n    \"fatal\",\n    \"doNotSend\",\n    \"flags\"\n  )\n  return isEmptyObj(ctx) ? undefined : stringify(ctx)\n}\n\nfunction mkMessage(message?: string, opts?: NewWrappedError) {\n  let arr = splitErrorMessage(\n    message,\n    opts?.message,\n    opts?.cause,\n    ...(opts?.causes ?? [])\n  )\n  const path = opts?.path\n  if (!blank(path)) {\n    arr = dedupeNeedle(arr, path, \"file\")\n  }\n\n  return joinErrorMessages([\n    arr[0],\n    opts?.code,\n    ...toA(opts?.codes),\n    opts?.syscall,\n    message,\n    ...arr.slice(1)\n  ])\n}\n\nexport class WrappedError extends Error {\n  readonly code?: string\n  readonly codes?: string[]\n  readonly errno?: number\n  readonly syscall?: string\n  readonly path?: string\n  readonly causes: Error[]\n  readonly retriable?: boolean\n  readonly ignorable?: boolean\n  readonly fatal?: boolean\n  readonly doNotSend?: boolean\n  readonly flags: ErrorFlag[]\n\n  /**\n   * No string ellipsis-ing. Flags are shoved to the end and uniq'ed.\n   */\n  static mkMessage(message?: string, opts?: NewWrappedError) {\n    const s = splitErrorMessage(\n      message,\n      opts?.cause,\n      ...toA(opts?.causes),\n      mkCtx(opts)\n    ).join(ErrorDelimiter)\n    return stripErrorFlags(s) + extractErrorFlags(s).join(\"\")\n  }\n\n  constructor(message: string, opts: Partial<NewWrappedError> = {}) {\n    super(message)\n\n    this.causes = uniqBy(\n      toErrs(opts.cause, ...toA(opts.causes)),\n      ea => ea.message\n    )\n\n    this.name = errorName(opts) ?? first(this.causes, errorName) ?? \"Error\"\n\n    this.codes = splitUniq(\n      [opts.code, ...this.causes.map(errorCode)],\n      ErrorDelimiter\n    )\n    this.code = this.codes[0]\n    // unset this.codes if this.code is sufficient:\n    if (this.codes.length <= 1) this.codes = undefined\n\n    this.errno = opts.errno ?? first(this.causes, ea => errorErrno(ea))\n\n    this.syscall =\n      opts.syscall ?? first(this.causes, (ea: any) => toNotBlank(ea[\"syscall\"]))\n\n    this.path =\n      opts.path ?? first(this.causes, (ea: any) => toNotBlank(ea[\"path\"]))\n\n    this.flags = opts?.flags ?? []\n    const arr = [opts, this.flags.join(\"\"), ...this.causes]\n\n    // If any are fatal, we're fatal.\n    this.fatal = opts.fatal ?? arr.some(isFatalError)\n\n    // If any are NOT retriable, we aren't retriable. If none make an assertion,\n    // we shouldn't either.\n    this.retriable = opts.retriable ?? maybeAnd(arr.map(isRetriableError))\n\n    // If any are NOT ignorable, we aren't ignorable. If none make an assertion,\n    // we shouldn't either.\n    this.ignorable = opts.ignorable ?? maybeAnd(arr.map(isIgnorableError))\n\n    // If any say we need to send, we should.\n    this.doNotSend = opts.doNotSend ?? maybeAnd(arr.map(isDoNotSendError))\n\n    this.flags = sortErrorFlags([\n      ...this.flags,\n      this.fatal ? FatalErrorFlag : undefined,\n      this.retriable === true ? RetriableErrorFlag : undefined,\n      this.retriable === false ? NonRetriableErrorFlag : undefined,\n      this.ignorable === true ? IgnorableErrorFlag : undefined,\n      this.doNotSend === false ? PleaseSendErrorFlag : undefined,\n      this.doNotSend === true ? DoNotSendErrorFlag : undefined\n    ])\n\n    // Now that we have all the flags, rebuild the message:\n    this.message =\n      stripErrorFlags(mkMessage(message, this)) + this.flags.join(\"\")\n\n    this.stack = opts.stack ?? first(this.causes, (ea: any) => ea[\"stack\"])\n    if (this.stack == null) Error.captureStackTrace(this)\n  }\n\n  toJSON() {\n    return {\n      _ctor: \"WrappedError\",\n      ...this,\n      message: this.message\n    }\n  }\n\n  static fromJSON(json: any) {\n    return new WrappedError(json.message, json)\n  }\n\n  toString() {\n    return this.message\n  }\n\n  toS(opts?: { maxLen: number; trailingChars: number }): string {\n    return opts == null\n      ? this.message\n      : ellipsize(\n          this.message, // flags are already at the end--just don't\n          opts.maxLen,\n          Math.max(opts.trailingChars, this.flags.length + 1)\n        )\n  }\n}\n","export function stack(): string[] {\n  const e: any = {}\n  Error.captureStackTrace(e, stack)\n  return e.stack.split(/\\n(?:\\s*at\\s+)?/).slice(1)\n}\n","import { filterInPlace } from \"../../fe/Array\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { map } from \"../../fe/Maybe\"\nimport { toS } from \"../../fe/toS\"\nimport { Args } from \"../Args\"\nimport { Deferred } from \"../async/Deferred\"\nimport { BoundedList } from \"../BoundedList\"\nimport { isTest } from \"../NodeEnv\"\nimport { OmniEventListener } from \"./OmniEventListener\"\nimport { TypedEventEmitter } from \"./TypedEventEmitter\"\n\nexport interface CapturedEvent<T, E extends keyof T = keyof T> {\n  name: E\n  args: Args<T[E]>\n}\n\nexport class CapturingEventEmitter<T> implements TypedEventEmitter<T> {\n  readonly priorEvents: BoundedList<CapturedEvent<T>>\n  readonly omniListeners: OmniEventListener<T>[] = []\n  readonly #eventDeferreds = new Map<keyof T, Deferred<any>>()\n  readonly #eventDebounceTimers = new Map<keyof T, NodeJS.Timeout>()\n\n  constructor(\n    readonly target: TypedEventEmitter<T>,\n    readonly eventsToRetain = isTest ? 10 : 0\n  ) {\n    this.priorEvents = new BoundedList(eventsToRetain)\n  }\n\n  once<E extends keyof T>(\n    eventName: E,\n    listener: (...args: Args<T[E]>) => void\n  ) {\n    this.target.once(eventName, listener)\n    return this\n  }\n\n  // CAUTION: an omniEventListener that logs may cause a stack overflow on errors!\n\n  addOmniListener(l: OmniEventListener<T>) {\n    this.omniListeners.push(l)\n    return this\n  }\n\n  watchEvent<E extends keyof T>(eventName: E): Deferred<Args<T[E]>> {\n    return getOrSet(\n      this.#eventDeferreds,\n      eventName,\n      () => new Deferred<any>(\"watchEvent(\" + toS(eventName) + \")\")\n    )\n  }\n\n  removeOmniListener(l: OmniEventListener<T>) {\n    return filterInPlace(this.omniListeners, ea => ea !== l)\n  }\n\n  on<E extends keyof T>(eventName: E, listener: (...args: Args<T[E]>) => void) {\n    this.target.on(eventName, listener)\n    return this\n  }\n\n  off<E extends keyof T>(\n    eventName: E,\n    listener: (...args: Args<T[E]>) => void\n  ) {\n    this.target.off(eventName, listener)\n    return this\n  }\n\n  /**\n   * @return `true` if the event had listeners, `false` otherwise.\n   */\n  emit<E extends keyof T>(eventName: E, ...args: Args<T[E]>) {\n    map(this.#eventDebounceTimers.get(eventName), clearTimeout)\n    this.#eventDebounceTimers.delete(eventName)\n    for (const ea of this.omniListeners) {\n      ea(eventName, ...args)\n    }\n    if (this.eventsToRetain > 0) {\n      this.priorEvents.push({\n        name: eventName,\n        args\n      })\n    }\n    const result = this.target.emit(eventName, ...args)\n\n    const d = this.#eventDeferreds.get(eventName)\n    if (d != null) {\n      void d.resolve(args)\n      this.#eventDeferreds.delete(eventName)\n    }\n\n    return result\n  }\n\n  emitDebounced<E extends keyof T>(eventName: E, ...args: Args<T[E]>) {\n    map(this.#eventDebounceTimers.get(eventName), clearTimeout)\n    this.#eventDebounceTimers.set(\n      eventName,\n      setTimeout(() => this.emit(eventName, ...args), 50)\n    )\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  listeners<E extends keyof T>(event: E): Function[] {\n    return this.target.listeners(event)\n  }\n\n  removeAllListeners(eventName?: keyof T): this {\n    this.target.removeAllListeners(eventName)\n    return this\n  }\n}\n","import { map } from \"../../fe/Maybe\"\nimport { cacheDir } from \"../dir/CacheDir\"\nimport { BaseFile } from \"../fs/BaseFile\"\n\nexport function DefaultSharedStateDir() {\n  return map(cacheDir(), ea => BaseFile.for(ea).join(\"shared-state\"))\n}\n","import { EventEmitter } from \"events\"\nimport { lazy } from \"../../core/Lazy\"\nimport { CapturingEventEmitter } from \"./CapturingEventEmitter\"\nimport {\n  PhotoStructureEmitter,\n  PhotoStructureEvents\n} from \"./PhotoStructureEvents\"\n\nexport function mkEE(\n  eventsToRetain?: number\n): CapturingEventEmitter<PhotoStructureEvents> {\n  const e = new EventEmitter()\n  e.setMaxListeners(70) // because of ee().on(\"clearCache\")\n  return new CapturingEventEmitter(e as PhotoStructureEmitter, eventsToRetain)\n}\n\nexport const ee = lazy(mkEE)\n","import fs from \"fs\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isWin } from \"../platform/Platform\"\n\nconst getUid = lazy(() => process.geteuid?.())\nconst getGids = lazy(() => process.getgroups?.())\n\nexport function isStatRWX(stat: Maybe<fs.Stats>): boolean {\n  return access({ stat, r: true, w: true, x: true })\n}\nexport function isStatRX(stat: Maybe<fs.Stats>): boolean {\n  return access({ stat, r: true, x: true })\n}\n\nexport function access({\n  stat,\n  r = false,\n  w = false,\n  x = false,\n  processUid,\n  processGid\n}: {\n  stat: Maybe<fs.Stats>\n  r?: boolean\n  w?: boolean\n  x?: boolean\n  processUid?: number\n  processGid?: number\n}): boolean {\n  if (stat == null) return false\n  const uid = processUid ?? getUid()\n  const gids = processGid != null ? [processGid] : getGids() ?? []\n\n  const isRoot = uid === 0\n  const isUser = isRoot || stat.uid === uid\n  const isGroup = isRoot || gids.includes(stat.gid)\n\n  if (r) {\n    const mask = (isUser ? 0o400 : 0) | (isGroup ? 0o040 : 0) | 0o004\n    if ((mask & stat.mode) === 0) return false\n  }\n\n  if (w) {\n    const mask = (isUser ? 0o200 : 0) | (isGroup ? 0o020 : 0) | 0o002\n    if ((mask & stat.mode) === 0) return false\n  }\n\n  // windows doesn't care about x: it happily executes files with no execute\n  // bit as long as the extension is .exe/.bat/...\n  if (x && !isWin) {\n    const mask = (isUser ? 0o100 : 0) | (isGroup ? 0o010 : 0) | 0o001\n    if ((mask & stat.mode) === 0) return false\n  }\n\n  return true\n}\n","import _path from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { equalsIgnoreCase } from \"../String\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { isLinux } from \"../platform/Platform\"\nimport { FileCache } from \"./FileCache\"\nimport { logger, parseNativePath, pathIsRoot, resolve } from \"./Path\"\nimport { readdir_ } from \"./Readdir\"\n\nexport async function actualPath(...nativePath: string[]): Promise<string> {\n  try {\n    return await actualPath_(...nativePath)\n  } catch (error) {\n    logger().warn(\"actualPath() failed, reverting to resolve()\", {\n      nativePath,\n      error\n    })\n    return resolve(...nativePath)\n  }\n}\nconst actualPathCache = lazy(\n  () => new FileCache<string>({ name: \"fs.Path.actualPathCache\" })\n)\n/**\n * `node:fs.resolve()`, `node:fs.normalize()`, and `node:fs.realpath()` don't\n * actually return the _actual_ correctly-cased filename for case-insensitive\n * filesystems on Windows and macOS.\n *\n * This method does that.\n */\n\nexport async function actualPath_(...nativePath: string[]): Promise<string> {\n  // our resolve() upcases drive letters:\n  const resolved = resolve(...nativePath)\n  // No need to check on Linux (filesystems are case-sensitive), or for root\n  // paths (which would cause an infinite loop)\n  if (isLinux || pathIsRoot(resolved)) {\n    return resolved\n  }\n\n  return actualPathCache().getOrSetAsync(resolved, async () => {\n    const p = parseNativePath(resolve(...nativePath))\n    const actualDir = await actualPath_(p.dir)\n    for (const ea of await readdir_(actualDir)) {\n      // equalsIgnoreCase does unicode normalization!\n      if (equalsIgnoreCase(ea.basename, p.base)) {\n        return _path.join(actualDir, ea.basename)\n      }\n    }\n    throw new WrappedError(resolved + \" not found\", {\n      code: \"ENOENT\",\n      path: resolved\n    })\n  })\n}\n","import { readdirSync } from \"fs\"\nimport { dirname } from \"path\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\n\nexport function ancestors(path: string): string[] {\n  const arr = []\n  while (path !== dirname(path)) {\n    path = dirname(path)\n    arr.push(path)\n  }\n  return arr\n}\n\nexport function childrenSync(path: string): string[] {\n  try {\n    return readdirSync(path)\n  } catch (err) {\n    return []\n  }\n}\nexport function hasChildren(path: string, childNames: string[]): boolean {\n  const actual = childrenSync(path)\n  return childNames.every(ea => actual.includes(ea))\n}\n\nexport function ancestorWithChildren(\n  path: string,\n  childNames: string[]\n): Maybe<string> {\n  return ancestors(path).find(ea => hasChildren(ea, childNames))\n}\n","import fs, { readFileSync, watch, WatchEventType } from \"fs\"\nimport * as _fse from \"fs-extra\"\nimport { readFile } from \"fs/promises\"\nimport _path from \"path\"\nimport process from \"process\"\nimport stream from \"stream\"\nimport { pipeline } from \"stream/promises\"\nimport util from \"util\"\nimport zlib from \"zlib\"\nimport { lazy } from \"../../core/Lazy\"\nimport {\n  compact,\n  filterInPlaceAsync,\n  includesAll,\n  isEmpty,\n  isNotEmpty\n} from \"../../fe/Array\"\nimport { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { blank } from \"../../fe/Blank\"\nimport { minuteMs, secondMs, unixtime } from \"../../fe/Date\"\nimport { eql } from \"../../fe/Eql\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { stringify } from \"../../fe/JSON\"\nimport { denull, map, map3, mapOr, orElse } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { closeTo, gt0, gte } from \"../../fe/Number\"\nimport { omit } from \"../../fe/Object\"\nimport { opt } from \"../../fe/Opt\"\nimport { pad2 } from \"../../fe/Pad\"\nimport { newlineRe } from \"../../fe/String\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { leastBy, leastIndex, max } from \"../Array\"\nimport { Deferred } from \"../async/Deferred\"\nimport {\n  thenDefined,\n  thenMap,\n  thenMap2Or,\n  thenMapOr,\n  thenNot\n} from \"../async/Promise\"\nimport { time, timeSync } from \"../async/PromiseTimer\"\nimport { untilTrue } from \"../async/until\"\nimport { bufferToString } from \"../Buffer\"\nimport { isRetriableError } from \"../error/ErrorTypes\"\nimport { ee } from \"../event/EventEmitter\"\nimport { parseJSON } from \"../JSON\"\nimport { LogLevel } from \"../log/LogLevel\"\nimport { mkLogger } from \"../Logger\"\nimport { min } from \"../math/Vector\"\nimport { isLinux, isWin } from \"../platform/Platform\"\nimport { Predicate } from \"../predicates/Predicates\"\nimport { SyncPredicate } from \"../predicates/SyncPredicates\"\nimport { equalsIgnoreCase, stripSuffix } from \"../String\"\nimport { diceCoeff, hamming } from \"../StringSimilarity\"\nimport { bname } from \"../tags/Bname\"\nimport { userDesc } from \"../UserInfo\"\nimport { access, isStatRWX } from \"./Access\"\nimport { actualPath } from \"./ActualPath\"\nimport { splitLines } from \"./CRLF\"\nimport { DirectoryEntry, StatDirent } from \"./DirectoryEntry\"\nimport {\n  ensureNewNativePath_,\n  ensureNewNativePathSync_,\n  EnsureNewOptions\n} from \"./EnsureNew\"\nimport { CacheableFile, FileCache } from \"./FileCache\"\nimport { fileSha_, fileShaMeta_ } from \"./Hash\"\nimport { JsonWriteOptions } from \"./JsonWriteOptions\"\nimport { LineReader } from \"./LineReader\"\nimport {\n  containedByNativePath,\n  ellipsizePath,\n  isAbsolute,\n  isHiddenBasename,\n  isUNC,\n  mkdirp_,\n  mkdirpSync_,\n  parseNativePath,\n  pathDepth,\n  pathIsRoot,\n  posixPathFrom,\n  resolve,\n  splitNativePath\n} from \"./Path\"\nimport { native2posix } from \"./PosixNative\"\nimport { ProjectPath } from \"./ProjectPath\"\nimport { readdir_ } from \"./Readdir\"\nimport { SimpleDirent } from \"./SimpleDirent\"\nimport {\n  isSimpleFile,\n  SimpleFile,\n  SimpleFileOrString,\n  toNativePath_\n} from \"./SimpleFile\"\nimport { stat_, statMaybe, statTimes } from \"./Stat\"\nimport { statSync } from \"./StatSync\"\nimport { onDataChunked } from \"./StreamChunker\"\nimport { touch_ } from \"./Touch\"\nimport { writeFile_, writeText_, writeTextSync_ } from \"./WriteFile\"\nimport { zCopyToBuffer_ } from \"./zcat\"\n\nexport function isBaseFile(object: any): object is BaseFile {\n  return isSimpleFile(object) && object instanceof BaseFile\n}\n\nexport interface FileProgress {\n  path: string\n  /**\n   * operation (like \"sha\" or \"cp\")\n   */\n  op: string\n  /**\n   * percent complete\n   */\n  pct: number\n}\nconst cache = lazy(() => new FileCache<BaseFile>({ name: \"fs.BaseFile\" }))\n\nexport type UtimesArgs = Omit<\n  Parameters<typeof touch_>[0],\n  \"file\" | \"ensureFile\"\n>\n\nexport type RefreshArgs = {\n  refresh?: boolean\n  logLevel?: LogLevel\n}\n\n/**\n * Extracted from PosixFile, this superclass is used by the FileLogger.\n *\n * It must not depend on core code that also requires a Logger.\n */\nexport class BaseFile implements SimpleFile, CacheableFile {\n  protected readonly bflog = lazy(() =>\n    mkLogger(\"fs.BaseFile(\" + this.nativePath + \")\")\n  )\n\n  protected static attrTTL = 3 * minuteMs\n  readonly posixPath: string\n  readonly nativePath: string\n\n  /** \"/home/user/dir\" of \"/home/user/dir/file.txt\" */\n  readonly dir: string\n  /** \"file.txt\" of \"/home/user/dir/file.txt\" */\n  readonly base: string\n  /** \"file\" of \"/home/user/dir/file.txt\" */\n  readonly name: string\n  /** \".txt\" of \"/home/user/dir/file.txt\" */\n  readonly ext: string\n\n  protected constructor(\n    nativePath: string,\n    private dirent?: DirectoryEntry\n  ) {\n    if (dirent != null) {\n      this.nativePath = dirent.nativePath\n      this.dir = dirent.dir\n      this.base = dirent.base\n      this.name = dirent.name\n      this.ext = dirent.ext\n    } else {\n      this.nativePath = nativePath\n      const parsed = parseNativePath(this.nativePath)\n      this.dir = parsed.dir\n      this.base = parsed.base\n      this.name = parsed.name\n      this.ext = parsed.ext\n    }\n    this.posixPath = native2posix(this.nativePath)\n  }\n\n  toJSON() {\n    return {\n      _ctor: this.constructor.name,\n      nativePath: this.nativePath\n    }\n  }\n\n  toLogJSON() {\n    return this.nativePath\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON()\n  }\n\n  static async withFastestAccess<F extends BaseFile>(\n    files: Maybe<F>[]\n  ): PromiseMaybe<F> {\n    const arr = compact(files)\n    const msArr = await Promise.all(arr.map(f => f.shaMs()))\n    return arr[leastIndex(msArr)]\n  }\n\n  static projectRoot = lazy(() => {\n    const root = ProjectPath.Root()\n    if (root == null) {\n      throw new Error(\"Cannot find project path\")\n    } else {\n      return BaseFile.for(root)\n    }\n  })\n\n  static forPosix(posixPathOrFile: string | BaseFile) {\n    return posixPathOrFile instanceof BaseFile\n      ? posixPathOrFile\n      : this.for(posixPathOrFile.split(\"/\").join(_path.sep))\n  }\n\n  static forDirectoryEntry(de: DirectoryEntry) {\n    return this.for(de.nativePath, de)\n  }\n\n  static for(nativePathOrFile: SimpleFileOrString, dirent?: DirectoryEntry) {\n    if (nativePathOrFile instanceof BaseFile) {\n      return nativePathOrFile\n    }\n\n    // resolve() is expensive! Try to avoid it...\n\n    const nativePath = isSimpleFile(nativePathOrFile)\n      ? nativePathOrFile.nativePath\n      : toS(nativePathOrFile)\n\n    if (blank(nativePath)) {\n      throw new Error(\"BaseFile.for(): empty nativePathOrFile\")\n    }\n    const prior = cache().get(nativePath)\n    if (prior != null) return prior\n\n    // no need for a mutex: we're sync!\n    const resolved = resolve(nativePath)\n    const result = new BaseFile(resolved, dirent)\n    cache().set(nativePath, result)\n    cache().set(resolved, result)\n    return result\n  }\n\n  /**\n   * Wipe the instance cache and caches of all instances.\n   *\n   * This should only be used by tests.\n   *\n   * @param fromPath if undefined, all instances will be cleared.\n   */\n  static clear(fromPath?: string) {\n    ee().emit(\"fileChanged\", fromPath)\n  }\n\n  for(path: string, dirent?: DirectoryEntry): this {\n    return BaseFile.for(path, dirent) as this\n  }\n\n  forDirectoryEntry(de: DirectoryEntry): this {\n    return BaseFile.for(de.nativePath, de) as this\n  }\n\n  forChildDirent(dirent: SimpleDirent): this {\n    return this.forDirectoryEntry(\n      DirectoryEntry.fromSimpleDirent(this.nativePath, dirent)\n    )\n  }\n\n  forSiblingDirent(dirent: SimpleDirent): this {\n    return this.forDirectoryEntry(\n      DirectoryEntry.fromSimpleDirent(this.dir, dirent)\n    )\n  }\n\n  clear({ emit }: { emit?: boolean } = {}): this {\n    if (emit === true) ee().emit(\"fileChanged\", this.nativePath)\n    this.dirent = undefined\n    this.#childDirectoryEntries.unset()\n    this.#stat = undefined\n    return this\n  }\n\n  clearThisAndParent(): this {\n    ee().emit(\"fileChanged\", this.dir)\n    // this .clear() shouldn't be necessary, but it prevents race conditions\n    // from async onFileChanged listeners.\n    return this.clear({ emit: false })\n  }\n\n  toString() {\n    return this.nativePath\n  }\n\n  valueOf() {\n    return this.pathnames\n  }\n\n  eql(that: Maybe<SimpleFileOrString>): boolean {\n    if (that == null) return false\n    const thatNativePath = toNativePath_(that)\n    // These paths have already been resolve()d. We don't need to do it again\n    // here.\n    return isLinux\n      ? this.nativePath === thatNativePath\n      : // darn Windows and macOS have case-insensitive filesystems!\n        equalsIgnoreCase(this.nativePath, thatNativePath)\n  }\n\n  get isUNC() {\n    return isUNC(this.nativePath)\n  }\n\n  /**\n   * Posix path from parent\n   */\n  get baseWithParent(): string {\n    return (\n      this.isRoot\n        ? \"/\"\n        : this.parent().isRoot\n        ? \"/\" + this.base\n        : (this.parent().parent().isRoot ? \"/\" : \"\") + // <  prefixes the path with a / if grandparent is root.\n          this.parent().base +\n          \"/\" +\n          this.base\n    ).normalize() // < normalize for macOS\n  }\n\n  /**\n   * @return nativePath \"…/path/to/file.ext\" with ancestors such that the\n   * result doesn't exceed maxLength\n   */\n  ellipsize({\n    maxLength = 80\n  }: { maxLength?: number; maxDepth?: number } = {}) {\n    return ellipsizePath({ p: this, maxLength })\n  }\n\n  get baseWithParentNoExt(): string {\n    return stripSuffix(this.baseWithParent, this.ext)\n  }\n\n  /**\n   * posix path from grandparent\n   */\n  get baseWithGrandparent(): string {\n    return (\n      this.isRoot\n        ? \"/\"\n        : this.parent().isRoot\n        ? this.baseWithParent\n        : this.parent().baseWithParent + \"/\" + this.base\n    ).normalize()\n  }\n\n  posixPathFrom(from: SimpleFileOrString): string {\n    return posixPathFrom(from, this) + (this.isDirectorySync() ? \"/\" : \"\")\n  }\n\n  async directoryEntry(): PromiseMaybe<DirectoryEntry> {\n    return (this.dirent ??= await thenMap(\n      this.stat(),\n      ea => new DirectoryEntry(this.dir, new StatDirent(this.base, ea))\n    ))\n  }\n\n  directoryEntrySync(): Maybe<DirectoryEntry> {\n    return (this.dirent ??= map(\n      this.statSync(),\n      ea => new DirectoryEntry(this.dir, new StatDirent(this.base, ea))\n    ))\n  }\n\n  readonly #childDirectoryEntries = lazy(() =>\n    thenMap(this.directoryEntry(), de => de.children())\n  )\n\n  async childDirectoryEntries(f?: Predicate<DirectoryEntry>) {\n    const dirents = await this.#childDirectoryEntries()\n    if (dirents == null || f == null || isEmpty(dirents)) return dirents\n\n    // PERF: don't filterAsync here to avoid lots of Promises GC\n    const result: DirectoryEntry[] = []\n    for (const dirent of dirents) {\n      if (true === (await f(dirent))) result.push(dirent)\n    }\n    return result\n  }\n\n  _directoryEntryChild(de: DirectoryEntry) {\n    return this.for(_path.join(this.nativePath, de.base), de)\n  }\n\n  /**\n   * @return the basename of the children of `this`, locale sorted.\n   */\n  childNames(): PromiseMaybe<string[]> {\n    return thenMap(this.childDirectoryEntries(), arr => arr.map(ea => ea.base))\n  }\n\n  /**\n   * For case-insensitive filesystems, return the closest-matching existing file\n   * **with case matching whats on the filesystem**\n   */\n  async resolve_(): PromiseMaybe<this> {\n    return (\n      (await this.#resolve_()) ?? (await this.clearThisAndParent().#resolve_())\n    )\n  }\n  async #resolve_(): PromiseMaybe<this> {\n    // DON'T USE this.siblingDirectoryEntries(): that filters `this`!\n\n    // Use readdir_() directly to avoid needless DirectoryEntry creation:\n    const sibs = (await readdir_(this.dir)).filter(ea =>\n      equalsIgnoreCase(ea.basename, this.base)\n    )\n    const closest = leastBy(sibs, ea => hamming(ea.basename, this.base))\n    return this.bflog().tap({\n      msg: \"resolve()\",\n      result:\n        closest?.basename === this.base\n          ? this\n          : map(closest, ea => this.forSiblingDirent(ea)),\n      meta: { sibs }\n    })\n  }\n\n  /**\n   * @throws if `readdir` fails\n   */\n  async children_(predicate?: Predicate<SimpleDirent>): Promise<this[]> {\n    const dirents = await readdir_(this.nativePath)\n    if (predicate != null) {\n      await filterInPlaceAsync(dirents, predicate)\n    }\n    // readdir_ gives us sorted files already!\n    return dirents.map(ea => this.forChildDirent(ea))\n  }\n\n  async children(predicate?: Predicate<DirectoryEntry>): PromiseMaybe<this[]> {\n    return (await this.childDirectoryEntries(predicate))?.map(ea =>\n      this._directoryEntryChild(ea)\n    )\n  }\n\n  async childFiles(\n    predicate?: Predicate<DirectoryEntry>\n  ): PromiseMaybe<this[]> {\n    const arr = await this.childDirectoryEntries(async ea => {\n      return (\n        ea.isFile() && (predicate == null || true === (await predicate(ea)))\n      )\n    })\n    return arr == null\n      ? undefined\n      : arr.map(ea => this._directoryEntryChild(ea))\n  }\n\n  async childDirectories(\n    predicate?: Predicate<DirectoryEntry>\n  ): PromiseMaybe<this[]> {\n    const arr = await this.childDirectoryEntries(async ea => {\n      return (\n        ea.isDirectory() &&\n        (predicate == null || true === (await predicate(ea)))\n      )\n    })\n    return arr == null\n      ? undefined\n      : arr.map(ea => this._directoryEntryChild(ea))\n  }\n\n  /**\n   * ONLY FOR TESTS\n   */\n  childrenSync(): this[] {\n    return orElse(\n      this.trapSync(\"childrenSync\", () =>\n        fs.readdirSync(this.nativePath).map(ea => this.join(ea))\n      ),\n      []\n    )\n  }\n  childFilesSync(): this[] {\n    return orElse(\n      this.trapSync(\"childrenSync\", () =>\n        fs\n          .readdirSync(this.nativePath, { withFileTypes: true })\n          .filter(ea => ea.isFile())\n          .map(ea => this.join(ea.name))\n      ),\n      []\n    )\n  }\n\n  async hasChildren(childNames?: string[]) {\n    const actualChildNames = await this.childNames()\n    return isNotEmpty(childNames)\n      ? includesAll(actualChildNames, childNames)\n      : isNotEmpty(actualChildNames)\n  }\n\n  async hasNoChildren() {\n    return (await this.isFile()) || isEmpty(await this.childNames())\n  }\n\n  /**\n   * Depth-first recursion, includes child directories.\n   */\n  async visitDescendants(\n    f: (descendant: this) => any | Promise<any>\n  ): Promise<void> {\n    return thenMap(this.children(), async children => {\n      for (const child of children) {\n        await child.visitDescendants(f)\n        await f(child)\n      }\n    })\n  }\n\n  /**\n   * Breadth-first recursion\n   *\n   * @return all files (no directories) that pass the given predicate.\n   */\n  async descendants(\n    predicate: Predicate<DirectoryEntry>\n  ): PromiseMaybe<this[]> {\n    const result: this[] = []\n    result.push(...toA(await this.childFiles(predicate)))\n    const dirs = await this.childDirectories()\n    if (dirs == null) return result\n    for (const dir of dirs) {\n      result.push(...toA(await dir.descendants(predicate)))\n    }\n    return result\n  }\n\n  async someDescendant(\n    predicate: Predicate<DirectoryEntry>,\n    depth: number = 0\n  ): PromiseMaybe<this> {\n    if (!gt0(depth)) return\n    const arr = (await this.#childDirectoryEntries()) ?? []\n    for (const ea of arr) {\n      if (true === (await predicate(ea))) {\n        return this._directoryEntryChild(ea)\n      }\n    }\n    if (depth > 0) {\n      for (const ea of arr) {\n        if (ea.isDirectory()) {\n          const result = await this._directoryEntryChild(ea).someDescendant(\n            predicate,\n            depth - 1\n          )\n          if (result != null) return result\n        }\n      }\n    }\n    return\n  }\n\n  /**\n   * Lightweight breadth-first directory entry visiting\n   *\n   * @return all files (no directories) that pass the given predicate.\n   */\n  descendantsSync(predicate: SyncPredicate<DirectoryEntry>): this[] {\n    const thisDe = this.directoryEntrySync()\n    const result: this[] = []\n    thisDe?.visitDescendantsSync(ea => {\n      if (true === predicate(ea)) {\n        result.push(this.forDirectoryEntry(ea))\n      }\n    })\n    return result\n  }\n\n  async ancestorWithChildren(childNames: string[]): PromiseMaybe<this> {\n    if (await this.hasChildren(childNames)) {\n      return this\n    } else if (this.isRoot) {\n      return undefined\n    } else {\n      return this.parent().ancestorWithChildren(childNames)\n    }\n  }\n\n  async siblings(f?: Predicate<DirectoryEntry>): PromiseMaybe<this[]> {\n    const p = this.parent()\n    return (await this.siblingDirectoryEntries(f))?.map(ea =>\n      p._directoryEntryChild(ea)\n    )\n  }\n\n  async siblingDirectoryEntries(\n    f?: Predicate<DirectoryEntry>\n  ): PromiseMaybe<DirectoryEntry[]> {\n    return this.parent().childDirectoryEntries(\n      async ea => ea.base !== this.base && (f == null || true === (await f(ea)))\n    )\n  }\n\n  async selfAndSiblings() {\n    return this.parent().children()\n  }\n\n  async firstExistingSelfOrAncestor(): Promise<this> {\n    return this.isRoot || (await this.exists())\n      ? this\n      : this.parent().firstExistingSelfOrAncestor()\n  }\n\n  /**\n   * @return [\"C:\", \"Users\", \"Bob\", \"image.jpg\"] on win, [\"home\", \"bob\",\n   * \"image.jpg\"] on !win\n   */\n  get pathnames(): string[] {\n    return splitNativePath(this.nativePath)\n\n    // return this.bflog().tap({\n    //   msg: \"pathnames()\",\n    //   result: splitNativePath(this.nativePath),\n    //   meta: { nativePath: this.nativePath }\n    // })\n  }\n\n  get pathsForDateParsing(): string[] {\n    return [\n      ...(this.isRoot ? [] : this.parent().pathnamesWithoutDrive),\n      bname(this.name)\n    ]\n  }\n\n  get pathnamesWithoutDrive(): string[] {\n    return isWin ? this.pathnames.slice(1) : this.pathnames\n  }\n\n  /**\n   * @return 0 for \"/\" or \"C:\\\", 1 for \"C:\\Users\" or \"/etc\", ...\n   */\n  get depth(): number {\n    return pathDepth(this)!\n  }\n\n  get isRoot(): boolean {\n    return pathIsRoot(this)\n  }\n\n  /**\n   * @param depth The number of directories from root to include. For example,\n   * \"C:\\\" or \"/\" for 0, \"C:\\Users\" or \"/home\" for depth 1\n   */\n  root(depth: number = 0): this {\n    // \"/\".root(1) should return \"/\"\n    return this.depth <= depth ? this : this.parent().root(depth)\n  }\n\n  parent(): this {\n    // MEMLEAK: don't cache this: this.for will do that for us.\n    return this.isRoot ? this : (this.for(this.dir) as this)\n  }\n\n  isAncestorOf(\n    maybeDescendant: Maybe<string | SimpleFile>,\n    args?: { acceptSelf: boolean }\n  ): boolean {\n    return containedByNativePath({\n      ancestor: this,\n      descendant: maybeDescendant,\n      ...args\n    })\n  }\n\n  isDescendantOf(maybeAncestor: Maybe<string | SimpleFile>): boolean {\n    return containedByNativePath({ descendant: this, ancestor: maybeAncestor })\n  }\n\n  isSelfOrDescendantOf(maybeAncestor: Maybe<string | SimpleFile>): boolean {\n    return (\n      maybeAncestor != null &&\n      (this.nativePath === toNativePath_(maybeAncestor) ||\n        this.isDescendantOf(maybeAncestor))\n    )\n  }\n\n  parentsAndSelf(): this[] {\n    return [...this.parents(), this]\n  }\n\n  selfAndParents(depth: number): this[] {\n    return [\n      this,\n      ...(this.isRoot || depth <= 0\n        ? []\n        : this.parent().selfAndParents(depth - 1))\n    ]\n  }\n\n  ancestor(depth = 1): Maybe<this> {\n    // TODO: remove recursion\n    return this.isRoot && depth > 0\n      ? undefined\n      : depth === 0\n      ? this\n      : this.parent().ancestor(depth - 1)\n  }\n\n  findAncestor(predicate: (ea: this) => boolean): Maybe<this> {\n    return this.isRoot\n      ? undefined\n      : predicate(this)\n      ? this\n      : this.parent().findAncestor(predicate)\n  }\n\n  /**\n   * Root-first order of paths (so [/, /var, /var/tmp, ...]\n   */\n  parents(): this[] {\n    const p = this.parent()\n    // NOTE: ALWAYS RETURN A NEW ARRAY, because consumers may .reverse or do\n    // other nasty things to it.\n    return this.isRoot ? [] : [...p.parents(), p]\n  }\n\n  /**\n   * Paths from URIs can have differently-encoded unicode paths (which switching\n   * from macOS to linux or Windows, for example.)\n   *\n   * If `this` exists, return it.\n   *\n   * If it doesn't, walk from the root of the path and try to find elements that,\n   * when unicode-normalized, match the current filesystem.\n   *\n   * As a last-ditch effort, try a case-insensitive match.\n   */\n  async normalize(): Promise<this> {\n    // Don't need to handle UNC paths (they are always windows-only):\n    return this.isUNC ? this : this.for(await actualPath(this.nativePath))\n  }\n\n  sibling(base: string): this {\n    return this.parent().join(base)\n  }\n\n  withPrefix(prefix: string): this {\n    return this.sibling(prefix + this.base)\n  }\n\n  /**\n   * @return this.sibling(this.name + suffix + this.ext)\n   */\n  withNameSuffix(suffix: string): this {\n    return this.sibling(this.name + suffix + this.ext)\n  }\n\n  /**\n   * @return this.sibling(this.base + suffix)\n   */\n  withSuffix(suffix: string): this {\n    return this.sibling(this.base + suffix)\n  }\n\n  siblingOf(possibleSibling: BaseFile): boolean {\n    return (\n      this.nativePath !== possibleSibling.nativePath &&\n      this.dir === possibleSibling.dir\n    )\n  }\n\n  /**\n   * Allows ../... directory traversals.\n   */\n  join(...paths: string[]): this {\n    if (isEmpty(paths) || eql([\".\"], paths) || paths.every(blank)) return this\n    return isAbsolute(paths[0])\n      ? this.for(_path.join(...paths))\n      : this.for(_path.join(this.nativePath, ...paths))\n  }\n\n  joinYMD(d = new Date()): Maybe<this> {\n    return map3(\n      d?.getFullYear(),\n      d?.getMonth(),\n      d?.getDate(),\n      (year, month, day) => this.join(toS(year), pad2(month + 1), pad2(day))\n    )\n  }\n\n  /**\n   * Prevents `..` directory traversals\n   * @param paths\n   */\n  child(...paths: string[]): this {\n    if (isEmpty(paths)) return this\n    const pathElements = flatten(paths.map(ea => ea.split(_path.sep))).filter(\n      ea => ea !== \"..\"\n    )\n    // Convert to posix to prevent \"\\\\\" and \"/\" from confusing the split:\n    return this.join(...pathElements)\n  }\n\n  //  _  _    _\n  // (_)| |_ ( )___    __ _\n  // | || __||// __|  / _` |\n  // | || |_   \\__ \\ | (_| | _  _  _\n  // |_| \\__|  |___/  \\__,_|(_)(_)(_)\n  protected async trap<T>(\n    methodName: string,\n    p: () => SyncOrAsync<T>,\n    errLogLevel: LogLevel = \"warn\"\n  ): PromiseMaybe<T> {\n    try {\n      return await time(\"fs.\" + methodName, p)\n    } catch (err) {\n      this.bflog().log(errLogLevel, `trap: ${methodName}() failed: ${err}`)\n      return undefined\n    }\n  }\n\n  // Return true if p() doesn't raise an error, else return false.\n  protected async trapOr(\n    methodName: string,\n    p: () => Promise<any>,\n    errLogLevel: LogLevel = \"warn\"\n  ): Promise<boolean> {\n    try {\n      await time(\"fs.\" + methodName, p)\n      return true\n    } catch (err) {\n      this.bflog().log(errLogLevel, `trapOr: ${methodName}() failed: ${err}`)\n      return false\n    }\n  }\n\n  protected trapSync<T>(\n    methodName: string,\n    p: () => T,\n    errLogLevel: LogLevel = \"warn\"\n  ): Maybe<T> {\n    try {\n      // this.bflog().trace(`trapSync ${methodName}()`)\n      return timeSync(\"fs.\" + methodName, p)\n    } catch (err) {\n      this.bflog().log(errLogLevel, `${methodName}() failed: ${err}`)\n      return undefined\n    }\n  }\n\n  /**\n   * Never cached\n   */\n  stat_() {\n    return stat_(this.nativePath)\n  }\n\n  #stat: Maybe<fs.Stats> = undefined\n\n  async stat(opts?: RefreshArgs) {\n    if (opts?.refresh ?? false) {\n      this.#stat = undefined\n    }\n    return (this.#stat ??= await statMaybe(this.nativePath))\n  }\n\n  statSync(opts?: RefreshArgs) {\n    if (opts?.refresh ?? false) {\n      this.#stat = undefined\n    }\n    return (this.#stat ??= statSync(this.nativePath))\n  }\n\n  async exists(opts?: RefreshArgs): Promise<boolean> {\n    if (opts?.refresh ?? false) {\n      this.dirent = undefined\n    }\n    return this.dirent != null || (await thenDefined(this.stat(opts)))\n  }\n\n  existsSync(opts?: RefreshArgs): boolean {\n    if (opts?.refresh ?? true) {\n      this.dirent = undefined\n    }\n    return this.dirent != null || this.statSync(opts) != null\n  }\n\n  async notExists(opts?: RefreshArgs): Promise<boolean> {\n    return thenNot(this.exists(opts))\n  }\n\n  async isDeleted(maxDepth = 3): PromiseMaybe<boolean> {\n    if (await this.exists({ refresh: true })) {\n      return this.bflog().tap({\n        result: false,\n        msg: \"isDeleted(): file exists\"\n      })\n    }\n\n    if (this.isRoot || maxDepth <= 0) {\n      return this.bflog().tap({\n        result: undefined,\n        msg: \"isDeleted(): isRoot() and doesn't exist (volume is just unmounted)\"\n      })\n    }\n\n    const parentIsDeleted = await this.parent().isDeleted(maxDepth - 1)\n\n    if (parentIsDeleted == null) {\n      return this.bflog().tap({\n        result: undefined,\n        msg: \"isDeleted(): parent().isDeleted was undefined\",\n        meta: { parentIsDeleted }\n      })\n    } else {\n      return this.bflog().tap({\n        result: true,\n        msg: \"isDeleted(): parent was either deleted or not deleted: either way, that means I am deleted.\",\n        meta: { parentIsDeleted }\n      })\n    }\n  }\n\n  mtime(): PromiseMaybe<Date> {\n    return thenMap(this.stat(), s => s.mtime)\n  }\n\n  mtimeMs(opts?: RefreshArgs): PromiseMaybe<number> {\n    return thenMap(this.stat(opts), s => Math.floor(s.mtimeMs))\n  }\n\n  async mtimeSec(): PromiseMaybe<number> {\n    const s = await this.stat()\n    return s == null ? undefined : unixtime(s.mtimeMs)\n  }\n\n  async lastModifiedUtc(): PromiseMaybe<string> {\n    return (await this.stat())?.mtime.toUTCString()\n  }\n\n  // The mtime, rather than the birthtime, will actually be the capture\n  // time if the file is \"copied and pasted\" via the Windows explorer\n  // (rather than using `rsync --times` or `cp --preserve=all`).\n\n  // Birthtime isn't supported by default in linux, and seems to just return\n  // the ctime.\n\n  /**\n   * @return the uniq stat times, including birthtime, mtime, and ctime.\n   */\n  async statTimes(): PromiseMaybe<number[]> {\n    const s = await this.stat()\n    return s == null ? undefined : statTimes(s)\n  }\n\n  maxStatMs(): PromiseMaybe<number> {\n    return thenMap(this.statTimes(), max)\n  }\n\n  maxStatDate(): PromiseMaybe<Date> {\n    return thenMap(this.maxStatMs(), ea => new Date(ea))\n  }\n\n  minStatMs(): PromiseMaybe<number> {\n    return thenMap(this.statTimes(), min)\n  }\n\n  minStatDate(): PromiseMaybe<Date> {\n    return thenMap(this.minStatMs(), ea => new Date(ea))\n  }\n\n  async size(opts?: RefreshArgs): PromiseMaybe<number> {\n    return thenMap(this.stat(opts), s => s.size)\n  }\n\n  /**\n   * Always uncached\n   */\n  async size_(): Promise<number> {\n    return (await this.stat_()).size\n  }\n\n  /**\n   * @return Promise<true> if the file is executable (not relevant on windows)\n   */\n  async isExecutable(): Promise<boolean> {\n    return access({ stat: await this.stat(), r: true, x: true })\n  }\n\n  async isReadable(): Promise<boolean> {\n    return access({ stat: await this.stat(), r: true })\n  }\n\n  isNotReadable(): Promise<boolean> {\n    return thenNot(this.isReadable())\n  }\n\n  async isReadWritable(): Promise<boolean> {\n    return access({ stat: await this.stat(), r: true, w: true })\n  }\n\n  isNotReadWritable(): Promise<boolean> {\n    return thenNot(this.isReadWritable())\n  }\n\n  async isReadWriteExecutable(): Promise<boolean> {\n    return isStatRWX(await this.stat())\n  }\n\n  isReadWriteExecutableSync(): boolean {\n    return isStatRWX(this.statSync())\n  }\n\n  async isReadWriteExecutable_(): Promise<boolean> {\n    return isStatRWX(await this.stat_())\n  }\n\n  async isReadWriteDirectory(): Promise<boolean> {\n    const stat = await this.stat()\n    return stat?.isDirectory() === true && isStatRWX(stat)\n  }\n\n  async assertReadWriteExecutable(): Promise<void> {\n    if (!(await this.isReadWriteExecutable())) {\n      throw new Error(\n        `Please check directory permissions for ${\n          this.nativePath\n        }: it must be read/write${\n          isWin ? \"\" : \"/execute\"\n        } by ${await userDesc()}`\n      )\n    }\n  }\n\n  /**\n   * Is this a rw dir, or **is it possible** for this directory to be made rw?\n   */\n  async maybeReadWriteDirectory(): Promise<boolean> {\n    if ((await this.isFile()) === true) {\n      return false\n    } else if (await this.isDirectory()) {\n      return this.isReadWriteExecutable()\n    } else {\n      // I don't exist! ask my parent:\n      return this.parent().maybeReadWriteDirectory()\n    }\n  }\n\n  isHiddenBasename(): boolean {\n    return isHiddenBasename(this.base)\n  }\n\n  async isEmpty(bytesConsideredEmpty = 0): Promise<boolean> {\n    if (await this.isDirectory()) {\n      return isNotEmpty(await this.childNames())\n    } else {\n      const s = await this.size()\n      return s == null || s <= bytesConsideredEmpty\n    }\n  }\n\n  isNonEmpty(minSizeBytes = 1): Promise<boolean> {\n    return thenNot(this.isEmpty(minSizeBytes))\n  }\n\n  async isEmptyFile(minSizeBytes = 1): Promise<boolean> {\n    const s = await this.stat()\n    return (\n      s == null ||\n      ((await this.isFile()) && !gte(await this.size(), minSizeBytes))\n    )\n  }\n\n  async isNonEmptyFile(minSizeBytes = 1): Promise<boolean> {\n    return (await this.isFile()) && (await this.isNonEmpty(minSizeBytes))\n  }\n\n  async modifiedGTE(mtime: Date): PromiseMaybe<boolean> {\n    return thenMap(\n      this.mtime(),\n      thisMtime =>\n        // Filesystems have only second-level resolution\n        unixtime(thisMtime) >= unixtime(mtime)\n    )\n  }\n\n  async modifiedCloseTo(\n    mtimeMs: number,\n    deltaMs: number\n  ): PromiseMaybe<boolean> {\n    return thenMap(\n      this.mtimeMs(),\n      thisMtimeMs => Math.abs(thisMtimeMs - mtimeMs) <= deltaMs\n    )\n  }\n\n  async isRecent(agoMs: number): Promise<boolean> {\n    const mtime = await this.maxStatMs()\n    return mtime != null && mtime > Date.now() - agoMs\n  }\n\n  async modifiedGT(mtime: Maybe<Date>): PromiseMaybe<boolean> {\n    if (mtime == null) return\n    return thenMap(\n      this.mtime(),\n      thisMtime =>\n        // Filesystems have only second-level resolution\n        unixtime(thisMtime) > unixtime(mtime)\n    )\n  }\n\n  isDirectory(opts?: RefreshArgs): SyncOrAsync<boolean> {\n    if (this.dirent != null) return this.dirent.isDirectory()\n    return thenMapOr(\n      this.stat(opts),\n      ea => ea.isDirectory(),\n      () => false\n    )\n  }\n\n  async isNotDirectory(): Promise<boolean> {\n    return thenNot(this.isDirectory())\n  }\n\n  isDirectorySync(opts?: RefreshArgs): boolean {\n    if (this.dirent != null) return this.dirent.isDirectory()\n    return mapOr(\n      this.statSync(opts),\n      ea => ea.isDirectory(),\n      () => false\n    )\n  }\n\n  async nearestDir(): Promise<this> {\n    return (await this.isDirectory()) ? this : this.parent()\n  }\n\n  async isFile(): Promise<boolean> {\n    if (this.dirent != null) return this.dirent.isFile()\n    const s = await this.stat()\n    return s != null ? s.isFile() : false\n  }\n\n  isFileSync(): boolean {\n    if (this.dirent != null) return this.dirent.isFile()\n    return opt(this.statSync()).filter(ea => ea.isFile()).isDefined\n  }\n\n  async rmdir(errLogLevel: LogLevel = \"warn\"): Promise<boolean> {\n    this.clear()\n    return (\n      (await this.trap(\n        \"rmdir\",\n        async () => {\n          await _fse.rmdir(this.nativePath, {\n            recursive: false,\n            maxRetries: 8,\n            retryDelay: 500\n          })\n          return true\n        },\n        errLogLevel\n      )) ?? false\n    )\n  }\n\n  rmdirSync(errLogLevel: LogLevel = \"warn\"): boolean {\n    this.clear()\n    return (\n      this.trapSync(\n        \"rmdirSync\",\n        () => {\n          _fse.rmdirSync(this.nativePath, {\n            recursive: false,\n            maxRetries: 8,\n            retryDelay: 500\n          })\n          return true\n        },\n        errLogLevel\n      ) ?? false\n    )\n  }\n\n  /**\n   * @throws on error\n   */\n  async mkdirp_(): Promise<this> {\n    try {\n      await mkdirp_(this.nativePath)\n    } catch (err: any) {\n      // EEXIST is from race conditions, and can be ignored.\n      if (err?.code !== \"EEXIST\") throw err\n    }\n    if (\n      // kernel FS lag can't be longer than a second or two\n      false ===\n      (await untilTrue(() => this.clear().isDirectory(), {\n        timeoutMs: 2 * secondMs,\n        intervalMs: 200\n      }))\n    ) {\n      throw new Error(\"Failed to mkdirp \" + this)\n    } else {\n      // this and parent because parent caches children.\n      return this.clearThisAndParent()\n    }\n  }\n\n  async mkdirp(): PromiseMaybe<this> {\n    if ((await this.clear().isDirectory()) || this.isRoot) return this\n    return this.trap(\"mkdirp\", async () => this.mkdirp_())\n  }\n\n  /**\n   * @throws on error\n   */\n  mkdirpSync_(): this {\n    mkdirpSync_(this.nativePath)\n    return this.clearThisAndParent()\n  }\n\n  mkdirpSync(): Maybe<this> {\n    if (this.isRoot) return this\n    return this.trapSync(\"mkdirpSync\", () => this.mkdirpSync_())\n  }\n\n  // no need lazy() or cache: fileSha_ already has smart caching.\n  sha_(): Promise<string> {\n    return fileSha_(this.nativePath)\n  }\n\n  /**\n   * base64 encoded SHA-512/192 (ish)\n   */\n  async sha(): PromiseMaybe<string> {\n    return this.trap(\"sha\", () => this.sha_())\n  }\n\n  /**\n   * @return ms to gather the sha for this file\n   */\n  async shaMs(): PromiseMaybe<number> {\n    // we don't care if the metadata is stale!\n    return this.trap(\n      \"shaMs\",\n      async () =>\n        (await fileShaMeta_(this, { autoInvalidate: false })).elapsedMs\n    )\n  }\n\n  async readJson_<T>(): Promise<T> {\n    return parseJSON((await _fse.readFile(this.nativePath)).toString()) as any\n  }\n\n  readJson<T>(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<T> {\n    return this.trap(\"readJson\", () => this.readJson_<T>(), errLogLevel)\n  }\n\n  readJsonSync<T>(): Maybe<T> {\n    return this.trapSync(\"readJsonSync\", () =>\n      parseJSON<T>(fs.readFileSync(this.nativePath).toString())\n    )\n  }\n\n  readFileSync_() {\n    return readFileSync(this.nativePath)\n  }\n\n  readFile_(): Promise<Buffer> {\n    return readFile(this.nativePath)\n  }\n\n  readFile(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<Buffer> {\n    return this.trap(\"readFile\", () => this.readFile_(), errLogLevel)\n  }\n\n  async readTextFile_() {\n    return bufferToString(await this.readFile_())\n  }\n\n  readTextFile(errLogLevel: LogLevel = \"warn\") {\n    return this.trap(\"readTextFile\", () => this.readTextFile_(), errLogLevel)\n  }\n\n  /**\n   * `readFile`, but on-the-fly decompression for .gz and .br\n   * @throws on error\n   */\n  async zReadFile_(options?: {\n    start?: number\n    end?: number\n  }): PromiseMaybe<Buffer> {\n    return zCopyToBuffer_(this.nativePath, options)\n  }\n\n  async zcat(options?: { start?: number; end?: number }): PromiseMaybe<string> {\n    return this.trap(\"zcat\", () => thenMap(this.zReadFile_(options), toS))\n  }\n\n  readLines(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<string[]> {\n    return thenMap(this.readTextFile(errLogLevel), splitLines)\n  }\n\n  readFileSync(): Maybe<string> {\n    try {\n      return fs.readFileSync(this.nativePath).toString()\n    } catch (error) {\n      this.bflog().warn(\"readFileSync() failed\", { error })\n      return\n    }\n  }\n\n  /**\n   * @throws on error\n   */\n  async writeText_(...txt: string[]) {\n    await writeText_(this.nativePath, ...txt)\n    return this\n  }\n\n  writeTextSync_(...txt: string[]) {\n    writeTextSync_(this.nativePath, ...txt)\n    return this\n  }\n\n  /**\n   * @throws on error\n   */\n  async writeFile_(data: string | Buffer) {\n    await writeFile_(this.nativePath, data)\n    return this\n  }\n\n  async writeJson(object: any, options?: JsonWriteOptions): PromiseMaybe<this> {\n    // outputJSON is almost the same as writeJson, except that if the directory\n    // does not exist, it's created\n    return this.trap(\"writeJsonMaybe\", () => this.writeJson_(object, options))\n  }\n\n  /**\n   * @throws on error\n   */\n  async writeJson_(object: any, options?: JsonWriteOptions): Promise<this> {\n    await mkdirp_(this.dir)\n    await _fse.writeFile(\n      this.nativePath,\n      stringify(object, options?.replacer, options?.spaces),\n      omit(options, \"replacer\", \"spaces\")\n    )\n    this.clearThisAndParent()\n    return this\n  }\n\n  async matchesContent(that: this): Promise<boolean> {\n    const stats = await Promise.all([\n      this.stat({ refresh: true }),\n      that.stat({ refresh: true })\n    ])\n    if (stats[0] == null || stats[1] == null || stats[0].size !== stats[1].size)\n      return false\n    return (await this.sha()) === (await that.sha())\n  }\n\n  async touch(args: UtimesArgs = {}): PromiseMaybe<this> {\n    return this.trap(\"touch\", () => this.touch_(args))\n  }\n\n  async touch_(args: UtimesArgs = {}): Promise<this> {\n    await touch_({\n      ...args,\n      file: this,\n      ensureFile: true\n    })\n    return this.clearThisAndParent()\n  }\n\n  async utimes(args: UtimesArgs = {}): PromiseMaybe<this> {\n    return this.trap(\"utimes\", async () => {\n      await touch_({\n        ...args,\n        file: this,\n        ensureFile: false\n      })\n      this.clearThisAndParent()\n      return this\n    })\n  }\n\n  async rm(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<this> {\n    return this.unlink(errLogLevel)\n  }\n\n  /**\n   * Deletes the current file.\n   * @return Promise<this> if unlink was successful\n   */\n  async unlink(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<this> {\n    return this.trap(\"unlink\", () => this.unlink_(), errLogLevel)\n  }\n\n  /**\n   * Deletes the current file.\n   */\n  unlinkSync(logLevel: LogLevel = \"info\") {\n    return this.trapSync(\n      \"unlinkSync\",\n      () => {\n        _fse.unlinkSync(this.nativePath)\n        this.clearThisAndParent()\n      },\n      logLevel\n    )\n  }\n\n  async unlink_(): Promise<this> {\n    await _fse.unlink(this.nativePath)\n    return this.clearThisAndParent()\n  }\n\n  /**\n   * Delete files or directories. Should only be needed by tests or applied to\n   * cache dirs.\n   *\n   * Note that the promise may be returned before the file op is actually\n   * complete due to a (bug?) in fs-extra.\n   */\n  async rmrf(logLevel: LogLevel = \"info\"): PromiseMaybe<this> {\n    return this.trap(\"rmrf\", () => this.rmrf_(), logLevel)\n  }\n\n  async rmrf_(): Promise<this> {\n    // retries may be required for windows\n    return retryOnReject(\n      async () => {\n        const s = await this.stat({ refresh: true })\n        if (s != null) {\n          await _fse.rm(this.nativePath, {\n            recursive: s.isDirectory(),\n            force: true\n          })\n        }\n        return this.clearThisAndParent()\n      },\n      {\n        maxRetries: 3,\n        timeoutMs: 0, // recursive deletions may take a while\n        retryDelay: secondMs,\n        errorIsRetriable: isRetriableError\n      }\n    )\n  }\n\n  /**\n   * Supports gzip/gunzip/brotli/whatever transform you've got:\n   *\n   * THIS FILE IS DELETED AFTER THE PIPELINE COMPLETES\n   */\n  async #pipeTo(base: string, transform: stream.Transform) {\n    return this.trap(\"pipeTo(\" + base + \")\", async () => {\n      const dest = await this.sibling(base).ensureNew_()\n      await pipeline([\n        fs.createReadStream(this.nativePath, { autoClose: true }),\n        transform,\n        fs.createWriteStream(dest.nativePath, { autoClose: true })\n      ])\n      await this.unlink()\n      return dest\n    })\n  }\n\n  async gunzip(): PromiseMaybe<this> {\n    return this.#pipeTo(stripSuffix(this.base, \".gz\"), zlib.createGunzip())\n  }\n\n  async gzip(): PromiseMaybe<this> {\n    return this.#pipeTo(this.base + \".gz\", zlib.createGzip())\n  }\n\n  async compressBrotli(): PromiseMaybe<this> {\n    return this.#pipeTo(this.base + \".br\", zlib.createBrotliCompress())\n  }\n\n  ensureFile_(): Promise<this> {\n    return _fse\n      .ensureFile(this.nativePath)\n      .then(() => this.clearThisAndParent())\n  }\n\n  ensureFile(): PromiseMaybe<this> {\n    return this.trap(\"ensureFile\", () => this.ensureFile_())\n  }\n\n  /**\n   * @throws on error\n   */\n  ensureFileSync_() {\n    _fse.ensureFileSync(this.nativePath)\n    return this.clearThisAndParent()\n  }\n\n  /**\n   * Returns a basename in this directory with this same .ext and prefixed with\n   * this.name which either doesn't exist or is zero length.\n   *\n   * If `options.emptyIsNew` is `true`, the file may exist, but must be\n   * zero-length. If `options.emptyIsNew` is `false`, the returned path will be\n   * nonexistent.\n   */\n  async ensureNewNativePath(\n    options: Omit<EnsureNewOptions, \"nativePath\">\n  ): Promise<string> {\n    return ensureNewNativePath_({ nativePath: this.nativePath, ...options })\n  }\n\n  /**\n   * @throws if errors\n   */\n  ensureNew_(opts: Partial<EnsureNewOptions> = {}): Promise<this> {\n    return this.ensureNewNativePath(opts).then(p => this.for(p))\n  }\n\n  /**\n   * @throws if errors\n   */\n  ensureNewSync_(opts: Partial<EnsureNewOptions> = {}): this {\n    return this.for(\n      ensureNewNativePathSync_({ nativePath: this.nativePath, ...opts })\n    )\n  }\n\n  /**\n   * Make sure you encode `mode` in octal! 0o644\n   */\n  async chmod_(mode: string | number): Promise<this> {\n    await _fse.chmod(this.nativePath, mode)\n    return this.clear()\n  }\n\n  async chmod(mode: string | number): PromiseMaybe<this> {\n    try {\n      await this.chmod_(mode)\n      return this\n    } catch (err) {\n      this.bflog().warn(\"failed to chmod to \" + mode.toString(8), err)\n      return\n    }\n  }\n\n  chmodSync(mode: string | number): Maybe<this> {\n    try {\n      fs.chmodSync(this.nativePath, mode)\n      return this\n    } catch (err) {\n      this.bflog().warn(\"failed to chmod to \" + mode.toString(8), err)\n      return\n    }\n  }\n\n  zreadline(): LineReader {\n    return fs\n      .createReadStream(this.nativePath)\n      .on(\"error\", (err: any) => {\n        throw new Error(\"Failed to read from \" + this + \": \" + err)\n      })\n      .pipe(zlib.createGunzip())\n      .on(\"error\", (err: any) => {\n        throw new Error(\"Failed to gunzip \" + this + \": \" + err)\n      })\n      .pipe(new LineReader())\n  }\n\n  async siblingWithSameContents(): PromiseMaybe<this> {\n    return this.parent().childWithSameContents(this)\n  }\n\n  async childWithSameContents(target: BaseFile): PromiseMaybe<this> {\n    return time(\"fs.childWithSameContents\", async () => {\n      if (!(await this.isDirectory())) return\n\n      const targetSize = await target.size()\n      if (targetSize == null) return\n\n      // Only look for a same-named file if the parent directories are different:\n      if (!this.eql(target.parent())) {\n        const withSameName = this.join(target.base)\n        // SWEET we don't have to this.readdir()!\n        if (await target.matchesContent(withSameName)) return withSameName\n      }\n\n      const sameSize = await this.children(\n        async ea =>\n          !ea.isNameHidden() &&\n          targetSize === (await ea.size()) &&\n          // Don't include target!\n          ea.nativePath !== target.nativePath\n        // (we're not normalizing or case-insensitive matching here: there shouldn't be a need to, and that will be wrong on non-ci filesystems.)\n      )\n\n      // Don't need to sha target if none are the same size:\n      if (isEmpty(sameSize)) return\n\n      const targetSha = await target.sha()\n      if (targetSha == null) return\n\n      // Assume similar names are more likely to be the same, so try those first.\n      // if we have to check _64_ files with the same exact size, something screwy is going on: give up.\n      for (const child of sameSize\n        .sort((a, b) => -diceCoeff(a.base, b.base))\n        .slice(0, 64)) {\n        if ((await child.sha()) === targetSha) {\n          return child\n        }\n      }\n      return\n    })\n  }\n\n  firstMatchingLine(re: RegExp): PromiseMaybe<RegExpMatchArray> {\n    const d = new Deferred<Maybe<RegExpMatchArray>>(\n      \"firstMatchingLine(\" + this + \")\"\n    )\n    const r = fs.createReadStream(this.nativePath, { flags: \"r\" })\n    r.on(\"error\", (err: any) => {\n      if (err.errno === -2 || err.code === \"ENOENT\") {\n        void d.maybeResolve(undefined)\n        r.close()\n      } else {\n        void d.maybeReject(err)\n      }\n    })\n    r.on(\"close\", () => d.maybeResolve(undefined))\n    void onDataChunked(r, newlineRe(), ea => {\n      const m = re.exec(ea)\n      if (m != null) {\n        void d.maybeResolve(m)\n        r.close()\n      }\n    })\n    return d.promise\n  }\n\n  contemporary(b: BaseFile, maxDiffMs: number): Promise<boolean> {\n    return thenMap2Or(\n      this.statTimes(),\n      b.statTimes(),\n      (arr1, arr2) => {\n        for (const i of arr1) {\n          for (const j of arr2) {\n            if (closeTo(i, j, maxDiffMs)) {\n              return true\n            }\n          }\n        }\n        return false\n      },\n      () => false\n    )\n  }\n\n  /**\n   * NOTE: recursive is only supported if Settings.useFsWatch is true.\n   */\n  watchUntil<T>(opts: {\n    f: (event?: WatchEventType, filename?: string) => PromiseMaybe<T>\n    timeoutMs: number\n    persistent: boolean\n    recursive: boolean\n    intervalMs?: number\n    accept?: (t: Maybe<T>) => boolean\n  }): Deferred<T> {\n    const accept = (opts.accept ??= (t: Maybe<T>) => t != null && t !== false)\n    const d = new Deferred<T>(\"watchUntil(\" + this.nativePath + \")\")\n    if (opts.timeoutMs > 0) {\n      void d.setTimeout(opts.timeoutMs, !opts.persistent)\n    }\n    if (_useFsWatch) {\n      try {\n        const watcher = watch(\n          this.nativePath,\n          {\n            persistent: opts.persistent,\n            recursive: opts.recursive,\n            encoding: \"utf8\"\n          },\n          async (event, filename) => {\n            try {\n              const result = await opts.f(event, denull(filename))\n              if (accept(result)) {\n                void d.resolve(result!)\n              }\n            } catch (error) {\n              void d.reject(error)\n            }\n          }\n        )\n        void d.finally(() => {\n          watcher.close()\n        })\n      } catch (error) {\n        opts.intervalMs ??= 500\n        this.bflog().warn(\"fs.watch failed, using polling\", { error, opts })\n      }\n    } else {\n      // Force polling:\n      opts.intervalMs ??= 500\n      this.bflog().warn(\"watchUntil(): fsWatch disabled, using polling\", {\n        opts\n      })\n    }\n\n    if (gt0(opts.intervalMs)) {\n      const interval = setInterval(async () => {\n        try {\n          const result = await opts.f()\n          if (accept(result)) {\n            void d.resolve(result!)\n          }\n        } catch (error) {\n          void d.reject(error)\n        }\n      }, opts.intervalMs)\n      if (!opts.persistent) {\n        interval.unref()\n      }\n      void d.finally(() => {\n        clearInterval(interval)\n      })\n    }\n\n    return d\n  }\n}\n\nexport function execDir(): BaseFile {\n  return BaseFile.for(process.execPath).parent()\n}\n\n// This is used to break a circular dependency between fs and Settings:\nlet _useFsWatch: boolean = true\n\n// This is set in SettingsDefaults to watch Settings.useFsWatch:\nexport function useFsWatch(b: boolean) {\n  _useFsWatch = b\n}\n","import { compactBlanks } from \"../../fe/Array\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { newlineRe } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { isWin } from \"../platform/Platform\"\n\nexport const Newline = isWin ? \"\\r\\n\" : \"\\n\"\n\nexport function crlf(...s: string[]): string {\n  const result = s.map(toS).join(\"\\n\")\n  return isWin ? result.replace(newlineRe(), \"\\r\\n\") : result\n}\n\nexport function splitLines(...arr: Maybe<string | Buffer>[]): string[] {\n  return flatten(\n    arr.map(ea =>\n      Array.isArray(ea) ? splitLines(...ea) : toS(ea).split(newlineRe())\n    )\n  )\n}\n\nexport function joinLines(...lines: string[]): string {\n  return splitLines(...lines).join(Newline)\n}\n\nexport function splitCompactLines(...arr: Maybe<string | Buffer>[]): string[] {\n  return compactBlanks(splitLines(...arr))\n}\n","import path from \"path\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mapNotBlankOr } from \"../../fe/Blank\"\nimport { isMac, isWin } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\n\nconst DefaultMacOSPaths = Object.freeze([\n  \"/opt/homebrew/bin\",\n  \"/opt/homebrew/sbin\",\n  \"/usr/local/bin\",\n  \"/usr/local/sbin\",\n  \"/usr/bin\",\n  \"/bin\",\n  \"/usr/sbin\",\n  \"/sbin\"\n])\n\n// exported for tests:\nexport const DefaultPosixPaths = Object.freeze([\n  // From Ubuntu's /etc/environment:\n  \"/usr/local/bin\",\n  \"/usr/local/sbin\",\n  \"/usr/lib/libraw\", // where dcraw_emu lives\n  \"/opt/local/bin\", // macports\n  \"/opt/local/sbin\", // macports\n  \"/usr/sbin\",\n  \"/usr/bin\",\n  \"/sbin\",\n  \"/bin\"\n])\n\nexport const DefaultDockerPaths = Object.freeze([\n  \"/opt/photostructure/tools/bin\",\n  ...DefaultPosixPaths\n])\n\nexport const DefaultWinPaths = lazy(() => [\n  ...mapNotBlankOr(\n    process.env.SYSTEMROOT,\n    ea => [ea, path.join(ea, \"System32\"), path.join(ea, \"System32\", \"webm\")],\n    () => []\n  ),\n  \"C:\\\\cygwin64\\\\bin\"\n])\n\n// exported for tests:\nexport const DefaultPaths = Object.freeze(\n  isDocker()\n    ? DefaultDockerPaths\n    : isWin\n    ? DefaultWinPaths()\n    : isMac\n    ? DefaultMacOSPaths\n    : DefaultPosixPaths\n)\n","import fs from \"fs\"\nimport * as fse from \"fs-extra\"\nimport { join, parse, sep } from \"path\"\nimport { inspect } from \"util\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { MaybeSyncOrAsync, SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { toA } from \"../../fe/toA\"\nimport { mkLogger } from \"../Logger\"\nimport { stripSuffix } from \"../String\"\nimport { thenMap } from \"../async/Promise\"\nimport { ee } from \"../event/EventEmitter\"\nimport { ParsedFile, parentBasename, parseNativePath } from \"./Path\"\nimport { readdir } from \"./Readdir\"\nimport { SimpleDirent, isSimpleDirent } from \"./SimpleDirent\"\nimport { SimpleFile, isSimpleFile } from \"./SimpleFile\"\nimport { stat_ } from \"./Stat\"\n\n// DON'T REFERENCE PosixFile HERE, you'll have circular deps.\n\nexport class StatDirent implements Partial<Pick<fs.Stats, \"size\" | \"mtimeMs\">> {\n  readonly isFile: boolean\n  readonly isDirectory: boolean\n  size: Maybe<number>\n  mtimeMs: Maybe<number>\n  // Allow the Stats instance to be GC'ed by copying what I need out of it:\n  constructor(\n    readonly base: string,\n    s: fs.Stats | fs.Dirent | SimpleDirent\n  ) {\n    if (isSimpleDirent(s)) {\n      // TODO: assert that base === s.basename\n      this.isFile = s.isFile\n      this.isDirectory = s.isDirectory\n    } else {\n      this.isFile = s.isFile()\n      this.isDirectory = s.isDirectory()\n      // isSymbolicLink is always false unless you use lstat, which we never use.\n    }\n    if (s instanceof fs.Stats) {\n      this.size = s.size\n      this.mtimeMs = s.mtimeMs\n    }\n  }\n}\n\nconst logger = lazy(() => mkLogger(\"fs.DirectoryEntry\"))\n\nexport class DirectoryEntry implements ParsedFile, SimpleFile {\n  /**\n   * Full path\n   */\n  readonly nativePath: string\n\n  /**\n   * @return extension (`.jpg` for `image.jpg`)\n   */\n  readonly ext: string\n\n  /**\n   * Should only be constructed by BaseFile\n   *\n   * @param dir The full parent directory path such as `/home/user/dir` or\n   * `c:\\\\path\\\\dir` for `/home/user/dir/file.txt` or `c:\\\\path\\\\dir\\\\file.txt`\n   */\n  constructor(\n    readonly dir: string,\n    public dirent: StatDirent\n  ) {\n    this.nativePath = join(this.dir, dirent.base)\n    this.ext = parseNativePath(dirent.base).ext\n  }\n\n  static fromSimpleDirent(dir: string, dirent: SimpleDirent) {\n    return new DirectoryEntry(dir, new StatDirent(dirent.basename, dirent))\n  }\n\n  static async for(\n    nativePathOrFile: string | SimpleFile\n  ): PromiseMaybe<DirectoryEntry> {\n    try {\n      return await this.for_(nativePathOrFile)\n    } catch {\n      return\n    }\n  }\n\n  static async for_(\n    nativePathOrFile: string | SimpleFile\n  ): Promise<DirectoryEntry> {\n    const { nativePath, dir, base } = isSimpleFile(nativePathOrFile)\n      ? nativePathOrFile\n      : { nativePath: nativePathOrFile, ...parseNativePath(nativePathOrFile) }\n\n    const s = await fse.stat(nativePath)\n    return new DirectoryEntry(dir, new StatDirent(base, s))\n  }\n\n  clear() {\n    ee().emit(\"fileChanged\", this.nativePath)\n    this.dirent.size = undefined\n    this.dirent.mtimeMs = undefined\n    return this\n  }\n\n  async join(...path: string[]) {\n    return DirectoryEntry.for(join(this.nativePath, ...path))\n  }\n\n  /**\n   * @return the full basename `image.jpg`\n   */\n  get base() {\n    return this.dirent.base\n  }\n\n  /**\n   * @return basename without the ext (`image` for `image.jpg`)\n   */\n  get name() {\n    return stripSuffix(this.base, this.ext)\n  }\n\n  get pathnames(): string[] {\n    return this.nativePath.split(sep)\n  }\n\n  get parentAndBase(): string {\n    return this.pathnames.slice(-2).join(\"/\")\n  }\n\n  get parentBasename(): string {\n    return parentBasename(this.nativePath)\n  }\n\n  toJSON() {\n    return {\n      _ctor: this.constructor.name,\n      nativePath: this.nativePath\n    }\n  }\n\n  toLogJSON() {\n    return this.nativePath\n  }\n\n  [inspect.custom]() {\n    return this.toJSON()\n  }\n\n  toString() {\n    return this.nativePath\n  }\n\n  isFile() {\n    return this.dirent.isFile\n  }\n\n  isFileSync() {\n    return this.dirent.isFile\n  }\n\n  isDirectory() {\n    return this.dirent.isDirectory\n  }\n\n  isDirectorySync() {\n    return this.dirent.isDirectory\n  }\n\n  get isRoot() {\n    return this.dir === parse(this.dir).dir\n  }\n\n  isNameHidden() {\n    return this.name.startsWith(\".\")\n  }\n\n  parent(): SyncOrAsync<Maybe<this>> {\n    const p = parseNativePath(this.dir)\n    return p.dir === this.dir\n      ? this // root\n      : (new DirectoryEntry(p.dir, {\n          base: p.base,\n          isFile: false,\n          isDirectory: true,\n          mtimeMs: undefined as any,\n          size: undefined as any\n        }) as this)\n  }\n\n  async childNames() {\n    try {\n      return !this.isDirectory()\n        ? undefined\n        : (await readdir(this.nativePath))?.map(ea => ea.basename)\n    } catch (err) {\n      logger().warn(\n        \"childNames() failed to readdir(\" + this.nativePath + \")\",\n        err\n      )\n      return\n    }\n  }\n\n  async children() {\n    try {\n      if (!this.isDirectory()) return undefined\n      const arr = await readdir(this.nativePath) // readdir is already sorted\n      return arr?.map(\n        ea => DirectoryEntry.fromSimpleDirent(this.nativePath, ea) as this\n      )\n    } catch (err) {\n      logger().warn(\n        \"children() failed to readdir(\" + this.nativePath + \")\",\n        err\n      )\n      return\n    }\n  }\n\n  childrenSync() {\n    try {\n      if (!this.isDirectory()) return undefined\n      const arr = fs.readdirSync(this.nativePath, { withFileTypes: true }) // readdir is already sorted\n      return arr?.map(\n        ea => new DirectoryEntry(this.nativePath, new StatDirent(ea.name, ea))\n      )\n    } catch (err) {\n      logger().warn(\n        \"children() failed to readdir(\" + this.nativePath + \")\",\n        err\n      )\n      return\n    }\n  }\n\n  async childDirectories() {\n    return toA(await this.children()).filter(ea => ea.isDirectory())\n  }\n\n  async childFiles() {\n    return toA(await this.children()).filter(ea => ea.isFile())\n  }\n\n  /**\n   * Depth-first\n   */\n  async visitDescendants(f: (child: this) => any): Promise<void> {\n    const children = await this.children()\n    if (children == null) return\n\n    for (const dir of children.filter(ea => ea.isDirectory())) {\n      await dir.visitDescendants(f)\n    }\n\n    for (const ea of children) {\n      if (ea.isFile()) {\n        await f(ea)\n      }\n    }\n\n    for (const ea of children) {\n      if (ea.isDirectory()) {\n        await f(ea)\n      }\n    }\n\n    return\n  }\n\n  visitDescendantsSync(f: (child: DirectoryEntry) => any): void {\n    const children = this.childrenSync()\n    if (children == null) return\n    for (const ea of children) {\n      if (ea.isFile()) f(ea)\n    }\n    for (const ea of children) {\n      if (ea.isDirectory()) {\n        ea.visitDescendantsSync(f)\n        f(ea)\n      }\n    }\n  }\n\n  async visitDescendantFiles(f: (child: this) => any): Promise<void> {\n    return this.visitDescendants(ea => (ea.isFile() ? f(ea) : undefined))\n  }\n\n  async filterDescendantFiles(\n    predicate: (child: this) => SyncOrAsync<boolean>\n  ) {\n    const arr: this[] = []\n    await this.visitDescendantFiles(async ea => {\n      if (true === (await predicate(ea))) arr.push(ea)\n    })\n    return arr\n  }\n\n  async stat() {\n    try {\n      const s = await stat_(this.nativePath)\n      this.dirent = new StatDirent(this.base, s)\n      return s\n    } catch {\n      return\n    }\n  }\n\n  size(): MaybeSyncOrAsync<number> {\n    // Try to reduce the number of promises we're making:\n    return this.dirent.size ?? thenMap(this.stat(), ea => ea.size)\n  }\n\n  mtimeMs(): MaybeSyncOrAsync<number> {\n    // Try to reduce the number of promises we're making:\n    return this.dirent.mtimeMs ?? thenMap(this.stat(), ea => ea.mtimeMs)\n  }\n\n  unlink_() {\n    ee().emit(\"fileChanged\", this.nativePath)\n    return fse.unlink(this.nativePath)\n  }\n\n  rmdir_() {\n    ee().emit(\"fileChanged\", this.nativePath)\n    return fse.rmdir(this.nativePath)\n  }\n}\n","import path from \"path\"\nimport { leftPad } from \"../../fe/Pad\"\nimport { mkdirpSync_, mkdirp_, parseNativePath } from \"./Path\"\nimport { isEmptyFile } from \"./Stat\"\nimport { isEmptyFileSync } from \"./StatSync\"\n\nexport interface EnsureNewOptions {\n  nativePath: string\n  emptyIsNew?: boolean\n  maxVersions?: number\n  requireNumber?: boolean\n  leftPad?: number\n  startIndex?: number\n}\n\nexport const DefaultEnsureNewOptions: Omit<\n  Required<EnsureNewOptions>,\n  \"nativePath\"\n> = Object.freeze({\n  emptyIsNew: true,\n  maxVersions: 512,\n  requireNumber: false,\n  leftPad: 1,\n  startIndex: 1\n})\n\nexport async function ensureNewNativePath_(\n  arg: EnsureNewOptions\n): Promise<string> {\n  const opts: Required<EnsureNewOptions> = {\n    ...DefaultEnsureNewOptions,\n    ...arg\n  }\n  const p = parseNativePath(opts.nativePath)\n  await mkdirp_(p.dir)\n  {\n    if (!opts.requireNumber && (await isEmptyFile(opts.nativePath, opts))) {\n      return opts.nativePath\n    }\n  }\n  for (let i = opts.startIndex; i <= opts.maxVersions; i++) {\n    const f = path.join(\n      p.dir,\n      `${p.name}-${leftPad(i, opts.leftPad, \"0\")}${p.ext}`\n    )\n    if (await isEmptyFile(f, opts)) return f\n  }\n  throw new Error(\n    \"There are already more than \" + opts.maxVersions + \" of \" + opts.nativePath\n  )\n}\n\nexport function ensureNewNativePathSync_(arg: EnsureNewOptions): string {\n  const opts: Required<EnsureNewOptions> = {\n    ...DefaultEnsureNewOptions,\n    ...arg\n  }\n  const p = parseNativePath(opts.nativePath)\n  mkdirpSync_(p.dir)\n  if (!opts.requireNumber && isEmptyFileSync(opts.nativePath, opts)) {\n    return opts.nativePath\n  }\n  for (let i = opts.startIndex; i <= opts.maxVersions; i++) {\n    const f = path.join(\n      p.dir,\n      `${p.name}-${leftPad(i, opts.leftPad, \"0\")}${p.ext}`\n    )\n    if (isEmptyFileSync(f, opts)) return f\n  }\n  throw new Error(\n    \"There are already more than \" + opts.maxVersions + \" of \" + opts.nativePath\n  )\n}\n","import { isNotEmpty } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { later } from \"../../fe/Delay\"\nimport { keys } from \"../../fe/Object\"\nimport { EndableRanks } from \"../async/Endable\"\nimport { EndableWrapper } from \"../async/EndableWrapper\"\nimport { ee } from \"../event/EventEmitter\"\nimport { FifoCacheAsync, FifoCacheAsyncOpts } from \"../FifoCacheAsync\"\nimport { mkLogger } from \"../Logger\"\nimport { mapEntries } from \"../Object\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\n\n// DEPLOOP DANGER: DON'T REFERENCE BASEFILE!\n\nexport const InstanceCacheMaxSize = 256\n\nexport interface CacheableFile {\n  clear(args?: { emit?: boolean }): this\n}\n\nexport function isCacheableFile(o: any): o is CacheableFile {\n  return typeof o === \"object\" && typeof o.clear === \"function\"\n}\n\nexport class FileCache<T> extends FifoCacheAsync<T> {\n  constructor(\n    opts: Partial<FifoCacheAsyncOpts> & Pick<FifoCacheAsyncOpts, \"name\">\n  ) {\n    super({\n      maxSize: InstanceCacheMaxSize,\n      timeoutMs: ShortCommandTimeoutMs,\n      ...opts\n    })\n\n    // break circular deps:\n    later(() => {\n      ee().on(\"fileChanged\", path => this.#clearFromPath(path))\n      ee().on(\"clearCache\", () => this.clear())\n\n      new EndableWrapper(\n        opts.name + \" stats\",\n        () => {\n          const s = mapEntries(this.stats(), (_, v) => (v > 0 ? v : undefined))\n          if (isNotEmpty(keys(s))) {\n            mkLogger(opts.name).info(\"stats\", s)\n          }\n        },\n        EndableRanks.stats\n      )\n    })\n  }\n\n  async #clearFromPath(fromPath?: string) {\n    if (blank(fromPath)) {\n      // full wipe: the singleton expectation can't/shouldn't be expected.\n      await this.clear()\n    } else {\n      for (const k of this.cache.keys()) {\n        if (k.startsWith(fromPath)) {\n          const v = await this.cache.get(k) // values may be promises\n          if (isCacheableFile(v)) {\n            // NOTE: BaseFile and PosixFile instances are expected to be\n            // singletons for a given path, so if we remove the instance from\n            // here, they won't be singletons anymore: we just want to remove\n            // any cached state they currently have.\n            v.clear({ emit: false })\n          } else {\n            this.cache.delete(k)\n          }\n        }\n      }\n    }\n  }\n}\n","import { Dirent } from \"fs\"\nimport { lazy } from \"../../core/Lazy\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { values } from \"../../fe/Object\"\nimport { toS } from \"../../fe/toS\"\nimport { MaybeFileish } from \"../fs/MaybeFileish\"\nimport { JpegExts } from \"./JpegExts\"\nimport { isSimpleFile } from \"./SimpleFile\"\n\nconst ShortExtRe = /(?:^\\.?|.\\.)([a-z0-9]{2,4})$/i\n\n/**\n * @return the file extension, in lower case, without a \".\" prefix. File\n * extensions longer than 4 characters are not supported.\n */\nexport function normalizeExt(ext: MaybeFileish): Maybe<string> {\n  ext = isSimpleFile(ext) ? ext.ext : ext instanceof Dirent ? ext.name : ext\n  const result = map(ShortExtRe.exec(toS(ext)), m => m[1])?.toLowerCase()\n  // hack to normalize all JPEG to \"jpg\"\n  return JpegExts.includes(result as any) ? \"jpg\" : result\n}\n\nexport function isExt(ext: MaybeFileish, ...exts: string[]): boolean {\n  ext = normalizeExt(ext)\n  return exts.some(ea => normalizeExt(ea) === ext)\n}\n\nexport function isJpegExt(ext: MaybeFileish): boolean {\n  return isExt(ext, ...JpegExts)\n}\nexport function isJsonExt(ext: MaybeFileish): boolean {\n  return isExt(ext, \"json\")\n}\nexport function isCsvExt(ext: MaybeFileish): boolean {\n  return isExt(ext, \"csv\")\n}\n\nexport const SidecarFiletypes = {\n  \"application/rdf+xml\": [\"xmp\"],\n  \"application/json\": [\"json\"],\n  \"application/x-mie\": [\"mie\"],\n  \"application/x-exif\": [\"exif\"],\n  \"application/vnd.apple.photos\": [\"aae\"],\n  \"image/x-exv\": [\"exv\"] // BOO it's not an image!\n} as const\n\nexport const SidecarExts = flatten(\n  values(SidecarFiletypes)\n) as unknown as string[]\n\n/**\n * Note that JSON is considered a sidecar type\n */\nexport function isSidecarExt(ext: MaybeFileish): boolean {\n  return isExt(ext, ...SidecarExts)\n}\n\nexport const extAliases = lazy(() => {\n  const result = new Map<string, string[]>()\n  for (const arr of [\n    JpegExts,\n    [\"tif\", \"tiff\"],\n    [\"heif\", \"heic\"],\n    [\"html\", \"htm\"],\n    [\"jp2\", \"jp2k\"]\n  ] as string[][]) {\n    for (const ea of arr) {\n      result.set(ea, arr)\n    }\n  }\n  return result\n})\n\nconst regexCache = new Map<string, RegExp>()\n\n/**\n * NOTE: Assumes exts doesn't need normalization, and comes directly from getExtInfo!\n */\nexport function mkExtsRegExp(exts: string[]): RegExp {\n  return getOrSet(\n    regexCache,\n    exts.join(\",\"),\n    () => new RegExp(\"\\\\.(?:\" + exts.join(\"|\") + \")$\", \"im\")\n  )\n}\n","import fs from \"fs\"\nimport { stat } from \"fs/promises\"\nimport { pick } from \"../../fe/Object\"\nimport { SimpleFileOrString, toNativePath_ } from \"./SimpleFile\"\n\nexport type FileStats = Pick<fs.Stats, \"size\" | \"mtimeMs\">\n\nexport async function fileStats_(f: SimpleFileOrString): Promise<FileStats> {\n  return pick((await stat(toNativePath_(f)))!, \"size\", \"mtimeMs\")\n}\n","import { blank, toNotBlank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { isString, stripPrefix } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { extractInt } from \"../Number\"\nimport { ParsedFile, parsePosixPath } from \"./Path\"\nimport { SimpleFile } from \"./SimpleFile\"\n\nconst CopiesRe = [\n  // macOS, when you copy-paste-paste, you get\n  // img.jpg\n  // img copy.jpg\n  // img copy 2.jpg\n  // img copy 3.jpg\n\n  // Windows, when you copy-paste-paste, you get\n  // img.jpg\n  // img - Copy.jpg\n  // img - Copy 2.jpg\n  // img - Copy 3.jpg\n  /\\s*-?\\s*copy(?:\\s*\\d{1,3}\\s*)?$/i,\n\n  // img - Copy (2).jpg\n  // img - Copy (3).jpg\n  // img - Copy (101).jpg\n  /\\s*-?\\s*copy(?:\\s*\\(\\s*\\d{1,3}\\s*\\))$/i,\n\n  // Ubuntu when you copy-paste-paste-paste, you get\n  // img.jpg\n  // img (copy).jpg\n  // img (another copy).jpg // <-- srsly wth\n  // img (3rd copy).jpg\n  // img (4th copy).jpg\n  /\\s*\\((?:another|\\d+[a-z]{2})?\\s*copy\\)$/i,\n\n  // foobar(1).jpg\n  // foobar (1).jpg\n  // foobar ( 32 ).jpg\n  // foobar-(1).jpg\n  // foobar-( 32 ).jpg\n  /\\s*-?\\(\\s*\\d{1,4}\\s*\\)$/,\n\n  // frakkin google sidecars chop the right bit off the UUID.\n  // https://forum.photostructure.com/t/574/7\n\n  // The \"38\" means we leave a - on the end of UUIDs. That dash should make all\n  // other patterns not match, so this regex will be the only one applied.\n  /(?<=[0-9a-f-]{37}-)[0-9a-f-]+$/i,\n\n  // Variations added by EnsureNew.\n  // P432781234-1.jpg\n  // P432781234-01.jpg\n  // P432781234-001.jpg\n\n  /\\s*-\\s*\\d{1,3}$/\n]\n\nconst Copies2Re = [\n  ...CopiesRe,\n  // // img edit.jpg\n  // // img-edit.jpg\n  // // img edited.jpg\n  // // img-edited.jpg\n  /\\s*-?edit(?:ed)?$/i\n]\n\nexport const ymdIsoRE = /^(?:\\d\\d){1,2}-\\d\\d-\\d\\d$/\n\nexport function ciStablePosixPath(posixPath: string): string {\n  const path = posixPath.split(\"/\")\n  const basename = path.pop()\n  if (blank(basename)) return posixPath\n  const parsed = parsePosixPath(basename)\n  const strippedName = stripCopySuffixFromName(parsed, { aggressive: false })\n  return [...path, strippedName + parsed.ext].join(\"/\").normalize()\n}\n\n/**\n * @return the file's name, stripped of any suffixes due to copies. DOES NOT LOWER CASE OR NORMALIZE.\n */\nexport function stripCopySuffixFromName(\n  f: SimpleFile | ParsedFile | string,\n  opts: { aggressive: boolean } = { aggressive: true }\n): string {\n  return _stripCopySuffixFromName(toNotBlank((f as any).name) ?? toS(f), opts)\n}\n\nfunction _stripCopySuffixFromName(\n  initialName: string,\n  opts: { aggressive: boolean }\n): string {\n  // Don't touch yyyy-mm-dd:\n  if (ymdIsoRE.test(initialName)) return initialName\n  let name = initialName\n  for (const re of opts.aggressive ? Copies2Re : CopiesRe) {\n    const m = name.match(re)\n    if (gt0(m?.index)) {\n      const s = name.slice(0, m!.index).trim()\n      if (s.length > 0) name = s\n    }\n  }\n  // If you make a copy of a copy, you'll get \"image - Copy 2 - copy\". We\n  // don't want to hit the exported function, because then the file ext may be\n  // stripped multiple times.\n  return initialName === name\n    ? initialName\n    : _stripCopySuffixFromName(name, opts)\n}\n\nexport function copySuffixCountFromName(\n  f: string | SimpleFile | ParsedFile\n): Maybe<number> {\n  const name = (isString(f) ? f : f.name).toLowerCase().normalize()\n  const strip = stripCopySuffixFromName(name)\n  const stripped = stripPrefix(name.toLowerCase().normalize(), strip)\n  return map(extractInt(stripped), Math.abs)\n}\n\nconst burstRe = /(?:burst)\\s*([\\w-]{8,})\\s*$/i\n\nconst coverRe = /(?<=.{6})_cover$/i\n\n// https://en.wikipedia.org/wiki/Design_rule_for_Camera_File_system\n// IMG_E0001.JPG is an edited version of IMG_0001.JPG\nconst dscPrefixRe =\n  /^(?:(?:dsc|dscf|img|gpfr|gopro?|gf|gh|gp|mov|mvi|mvimg|p|vid)(?:[-_ ]{0,2}e?))(\\d.+)$/i\nexport function stripDSC(f: SimpleFile | string): string {\n  let name = (isString(f) ? f : f.name).trim().replace(coverRe, \"\").trim()\n  map(burstRe.exec(name), m => (name = m[1].trim()))\n  map(dscPrefixRe.exec(name), m => (name = m[1].trim()))\n  return name\n}\n","import crypto from \"crypto\"\nimport fs from \"fs\"\nimport { pipeline } from \"stream/promises\"\nimport { lazy } from \"../../core/Lazy\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { eql } from \"../../fe/Eql\"\nimport { stringify } from \"../../fe/JSON\"\nimport { pick } from \"../../fe/Object\"\nimport { FifoCacheAsync } from \"../FifoCacheAsync\"\nimport { HashBits } from \"../HashBits\"\nimport { mkLogger } from \"../Logger\"\nimport { shim1 } from \"../Shim1\"\nimport { stringShaToBuffer } from \"../StringHash\"\nimport { FileStats, fileStats_ } from \"./FileStats\"\nimport { SimpleFileOrString, toNativePath_ } from \"./SimpleFile\"\nimport { stat_ } from \"./Stat\"\n\nconst logger = lazy(() => mkLogger(\"fs.Hash\"))\n\nexport interface ShaMeta {\n  sha: string\n  stats: FileStats\n  elapsedMs: number\n}\n\nconst cache = lazy(\n  () =>\n    // we're not using a FileCache here, because SHAs are so expensive we want\n    // to manage cache invalidation ourselves.\n    new FifoCacheAsync<ShaMeta>({\n      name: \"fs.fileSha\",\n      maxSize: 512,\n      timeoutMs: 0, // TODO: we should be able to read any file in under a minute? What about videos?\n      clearEveryMs: 0, // no periodic clearing--no need.\n      useFsCache: true,\n      fsCacheTtlMs: 30 * minuteMs\n    })\n)\n\n/**\n * Consumers should not directly call this: use {@link fileSha_()} instead.\n * @return a Buffer with the first 192 bits of a SHA512 digest.\n * @throws on read error\n */\nexport const shimmedFileSha_ = shim1({\n  name: \"fs.Hash\",\n  cache,\n  impl: uncachedFileSha_\n})\n\n/**\n * Automatically invalidates SHAs whose stats have changed.\n */\nexport async function fileShaMeta_(\n  f: SimpleFileOrString,\n  { autoInvalidate = true }: { autoInvalidate?: boolean } = {}\n): Promise<ShaMeta> {\n  const nativePath = toNativePath_(f)\n  if (autoInvalidate) {\n    const prior = cache().get(nativePath)\n    if (prior != null) {\n      if (eql(prior.stats, await fileStats_(f))) {\n        logger().debug(\"fileSha_() cache matches current Stats\", {\n          nativePath,\n          prior\n        })\n        return prior\n      } else {\n        logger().debug(\"fileSha_() prior cache is invalid, re-reading SHA\", {\n          nativePath,\n          prior\n        })\n        cache().delete(nativePath) // prior sha is invalid!\n      }\n    }\n  }\n  return shimmedFileSha_(f)\n}\n\n/**\n * Automatically invalidates SHAs whose stats have changed.\n */\nexport async function fileSha_(f: SimpleFileOrString): Promise<string> {\n  return (await fileShaMeta_(f)).sha\n}\n\n/**\n * Uncached file SHA. Throws on error.\n */\nexport async function uncachedFileSha_(f: SimpleFileOrString) {\n  const start = Date.now()\n  const nativePath = toNativePath_(f)\n  return {\n    sha: await streamSha_(fs.createReadStream(nativePath)),\n    stats: pick(await stat_(nativePath), \"size\", \"mtimeMs\"),\n    elapsedMs: Date.now() - start\n  }\n}\n\nexport async function streamSha_(\n  source: NodeJS.ReadableStream,\n  transforms: NodeJS.ReadWriteStream[] = [],\n  hashAlgorithm: string = \"sha512\"\n): Promise<string> {\n  const hash = crypto.createHash(hashAlgorithm)\n  await pipeline([source, ...transforms, hash])\n  return hash\n    .digest()\n    .subarray(0, HashBits / 8)\n    .toString(\"base64\")\n}\n\n// /**\n//  * Take the SHA of a readable\n//  */\n// export async function readableShaB64(reader: Readable): Promise<string> {\n//   const hash = crypto.createHash(\"sha512\")\n//   await  pipelinePromise([reader, hash])\n//   return sliced(hash.digest()).toString(\"base64\")\n// }\n\nexport function numericSha(obj: any, msbits = 48): number {\n  return parseInt(stringShaToBuffer(stringify(obj), msbits).toString(\"hex\"), 16)\n}\n\nexport function randomSha() {\n  return crypto.randomBytes(HashBits / 8).toString(\"base64\")\n}\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { isTest } from \"../NodeEnv\"\nimport { isMac } from \"../platform/Platform\"\nimport { isExcludedMountpoint } from \"../volumes/PosixVolumes\"\n\nconst DevMounts = /^\\/dev(\\/|$)/i\n\n// Mojave mounts to /private/var/vm.\n// BigSur mounts to /System/Volumes/VM, /System/Volumes/Preboot, /System/Volumes/xarts, ...\n\n// mrm@mini ~ % mount | sed -e \"s/map auto/map_auto/\" | cut -d\\  -f3\n// /\n// /dev\n// /System/Volumes/Data\n// /private/var/vm\n// /Volumes/Mojave\n// /System/Volumes/Data/home\n// /System/Volumes/Hardware\n// /Volumes/Update\n// /Volumes/Install\n// /Volumes/SSD\n// /Volumes/Big\n// /Volumes/Update\n// /Volumes/Mojave\n// /Volumes/Recovery\n// mrm@mini ~ % uname -a\n// Darwin mini 19.6.0 Darwin Kernel Version 19.6.0: Sun Nov 14 19:58:51 PST 2021; root:xnu-6153.141.50~1/RELEASE_X86_64 x86_64\n\nconst MacSystemVolumes =\n  isMac || isTest\n    ? [\n        \"/dev\",\n        \"/System/Volumes/Hardware\",\n        \"/System/Volumes/iSCPreboot\",\n        \"/System/Volumes/Preboot\",\n        \"/System/Volumes/Update\",\n        \"/System/Volumes/VM\",\n        \"/System/Volumes/xarts\",\n        \"/Volumes/Install\",\n        \"/Volumes/Recovery\"\n      ].map(ea => ea.toLowerCase())\n    : undefined\n\nconst MacPrivate = isMac || isTest ? /^\\/private\\//i : undefined\n\n// macOS installation media\nconst MacOsInstall =\n  isMac || isTest ? /^\\/Volumes\\/install macos\\b/i : undefined\n\nconst MacNotDmg =\n  isMac || isTest // support \"v1.2\", \"v1.2.3\", \"v1.2.3-beta.4\", \"v1.2.3-beta.4-pre\", ...\n    ? /^\\/Volumes\\/PhotoStructure v?[\\d\\.]{3,}/i\n    : undefined\n\nexport function isPhotoStructureDmg(mountpoint: string): boolean {\n  return MacNotDmg?.exec(toS(mountpoint)) != null\n}\n\nexport function isIgnorableMountpoint(mountpoint: string): boolean {\n  return whyIgnorableMountpoint(mountpoint) != null\n}\n\nexport function whyIgnorableMountpoint(mountpoint: string): Maybe<string> {\n  return blank(mountpoint)\n    ? \"blank\"\n    : isExcludedMountpoint(mountpoint)\n    ? \"excluded\"\n    : DevMounts.test(mountpoint)\n    ? \"/dev\"\n    : MacSystemVolumes?.includes(mountpoint.toLowerCase()) === true\n    ? \"macOS system volume\"\n    : MacOsInstall?.test(mountpoint) === true\n    ? \"macOS installer volume\"\n    : MacPrivate?.test(mountpoint) === true\n    ? \"macOS private volume\"\n    : isPhotoStructureDmg(mountpoint)\n    ? \"PhotoStructure dmg\"\n    : undefined\n}\n","export const JpegExts = [\"jpg\", \"jpeg\", \"jpe\"] as const\n","import { Transform, TransformCallback } from \"stream\"\nimport { newlineRe } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\n\nexport class LineReader extends Transform {\n  private _prior: string = \"\"\n\n  constructor() {\n    super({ objectMode: false, autoDestroy: true })\n  }\n\n  _transform(chunk: any, _encoding: BufferEncoding, done: TransformCallback) {\n    const lines = (this._prior + toS(chunk)).split(newlineRe())\n    const last = lines.pop()\n    // if the last line is \"\", we ended with a newline, and we don't have a prior.\n    this._prior = last ?? \"\"\n    let delay = false\n    for (const ea of lines) {\n      // .push returns true if additional chunks of data may continue to be pushed; false otherwise\n      delay ||= !this.push(ea)\n    }\n    if (delay) setTimeout(done, 1)\n    else done()\n  }\n\n  _flush(done: TransformCallback): void {\n    if (this._prior !== \"\") this.push(this._prior)\n    this._prior = \"\"\n    done()\n  }\n}\n","import _path from \"path\"\nimport { SimpleFile, toNativePath_ } from \"./SimpleFile\"\nimport { writeTextfile_ } from \"./WriteFile\"\n\nexport function mkNoMedia_(dir: SimpleFile | string) {\n  return writeTextfile_(\n    _path.join(toNativePath_(dir), \".NoMedia\"),\n    `This directory's contents are excluded from PhotoStructure libraries.`,\n    ``,\n    `See https://photostructure.com/nomedia/ for details.`\n  )\n}\n","import _fse from \"fs-extra\"\nimport _path from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { ensurePrefix, splitLast } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { greatestBy } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport {\n  ensureSuffix,\n  equalsIgnoreCase,\n  spliceCapture,\n  stripPrefix\n} from \"../String\"\nimport { isRetriableError } from \"../error/ErrorTypes\"\nimport { isPosix, isWin } from \"../platform/Platform\"\nimport { native2posix, posix2native } from \"./PosixNative\"\nimport {\n  SimpleFile,\n  SimpleFileOrString,\n  isSimpleFile,\n  toNativePath_\n} from \"./SimpleFile\"\nimport { isReadableDirectory } from \"./Stat\"\nimport { isReadWriteableDirectorySync } from \"./StatSync\"\n\nexport const logger = lazy(() => mkLogger(\"fs.Path\"))\n\nexport function isHiddenBasename(f: SimpleFileOrString): boolean {\n  const base = isSimpleFile(f) ? f.base : _path.basename(_path.resolve(f))\n  return base.startsWith(\".\")\n}\n\nexport function containsHiddenPathname(f: SimpleFileOrString): boolean {\n  return toPathnames(f).some(isHiddenBasename)\n}\n\nexport function isNotHiddenPosixPath(f: SimpleFileOrString): boolean {\n  return toPathnames(f).every(ea => !isHiddenBasename(ea))\n}\n\nconst driveRe = /^(?<drive>[A-Z]:)(?<path>[\\\\/].*)?$/i\n\nfunction upcaseDriveLetters(nativePath: string): string {\n  const g = driveRe.exec(nativePath)?.groups\n  return g == null\n    ? nativePath\n    : g.drive.toUpperCase() + toS(g.path ?? _path.sep)\n}\n\nexport function resolveSimpleFile(f: SimpleFileOrString) {\n  return isSimpleFile(f) ? f.nativePath : resolve(f.toString())\n}\n\nexport function resolve(...paths: string[]): string {\n  if (blank(paths.join(\"\"))) {\n    throw new Error(\"resolve(): empty paths\")\n  }\n  return _path.resolve(upcaseDriveLetters(paths[0]), ...paths.slice(1))\n}\n\n/**\n * Reject if any of the paths are blank\n */\nexport function resolveMaybe(...paths: Maybe<string>[]): Maybe<string> {\n  return paths.some(blank) ? undefined : resolve(...(paths as string[]))\n}\n\nexport interface ParsedFile {\n  /** \"/home/user/dir\" of \"/home/user/dir/file.txt\" */\n  readonly dir: string\n  /** \"file.txt\" of \"/home/user/dir/file.txt\" */\n  readonly base: string\n  /** \"file\" of \"/home/user/dir/file.txt\" */\n  readonly name: string\n  /** \".txt\" or \".log.gz\" of \"/home/user/dir/file.txt\" */\n  readonly ext: string\n}\n\nexport function parsePosixPath(posixPath: string): ParsedFile {\n  return parseNativePath(posix2native(posixPath))\n}\n\n/** @return \".txt\" or \".log.gz\" of \"/home/user/dir/file.txt\" */\nexport function extname(nativePath: string): string {\n  return parseNativePath(nativePath).ext\n}\n\n/**\n * @return parent directory of `fileish`\n */\nexport function dirname(fileish: SimpleFileOrString): string {\n  return _path.dirname(toNativePath_(fileish))\n}\n\nexport function extMatches(pathlike1: Maybe<string>, pathlike2: Maybe<string>) {\n  if (blank(pathlike1) || blank(pathlike2)) return false\n  return equalsIgnoreCase(\n    _path.parse(pathlike1).ext,\n    _path.parse(pathlike2).ext\n  )\n}\n\nconst CompressedExtRE = /(\\.(?:gz|z|7z|xz|bz2))$/i\n\n/**\n * Supports hidden files and extracting \".log.gz\" as the `ext` for \"file.log.gz\"\n */\nexport function parseNativePath(nativePath: string): ParsedFile {\n  const r = spliceCapture(nativePath, CompressedExtRE)\n  const p = _path.parse(r?.uncaptured ?? nativePath)\n  return {\n    ...p,\n    ...(r == null\n      ? {}\n      : {\n          ext: p.ext + r.captured,\n          base: p.base + r.captured\n        })\n  }\n}\n\n// BEWARE!\n\n// > require(\"path\").parse(\"C:\")\n// { root: 'C:', dir: 'C:', base: '', ext: '', name: '' }\n\n/**\n * Return the name (NOT the path!) of the parent directory\n */\nexport function parentBasename(nativePath: SimpleFileOrString) {\n  const p = _path.parse(toNativePath_(nativePath))\n  return p.root === p.dir ? p.root : splitLast(p.dir, _path.sep)\n}\n\nexport function grandParentBasename(nativePath: SimpleFileOrString) {\n  return parentBasename(_path.parse(toNativePath_(nativePath)).dir)\n}\n\nexport function containedByNativePath(args: {\n  ancestor: Maybe<SimpleFileOrString>\n  descendant: Maybe<SimpleFileOrString>\n  acceptSelf?: boolean // false\n}): boolean {\n  try {\n    if (args.descendant == null || args.ancestor == null) return false\n    const ancestor = toNativePath_(args.ancestor)\n    const descendant = toNativePath_(args.descendant)\n    if (blank(ancestor) || blank(descendant)) return false\n    const acceptSelf = args.acceptSelf ?? false\n    if (ancestor === descendant) return acceptSelf\n    return descendant.startsWith(ensureSuffix(ancestor, _path.sep))\n  } catch (error) {\n    logger().warn(\"containedByNativePath() failed (returning false)\", {\n      args,\n      error\n    })\n    return false\n  }\n}\n\nexport function toPathnames(nativePath: SimpleFileOrString): string[] {\n  return isSimpleFile(nativePath)\n    ? nativePath.pathnames\n    : nativePath.split(_path.sep).filter(ea => ea != null && ea !== \"\")\n}\n\nexport function pathIsRoot(f: Maybe<SimpleFileOrString>): boolean {\n  return notBlank(f) && toPathnames(f).length === (isWin ? 1 : 0)\n}\n\nexport function pathDepth(f: Maybe<SimpleFileOrString>): Maybe<number> {\n  return blank(f) ? undefined : toPathnames(f).length - (isWin ? 1 : 0)\n}\n\nexport type NativePathed = Pick<SimpleFile, \"nativePath\">\n\nexport function posixPathFrom(\n  parent: string | NativePathed,\n  child: string | NativePathed\n): string {\n  const p = toNativePath_(parent)\n  const c = toNativePath_(child)\n  if (blank(p) || blank(c))\n    throw new Error(\"posixPathFrom empty args \" + stringify({ parent, child }))\n\n  return p === c\n    ? \"\"\n    : // The ensureSuffix handles windows drive letters properly:\n      stripPrefix(\n        native2posix(c).normalize(),\n        ensureSuffix(native2posix(p), \"/\").normalize()\n      ).normalize() // < macOS requires us to normalize\n}\n\n/**\n * @return the native path of `p`. If the full path is longer than\n * `maxLength`, only include the root and parent directory names until the\n * path is at most `maxLength` characters long.\n */\nexport function ellipsizePath({\n  p,\n  maxLength\n}: {\n  p: SimpleFileOrString\n  maxLength: number\n}) {\n  const np = toNativePath_(p)\n  if (np.length <= maxLength) return np\n  const pathnames = toPathnames(p)\n  const base = pathnames.pop()!\n  const lhs = []\n  const rhs = [base]\n  while (pathnames.length > 0) {\n    if (lhs.length < rhs.length) {\n      // pop off something for lhs:\n      lhs.push(pathnames.shift()!)\n      if (joinNativePath([...lhs, ...rhs]).length >= maxLength) {\n        pathnames.unshift(lhs.pop()!)\n        break\n      }\n    } else {\n      rhs.unshift(pathnames.pop()!)\n      if (joinNativePath([...lhs, ...rhs]).length >= maxLength) {\n        pathnames.push(rhs.shift()!)\n        break\n      }\n    }\n  }\n\n  if (pathnames.length > 0) {\n    lhs.push(\"…\")\n  }\n  return joinNativePath([...lhs, ...rhs])\n}\n\nexport function posixPathFromParent(nativePath: string): string {\n  return toPathnames(nativePath).slice(-2).join(\"/\")\n}\n\nexport function posixPathFromGrandparent(nativePath: string): string {\n  return toPathnames(nativePath).slice(-3).join(\"/\")\n}\n\nexport function addNameSuffix(basename_: string, suffix: string): string {\n  const p = parseNativePath(basename_)\n  return `${p.base}${suffix}${p.ext}`\n}\n\nexport function isUNC(nativePath: string) {\n  return nativePath.startsWith(\"\\\\\\\\\")\n}\n\nexport function isAbsolute(nativePath: string) {\n  return (\n    (isPosix && nativePath.startsWith(\"/\")) ||\n    (isWin && (isUNC(nativePath) || nativePath.match(driveRe) != null))\n  )\n}\n\nexport async function mkdirp_(nativePath: string) {\n  try {\n    // Don't try to make the mountpoint (or, say, \"c:\")\n    if (await isReadableDirectory(nativePath)) return\n    await _fse.mkdirp(nativePath)\n  } catch (err) {\n    // concurrent mkdirp() calls spuriously throw EACCES or EEXIST\n    if (await isReadableDirectory(nativePath)) return\n    else throw err\n  }\n}\n\nexport function mkdirpSync_(\n  nativePath: string,\n  options?: _fse.EnsureDirOptions\n) {\n  try {\n    // Don't try to make the mountpoint (or, say, \"c:\")\n    if (isReadWriteableDirectorySync(nativePath)) return\n    _fse.mkdirpSync(nativePath, options)\n  } catch (err) {\n    // concurrent mkdirp() calls spuriously throw EACCES\n    if (isReadWriteableDirectorySync(nativePath)) return\n    else throw err\n  }\n}\n\nexport async function move_(srcNativePath: string, destNativePath: string) {\n  return retryOnReject(\n    () => _fse.move(srcNativePath, destNativePath, { overwrite: true }),\n    {\n      errorIsRetriable: isRetriableError,\n      maxRetries: 5, // windows may throw EBUSY\n      retryDelay: 250\n    }\n  )\n}\n\nexport function splitNativePath(nativePath: SimpleFileOrString): string[] {\n  const result = toNativePath_(nativePath)\n  // DON'T USE compactBlanks: (correct) tests will fail, because a path can\n  // validly be \" \"\n  return result.split(_path.sep).filter(ea => ea != null && ea !== \"\")\n}\n\nexport function joinNativePath(filePaths: string[]): string {\n  return ensurePrefix(\n    compactBlanks(filePaths).join(_path.sep),\n    isWin ? \"\" : _path.sep\n  )\n}\n\nexport function joinNativePathMaybe(...paths: Maybe<string>[]): Maybe<string> {\n  return paths.some(blank) ? undefined : joinNativePath(paths as string[])\n}\n\nexport function bestMountpointForDir(\n  dir: SimpleFileOrString,\n  mountpoints: SimpleFileOrString[]\n): Maybe<SimpleFileOrString> {\n  return greatestBy(mountpoints, ea =>\n    // containedByNativePath handles blank and null properly:\n    containedByNativePath({\n      ancestor: ea,\n      descendant: dir,\n      acceptSelf: true\n    })\n      ? [toNativePath_(ea).length]\n      : undefined\n  )\n}\n\nexport function posixPathIncludesPathElement(\n  posixPath: string,\n  name: string\n): boolean {\n  return posixPath.split(\"/\").includes(name)\n}\n","import _path from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks, uniq } from \"../../fe/Array\"\nimport { toNotBlank } from \"../../fe/Blank\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt } from \"../../fe/Number\"\nimport { ensureSuffix } from \"../../fe/String\"\nimport { KiB } from \"../../fe/Units\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { env } from \"../env/Env\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { isLinux, isWin } from \"../platform/Platform\"\nimport { access, isStatRX } from \"./Access\"\nimport { actualPath } from \"./ActualPath\"\nimport { BaseFile } from \"./BaseFile\"\nimport { statMaybe } from \"./Stat\"\n\nconst logger = lazy(() => mkLogger(\"fs.PathTo\"))\n\n// This file is instead of depending on the npm \"which \" package, which doesn't have fallbacks, nor min filesize, nor access validation\n\n// dcraw_emu.exe is the smallest binary, and it's 26K.\nconst MinBinarySize = KiB\n\nasync function isBinaryFile(nativePath: string): Promise<boolean> {\n  const stat = await statMaybe(nativePath, \"trace\")\n  return (\n    stat != null &&\n    stat.isFile() &&\n    gt(stat.size, MinBinarySize) &&\n    access({ stat, r: true, x: true })\n  )\n}\n\nfunction fallbackPathDirectories() {\n  if (isWin) {\n    const systemRoot = toNotBlank(getEnv(\"SystemRoot\")) ?? \"C:\\\\Windows\"\n    return [\n      systemRoot,\n      _path.join(systemRoot, \"System32\"),\n      _path.join(systemRoot, \"System32\", \"Wbem\") // < wmic is hiding in Wbem\n    ]\n  } else {\n    return [\"/usr/local/bin\", \"/usr/bin\", \"/bin\", \"/usr/sbin\", \"/sbin\"]\n  }\n}\n\nfunction pathDirectories() {\n  const paths = toS(env().PATH).split(_path.delimiter)\n  return uniq(compactBlanks([...paths, ...fallbackPathDirectories()]))\n}\n\nexport async function pathTo(tool: string): PromiseMaybe<string> {\n  const base = isWin ? ensureSuffix(tool, \".exe\") : tool\n  const dirs = pathDirectories()\n\n  for (const dir of dirs) {\n    const nativePath = _path.join(dir, base)\n    if (await isBinaryFile(nativePath)) {\n      // only run actualPath for case-insensitive OSes:\n      return isLinux ? nativePath : actualPath(nativePath)\n    }\n  }\n  logger().warn(\"Failed to find tool\", { tool, dirs })\n  return\n}\n\nexport async function pathIfExists(f: Maybe<BaseFile>) {\n  const s = await f?.stat({ logLevel: \"debug\" })\n  return s != null && s.isFile() && s.size > MinBinarySize && isStatRX(s)\n    ? f!.nativePath\n    : undefined\n}\n\nexport const wmic = () => \"wmic\"\nexport const fsutil = () => \"fsutil\"\nexport const nslookupWin = () => \"nslookup\"\nexport const pingWin = () => \"ping\"\nexport const arpWin = () => \"arp\"\n\n// export const wmic = lazy(() => pathTo(\"wmic\", [\"OS\", \"GET\", \"localdatetime\"], [\"System32\", \"wbem\"]) )\n// export const fsutil = lazy(() => pathTo(\"fsutil\", []))\n// export const nslookupWin = lazy(() => pathTo(\"nslookup\", [\"127.0.0.1\"]))\n// export const pingWin = lazy(() => pathTo(\"ping\", [\"-n\", \"1\", \"localhost\"]))\n// export const arpWin = lazy(() => pathTo(\"arp\", [\"-a\"]))\n","import _path from \"path\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { equalsIgnoreCase } from \"../String\"\n\nexport function posix2native(posixPath: string, hostname?: string): string {\n  if (blank(posixPath)) return posixPath\n  if (_path.sep === _path.posix.sep) return posixPath\n  const prefix = notBlank(hostname)\n    ? _path.sep + _path.sep + hostname + _path.sep\n    : \"\"\n  const split = posixPath.split(_path.posix.sep)\n  if (equalsIgnoreCase(split[0], hostname)) split.unshift()\n  return prefix + split.join(_path.sep)\n}\n\nexport function native2posix(nativePath: string): string {\n  if (blank(nativePath)) return nativePath\n  if (_path.sep === _path.posix.sep) return nativePath\n  return _path.posix.sep === _path.sep\n    ? nativePath\n    : nativePath.split(_path.sep).join(_path.posix.sep)\n}\n","import _path from \"path\"\nimport process from \"process\"\nimport { lazy, MemoizedThunk } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { uniqInPlace } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { isElectron, isMac } from \"../platform/Platform\"\nimport { ancestors, hasChildren } from \"./Ancestors\"\nimport { isPhotoStructureDmg } from \"./IgnorableMountpoint\"\n\nexport const execDir = lazy(() => _path.dirname(process.execPath))\n\nfunction pathTo(...child: string[]): MemoizedThunk<string> {\n  return lazy<string>(() => _path.join(ProjectPath.Root() as string, ...child))\n}\n\nexport const ProjectPath = {\n  Root: lazy(() => {\n    const projectDirs = [\"data\", \"public\", \"views\"]\n    const dirs: string[] = []\n    if (isDocker()) {\n      dirs.push(\"/opt/photostructure\")\n    }\n    if (isElectron) {\n      dirs.push(\n        _path.join(execDir(), \"resources\"), // win electron\n        _path.join(execDir(), \"..\", \"Resources\") // mac electron\n      )\n    }\n    dirs.push(...compactBlanks([execDir(), process.cwd(), __dirname]))\n    uniqInPlace(dirs)\n    for (const dir of dirs) {\n      if (hasChildren(dir, projectDirs)) return dir\n      // don't go too far up:\n      for (const parent of ancestors(dir).slice(0, 4)) {\n        if (hasChildren(parent, projectDirs)) return parent\n        const npx = _path.join(dir, \"node_modules\", \"photostructure\")\n        if (hasChildren(npx, projectDirs)) return npx\n      }\n    }\n    return mkLogger(\"fs.ProjectPath\").throw(\n      \"Failed to find project root. Looked in \" + dirs\n    )\n  }),\n  Bin: pathTo(\"bin\"), // only present in docker and node\n  Data: pathTo(\"data\"),\n  ICC: pathTo(\"data\", \"icc\"),\n  Migrations: pathTo(\"data\", \"migrations\"),\n  Public: pathTo(\"public\"),\n  Tools: pathTo(\"tools\"),\n  Views: pathTo(\"views\"),\n  isInDMG: function (projectPathRoot?: string) {\n    if (!isMac) return false\n\n    // If PhotoStructure.app has a sibling called .background with a\n    // nobg-background.tiff, we're still in the DMG, but that will break if we\n    // change the DMG background. We could also check to see that we live in an\n    // Applications directory, but that's also not guaranteed.\n    return isPhotoStructureDmg(projectPathRoot ?? ProjectPath.Root())\n  }\n}\n","import * as fs from \"fs\"\nimport { readFile } from \"fs-extra\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toInt } from \"../../fe/Number\"\nimport { mkLogger } from \"../Logger\"\nimport { LogLevel, LogLevels } from \"../log/LogLevel\"\n\nconst logger = lazy(() => mkLogger(\"fs.ReadFile\"))\n\nexport async function readFileMaybe(\n  nativePath: string,\n  errLogLevel: LogLevel = LogLevels.info\n): PromiseMaybe<Buffer> {\n  try {\n    return await readFile(nativePath)\n  } catch (err) {\n    logger().log(errLogLevel, \".readFileMaybe(\" + nativePath + \")\", err)\n    return\n  }\n}\n\nexport function readFileSync(nativePath: string): Maybe<Buffer> {\n  try {\n    return fs.readFileSync(nativePath)\n  } catch {\n    //\n  }\n  return\n}\n\nexport function intFromFileSync(nativePath: string): Maybe<number> {\n  return logger().tap({\n    msg: \"intFromFileSync()\",\n    result: toInt(readFileSync(nativePath)?.toString(), {\n      defaultValue: undefined\n    }),\n    meta: { nativePath }\n  })\n}\n","import { Readable } from \"stream\"\n\nexport class ReadableBuffer extends Readable {\n  constructor(buffer: Buffer | string) {\n    super()\n    this.push(buffer)\n    this.push(null)\n  }\n}\n","import fsp from \"fs/promises\"\nimport { join } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0, toGt0 } from \"../../fe/Number\"\nimport {\n  Timeout,\n  thenOrTimeout,\n  thenOrTimeoutAt,\n  toNotTimeout\n} from \"../../fe/ThenOrTimeout\"\nimport { FifoSet } from \"../FifoSet\"\nimport { mkLogger } from \"../Logger\"\nimport { onTimeout } from \"../async/TimeoutHandler\"\nimport { ee } from \"../event/EventEmitter\"\nimport { Settings } from \"../settings/Settings\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { FileCache } from \"./FileCache\"\nimport { SimpleDirent } from \"./SimpleDirent\"\nimport { statTimeoutMs } from \"./StatTimeout\"\n\nexport interface CachedReaddir {\n  ts: number\n  path: string\n  result: SimpleDirent[]\n}\n\nexport const ReadDirCacheName = \"readdircache\"\n\nexport const readdirCacheDir = lazy(() =>\n  join(Settings.cacheDir.valueOrDefault, ReadDirCacheName)\n)\n\nconst logger = lazy(() => mkLogger(\"fs.Readdir\"))\n\nexport async function clearReaddirCaches() {\n  try {\n    await fsp.rm(readdirCacheDir(), { force: true, recursive: true })\n  } catch (error) {\n    logger().warn(\"clearReaddirCaches(): failed\", { error })\n  }\n}\n\nconst path2cache = lazy(\n  () =>\n    new FileCache<SimpleDirent[]>({\n      name: \"fs.readdir\",\n      maxSize: 256,\n      timeoutMs: commandTimeoutMs(),\n      clearEveryMs: minuteMs,\n      useFsCache: true,\n      fsCacheTtlMs: Settings.readdirCacheMs.valueOrDefault\n    })\n)\n\nexport function clearCachedReaddir(nativePath: string) {\n  if (!blank(nativePath)) {\n    path2cache.prior()?.delete(nativePath)\n  }\n}\n\nlater(() => {\n  Settings.cacheDir.watchLater(() => {\n    readdirCacheDir.clear()\n    void path2cache.prior()?.clear()\n    slowDirs.prior()?.clear()\n  })\n  ee().on(\"clearCache\", () => {\n    slowDirs.prior()?.clear()\n    // path2cache is a FileCache--they're already watching for \"clearCache\" and fileChanged.\n    return clearReaddirCaches()\n  })\n  ee().on(\"fileChanged\", nativePath =>\n    blank(nativePath) ? clearReaddirCaches() : clearCachedReaddir(nativePath)\n  )\n})\n\n// Only exposed for tests\nexport const slowDirs = lazy(() => new FifoSet<string>(256))\n\nexport async function isSlowDir(nativePath: string) {\n  if (blank(nativePath)) return false\n  if (slowDirs().has(nativePath)) return true\n  if (path2cache().has(nativePath)) {\n    slowDirs().add(nativePath)\n    return true\n  }\n  return false\n}\n\nexport function setSlowDir(nativePath: string) {\n  clearCachedReaddir(nativePath)\n  slowDirs().add(nativePath)\n}\n\nexport async function isCachedDir(nativePath: string) {\n  return path2cache().get(nativePath) != null\n}\n\nexport async function childDirectories_(nativePath: string): Promise<string[]> {\n  return (await readdir_(nativePath))\n    .filter(ea => ea.isDirectory)\n    .map(ea => join(nativePath, ea.basename))\n}\n\nexport async function readdir(\n  nativePath: string\n): PromiseMaybe<SimpleDirent[]> {\n  try {\n    return await (gt0(Settings.readdirCacheMs.valueOrDefault)\n      ? readdir_(nativePath)\n      : readdirUncached_(nativePath))\n  } catch (err) {\n    logger().warn(\"readdir() failed for \" + nativePath, err)\n    return\n  }\n}\n\n/**\n * @throws if readdir() fails.\n */\nexport async function readdir_(nativePath: string): Promise<SimpleDirent[]> {\n  return logger().tap({\n    level: \"trace\",\n    msg: \"readdir_(\" + nativePath + \")\",\n    result: await path2cache().getOrSetAsync(nativePath, () =>\n      _readdir_(nativePath)\n    )\n  })\n}\n\nexport function readdirCached(nativePath: string): Maybe<SimpleDirent[]> {\n  return path2cache().get(nativePath)\n}\n\nasync function _readdir_(nativePath: string): Promise<SimpleDirent[]> {\n  const ts = Date.now()\n  const timeoutAt = ts + statTimeoutMs() * 2\n\n  const p = readdirUncached_(nativePath)\n\n  // If readdir() completes quickly, don't bother with .json caching (which is\n  // expensive and generates a bunch of GC)\n\n  const quickResult = await thenOrTimeout(\n    p,\n    toGt0(Settings.fsCacheSlowMs.valueOrDefault) ?? statTimeoutMs()\n  )\n\n  if (quickResult === Timeout) {\n    onTimeout({ soft: false })\n  }\n\n  if (\n    quickResult !== Timeout &&\n    quickResult.length < Settings.readdirSizeCacheThresh.valueOrDefault\n  ) {\n    return quickResult\n  }\n\n  // Dang, we're dealing with a slow or very large directory.\n  logger().info(\"readdir(): slow or large dir\", { nativePath })\n  slowDirs().add(nativePath)\n\n  const result =\n    toNotTimeout(quickResult) ?? (await thenOrTimeoutAt(p, timeoutAt))\n\n  if (result === Timeout) {\n    return logger().throw(\"readdir() timeout\", { nativePath, doNotSend: true })\n  }\n\n  return result\n}\n\n/**\n * NOTE: CALLER SHOULD WRAP WITH A TIMEOUT!\n */\nexport async function readdirUncached_(\n  nativePath: string\n): Promise<SimpleDirent[]> {\n  const r = await fsp.readdir(nativePath, { withFileTypes: true })\n  return sortBy(\n    // this strips off the node 20 added \"path\" field:\n    r.map(ea => ({\n      basename: ea.name,\n      isFile: ea.isFile(),\n      isDirectory: ea.isDirectory()\n    })),\n    ea => [\n      ea.isFile, // < order files last\n      ea.basename.toLowerCase(), // < case insensitive sort (ish, but good enough here)\n      ea.basename // < for determinism with colliding FILE.txt and file.txt\n    ]\n  )\n}\n","import { notBlank } from \"../../fe/Blank\"\nimport { isBoolean } from \"../../fe/Boolean\"\n\nexport interface SimpleDirent {\n  /**  isFile */\n  isFile: boolean\n  /**  isDirectory */\n  isDirectory: boolean\n  /** full base name */\n  basename: string\n}\nexport function isSimpleDirent(d: any): d is SimpleDirent {\n  return (\n    d != null &&\n    notBlank(d.basename) &&\n    isBoolean(d.isFile) &&\n    isBoolean(d.isDirectory)\n  )\n}\n","import _fs from \"fs\"\nimport _path from \"path\"\nimport { blank } from \"../../fe/Blank\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe, MaybePromiseMaybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { equalsIgnoreCase, isString, stripPrefix } from \"../String\"\nimport { isWin } from \"../platform/Platform\"\nimport { NativePathed, resolve } from \"./Path\"\nimport { isSimpleDirent } from \"./SimpleDirent\"\n\n// BEST TYPE NAME EVAR\nexport type SimpleFileOrString = SimpleFile | string\n\nexport interface SimpleFile {\n  /**\n   * Absolute path\n   */\n  readonly nativePath: string\n  /**\n   * Absolute path elements\n   */\n  readonly pathnames: string[]\n  /**\n   * The file name including extension (if any) such as 'index.html'\n   */\n  readonly base: string\n  /**\n   * The file extension (if any) such as '.html'\n   */\n  readonly ext: string\n  /**\n   * The file name without extension (if any) such as 'index'\n   */\n  readonly name: string\n  /**\n   * The nativePath of the parent directory\n   */\n  readonly dir: string\n\n  /**\n   * True iff this directory has no parent\n   */\n  readonly isRoot: boolean\n\n  isFile(): SyncOrAsync<boolean>\n  isDirectory(): SyncOrAsync<boolean>\n  isFileSync(): boolean\n  isDirectorySync(): boolean\n\n  // No isSymbolicLink, as this method is only valid when using fs.lstat():\n  // https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_stats_issymboliclink\n\n  children(): MaybePromiseMaybe<this[]>\n  childNames(): MaybePromiseMaybe<string[]>\n  parent(): SyncOrAsync<Maybe<this>>\n\n  size(): SyncOrAsync<Maybe<number>>\n  mtimeMs(): SyncOrAsync<Maybe<number>>\n}\n\nexport function isSimpleFile(object: any): object is SimpleFile {\n  return (\n    object != null &&\n    // HEY FUTURE ME! Don't `instanceof DirectoryEntry` or BaseFile here: that\n    // causes a deploop\n    typeof object === \"object\" &&\n    !Array.isArray(object) &&\n    typeof object.nativePath === \"string\" &&\n    typeof object.base === \"string\" &&\n    typeof object.ext === \"string\" &&\n    typeof object.base === \"string\" &&\n    typeof object.dir === \"string\" &&\n    typeof object.isFile === \"function\"\n  ) // meh good enough\n}\n\nexport function toNativePath_(s: string | NativePathed) {\n  if (s == null) {\n    throw new Error(\"toNativePath(null)\")\n  }\n  if (blank(s)) {\n    throw new Error(\"toNativePath(blank)\")\n  }\n  if (isString(s)) {\n    // only resolve strings--if it has a nativePath, it's already resolved:\n    return resolve(s)\n  }\n  if (blank(s.nativePath)) {\n    throw new Error(`toNativePath(${stringify(s)})`)\n  }\n  return s.nativePath\n}\n\nexport function basename(s: SimpleFileOrString | _fs.Dirent) {\n  return s instanceof _fs.Dirent\n    ? s.name\n    : isSimpleFile(s)\n    ? s.base\n    : _path.basename(toNativePath_(s))\n}\n\nexport function dirname(s: SimpleFileOrString) {\n  return isSimpleFile(s) ? s.dir : _path.dirname(toNativePath_(s))\n}\n\nconst winDriveRE = /^[a-z]:$/i\n\nexport function rootDir(s: SimpleFileOrString): Maybe<string> {\n  // TODO: handle UNC paths\n  if (isSimpleFile(s)) {\n    const arr = s.pathnames\n    return isWin && arr[0].match(winDriveRE) != null ? arr[1] : arr[0]\n  } else {\n    const str = stripPrefix(s, \"/\") // ignore the initial \"/\"\n    const i = str.indexOf(_path.sep)\n    return i > 0 ? str.slice(1, i) : undefined\n  }\n}\n\nexport function findFileIndex(\n  needle: SimpleFile,\n  haystack: SimpleFile[]\n): number {\n  for (let i = 0; i < haystack.length; i++) {\n    if (haystack[i].nativePath === needle.nativePath) return i\n  }\n  for (let i = 0; i < haystack.length; i++) {\n    if (equalsIgnoreCase(haystack[i].nativePath, needle.nativePath)) return i\n  }\n  return -1\n}\n\nexport function isFileSync(s: SimpleFileOrString) {\n  if (blank(s)) return false\n\n  if (s instanceof _fs.Dirent) return s.isFile()\n\n  for (const ea of [s, (s as any)[\"dirent\"]]) {\n    if (isSimpleDirent(ea)) return ea.isFile // < not a method.\n  }\n\n  try {\n    const stat = _fs.statSync(toNativePath_(s))\n    return stat.isFile()\n  } catch {\n    return false\n  }\n}\n\nexport async function someSelfOrAncestor<T extends SimpleFile>(\n  sf: Maybe<T>,\n  predicate: (t: T) => SyncOrAsync<boolean>\n): Promise<boolean> {\n  if (sf == null) return false\n  const result = await predicate(sf)\n  return result === true || sf.isRoot\n    ? result\n    : someSelfOrAncestor(await sf.parent(), predicate)\n}\n\nexport async function firstSelfOrAncestor<T extends SimpleFile, R>(\n  sf: Maybe<T>,\n  predicate: (t: T) => SyncOrAsync<R>\n): PromiseMaybe<R> {\n  if (sf == null) return\n  const result = await predicate(sf)\n  return result != null || sf.isRoot\n    ? result\n    : firstSelfOrAncestor(await sf.parent(), predicate)\n}\n","import { Stats } from \"fs\"\nimport _fse from \"fs-extra\"\nimport { lazy } from \"../../core/Lazy\"\nimport { uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { isDate, unixtime } from \"../../fe/Date\"\nimport { Maybe, MaybePromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { diff, isNumber } from \"../../fe/Number\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { mkLogger } from \"../Logger\"\nimport { onTimeout } from \"../async/TimeoutHandler\"\nimport { isRecentMs } from \"../date/Date\"\nimport { LogLevel, LogLevels } from \"../log/LogLevel\"\nimport { access, isStatRWX } from \"./Access\"\nimport { isEmptyStats } from \"./StatSync\"\nimport { statTimeoutMs } from \"./StatTimeout\"\n\nconst logger = lazy(() => mkLogger(\"fs.Stat\"))\n\nexport async function stat_(nativePath: Maybe<string>): Promise<Stats> {\n  if (blank(nativePath)) {\n    return logger().throw(\"stat_() for blank path\", {\n      nativePath,\n      retriable: false,\n      fatal: false\n    })\n  }\n  const start = Date.now()\n  try {\n    return await thenOrTimeoutError(\n      _fse.stat(nativePath), // < no throwIfNoEntry option for async stat()\n      statTimeoutMs(),\n      true\n    )\n  } finally {\n    const elapsedMs = Date.now() - start\n    if (elapsedMs > statTimeoutMs() / 2) {\n      logger().warn(\"soft timeout for \" + nativePath, { elapsedMs })\n      onTimeout({ soft: true })\n    }\n  }\n}\n\nexport function statMaybe(\n  nativePath: Maybe<string>,\n  logLevel: LogLevel = LogLevels.info\n): MaybePromiseMaybe<Stats> {\n  return blank(nativePath)\n    ? undefined\n    : stat_(nativePath).catch(error => {\n        logger().log(logLevel, \"stat() failed\", { error, nativePath })\n        return undefined\n      })\n}\n\nexport function statToType(a: Stats) {\n  return a.isDirectory() ? \"directory\" : a.isFile() ? \"file\" : \"special\"\n}\n\nfunction statFieldToComparable(ea: Maybe<number | Date>): Maybe<number> {\n  return isDate(ea) ? unixtime(ea) : isNumber(ea) ? ea : undefined\n}\n\n/**\n * Given `Stats` objects from the same path, is it likely that the file has\n * changed?\n */\nexport function whyStatNotEql(a: Maybe<Stats>, b: Maybe<Stats>) {\n  if (a == null || b == null) {\n    return (\n      \"both must be defined: \" +\n      (a == null ? \"null\" : \"stat\") +\n      \" ≠ \" +\n      (b == null ? \"null\" : \"stat\")\n    )\n  }\n  const aType = statToType(a)\n  const bType = statToType(b)\n  if (aType !== bType) {\n    return \"inconsistent file type: \" + aType + \" ≠ \" + bType\n  }\n  // no atime, and birthtime isn't settable on linux--we're assuming we're\n  // comparing the same path.\n  for (const field of [\"size\", \"mtime\"] as const) {\n    const aVal = a[field]\n    const bVal = b[field]\n    const delta = diff(statFieldToComparable(aVal), statFieldToComparable(bVal))\n    // mtime and birthtime may be fractional milliseconds off.\n    if (delta == null || delta > 1) {\n      return \"unmatched \" + field + \": \" + aVal + \" ≠ \" + bVal\n    }\n  }\n  return\n}\n\nexport function statEql(a: Maybe<Stats>, b: Maybe<Stats>) {\n  return whyStatNotEql(a, b) == null\n}\n\nexport async function exists(\n  nativePath: string,\n  logLevel: LogLevel = LogLevels.info\n) {\n  return null != (await statMaybe(nativePath, logLevel))\n}\n\n/**\n * @return if the file is missing or empty\n */\nexport async function isEmptyFile(\n  nativePath: string,\n  opts?: { emptyIsNew?: boolean; logLevel?: LogLevel }\n) {\n  const s = await statMaybe(nativePath, opts?.logLevel ?? LogLevels.trace)\n  return s == null || (opts?.emptyIsNew ?? true) ? isEmptyStats(s) : false\n}\n\nexport async function isNonEmptyFile(nativePath: string, minFileSize = 0) {\n  const s = await statMaybe(nativePath)\n  return s != null && s.isFile() && s.size >= minFileSize\n}\n\nexport async function nativePathIsFile(\n  nativePath: Maybe<string>,\n  logLevel = LogLevels.info\n): Promise<boolean> {\n  return true === (await statMaybe(nativePath, logLevel))?.isFile()\n}\n\nexport async function isDirectory(nativePath: Maybe<string>): Promise<boolean> {\n  return true === (await statMaybe(nativePath))?.isDirectory()\n}\n\nexport async function isReadableDirectory(\n  nativePath: Maybe<string>,\n  logLevel: LogLevel = LogLevels.trace\n): Promise<boolean> {\n  const stat = await statMaybe(nativePath, logLevel)\n  return (\n    stat != null && stat.isDirectory() && access({ stat, r: true, x: true })\n  )\n}\n\nexport async function isReadWriteableDirectory(\n  nativePath: Maybe<string>,\n  logLevel: LogLevel = LogLevels.trace\n): Promise<boolean> {\n  const stat = await statMaybe(nativePath, logLevel)\n  return stat != null && stat.isDirectory() && isStatRWX(stat)\n}\n\nexport async function isMtimeRecent(\n  nativePath: Maybe<string>,\n  staleMs: number\n): Promise<boolean> {\n  return isRecentMs((await statMaybe(nativePath))?.mtimeMs, staleMs)\n}\n\n/**\n * @return the uniq stat times, including birthtime and mtime (not atime or\n * ctime!)\n */\nexport function statTimes(s: Stats): number[] {\n  return uniq(\n    // birthtimeMs will be 0 on OSes that don't support it. remember that\n    // ctime is last-status-change-time, (directory-change-time), _not_\n    // create-time. We don't want ctime!\n    [s.birthtimeMs, s.mtimeMs].filter(ea => ea != null && ea !== 0)\n  )\n}\n","import fs from \"fs\"\nimport { resolve } from \"path\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isRecentMs } from \"../date/Date\"\nimport { access } from \"./Access\"\nimport { posix2native } from \"./PosixNative\"\n\nexport function statSync(nativePath: Maybe<string>) {\n  if (blank(nativePath)) return\n  try {\n    return fs.statSync(nativePath, { throwIfNoEntry: false })\n  } catch {\n    // only will throw on older node.js versions:\n    return\n  }\n}\n\nexport function nativePathExistsSync(nativePath: Maybe<string>) {\n  if (blank(nativePath)) return false\n  try {\n    return fs.existsSync(nativePath)\n  } catch {\n    return false\n  }\n}\n\nexport function nativePathSizeSync(nativePath: Maybe<string>): Maybe<number> {\n  return statSync(nativePath)?.size\n}\n\nexport function isFileSync(nativePath: string, minSize = 0): boolean {\n  const s = statSync(nativePath)\n  return s != null && s.isFile() && s.size >= minSize\n}\n\nexport function isEmptyFileSync(\n  nativePath: string,\n  opts: { emptyIsNew: boolean } = { emptyIsNew: true }\n) {\n  const s = statSync(nativePath)\n  return opts.emptyIsNew ? s == null : isEmptyStats(s)\n}\n\nexport function isMtimeRecentSync(\n  nativePath: Maybe<string>,\n  staleMs: number\n): boolean {\n  return isRecentMs(statSync(nativePath)?.mtimeMs, staleMs)\n}\n\nexport function isEmptyStats(s: Maybe<fs.Stats>) {\n  return s == null || (s.isFile() && s.size === 0)\n}\n\nexport function isDirectorySync(nativePath: Maybe<string>): boolean {\n  return statSync(nativePath)?.isDirectory() === true\n}\n\nexport function isReadableDirectorySync(nativePath: Maybe<string>): boolean {\n  const stat = statSync(nativePath)\n  return (\n    stat != null && stat.isDirectory() && access({ stat, r: true, x: true })\n  )\n}\n\nexport function isReadWriteableDirectorySync(\n  nativePath: Maybe<string>\n): boolean {\n  if (blank(nativePath)) return false\n  const stat = statSync(nativePath)\n  return (\n    stat != null &&\n    stat.isDirectory() &&\n    access({ stat, r: true, w: true, x: true })\n  )\n}\n\nexport function firstExistingDirectory(paths: Maybe<string>[]): Maybe<string> {\n  for (const ea of paths) {\n    if (notBlank(ea)) {\n      const d = resolve(ea)\n      if (isDirectorySync(d)) return d\n    }\n  }\n  return undefined\n}\n\nexport function posixPathExistsSync(posixPath: Maybe<string>) {\n  return blank(posixPath)\n    ? false\n    : nativePathExistsSync(posix2native(posixPath))\n}\n","import { Settings } from \"../settings/Settings\"\n\nexport function statTimeoutMs() {\n  return Settings.statTimeoutMs.valueOrDefault\n}\n","import { notBlank } from \"../../fe/Blank\"\nimport { Latch } from \"../../fe/Latch\"\n\nexport function onDataChunked(\n  r: NodeJS.ReadableStream,\n  sep: string | RegExp,\n  onData: (data: string) => any\n): Latch {\n  const c = new Chunker(sep, onData, true)\n  c.read(r)\n  return c.done\n}\n\n/**\n * Handles data streams that may come in with disjoint chunks (like `[\"hel\",\n * \"lo\\n\"]`)\n */\nexport class Chunker {\n  private incompleteChunk = \"\"\n  readonly done = new Latch()\n\n  constructor(\n    readonly sep: string | RegExp,\n    readonly onData: (data: string) => any,\n    readonly filterBlanks = true\n  ) {}\n\n  onChunk(chunk: string | Buffer) {\n    if (chunk == null) return\n    const s = this.incompleteChunk + chunk.toString()\n    const split = s.split(this.sep)\n    // If s is not terminated by a separator, the last element in the array will\n    // be non-blank. If the string ends in a separator, an empty string will be\n    // the last element of the array, and this \"clears out\" incompleteChunk (as\n    // we'd want), so both cases are handled appropriately here:\n    this.incompleteChunk = split.pop()!\n    split.forEach(ea => {\n      if (!this.filterBlanks || notBlank(ea)) {\n        this.onData(ea)\n      }\n    })\n  }\n\n  clear() {\n    this.onChunk(\"\")\n    if (notBlank(this.incompleteChunk)) this.onData(this.incompleteChunk)\n    this.incompleteChunk = \"\"\n  }\n\n  read(r: NodeJS.ReadableStream) {\n    r.on(\"data\", ea => this.onChunk(ea))\n    r.on(\"end\", () => {\n      this.clear()\n      void this.done.resolve()\n    })\n    return this\n  }\n}\n","import { WriteStream } from \"tty\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\n\nexport function streamEnded(s: Maybe<WriteStream>): boolean {\n  return (\n    s == null ||\n    !s.writable ||\n    s.destroyed ||\n    s.writableEnded ||\n    s.writableFinished\n  )\n}\n","import { ChildProcess } from \"child_process\"\nimport _n from \"net\"\nimport _s from \"stream\"\nimport { delay } from \"../../fe/Delay\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, MaybeNull } from \"../../fe/MaybeTypes\"\nimport { maybeCall } from \"../../fe/Object\"\nimport { NoOp } from \"../../fe/Thunk\"\nimport { Try } from \"../Object\"\nimport { ending } from \"../async/Endable\"\nimport { isIgnorableError } from \"../error/ErrorTypes\"\n\nexport class PassthroughStream extends _s.Duplex {\n  _write(chunk: any, encoding: BufferEncoding) {\n    this.push(chunk, encoding)\n  }\n}\n\n/**\n * Handles backpressure by optionally waiting for the drain event\n */\nexport async function writeAsync(\n  stream: _s.Writable,\n  data: string | Buffer\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    if (\n      false ===\n      stream.write(data, err => {\n        if (err) reject(err)\n      })\n    ) {\n      stream.once(\"drain\", resolve)\n    } else {\n      resolve()\n    }\n  })\n}\n\n// I don't want to just Pick<Writable, \"end\"> because I don't want to require\n// all the overloaded signatures as well.\nexport interface EndableStream {\n  end(chunk: any, cb?: () => void): void\n}\n\nexport async function endStream(\n  endable: MaybeNull<EndableStream>\n): Promise<void> {\n  if (endable == null) return\n  // Make sure we don't hang waiting for this stream:\n  Try(() => maybeCall(endable, \"unref\"))\n  if (ending()) {\n    // no need to wait for the end callback:\n    endable.end(null)\n  } else {\n    // Half-closes the socket (!!)\n    await new Promise<void>(resolve => endable.end(null, resolve))\n  }\n  await delay(50)\n\n  // Ensures that no more I/O activity happens on this socket\n  Try(() => maybeCall(endable, \"destroy\"))\n  return\n}\n\nexport interface ClosableStream {\n  close(callback: () => void): void\n}\n\nexport async function closeStream(\n  closable: Maybe<ClosableStream>\n): Promise<void> {\n  if (closable == null) return\n  Try(() => maybeCall(closable, \"unref\"))\n  if (ending()) {\n    closable.close(NoOp)\n  } else {\n    await new Promise<void>(resolve => closable.close(resolve))\n  }\n  // I don't think this is necessary (and caused errors with electron last year):\n  // await delay(50)\n  // Try(() => maybeCall(closable, \"destroy\"))\n  return\n}\n\nexport function onChildError(\n  cp: ChildProcess,\n  f: (src: \"cp\" | \"stdin\" | \"stdout\" | \"stderr\", err: Error) => void\n): void {\n  ;[\n    { name: \"cp\", ea: cp },\n    { name: \"stdin\", ea: cp.stdin },\n    { name: \"stdout\", ea: cp.stdout },\n    { name: \"stderr\", ea: cp.stderr }\n  ].forEach(({ name, ea }) =>\n    map(ea, ea2 =>\n      ea2.on(\"error\", err => {\n        if (isIgnorableError(err) === false) f(name as any, err)\n      })\n    )\n  )\n}\n\nexport function closeStreams(cp: ChildProcess) {\n  for (const ea of [cp?.stdin, cp?.stdout, cp?.stderr]) {\n    try {\n      ea?.destroy()\n    } catch {\n      //\n    }\n  }\n}\n\nexport type Pipeline = [\n  NodeJS.ReadableStream,\n  ...(NodeJS.ReadWriteStream | NodeJS.WritableStream)[]\n]\n\nexport function remoteDesc(s: _n.Socket): string {\n  return s.destroyed\n    ? \"destroyed\"\n    : `${s.remoteFamily}:${s.remoteAddress}:${s.remotePort}`\n}\n\nexport class ByteCounter extends _s.Transform {\n  private bytes = 0\n  constructor(readonly onProgress: (bytes: number) => any) {\n    super({\n      transform: (\n        chunk: any,\n        _encoding: BufferEncoding,\n        callback: _s.TransformCallback\n      ) => {\n        this.onProgress((this.bytes += chunk.length))\n        callback(chunk)\n      }\n    })\n  }\n}\n","import fse from \"fs-extra\"\nimport { utimes } from \"utimes\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { isDate } from \"../../fe/Date\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { compactValues, keys } from \"../../fe/Object\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { Settings } from \"../settings/Settings\"\nimport { mkdirp_ } from \"./Path\"\nimport {\n  SimpleFile,\n  SimpleFileOrString,\n  dirname,\n  toNativePath_\n} from \"./SimpleFile\"\nimport { statMaybe } from \"./Stat\"\nimport { statTimeoutMs } from \"./StatTimeout\"\n\n// const logger = lazy(() => mkLogger(\"fs.Touch\"))\n\nfunction toMs(d: number | Date | undefined): Maybe<number> {\n  return d == null\n    ? undefined\n    : isDate(d)\n    ? d.getTime()\n    : gt0(d)\n    ? d\n    : undefined\n}\n\nexport async function touch_(args: {\n  file: SimpleFileOrString\n  ensureFile?: boolean\n  atimeMs?: number | Date\n  mtimeMs?: number | Date\n  btimeMs?: number | Date\n  reference?: SimpleFile\n}): Promise<void> {\n  const ensureFile = args.ensureFile ?? true\n  if (args.file == null || blank(args.file))\n    throw new Error(\"can't touch blank path\")\n  const nativePath = toNativePath_(args.file)\n  if (ensureFile) {\n    await mkdirp_(dirname(args.file))\n  }\n  const rStat = lazy(() => statMaybe(args.reference?.nativePath))\n  const mtimeMs = Math.round(\n    toMs(args.mtimeMs) ?? (await rStat())?.mtimeMs ?? Date.now()\n  )\n  const atimeMs = Math.round(\n    toMs(args.atimeMs) ?? (await rStat())?.atimeMs ?? mtimeMs\n  )\n  const btimeMs = map(toMs(args.btimeMs) ?? (await rStat())?.birthtimeMs, ea =>\n    Math.round(ea)\n  )\n  // logger().debug(\"touch_(): utime()\", { args, mtimeMs, atimeMs, btimeMs })\n  try {\n    await thenOrTimeoutError(\n      btimeMs != null && Settings.retainFileBirthtimes.valueOrDefault\n        ? utimes(\n            nativePath,\n            compactValues({\n              atime: atimeMs,\n              mtime: mtimeMs,\n              btime: btimeMs\n            })\n          )\n        : fse.utimes(nativePath, new Date(atimeMs), new Date(mtimeMs)),\n      statTimeoutMs()\n    )\n  } catch (error: any) {\n    if (ensureFile && error.code === \"ENOENT\") {\n      // fsp.ensureFile() has issues: the file may not exist when the returned\n      // promise is resolved.\n      await thenOrTimeoutError(fse.ensureFile(nativePath), statTimeoutMs())\n      if (keys(args).length > 1) {\n        // args has more than just \"file\":\n        await touch_({ ...args, ensureFile: false })\n      }\n    } else {\n      throw error\n    }\n  }\n}\n","import { Writable, WritableOptions } from \"stream\"\nimport { Deferred } from \"../async/Deferred\"\n\n/**\n * Concats the result of a stream's data into a `Buffer`\n */\nexport class WritableToBuffer extends Writable {\n  private readonly deferred = new Deferred<Buffer>(\"WritableToBuffer\")\n  private readonly _buf: Buffer[] = []\n\n  constructor(opts?: WritableOptions) {\n    super(opts)\n    this.on(\"finish\", () => {\n      void this.deferred.resolve(this.data)\n    })\n    this.on(\"error\", err => {\n      void this.deferred.reject(err)\n    })\n  }\n\n  get data(): Buffer {\n    return Buffer.concat(this._buf)\n  }\n\n  /**\n   * Final result. Will only be resolved on finish.\n   */\n  get buffer(): Promise<Buffer> {\n    return this.deferred.promise\n  }\n\n  _write(chunk: any, encoding: BufferEncoding, next: () => void) {\n    this._buf.push(\n      Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding)\n    )\n    next()\n  }\n}\n","import _fse from \"fs-extra\"\nimport _path from \"path\"\nimport { ensureSuffix, wrap } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { ee } from \"../event/EventEmitter\"\nimport { crlf } from \"./CRLF\"\nimport { mkdirpSync_, mkdirp_ } from \"./Path\"\n\nexport async function writeFile_(nativePath: string, data: string | Buffer) {\n  const dir = _path.dirname(nativePath)\n  await mkdirp_(dir)\n  await _fse.writeFile(nativePath, data)\n  ee().emit(\"fileChanged\", dir) // because the parent directory has a new child!\n}\n\nexport async function writeText_(nativePath: string, ...txt: string[]) {\n  return writeFile_(\n    nativePath,\n    crlf(ensureSuffix(txt.map(toS).join(\"\\n\"), \"\\n\"))\n  )\n}\n\nexport async function writeTextfile_(nativePath: string, ...txt: string[]) {\n  const data = crlf(...wrap(txt))\n  await writeFile_(nativePath, data)\n}\n\nexport function writeFileSync_(nativePath: string, data: string | Buffer) {\n  const dir = _path.dirname(nativePath)\n  mkdirpSync_(dir)\n  _fse.writeFileSync(nativePath, data)\n  ee().emit(\"fileChanged\", dir) // because the parent directory has a new child!\n}\n\nexport function writeTextSync_(nativePath: string, ...txt: string[]) {\n  return writeFileSync_(\n    nativePath,\n    crlf(ensureSuffix(txt.map(toS).join(\"\\n\"), \"\\n\"))\n  )\n}\n","import _fs from \"fs\"\nimport { parse } from \"path\"\nimport _s from \"stream\"\nimport { pipeline } from \"stream/promises\"\nimport { createBrotliDecompress, createGunzip, createGzip } from \"zlib\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { parseJSON } from \"../JSON\"\nimport { mkLogger } from \"../Logger\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { mkdirp_ } from \"../fs/Path\"\nimport { LogLevel, LogLevels } from \"../log/LogLevel\"\nimport { ReadableBuffer } from \"./ReadableBuffer\"\nimport { Pipeline } from \"./Streams\"\nimport { WritableToBuffer } from \"./WritableToBuffer\"\n\nconst logger = lazy(() => mkLogger(\"fs.zcat\"))\n\n/**\n * @throw if the file is missing or unreadable\n */\nexport async function zcat_(\n  nativePath: string,\n  options?: { start?: number; end?: number }\n): Promise<string> {\n  return (await zCopyToBuffer_(nativePath, options)).toString()\n}\n\nexport async function zcat(\n  nativePath: string,\n  options?: { start?: number; end?: number }\n): PromiseMaybe<string> {\n  try {\n    return zcat_(nativePath, options)\n  } catch (err) {\n    logger().warn(\"zcat failed to read \" + nativePath, err)\n    return undefined\n  }\n}\n\nexport async function zpipe_(\n  nativePath: string,\n  outputStream: _s.Writable,\n  options?: { start?: number; end?: number }\n) {\n  const causes: Error[] = []\n  const p: Pipeline = [\n    _fs\n      .createReadStream(nativePath, { autoClose: true, ...options })\n      .on(\"error\", err => causes.push(err))\n  ]\n  if (nativePath.toLowerCase().endsWith(\".gz\")) {\n    p.push(createGunzip().on(\"error\", err => causes.push(err)))\n  } else if (nativePath.toLowerCase().endsWith(\".br\")) {\n    p.push(createBrotliDecompress().on(\"error\", err => causes.push(err)))\n  }\n  p.push(outputStream)\n  await pipeline(p)\n  if (isNotEmpty(causes)) {\n    throw new WrappedError(\"zPipe(\" + nativePath + \") failed\", {\n      causes,\n      path: nativePath\n    })\n  }\n}\n\n/**\n * `readFile`, but on-the-fly decompression for .gz and .br\n * @throws on error\n */\nexport async function zCopyToBuffer_(\n  nativePath: string,\n  options?: { start?: number; end?: number }\n): Promise<Buffer> {\n  const w = new WritableToBuffer()\n  await zpipe_(nativePath, w, options)\n  return await w.buffer\n}\n\nexport async function readJsonGz_<T = any>(nativePath: string) {\n  return parseJSON(await zCopyToBuffer_(nativePath)) as Maybe<T>\n}\n\nexport async function readJsonGz<T = any>(\n  nativePath: string,\n  level: LogLevel = LogLevels.warn\n) {\n  try {\n    return await readJsonGz_<T>(nativePath)\n  } catch (err) {\n    logger().log(level, \"readJsonGz(\" + nativePath + \"): failed\", err)\n    return\n  }\n}\n\nexport async function outputJsonGz_<T = any>(nativePath: string, obj: T) {\n  const json = stringify(obj)\n  await mkdirp_(parse(nativePath).dir)\n  await pipeline(\n    new ReadableBuffer(json),\n    createGzip(),\n    _fs.createWriteStream(nativePath, { autoClose: true })\n  )\n}\n\nexport async function outputJsonGz<T = any>(\n  nativePath: string,\n  obj: T,\n  level: LogLevel = LogLevels.warn\n) {\n  try {\n    await outputJsonGz_(nativePath, obj)\n  } catch (err) {\n    logger().log(level, \"outputJsonGz(\" + nativePath + \"): failed\", err)\n  }\n}\n","import { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\n\nexport const HealthCheckIds = strEnum(\n  \"library-db\",\n  \"library-directories\",\n  \"library-free-space\",\n  \"library-nothing-to-sync\",\n  \"media-directories\",\n  \"nodejs-version\",\n  \"proc-memory-use\",\n  \"proc-not-in-dmg\",\n  \"proc-not-superuser\",\n  \"settings-env\",\n  \"settings-library\",\n  \"settings-system\",\n  \"sync-paused\",\n  \"system-load\",\n  \"system-volumes\",\n  \"tools-exiftool\",\n  \"tools-heif\",\n  \"tools-powershell\",\n  \"tools-sqlite-version\",\n  \"tools-video\",\n  \"volume-uuids\"\n)\nexport type HealthCheckId =\n  | StrEnumKeys<typeof HealthCheckIds>\n  | \"summary\"\n  | \"test-health-check\"\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const CropStrategies = strEnum(\"center\", \"entropy\", \"attention\")\nexport type CropStrategy = StrEnumKeys<typeof CropStrategies>\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const SharpFailOns = strEnum(\"none\", \"truncated\", \"error\", \"warning\")\nexport type SharpFailOn = StrEnumKeys<typeof SharpFailOns>\n","import { lazy } from \"../../core/Lazy\"\nimport { processName } from \"../ServiceNames\"\nimport { logFilter } from \"./LogFilter\"\nimport { SimpleLogger } from \"./Logger\"\nimport { LogLevel } from \"./LogLevel\"\nimport { pushLogEntries } from \"./LogTailEntries\"\n\n/**\n * Works in concert with LogTail so both local and remote log messages are\n * emitted in chronological order.\n */\nexport class ConsoleLogger implements SimpleLogger {\n  static readonly instance = lazy(() => new ConsoleLogger())\n\n  log(level: LogLevel, context: string, msg: string, meta?: any) {\n    if (this.enabled(level, context)) {\n      pushLogEntries({\n        ts: Date.now(),\n        l: level,\n        from: processName(),\n        ctx: context,\n        msg,\n        meta\n      })\n    }\n  }\n\n  enabled(level: LogLevel, context: string): boolean {\n    return logFilter().enabled(level, context)\n  }\n\n  async flush() {\n    // no op\n  }\n\n  end() {\n    // no op\n  }\n\n  toJSON() {\n    // if we add an object that contains a logger to LogEntry.meta...\n    return {\n      _ctor: \"ConsoleLogger\"\n    }\n  }\n}\n","import { Logger } from \"batch-cluster\"\nimport { toNotBlank } from \"../../fe/Blank\"\nimport { shortStack } from \"../../fe/Error\"\nimport { Later } from \"../../fe/Later\"\nimport { map } from \"../../fe/Maybe\"\nimport { Obj } from \"../../fe/Object\"\nimport { Thunk } from \"../../fe/Thunk\"\nimport { isFunction } from \"../../fe/isFunction\"\nimport { rootLoggers } from \"../Logger\"\nimport { mapGt0 } from \"../Number\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { AbortError } from \"../async/AbortError\"\nimport { NewWrappedError, toWrappedError } from \"../error/WrappedError\"\nimport { LogLevel, LogLevels, msTolevel } from \"./LogLevel\"\nimport { SimpleLogger } from \"./Logger\"\n\n/**\n * Delegates to a SimpleLogger, applying filters, and exposing level-specific\n * log methods.\n */\nexport class ContextualLogger implements SimpleLogger, Logger {\n  readonly context: string\n  constructor(\n    context: string,\n    readonly loggers = rootLoggers\n  ) {\n    // shite goes real south if context is blank, so let's make sure it's not:\n    this.context =\n      toNotBlank(context) ??\n      // We have to skip over lazy(), mkLogger(), and this constructor:\n      shortStack().find(ea => !ea.includes(\"Logger\")) ??\n      \"\"\n  }\n\n  toLogJSON() {\n    return \"CtxLogger(\" + this.context + \")\"\n  }\n\n  /**\n   * @return `this.context + s`\n   */\n  addContext(s: string) {\n    return new ContextualLogger(this.context + s, this.loggers)\n  }\n\n  addParameterContext(param: string) {\n    return new ContextualLogger(this.context + \"(\" + param + \")\", this.loggers)\n  }\n\n  throwIfAborted(signal?: AbortSignal) {\n    if (signal?.aborted === true) {\n      const reason = signal.reason ?? \"(no reason given)\"\n      this.warn(\"process aborted: \" + (signal.reason ?? \"(no reason given)\"))\n      throw new AbortError(reason)\n    }\n  }\n\n  throw(\n    e: string | Error,\n    meta?: (NewWrappedError & { error: Error }) | Obj\n  ): never {\n    const result = toWrappedError(e, { ...meta, message: this.context })\n    this.log(\n      result.ignorable === true ? \"warn\" : \"error\",\n      \".throw() \" + result.message,\n      { stack: result.stack, ...meta }\n    )\n    throw result\n  }\n\n  tap<T>(o: { level?: LogLevel; msg: string; result: T; meta?: any }): T {\n    const level =\n      o.level ?? mapGt0(o.meta?.elapsedMs, msTolevel) ?? LogLevels.debug\n    this.log(level, o.msg, { result: o.result, ...o.meta })\n    return o.result\n  }\n\n  tapThunk<T>(o: {\n    level?: LogLevel\n    msg: string\n    result: Thunk<T>\n    meta?: any\n  }): T {\n    const start = Date.now()\n    let slowTimer\n    try {\n      slowTimer = setTimeout(\n        () => this.log(\"warn\", \"slow: \" + o.msg),\n        ShortCommandTimeoutMs\n      )\n      const result = o.result()\n      const elapsedMs = Date.now() - start\n      return this.tap({\n        level: o.level,\n        msg: o.msg,\n        result,\n        meta: { ...o.meta, elapsedMs }\n      })\n    } catch (error) {\n      this.log(\"error\", \"error: \" + o.msg, { error, ...o.meta })\n      throw error\n    } finally {\n      map(slowTimer, clearTimeout)\n    }\n  }\n\n  async tapAsync<T>(o: {\n    level?: LogLevel\n    errorLevel?: LogLevel\n    msg: string\n    errorMsg?: string\n    result: Later<T> | Promise<T>\n    meta?: any\n  }): Promise<T> {\n    const level =\n      o.level ?? mapGt0(o.meta?.elapsedMs, msTolevel) ?? LogLevels.debug\n    try {\n      const result = await (isFunction(o.result) ? o.result() : o.result)\n      this.log(level, o.msg, { result, ...o.meta })\n      return result\n    } catch (error) {\n      this.log(o.errorLevel ?? \"warn\", o.errorMsg ?? o.msg + \" failed\", {\n        error,\n        ...o.meta\n      })\n      throw error\n    }\n  }\n\n  /**\n   * Is _any_ logger enabled?\n   */\n  enabled(level: LogLevel, context?: string): boolean {\n    // PERF: avoid closure allocation:\n    for (const ea of this.loggers()) {\n      if (ea.enabled(level, context ?? this.context)) return true\n    }\n    return false\n  }\n\n  log(level: LogLevel, message: string, meta?: any): void {\n    for (const ea of this.loggers()) {\n      ea.log(level, this.context, message, meta)\n    }\n  }\n\n  elapsed(message: string, elapsedMs: number, meta?: any) {\n    this.log(msTolevel(elapsedMs), message, { elapsedMs, ...meta })\n  }\n\n  async flush() {\n    for (const ea of this.loggers()) {\n      await ea.flush()\n    }\n  }\n\n  async end() {\n    for (const ea of this.loggers()) {\n      await ea.end()\n    }\n  }\n\n  // Using fat arrows force the methods to stay bound to this instance:\n  readonly error = (msg: string, args?: any) => {\n    this.log(\"error\", msg, args)\n  }\n\n  readonly warn = (msg: string, args?: any) => {\n    this.log(\"warn\", msg, args)\n  }\n\n  readonly info = (msg: string, args?: any) => {\n    this.log(\"info\", msg, args)\n  }\n\n  readonly debug = (msg: string, args?: any) => {\n    this.log(\"debug\", msg, args)\n  }\n\n  readonly trace = (msg: string, args?: any) => {\n    this.log(\"trace\", msg, args)\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { LogFormatter } from \"./LogFormatter\"\nimport { PlaintextLogFormatter } from \"./PlaintextLogFormatter\"\n\nexport const DefaultLogFormatter = lazy<LogFormatter>(\n  () => new PlaintextLogFormatter()\n)\n","export const DefaultLogFlushMs = 250\n","import { sortByInPlace } from \"../../fe/ArraySort\"\nimport { isNumber } from \"../../fe/Number\"\nimport { isString } from \"../../fe/String\"\nimport { LogLevel, LogLevels } from \"./LogLevel\"\n\n/**\n * field names are abbreviated as they are encoded in JSON on disk.\n */\nexport interface LogEntry {\n  /**\n   * timestamp\n   */\n  ts: number\n  /**\n   * log level\n   */\n  l: LogLevel\n  /**\n   * context\n   */\n  ctx: string\n  /** message */\n  msg: string\n  meta?: any\n  from?: string\n}\n\nexport function isLogEntry(ea: any): ea is LogEntry {\n  return (\n    ea != null &&\n    isNumber(ea?.ts) &&\n    isString(ea?.msg) &&\n    LogLevels.includes(ea.l)\n  )\n}\n\nexport function logEntrySorter(ea: LogEntry) {\n  return ea?.ts\n}\n\nexport function sortLogEntriesInPlace(arr: LogEntry[]) {\n  sortByInPlace(arr, ea => ea.ts)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { levelIndex, LogLevel, LogLevels } from \"./LogLevel\"\n\nexport interface LogFilter {\n  highlight(context: string): boolean\n\n  /**\n   * @return true iff the given level and context are not configured to be\n   * squelched/omitted from downstream log writers.\n   */\n  enabled(level: LogLevel, context?: string): boolean\n  /**\n   * The level index that is enabled by default (ignoring context-specific overrides)\n   */\n  readonly defaultLevelIndex: number\n  silent: boolean\n}\n\nexport class SimpleLogFilter implements LogFilter {\n  readonly defaultLevelIndex\n  constructor(readonly minLogLevel: LogLevel) {\n    this.defaultLevelIndex = levelIndex(minLogLevel)\n  }\n  highlight() {\n    return false\n  }\n  enabled(level: LogLevel) {\n    // fatal < error < info < debug < trace\n    return levelIndex(level) <= this.defaultLevelIndex\n  }\n  silent = false\n}\n\nexport const LogLevelRe = /^(?:(.+?):)?(fatal|error|warn|info|debug|trace)$/i\n\nexport interface LogLevelContext {\n  prefix: string\n  levelIndex: number\n}\n\n// Replaced with a LogFilterImpl at log setup time (to avoid a dependency loop)\nexport const logFilter = lazy<LogFilter>(\n  () => new SimpleLogFilter(LogLevels.warn)\n)\n\n// set to watch Settings.logLevel by SetupLogger:\nexport const defaultLogLevel = lazy(\n  () => LogLevels.values[logFilter().defaultLevelIndex]\n)\n\nexport function isDefaultLogLevelAtLeast(logLevel: LogLevel) {\n  return logFilter().defaultLevelIndex >= levelIndex(logLevel)\n}\n\nexport function silently<T>(f: () => T): T {\n  try {\n    logFilter().silent = true\n    return f()\n  } finally {\n    logFilter().silent = false\n  }\n}\n\nexport async function silentlyAsync<T>(f: () => PromiseLike<T>): Promise<T> {\n  try {\n    logFilter().silent = true\n    return await f()\n  } finally {\n    logFilter().silent = false\n  }\n}\n\n/**\n * Apply `f()` if the given logLevel is enabled.\n */\nexport function ifLog<T>(logLevel: LogLevel, f: () => T): Maybe<T> {\n  return logFilter().enabled(logLevel) ? f() : undefined\n}\n\nexport function isLogged(logLevel: LogLevel, context?: string) {\n  return logFilter().enabled(logLevel, context)\n}\n","import { secondMs } from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gte } from \"../../fe/Number\"\nimport { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\n/**\n * These are driven by the `console` API\n */\nexport const LogLevels = strEnum(\n  \"fatal\",\n  \"error\",\n  \"warn\",\n  \"info\",\n  \"debug\",\n  \"trace\"\n)\nexport type LogLevel = StrEnumKeys<typeof LogLevels>\n\nconst TraceLevelIndex = LogLevels.indexOf(\"trace\")!\n\nexport function levelIndex(logLevel: string): number {\n  return (\n    LogLevels.indexOf(logLevel) ??\n    LogLevels.indexOf(logLevel.trim().toLowerCase()) ??\n    TraceLevelIndex\n  )\n}\n\nexport function levelGte(lhs: LogLevel | string, rhs: LogLevel | string) {\n  return gte(LogLevels.indexOf(lhs), LogLevels.indexOf(rhs))\n}\n\n// https://en.wikipedia.org/wiki/Syslog#Severity_level\nconst LogLevel2SyslogLevel = new Map<LogLevel, number>([\n  [LogLevels.fatal, 1],\n  [LogLevels.error, 3],\n  [LogLevels.warn, 4],\n  [LogLevels.info, 6],\n  [LogLevels.debug, 7]\n])\n\nexport function level2syslog(logLevel: string): Maybe<number> {\n  return LogLevel2SyslogLevel.get(logLevel as any)\n}\n\nexport function msTolevel(\n  elapsedMs: number,\n  errorMs: number = 7 * secondMs\n): LogLevel {\n  return elapsedMs >= errorMs\n    ? \"error\"\n    : elapsedMs >= errorMs / 2\n    ? \"warn\"\n    : elapsedMs >= errorMs / 4\n    ? \"info\"\n    : \"debug\"\n}\n","import { SortedSet } from \"../SortedSet\"\nimport { stdoutEnded } from \"../StdoutEnded\"\nimport { DefaultLogFormatter } from \"./DefaultLogFormatter\"\nimport { DefaultLogFlushMs } from \"./LogCommon\"\nimport { LogEntry, logEntrySorter } from \"./LogEntry\"\n\n// Separated from LogTail to break dependency loops\n\nlet _logTailEnabled = false\n\nexport function logTailEnabled() {\n  return _logTailEnabled\n}\n\nexport function setLogTailEnabled(b: boolean) {\n  _logTailEnabled = b\n}\n\nexport const logEntries = new SortedSet<LogEntry>(logEntrySorter)\n\n// WTH, AMIRITE? ConsoleLogger calls this method. If we're not tailing logs,\n// we don't need to order our log entries correctly, and can just console.log\n// immediately.\n\nexport function pushLogEntries(...arr: LogEntry[]) {\n  // PERF: for loop instead of .forEach\n  for (const ea of arr) {\n    // don't use Settings.logTail:\n    if (_logTailEnabled) {\n      logEntries.add(ea)\n    } else {\n      // if stdout is closed, don't try to write to it!\n      if (!stdoutEnded()) {\n        console.log(DefaultLogFormatter().formatLogEntry(ea))\n      }\n    }\n  }\n}\n\n/**\n * @param ttl if zero, pop everything (we're shutting down)\n */\nexport function popExpiredLogEntries(ttl = DefaultLogFlushMs * 2) {\n  return logEntries.shiftLte(Date.now() - ttl)\n}\n","import { inspect, InspectOptions } from \"util\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { map } from \"../../fe/Maybe\"\nimport { fromEntries } from \"../../fe/Object\"\nimport { toS } from \"../../fe/toS\"\nimport { processName } from \"../ServiceNames\"\nimport { rightPad, stripAnsiEsc } from \"../String\"\nimport { LogEntry } from \"./LogEntry\"\nimport { LogFormatter } from \"./LogFormatter\"\nimport { LogLevel, LogLevels } from \"./LogLevel\"\n\nexport class PlaintextLogFormatter implements LogFormatter {\n  constructor(\n    readonly inspectOptions: InspectOptions = {\n      colors: false,\n      depth: 4,\n      compact: true,\n      customInspect: true\n    }\n  ) {}\n\n  readonly paddedLogLevels = fromEntries(\n    LogLevels.values.map(ea => [ea, rightPad(ea, 5, \" \")])\n  )\n\n  formatLogEntry(le: LogEntry): string {\n    return compactBlanks([\n      new Date(le.ts).toISOString(),\n      le.from ?? processName(),\n      this.paddedLogLevels[le.l],\n      stripAnsiEsc(le.ctx),\n      stripAnsiEsc(le.msg),\n      map(le.meta, ea => inspect(ea, this.inspectOptions))\n    ])\n      .map(ea => toS(ea))\n      .join(\" \")\n  }\n\n  format(\n    level: LogLevel,\n    context: string,\n    message: string,\n    meta?: any\n  ): string {\n    return this.formatLogEntry({\n      ts: Date.now(),\n      l: level,\n      from: processName(),\n      ctx: context,\n      msg: message,\n      meta\n    })\n  }\n}\n","import { inspect } from \"util\"\nimport { mapNotEmpty } from \"../../fe/Array\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isNumber, sigFigs } from \"../../fe/Number\"\nimport { tap } from \"../../fe/Object\"\nimport { toA } from \"../../fe/toA\"\nimport { zip } from \"../Array\"\nimport { BoundedList } from \"../BoundedList\"\nimport { CountingSet } from \"../CountingSet\"\nimport { mapGte0f } from \"../Number\"\nimport {\n  MaybeNumericList,\n  avg,\n  max,\n  min,\n  slope,\n  stdDev,\n  variance,\n  weightedAvg\n} from \"./Vector\"\n\nexport interface AverageStats {\n  k: number\n  mean?: number\n  mode?: number\n  sd?: number\n  max?: number\n  min?: number\n  sum?: number\n}\n\nexport function averageStats(vec: number[]) {\n  return new Average().pushAll(vec).stats()\n}\n\nexport class Average {\n  static merge(a: Average, b: Average): Average {\n    if (a.n === 0 && b.n === 0) {\n      return new Average(Math.max(a.maxSamples, b.maxSamples))\n    } else if (a.n === 0) {\n      return b.clone()\n    } else if (b.n === 0) {\n      return a.clone()\n    } else if (a.n <= a.maxSamples) {\n      const r = b.clone()\n      r.pushAll(a.samples)\n      return r\n    } else if (b.n <= b.maxSamples) {\n      const r = a.clone()\n      r.pushAll(b.samples)\n      return r\n    } else {\n      const r = new Average(Math.max(a.maxSamples, b.maxSamples))\n      r._n = a.n + b.n\n      r._min = Math.min(a._min!, b._min!)\n      r._max = Math.max(a._max!, b._max!)\n      r._m = (a._m! * a.n) / r.n + (b._m! * b.n) / r.n\n      r._s = (a._s! * a.n) / r.n + (b._s! * b.n) / r.n\n      const samples = flatten(zip(a.samples, b.samples))\n      r._samples.push(...samples)\n      r._weightedTotalAvg = weightedAvg([r._m, ...samples])\n      return r\n    }\n  }\n\n  protected _n: number\n  protected _min?: number\n  protected _max?: number\n  protected _m?: number\n  protected _s?: number\n  protected _weightedTotalAvg?: number\n  protected readonly _samples: BoundedList<number>\n\n  constructor(readonly maxSamples: number = 20) {\n    this._n = 0\n    this._samples = new BoundedList(maxSamples)\n  }\n\n  [inspect.custom]() {\n    return this.stats()\n  }\n\n  toJSON() {\n    return {\n      _ctor: \"Average\",\n      n: this._n,\n      _m: this._m,\n      _s: this._s,\n      min: this._min,\n      max: this._max,\n      samples: this._samples.toA()\n    }\n  }\n\n  static fromJSON(obj: ReturnType<Average[\"toJSON\"]>) {\n    return new Average().with(obj)\n  }\n\n  with(obj: ReturnType<Average[\"toJSON\"]>) {\n    this._n = obj.n\n    this._min = obj.min\n    this._max = obj.max\n    this._m = obj._m\n    this._s = obj._s\n    this._samples.push(...toA(obj.samples))\n  }\n\n  merge(b: Maybe<Average>) {\n    if (b == null || b.n === 0) return this\n    if (this.n === 0) return this.with(b.toJSON())\n    this._min = min([this._min, b.min])\n    this._max = max([this._max, b.max])\n    const n = this.n + b.n\n    this._m = (this._m! * this.n) / n + (b._m! * b.n) / n\n    this._s = (this._s! * this.n) / n + (b._s! * b.n) / n\n    this._n += b._n\n    this._samples.push(...toA(b.samples))\n    return this\n  }\n\n  push(x: number): number {\n    if (!isFinite(x)) throw new Error(\"Average.push(\" + x + \"): not a number\")\n    this._n++\n    this._samples.push(x)\n    this._min = this._min == null ? x : Math.min(x, this._min)\n    this._max = this._max == null ? x : Math.max(x, this._max)\n\n    // https://math.stackexchange.com/a/116344\n    // https://www.johndcook.com/blog/standard_deviation/\n    if (\n      this._n === 1 ||\n      this._m == null ||\n      this._s == null ||\n      this._weightedTotalAvg == null\n    ) {\n      this._m = x\n      this._s = 0\n      this._weightedTotalAvg = x\n    } else {\n      const priorM = this._m\n      this._m += (x - priorM) / this._n\n      // CAUTION: this isn't correct variation: it's a streaming estimation.\n      this._s += ((x - this._m) * (x - this._m) - this._s!) / this._n\n      this._weightedTotalAvg = (this._weightedTotalAvg + x) / 2\n    }\n    return x\n  }\n\n  clone(): Average {\n    return tap(new Average(this.maxSamples), ea => {\n      ea._n = this._n\n      ea._m = this._m\n      ea._s = this._s\n      ea._min = this._min\n      ea._max = this._max\n      ea._weightedTotalAvg = this._weightedTotalAvg\n      ea._samples.push(...this._samples)\n    })\n  }\n\n  pushAll(arr: MaybeNumericList): this {\n    if (arr != null) {\n      for (const ea of arr) {\n        if (isNumber(ea)) this.push(ea)\n      }\n    }\n    return this\n  }\n\n  stats(sigfigs = 2): AverageStats {\n    const sf = (i?: number) =>\n      map(i, (ea: number) => (ea > 100 ? Math.round(ea) : sigFigs(ea, sigfigs)))\n    const o: AverageStats = {} as any\n    o.k = sf(this.n)!\n    if (!this.empty) {\n      o.mean = sf(this.avg)\n      o.sum = sf(this.sum)\n      // o.mode = sf(this.sampleMode)\n      o.sd = sf(this.stdDev)\n      o.max = sf(this.max)\n      o.min = sf(this.min)\n    }\n    return o\n  }\n\n  get empty(): boolean {\n    return this._n === 0\n  }\n\n  /**\n   * @return the total number of samples provided to `push()`\n   */\n  get n(): number {\n    return this._n\n  }\n\n  get avg(): Maybe<number> {\n    return this.empty ? undefined : sigFigs(this._m!, 4)\n  }\n\n  get sum(): number {\n    return this._n > 0 ? this._m! * this._n : 0\n  }\n\n  get max(): Maybe<number> {\n    return this._max\n  }\n\n  get min(): Maybe<number> {\n    return this._min\n  }\n\n  get last(): Maybe<number> {\n    return this._samples.last\n  }\n\n  #p(sigmasFromMean: number) {\n    return mapGte0f(this.avg, mu =>\n      mapGte0f(this.stdDev, sigma => sigFigs(mu + sigma * sigmasFromMean, 4))\n    )\n  }\n\n  // https://www.desmos.com/calculator/s2ybihaqjup\n\n  /**\n   * @return mean - 1 SD\n   */\n  get p16(): Maybe<number> {\n    return this.#p(-1)\n  }\n\n  get p29(): Maybe<number> {\n    return this.#p(-0.5)\n  }\n\n  get p38(): Maybe<number> {\n    return this.#p(-0.25)\n  }\n\n  /**\n   * @return mean + 1 SD\n   * @see https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule\n   */\n  get p84(): Maybe<number> {\n    return this.#p(1)\n  }\n\n  /**\n   * 97.5% = 50% + (95% / 2)\n   * @return mean + 1 SD\n   * @see https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule\n   */\n  get p98(): Maybe<number> {\n    return this.#p(2)\n  }\n\n  /**\n   * 99.86% = 50% + (99.73% / 2)\n   * @return mean + 1 SD\n   * @see https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule\n   */\n  get p99(): Maybe<number> {\n    return this.#p(3)\n  }\n\n  /**\n   * @return streaming estimation of variance\n   */\n  get variance(): Maybe<number> {\n    return this._s\n  }\n\n  /**\n   * @return streaming estimation of stdev\n   */\n  get stdDev(): Maybe<number> {\n    const v = this.variance\n    return v == null ? undefined : Math.sqrt(v)\n  }\n\n  get sampleMode(): Maybe<number> {\n    return this.sampleModes(1)?.[0]\n  }\n\n  sampleModes(n: number): Maybe<number[]> {\n    if (this.empty) return\n    const c = new CountingSet<number>()\n    this._samples.forEach(ea => c.incr(ea))\n    return c.topKeys(n)\n  }\n\n  get sampleVariance(): Maybe<number> {\n    return mapNotEmpty(this._samples, variance)\n  }\n\n  get sampleStdDev(): Maybe<number> {\n    return mapNotEmpty(this._samples, stdDev)\n  }\n\n  get sampleAvg(): Maybe<number> {\n    return mapNotEmpty(this._samples, avg)\n  }\n\n  get sampleSlope(): number {\n    return orElse(mapNotEmpty(this._samples, slope), 0)\n  }\n\n  get samples(): number[] {\n    return [...this._samples]\n  }\n\n  /**\n   * weighted average of the last `sampleCount` values\n   */\n  get weightedSampleAvg(): Maybe<number> {\n    return map(weightedAvg(this._samples), ea => sigFigs(ea, 4))\n  }\n\n  /**\n   * weighted average of all values\n   */\n  get weightedTotalAvg(): Maybe<number> {\n    return this._weightedTotalAvg\n  }\n\n  clear(): void {\n    this._n = 0\n    this._m = undefined\n    this._s = undefined\n    this._weightedTotalAvg = 0\n    this._samples.length = 0\n  }\n}\n","import { sum } from \"../../fe/Array\"\nimport { map2 } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { absdiff, clamp, times, toInt } from \"../../fe/Number\"\nimport { randomInt } from \"../../fe/Random\"\nimport { zip } from \"../Array\"\nimport { BitZipDimension } from \"./BitZipDimension\"\nimport { avg } from \"./Vector\"\n\nexport interface Dimension {\n  min: number\n  max: number\n}\nexport interface ValuedDimension extends Dimension {\n  value: number\n}\n\nexport interface BitMixArgs {\n  dims: ValuedDimension[]\n  bitDepth: number\n}\n\nexport function concatBits(arr: number[], bitsPerValue: number): number {\n  const max = Math.pow(2, bitsPerValue)\n  return arr.reduce(\n    (acc, i) => acc * max + clamp(0, max, toInt(i, { defaultValue: 0 })!),\n    0\n  )\n}\n\nexport function splitBits(n: number, bitsPerValue: number): number[] {\n  const max = Math.pow(2, bitsPerValue)\n  const result: number[] = []\n  while (n > 0) {\n    result.unshift(n % max)\n    n = Math.floor(n / max)\n  }\n  return result\n}\n\nexport function diffConcattedBits(\n  a: Maybe<number>,\n  b: Maybe<number>,\n  bitsPerValue: number\n): Maybe<number> {\n  return map2(a, b, (ea1, ea2) =>\n    sum(\n      zip(splitBits(ea1, bitsPerValue), splitBits(ea2, bitsPerValue)),\n      ([i, j]) => absdiff(i, j)!\n    )\n  )\n}\n\nexport class BitZip {\n  constructor(readonly dims: BitZipDimension[]) {}\n\n  clampValue(arr: number[]): number[] {\n    return arr.map((ea, i) => clamp(this.dims[i].min, this.dims[i].max, ea))\n  }\n\n  randomValue() {\n    return this.dims.map(dim => randomInt(dim.min, dim.max))\n  }\n\n  zipMin(bitDepth: number): number {\n    return this.zip(\n      this.dims.map(ea => ea.min),\n      bitDepth\n    )\n  }\n\n  zipMax(bitDepth: number): number {\n    return this.zip(\n      this.dims.map(ea => ea.max),\n      bitDepth\n    )\n  }\n\n  zip(value: number[], bitDepth: number) {\n    // We clone these because we change them as we process bits.\n    const min = this.dims.map(d => d.min)\n    const max = this.dims.map(d => d.max)\n    const clamped = this.clampValue(value)\n\n    let result = 0\n\n    for (let bit = 0; bit < bitDepth; bit++) {\n      // shift left, but this may be > 32 bits, so we can't use << operator,\n      // YAY JAVASCRIPT\n      result *= 2\n\n      const dimIndex = bit % min.length\n      const mid = (min[dimIndex] + max[dimIndex]) / 2\n      if (clamped[dimIndex] > mid) {\n        result += 1 // < no bit twiddling, we may be > 32 bits!\n        min[dimIndex] = mid\n      } else {\n        max[dimIndex] = mid\n      }\n    }\n    return result\n  }\n\n  unzip(n: number, bitDepth: number) {\n    const min = this.dims.map(d => d.min)\n    const max = this.dims.map(d => d.max)\n    for (let bit = 0; bit < bitDepth; bit++) {\n      const dIdx = bit % min.length\n      const mid = (min[dIdx] + max[dIdx]) / 2\n      if (isBitSet(n, bitDepth - bit - 1)) min[dIdx] = mid\n      else max[dIdx] = mid\n    }\n    return times(min.length, i => (min[i] + max[i]) / 2)\n  }\n}\n\nconst BitShiftMax = Math.pow(2, 32) - 1\n\nexport function isBitSet(n: number, bit: number, disableBitshifting?: boolean) {\n  if (disableBitshifting !== true && n < BitShiftMax && bit < 32) {\n    return ((n >> bit) & 1) === 1\n  } else {\n    return 1 === Math.floor(n / Math.pow(2, bit)) % 2\n  }\n}\n\nexport function bitZip(a: BitMixArgs): number {\n  a.dims.forEach(dim => (dim.value = clamp(dim.min, dim.max, dim.value)))\n\n  let result = 0\n\n  for (let bit = 0; bit < a.bitDepth; bit++) {\n    result *= 2 // < no bit twiddling, we may be > 32 bits!\n    const dIdx = bit % a.dims.length\n    const d = a.dims[dIdx]\n    const mid = avg([d.min, d.max])!\n    if (d.value > mid) {\n      result += 1 // < no bit twiddling, we may be > 32 bits!\n      d.min = mid\n    } else {\n      d.max = mid\n    }\n  }\n  return result\n}\n\nexport interface BitUnmixArgs {\n  dims: Dimension[]\n  bitDepth: number\n}\n\nexport function bitUnzip(n: number, a: BitUnmixArgs): Maybe<number[]> {\n  if (a.bitDepth > 52 || a.bitDepth < 0) return\n  const setBits = bitsSetBig(n)\n  for (let bit = 0; bit < a.bitDepth; bit++) {\n    const dIdx = bit % a.dims.length\n    const d = a.dims[dIdx]\n    const mid = avg([d.min, d.max])!\n    if (setBits.includes(a.bitDepth - bit - 1)) {\n      d.min = mid\n    } else {\n      d.max = mid\n    }\n  }\n  return a.dims.map(d => avg([d.min, d.max])!)\n}\n\n// Supports > 32 bit numbers\nexport function bitsSetBig(n: number): number[] {\n  return [...n.toString(2)]\n    .reverse()\n    .map((ea, idx) => (ea === \"1\" ? idx : -1))\n    .filter(ea => ea !== -1)\n}\n\n/**\n * Number of set bits in `x`\n * @see https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer#109117\n */\nexport function pop(x: number): number {\n  x = x - ((x >> 1) & 0x55555555)\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n  x = (x + (x >> 4)) & 0x0f0f0f0f\n  x = x + (x >> 8)\n  x = x + (x >> 16)\n  return x & 0x0000003f\n}\n\nexport function bits<T>(arr: T[], f: (t: T, index: number) => boolean): number {\n  return sum(arr, (ea, index) =>\n    f(ea, index) ? Math.pow(2, arr.length - index - 1) : 0\n  )\n}\n","import { sortBy } from \"../../fe/ArraySort\"\n\nexport function lerp(v0: number, v1: number, t = 0.5): number {\n  // See https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n  return (1 - t) * v0 + t * v1\n}\n\nexport interface Point {\n  x: number\n  y: number\n}\n\n/**\n * @return y for the given x, given the line defined p0 and p1\n */\nexport function lerp2d(x: number, ...arr: Point[]): number {\n  const nearest2 = sortBy(arr, ea => Math.abs(x - ea.x)).slice(0, 2)\n  const [p0, p1] = sortBy(nearest2, ea => ea.x)\n\n  const dx = p1.x - p0.x\n  const xdx = x - p0.x\n  const t = xdx / dx\n  return lerp(p0.y, p1.y, t)\n}\n\nexport function lerp2d_(x: number, p0: Point, p1: Point): number {\n  // https://en.wikipedia.org/wiki/Linear_interpolation\n  return (p0.y * (p1.x - x) + p1.y * (x - p0.x)) / (p1.x - p0.x)\n}\n","import { randomBytes } from \"crypto\"\nimport { blank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isFunction } from \"../../fe/isFunction\"\nimport { identity } from \"../Object\"\nimport { splitEvery } from \"../String\"\n\nconst zero: any = BigInt(0)\n\nexport function encodeDigits(base: number, i: number, minLength = 0): number[] {\n  if (!isFinite(i) || base <= 1) return []\n\n  const digits: number[] = []\n  if (i === 0) {\n    digits.unshift(0)\n  } else {\n    while (i > 0) {\n      digits.unshift(i % base)\n      i = Math.floor(i / base)\n    }\n  }\n  while (digits.length < minLength) digits.unshift(0)\n  return digits\n}\n\nexport class Radix {\n  readonly base: number\n  constructor(\n    readonly name: string,\n    readonly numerals: string,\n    readonly decodePreparser: (s: string) => string = identity\n  ) {\n    this.base = numerals.length\n  }\n\n  private digitsToNumerals(digits: number[]): string {\n    return digits.map(d => this.numerals[d]).join(\"\")\n  }\n\n  encode(num: number, minLength: number = 0): string {\n    if (!isFinite(num)) return \"\"\n    // r is a reversed array of chars:\n    const negate = num < 0\n    if (negate) {\n      num = Math.abs(num)\n      minLength-- // accommodate the sign\n    }\n    return (\n      (negate ? \"-\" : \"\") +\n      this.digitsToNumerals(encodeDigits(this.base, num, minLength))\n    )\n  }\n\n  encodeBigInt(bi: bigint): string {\n    if (typeof bi !== \"bigint\") throw new Error(\"bad input\")\n    if (bi === zero) return this.numerals[0]\n\n    const digits: number[] = []\n    const b = BigInt(this.base)\n    let i: any = bi\n\n    while (i > zero) {\n      digits.push(Number(i % b))\n      i = i / b\n    }\n    return this.digitsToNumerals(digits.reverse())\n  }\n\n  encodeBuffer(buf: Buffer): string {\n    if (buf == null || buf.length === 0) return \"\"\n    const digits = [0]\n    for (let b of buf) {\n      digits.forEach((d, i) => {\n        // const b0 = b\n        b += d << 8\n        digits[i] = b % this.base\n        b = Math.floor(b / this.base)\n        // console.dir({ i, b0, b, d0: d, d: digits[i], digits })\n      })\n\n      while (b > 0) {\n        digits.push(b % this.base)\n        b = Math.floor(b / this.base)\n        // console.dir({ b, digits })\n      }\n    }\n    return this.digitsToNumerals(digits.reverse())\n  }\n\n  decode(s: Maybe<string>): Maybe<number> {\n    return map(this.decodeBigInt(s), ea => {\n      if (ea > BigInt(Number.MAX_SAFE_INTEGER)) {\n        throw new Error(\"decode(\" + s + \") is > 2^53\")\n      } else {\n        return Number(ea)\n      }\n    })\n  }\n\n  normalize(s: string): string {\n    return this.decodePreparser(s)\n  }\n\n  decodeBigInt(s: Maybe<string>): Maybe<bigint> {\n    if (s == null || blank(s)) return\n    s = isFunction(this.decodePreparser) ? this.decodePreparser(s) : s\n    const negate = s[0] === \"-\"\n    if (negate) {\n      s = s.slice(1)\n    }\n    const b = BigInt(this.base)\n    let acc = BigInt(0)\n    for (const ch of s) {\n      const idx = this.numerals.indexOf(ch)\n      if (idx < 0) {\n        return undefined\n      }\n      acc = acc * b + BigInt(idx)\n    }\n    return negate ? BigInt(-1) * acc : acc\n  }\n\n  randomChars(length: number): string {\n    // bits per char is Math.log2(this.base).\n    // we need bpc * length / 8 = random bytes.\n    const s = this.encodeBuffer(\n      randomBytes(Math.ceil((Math.log2(this.base) * (length + 4)) / 8))\n    )\n    return s.slice(2, 2 + length)\n  }\n\n  /**\n   * UIDs are easier to parse or read if dashes break up the string.\n   *\n   * Reading 4-char groups is comfortable, 5 chars \"won-aye-six-gee-why\" is\n   * doable, I think, so split every 5?\n   *\n   * For GeoRadix, each char encodes 5 bits, so 20 chars is only 100 bits of\n   * entropy. 24 chars is 120. We need 32 chars for 160 bits, that's a lot.\n   */\n  randomUid(chars = 20, splitEveryN = 5, sepChar = \"-\"): string {\n    return splitEvery(this.randomChars(chars), splitEveryN).join(sepChar)\n  }\n\n  tokenEql(a: string, b: string, minLen: number): boolean {\n    const an = this.normalizeToken(a)\n    const bn = this.normalizeToken(b)\n    return an.length >= minLen && an === bn\n  }\n\n  normalizeToken(a: string) {\n    return [...this.decodePreparser(a.trim())]\n      .filter(ea => this.numerals.includes(ea))\n      .join(\"\")\n  }\n}\n\nexport const Hex = new Radix(\"hex\", \"0123456789abcdef\", s => s.toLowerCase())\n\n/**\n * URL-safe charset used for bitcoin and IPFS hashes\n * @see https://en.wikipedia.org/wiki/Base58\n */\nexport const Radix58 = new Radix(\n  \"Radix58\",\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n)\n\n/**\n * CAUTION! This doesn't do standard base64 padding!\n * @see b64.ts\n */\nexport const Base64 = new Radix(\n  \"Radix64\",\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n)\n\n/**\n * Used by StringSimilarity.radixDiff\n */\nexport const RadixAlphaNum = new Radix(\n  \"RadixAlphaNum\",\n  \"0123456789abcdefghijklmnopqrstuvwxyz\",\n  s => s.toLowerCase()\n)\n\n/**\n * Base 32 charset for case-insensitive filesystems and human consumption\n * @see https://en.wikipedia.org/wiki/Geohash\n */\nexport const GeoRadix = new Radix(\n  \"GeoRadix\",\n  \"0123456789bcdefghjkmnpqrstuvwxyz\", // y no a?\n  s => s.toLowerCase()\n)\n\n/**\n * Base 32 charset for case-insensitive filesystems and human consumption.\n *\n * Similar glyphs include 0O, 1lI, 2z, 5S, 9g\n */\nexport const TokenRadix = new Radix(\n  \"TokenRadix\",\n  \"0123456789abcdefhjkmnpqrtuvwxy\",\n  s =>\n    s\n      .toLowerCase()\n      .replace(/o/g, \"0\")\n      .replace(/[il]/g, \"1\")\n      .replace(/z/g, \"2\")\n      .replace(/s/g, \"5\")\n      .replace(/g/g, \"9\")\n)\n\nexport const AlphaRadix = new Radix(\n  \"AlphaRadix\",\n  \"abcdefghjkmnopqrtuvwxyz\",\n  s =>\n    s\n      .toLowerCase()\n      .replace(/0/g, \"o\")\n      .replace(/2/g, \"z\")\n      .replace(/5/g, \"s\")\n      .replace(/9/g, \"g\")\n)\n\nexport const NumericRadix = new Radix(\"NumericRadix\", \"0123456789\", s =>\n  s\n    .toLowerCase()\n    .replace(/o/g, \"0\")\n    .replace(/[il]/g, \"1\")\n    .replace(/z/g, \"2\")\n    .replace(/s/g, \"5\")\n    .replace(/g/g, \"9\")\n)\n","import { Rate } from \"batch-cluster\"\n\nexport function rateStats(r: Rate) {\n  return {\n    eventCount: r?.eventCount,\n    eventsPerSecond: r?.eventsPerSecond,\n    msSinceLastEvent: r?.msSinceLastEvent\n  }\n}\n","import { isEmpty } from \"../../fe/Array\"\nimport { List } from \"../../fe/List\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, finiteOrElse, isNumber } from \"../../fe/Number\"\nimport { toA } from \"../../fe/toA\"\nimport { CountingSet } from \"../CountingSet\"\nimport { intersection, union } from \"../Set\"\nimport { Average } from \"./Average\"\n\nexport type NumericList =\n  | List<number>\n  | Iterable<number>\n  | number[]\n  | Float32Array\n  | Uint32Array\n  | Int32Array\n\nexport type MaybeNumericList =\n  | List<Maybe<number>>\n  | Iterable<Maybe<number>>\n  | Maybe<number>[]\n  | Float32Array\n  | Uint32Array\n  | Int32Array\n\nexport function min<T>(vec: List<Maybe<T>>): Maybe<T> {\n  let result\n  for (const ea of vec) {\n    if (ea != null) {\n      if (result == null || ea < result) {\n        result = ea\n      }\n    }\n  }\n  return result\n}\n\nexport function max<T>(vec: List<Maybe<T>>) {\n  let result\n  for (const ea of vec) {\n    if (ea != null) {\n      if (result == null || ea > result) {\n        result = ea\n      }\n    }\n  }\n  return result\n}\n\n/**\n * @return `[arr[1] - arr[0], arr[2] - arr[1], ...]`\n */\nexport function deltas(vec: NumericList): number[] {\n  const l = toA(vec)\n  if (vec == null || l.length <= 1) return []\n  return l.slice(1).map((ea, idx) => ea - l[idx])\n}\n\nexport function modes(vec: MaybeNumericList, topN: number): number[] {\n  const cs = new CountingSet<number>()\n  for (const ea of vec) {\n    if (isNumber(ea)) {\n      cs.incr(ea)\n    }\n  }\n  return cs.topKeys(topN)\n}\n\nexport function mode(vec: MaybeNumericList): Maybe<number> {\n  return modes(vec, 1)[0]\n}\n\nexport function sum(vec: MaybeNumericList | Iterable<Maybe<number>>): number {\n  let acc = 0\n  for (const ea of vec) {\n    if (isNumber(ea)) {\n      acc += ea\n    }\n  }\n  return acc\n}\n\nexport function sumf<T>(\n  iter: Iterable<Maybe<T>>,\n  f: (t: T, index: number) => Maybe<number>\n): number {\n  let index = 0\n  let acc = 0\n  for (const ea of iter) {\n    if (ea != null) {\n      const i = f(ea, index)\n      if (isNumber(i)) {\n        acc += i\n      }\n    }\n    index++\n  }\n  return acc\n}\n\nexport class Mean {\n  #idx = 0\n  #mean: Maybe<number>\n\n  push(i: Maybe<number>) {\n    if (isNumber(i)) {\n      // prevent overflow:\n      // https://math.stackexchange.com/a/116344\n      // https://www.johndcook.com/blog/standard_deviation/\n      this.#mean =\n        this.#mean == null\n          ? i\n          : (this.#mean * this.#idx) / (this.#idx + 1) + i / (this.#idx + 1)\n      this.#idx++\n    }\n  }\n\n  get mean() {\n    return this.#mean\n  }\n}\n\nexport function avg(vec: MaybeNumericList): Maybe<number> {\n  const m = new Mean()\n  for (const ea of vec) {\n    m.push(ea)\n  }\n  return m.mean\n}\n\n// export function covariance(args: {\n//   a: number[]\n//   b: number[]\n//   aMean?: number\n//   bMean?: number\n// }): Maybe<number> {\n//   if (isEmpty(args.a) || isEmpty(args.b) || args.a.length !== args.b.length)\n//     return\n//   const a_mean = args.aMean ?? avg(args.a)!\n//   const b_mean = args.bMean ?? avg(args.b)!\n//   const cov = new Mean()\n//   for (let i = 0; i < args.a.length; i++) {\n//     cov.push((args.a[i] - a_mean) * (args.b[i] - b_mean))\n//   }\n//   return cov.mean\n// }\n\n/**\n * @param strength how strong should the normalization be applied. [0,1]\n */\nexport function normalize({\n  x,\n  strength = 1,\n  normMin,\n  normMax\n}: {\n  x: number[]\n  strength?: number\n  normMin: number\n  normMax: number\n}): number[] {\n  const xMin = min(x)!\n  const xRange = max(x)! - xMin\n  const normRange = normMax - normMin\n  return x.map(\n    ea =>\n      (1 - strength) * ea +\n      strength * (normMin + (normRange * (ea - xMin)) / xRange)\n  )\n}\n\nexport function slope(vec: MaybeNumericList): Maybe<number> {\n  const l = toA(vec).filter(isNumber)\n  const x_mean = avg(l)\n  if (x_mean != null) {\n    const y_mean = (l.length - 1) / 2\n    const num = sumf(l, (x, y) => (x - x_mean) * (y - y_mean))\n    const denom = sumf(l, x => (x - x_mean) ** 2)\n    return denom === 0 ? 0 : num / denom\n  } else {\n    return\n  }\n}\n\nexport function variance(arr: MaybeNumericList): Maybe<number> {\n  const mean = avg(arr)\n  if (mean == null) return undefined\n  let acc = 0\n  let len = 0\n  for (const i of arr) {\n    if (isNumber(i)) {\n      len++\n      acc += (i - mean) * (i - mean)\n    }\n  }\n  return acc / len\n}\n\nexport function stdDev(arr: MaybeNumericList): Maybe<number> {\n  return map(variance(arr), Math.sqrt)\n}\n\nexport function p84(arr: MaybeNumericList): Maybe<number> {\n  return new Average().pushAll(arr).p84\n}\n\n/**\n * @param carryForward ratio of prior means to average with subsequent values\n */\nexport function weightedAvg(\n  arr: List<number> | Iterable<number>,\n  carryForward = 0.5\n): Maybe<number> {\n  let acc\n  carryForward = clamp(0, 1, carryForward)\n  for (const ea of arr) {\n    acc = acc == null ? ea : acc * carryForward + ea * (1 - carryForward)\n  }\n  return acc\n}\n\n// export function euclidean<T extends NumericList>(x: T, y: T): number {\n//   return Math.sqrt(\n//     toA(x).reduce((sum_, ea, idx) => sum_ + Math.pow(ea - y[idx], 2), 0)\n//   )\n// }\n\nexport function centroid(vectors: number[][]): Maybe<number>[] {\n  const len = vectors[0].length\n  const arr: Maybe<number>[] = []\n  for (let i = 0; i < len; i++) {\n    arr.push(avg(vectors.map(ea => ea[i])))\n  }\n  return arr\n}\n\n/**\n * Euclidean norm, or L2 norm, of a given vector\n * @see https://en.wikipedia.org/wiki/Norm_(mathematics)\n */\nexport function l2norm(vec: List<number>): number {\n  // PERF: no closures\n  let acc = 0\n  for (const ea of vec) {\n    acc += ea * ea\n  }\n  return Math.sqrt(acc)\n}\n\n/**\n * @see https://en.wikipedia.org/wiki/Euclidean_vector#Dot_product\n */\nexport function dot(x: number[], y: number[]): number {\n  // PERF: no closures\n  let acc = 0\n  for (let i = 0; i < x.length; i++) {\n    acc += x[i] * y[i]\n  }\n  return acc\n}\n\n/**\n * Ranges between -1 (anticorrelation) to 1 (correlation)\n * @see https://en.wikipedia.org/wiki/Cosine_similarity\n */\nexport function cosineSimilarity(x: number[], y: number[]): Maybe<number> {\n  return finiteOrElse(dot(x, y) / (l2norm(x) * l2norm(y)), undefined)\n}\n\n/**\n * Ranges between 0 (no overlap) to 1 (complete overlap)\n */\nexport function jaccard(x: number[], y: number[]): Maybe<number> {\n  return isEmpty(x) && isEmpty(y)\n    ? 0\n    : finiteOrElse(intersection(x, y).size / union(x, y).size, undefined)\n}\n","import { join } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { toS } from \"../../fe/toS\"\n\n// Expect __filename to be something like\n// '/home/mrm/src/photostructure/src/core/dist/core/platform/IsPacked.js' if\n// we're not web-packed.\n\nexport const isPacked = lazy(\n  () => !toS(__filename).includes(join(\"core\", \"platform\", \"IsPacked\"))\n)\n","import os from \"os\"\nimport process from \"process\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { ELECTRON_RUN_AS_NODE } from \"../env/EnvKeys\"\n\n// THIS IS USED BY EVERYONE IN CORE, so only rely on fe code!\n\nconst _platform = os.platform()\n\nexport const inspectFlag =\n  process.argv.includes(\"--inspect\") || isTrue(process.env.NODE_INSPECT)\n\nexport const isCI = isTrue(process.env[\"CI\"])\n\nexport const isWin = _platform === \"win32\" || _platform === \"cygwin\"\nexport const isWinPortable =\n  isWin && notBlank(process.env.PORTABLE_EXECUTABLE_DIR)\n\nexport const isMac = _platform === \"darwin\"\n\nexport const isLinux = _platform === \"linux\"\nexport const isLinux_x64 = isLinux && os.arch() === \"x64\"\nexport const isArm = null != /^arm\\b/i.exec(os.arch()) // \"arm\" on RPi, \"arm64\" on M1\nexport const isLinux_arm = isLinux && isArm\nexport const isLinuxAppImage =\n  isLinux && (notBlank(process.env.APPIMAGE) || notBlank(process.env.APPDIR))\nexport const isLinuxSnap = isLinux && notBlank(process.env.SNAP_USER_DATA)\n\nexport const isPosix = isMac || isLinux\n\nexport const isMainElectron = process.versions[\"electron\"] != null\n\nexport const isElectron =\n  isMainElectron || isTrue(process.env[ELECTRON_RUN_AS_NODE])\n\n/**\n * Compatible with electron-builder:\n */\nexport type Platform = \"win\" | \"mac\" | \"linux\"\n\nexport const platformName: Platform = isWin\n  ? \"win\"\n  : isMac\n  ? \"mac\"\n  : isLinux\n  ? \"linux\"\n  : (_platform as any) // < punt\n","import { lazy } from \"../../core/Lazy\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { PS_IS_DOCKER } from \"../env/EnvKeys\"\nimport { isLinux } from \"../platform/Platform\"\n\n// HEY FUTURE ME: no need to get clever here with checking for Alpine Linux or\n// /.dockerenv. KISS.\n\n// NOTE TO THE FUTURE: we used to parse out the owner from /proc/1/cgroup but\n// that was missing from UnRAID docker containers.\n\nexport const isDocker = lazy(() => isLinux && isTrue(process.env[PS_IS_DOCKER]))\n","import fs from \"fs\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isLinux, isLinux_arm, isMac, isWin } from \"../platform/Platform\"\n\n// this works in and out of docker containers:\nexport function containsRpiModel(cpuinfoPath = \"/proc/cpuinfo\") {\n  if (isWin || isMac) return false\n  try {\n    const contents = fs.readFileSync(cpuinfoPath).toString()\n    return null != contents.match(/^\\s*model\\s*:\\s*Raspberry Pi/im)\n  } catch {\n    return false\n  }\n}\n\nexport const isRaspberryPi = lazy(() => isLinux_arm && containsRpiModel())\n\n/**\n * This seems to only be set on Raspberry PIs:\n */\nexport const procDeviceModel = lazy(() => {\n  try {\n    return isLinux\n      ? // \"Raspberry Pi 4 Model B Rev 1.1\" on pi4\n        fs.readFileSync(\"/proc/device-tree/model\").toString()\n      : undefined\n  } catch {\n    return\n  }\n})\n","import { BatchCluster, Parser, Task } from \"batch-cluster\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank, mapNotBlankOr, notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { Obj } from \"../../fe/Object\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { BatchClusterObserver } from \"../BatchClusterObserver\"\nimport { thenElapsed } from \"../Elapsed\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { ellipsize, ensureSuffix, stripPrefix } from \"../String\"\nimport { EndableRanks, ending } from \"../async/Endable\"\nimport { EndableWrapper } from \"../async/EndableWrapper\"\nimport { thenMap } from \"../async/Promise\"\nimport { until } from \"../async/until\"\nimport { execFile } from \"../child/ChildProcess\"\nimport { ee } from \"../event/EventEmitter\"\nimport { isWin } from \"../platform/Platform\"\nimport { Settings } from \"../settings/Settings\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\n\nconst Done = \"{ready}\"\n\nconst ConvertToCompressedJson = \" | ConvertTo-Json -Compress\"\n\nexport type Result = { stdout: string; stderr?: string; passed: boolean }\n\nexport interface PowerShellVersion {\n  Major: number\n  Minor: number\n  Build: number\n  Revision: number\n  MajorRevision: number\n  MinorRevision: number\n}\n\nexport function pwshQuote(s: string): string {\n  const s2 = s\n    .replace(/['`\"“”#]/g, ea => \"`\" + ea)\n    .replace(/\\0/g, \"`0\")\n    .replace(/\\n/g, \"`n\")\n    .replace(/\\r/g, \"`r\")\n    .replace(/\\t/g, \"`t\")\n    .replace(/\\v/g, \"`v\")\n  return '\"' + s2 + '\"'\n}\n\nfunction versionCommand() {\n  return [\n    `function prompt {\"${Done}\"}`,\n    ...mapNotBlankOr(\n      Settings.powerShellCulture.valueOrDefault,\n      ea => [\n        `[System.Threading.Thread]::CurrentThread.CurrentCulture = '${ea}'`,\n        `[System.Threading.Thread]::CurrentThread.CurrentUICulture = '${ea}'`\n      ],\n      []\n    )\n  ].join(\";\")\n}\n\nlater(() =>\n  ee().on(\"clearCache\", () => PowerShell.instance.prior()?.clearMockResults())\n)\n\nexport class PowerShell extends EndableWrapper {\n  static ensureInstance() {\n    const prior = this.instance()\n    return prior.ended ? this.instance.refresh() : prior\n  }\n  static readonly instance = lazy(() => {\n    if (!isWin) throw new Error(\"PowerShell isn't available on this platform\")\n    return new PowerShell()\n  })\n  private readonly bco: BatchClusterObserver<BatchCluster>\n  private readonly pwsh: BatchCluster\n  private readonly mockResults = new Map<string, Result>()\n\n  // always access through PowerShell.instance():\n  private constructor() {\n    super(\"PowerShell\", () => this.bco.end(), EndableRanks.postdb)\n    this.bco = new BatchClusterObserver(\n      \"PowerShell\",\n      new BatchCluster({\n        processFactory: () =>\n          execFile(\"powershell\", Settings.powerShellArgs.values),\n        logger: () => mkLogger(\"PowerShell\"),\n        versionCommand: versionCommand(),\n        pass: Done,\n        fail: \"Error\",\n        exitCommand: \"exit\",\n        maxProcs: Settings.powerShellProcs.valueOrDefault,\n        taskTimeoutMillis: commandTimeoutMs(),\n\n        maxIdleMsPerProcess: minuteMs,\n        cleanupChildProcs: false // we do this with the Pids class.\n      }),\n      EndableRanks.postdb // last to shut down.\n    )\n    Settings.powerShellProcs.watch(() =>\n      this.bco.t.setMaxProcs(Settings.powerShellProcs.valueOrDefault)\n    )\n    this.pwsh = this.bco.t\n  }\n\n  get lastStartError() {\n    return this.bco.lastStartError\n  }\n\n  get lastTaskError() {\n    return this.bco.lastTaskError\n  }\n\n  get ended() {\n    return this.pwsh.ended\n  }\n\n  versionPojo(): PromiseMaybe<PowerShellVersion> {\n    return this.executeJson(\"$PSVersionTable.PSVersion\")\n  }\n\n  version(): PromiseMaybe<string> {\n    return thenMap(\n      this.executeJson(\"$PSVersionTable.PSVersion\"),\n      ea => `${ea.Major}.${ea.Minor}.${ea.Build}`\n    )\n  }\n\n  get spawnedProcCount() {\n    return this.pwsh.spawnedProcCount\n  }\n\n  pushMockJsonResult(cmd: string, result: Result) {\n    this.pushMockResult(ensureSuffix(cmd, ConvertToCompressedJson), result)\n  }\n\n  pushMockResult(cmd: string, result: Result) {\n    this.mockResults.set(cmd, result)\n  }\n\n  clearMockResults() {\n    this.mockResults.clear()\n  }\n\n  async execute<T>(cmd: string, parser: Parser<T>): PromiseMaybe<T> {\n    if (this.pwsh.ended || ending()) {\n      this.logger.warn(\"execute() failed (ended)\", { cmd })\n      return\n    }\n\n    if (isTest && this.mockResults.has(cmd)) {\n      const f = this.mockResults.get(cmd)!\n      return parser(f.stdout, f.stderr, f.passed)\n    }\n\n    try {\n      const r = await thenElapsed(\n        this.pwsh.enqueueTask(\n          new Task(\n            cmd,\n            (stdout: string, stderr: string | undefined, passed: boolean) =>\n              parser(map(stdout, ea => stripPrefix(ea, cmd))!, stderr, passed)\n          )\n        )\n      )\n      return this.logger.tap({\n        msg: \"execute()\",\n        result: r.result,\n        meta: {\n          elapsedMs: r.elapsedMs,\n          cmd\n        }\n      })\n    } catch (err) {\n      this.logger.warn(\"execute() failed: \" + err, { cmd })\n      return\n    }\n  }\n\n  async executeJson(cmd: string): PromiseMaybe<any> {\n    const r = await this.execute(\n      ensureSuffix(cmd, ConvertToCompressedJson),\n      (stdout, stderr, passed) => ({ stdout, stderr, passed })\n    )\n    if (r == null) {\n      this.logger.warn(\"executeJson(): null result\", { cmd })\n      return\n    }\n    if (blank(r.stdout) || notBlank(r.stderr) || !r.passed) {\n      this.logger.warn(\"executeJson(): failed result\", { cmd, ...r })\n      return\n    }\n    try {\n      return JSON.parse(r.stdout)\n    } catch (err) {\n      const fixed = r.stdout.replace(/\\\\/g, \"\\\\\\\\\")\n      this.logger.info(\n        \"executeJson(): parsing failed, trying dub-whack fix...\",\n        { before: ellipsize(r.stdout), after: ellipsize(fixed) }\n      )\n      return JSON.parse(fixed)\n    }\n  }\n\n  async executeJsonToA(cmd: string): PromiseMaybe<Obj[]> {\n    return thenMap(this.executeJson(cmd), json =>\n      Array.isArray(json) ? json : [json]\n    )\n  }\n\n  /**\n   * @return the path to the command, if it's available on the PATH\n   */\n  async which(cmd: string): PromiseMaybe<string> {\n    // Note to Future Me: `where` (Windows' version of `which`) doesn't seem to\n    // find binaries reliably, and this prevents spawning a binary (double win!)\n    const json = await this.executeJson(\n      \"Get-Command -ErrorAction SilentlyContinue \" +\n        pwshQuote(cmd) +\n        \" | Select-Object -Property Source\"\n    )\n    return Array.isArray(json) ? json[0]?.Source : json?.Source\n  }\n}\n\n/**\n * @return the PowerShell version, or undefined on unsupported platforms.\n * @throws if PowerShell times out or has issues\n */\nexport async function checkPowerShell_() {\n  if (!isWin) return\n  const ps = PowerShell.instance()\n  if (ps.ended || ending()) return\n  const version = await thenOrTimeoutError(\n    () => ps.version(),\n    commandTimeoutMs()\n  )\n  if (blank(version)) {\n    const err = await until(() => orElse(ps.lastStartError, ps.lastTaskError), {\n      timeoutMs: ShortCommandTimeoutMs,\n      intervalMs: 250\n    })\n    if (err != null) throw err\n    else throw new Error(\"(unknown error)\")\n  }\n  return version\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const AggregateTypes = strEnum(\"union\", \"intersection\")\nexport type AggregateType = StrEnumKeys<typeof AggregateTypes>\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\n// order here is the default sort order!\nexport const AssetFileSortCriteria = strEnum(\n  // more pixels are always better (this is quantized using variantSortCriteriaPower):\n  \"resolution\",\n  // prefer files in the library:\n  \"schemeIdx\",\n\n  // prefer files with a more accurate date:\n  \"capturedAtPrecision\",\n  // prefer files with more fields with metadata we care about:\n  \"metadataCoverage\",\n  // prefer files we can directly throw at the browser:\n  \"isBrowserSupported\",\n\n  // if they edit a file, we should prefer that newly edited version:\n  \"mtime\",\n\n  // If we have a burst files, prefer the \"burst cover\"\n  \"isCover\",\n\n  // If there are many copies of a file (image.jpg, image (1).jpg, image\n  // (2).jpg), prefer the one with the highest number (assuming that's the\n  // latest copy):\n  \"count\",\n\n  // help make things deterministic:\n  \"fileSize\",\n  // help make things deterministic:\n  \"basename\",\n  // help make things deterministic:\n  \"parentBasename\",\n  // just to make things deterministic:\n  \"uri\"\n)\n\nexport type AssetFileSortCriterion = StrEnumKeys<typeof AssetFileSortCriteria>\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { toBoolean } from \"../../fe/Boolean\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class BooleanSetting extends Setting<boolean> {\n  constructor(opts: SettingOpts<boolean>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toBoolean\n    })\n  }\n}\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class BoundedFloatSetting extends Setting<number> {\n  constructor(\n    readonly options: SettingOpts<number> & { min: number; max: number }\n  ) {\n    super({\n      ...options,\n      toEnv: notBlankToS,\n      fromEnv: (value: Maybe<string>) =>\n        opt(value)\n          .flatMap(parseFloat)\n          .map(ea => clamp(options.min, options.max, ea))\n          .get()\n    })\n  }\n  addToJSON() {\n    return {\n      \"minimum value\": this.options.min,\n      \"maximum value\": this.options.max\n    }\n  }\n}\n","import { notBlank, notBlankToS } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, toInt } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class BoundedIntegerSetting extends Setting<number> {\n  constructor(\n    readonly options: SettingOpts<number> & { min: number; max: number }\n  ) {\n    super({\n      ...options,\n      toEnv: notBlankToS,\n      fromEnv: (value: Maybe<string>) =>\n        opt(value)\n          .filter(notBlank)\n          .flatMap(toInt)\n          .map(ea => clamp(options.min, options.max, ea))\n          .get()\n    })\n  }\n\n  get min(): number {\n    return this.options.min\n  }\n\n  get max(): number {\n    return this.options.max\n  }\n\n  clamp(value: Maybe<number>) {\n    return clamp(this.min, this.max, value ?? this.min)\n  }\n\n  addToJSON() {\n    return {\n      \"minimum value\": this.options.min,\n      \"maximum value\": this.options.max\n    }\n  }\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const ColorDistanceFunctions = strEnum(\"cie76\", \"cie94\", \"ciede2000\")\nexport type ColorDistanceFunction = StrEnumKeys<typeof ColorDistanceFunctions>\n","export const DominantColorKmeansRunsDefault = 7\n\n// Results from running ImageHash.spec.ts with different values:\n\n// with 32 runs: (mean: 108ms, sum: 5810ms)\n// dominantColorScore { k: 60, mean: 8.1, sum: 485, sd: 1.9, max: 15, min: 4.8 }\n\n// with 16 runs: (mean: 62ms, sum: 3327ms),\n// dominantColorScore { k: 60, mean: 8.2, sum: 494, sd: 2, max: 16, min: 5 }\n\n// with 8 runs: (mean: 36ms, sum: 1958ms)\n// dominantColorScore { k: 60, mean: 8.5, sum: 510, sd: 2.1, max: 17, min: 5 }\n\n// with 7 runs: (mean: 31ms, sum: 1636ms)\n// dominantColorScore { k: 60, mean: 8.5, sum: 511, sd: 2.1, max: 16, min: 4.8 }\n\n// with 5 runs: (mean: 24ms, sum: 1165ms )\n// dominantColorScore { k: 60, mean: 8.7, sum: 519, sd: 2.2, max: 17, min: 5.1 }\n\n// with 4 runs: (mean: 23ms, sum: 1067ms)\n// dominantColorScore { k: 60, mean: 8.7, sum: 523, sd: 2.2, max: 17, min: 5.2 }\n\n// with 3 runs: (mean: 19ms, sum: 611ms)\n// dominantColorScore { k: 60, mean: 8.8, sum: 528, sd: 2.3, max: 17, min: 5.2 }\n","export const DominantColorPixelsDefault = 1024\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { decodeDuration, encodeDuration } from \"../date/DurationCodec\"\nimport { fmtFullDuration } from \"../date/DurationFormat\"\nimport { BaseSettingOpts, Setting, SettingOpts } from \"./Setting\"\n\nexport class DurationSetting extends Setting<number> {\n  constructor(opts: SettingOpts<string | number>) {\n    super({\n      ...(opts as any),\n      toEnv: encodeDuration,\n      fromEnv: decodeDuration\n    })\n  }\n\n  get valueOrDefault() {\n    // code is expecting this to be in millis.\n    return decodeDuration(super.valueOrDefault) as any\n  }\n\n  get value() {\n    // code is expecting this to be in millis.\n    return decodeDuration(super.value) as any\n  }\n\n  set value(o: any) {\n    super.userValue = decodeDuration(o)\n  }\n\n  get humanValue() {\n    return fmtFullDuration(this.value)\n  }\n\n  // the file value is the only one 8601-encoded:\n  get fileValue() {\n    return encodeDuration(super.fileValue) as any\n  }\n\n  set fileValue(o: any) {\n    super.fileValue = decodeDuration(o)\n  }\n}\n\nexport class OptionalDurationSetting extends Setting<Maybe<number>> {\n  constructor(opts: BaseSettingOpts<Maybe<string | number>>) {\n    super({\n      ...(opts as any),\n      toEnv: encodeDuration,\n      fromEnv: decodeDuration,\n      defaultValue: undefined\n    })\n  }\n\n  get valueOrDefault() {\n    return this.value ?? decodeDuration(this.defaultValue as any)!\n  }\n\n  get fileValue() {\n    return encodeDuration(super.fileValue) as any\n  }\n}\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { toFloat } from \"../../fe/Number\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class FloatSetting extends Setting<number> {\n  constructor(opts: SettingOpts<number>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toFloat\n    })\n  }\n}\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { toInt } from \"../../fe/Number\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class IntegerSetting extends Setting<number> {\n  constructor(opts: SettingOpts<number>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toInt\n    })\n  }\n}\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { resolve } from \"../fs/Path\"\nimport { OptionalStringSetting } from \"./OptionalStringSetting\"\nimport { BaseSettingOpts, SettingOpts } from \"./Setting\"\n\nexport class OptionalFileSetting extends OptionalStringSetting {\n  constructor(\n    opts: BaseSettingOpts<Maybe<string>> & Partial<SettingOpts<Maybe<string>>>\n  ) {\n    super({\n      toEnv: ea => ea?.trim(),\n      fromEnv: ea => (blank(ea) ? undefined : resolve(ea)),\n      defaultValue: undefined,\n      ...opts\n    })\n  }\n}\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toFloat } from \"../../fe/Number\"\nimport { BaseSettingOpts, DefaultValued, Setting } from \"./Setting\"\n\nexport class OptionalFloatSetting extends Setting<Maybe<number>> {\n  constructor(\n    opts: BaseSettingOpts<Maybe<number>> & Partial<DefaultValued<Maybe<number>>>\n  ) {\n    super({\n      defaultValue: undefined,\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toFloat\n    })\n  }\n}\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toInt } from \"../../fe/Number\"\nimport { BaseSettingOpts, Setting } from \"./Setting\"\n\nexport class OptionalIntegerSetting extends Setting<Maybe<number>> {\n  constructor(opts: BaseSettingOpts<Maybe<number>>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toInt,\n      defaultValue: undefined\n    })\n  }\n}\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport {\n  BaseSettingOpts,\n  Setting,\n  SettingConverters,\n  SettingOpts\n} from \"./Setting\"\n\nexport class OptionalStringSetting extends Setting<Maybe<string>> {\n  constructor(\n    opts: BaseSettingOpts<Maybe<string>> &\n      Partial<SettingOpts<Maybe<string>>> &\n      Partial<SettingConverters<string>>\n  ) {\n    super({\n      toEnv: ea => ea?.trim(),\n      fromEnv: ea => ea,\n      defaultValue: undefined,\n      ...opts\n    })\n  }\n\n  hasValue() {\n    return this.value != null\n  }\n}\n","import { ensurePrefix } from \"../../fe/String\"\nimport { camel2snake, snake2camel } from \"../StringCase\"\nimport { SettingsName } from \"./SettingsName\"\n\nexport function nameFromEnv(name: string): string {\n  return snake2camel(name.replace(/^PS_/, \"\").toLowerCase())\n}\n\nexport function envFromName(name: SettingsName | string): string {\n  return ensurePrefix(camel2snake(name).toUpperCase(), \"PS_\")\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { filterInPlace, isEmpty, uniq } from \"../../fe/Array\"\nimport { ChangeListener } from \"../../fe/ChangeListener\"\nimport { shallowClone } from \"../../fe/Clone\"\nimport { eql } from \"../../fe/Eql\"\nimport { orList } from \"../../fe/FmtList\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Defined, map, mapOr } from \"../../fe/Maybe\"\nimport { Maybe, MaybeNull } from \"../../fe/MaybeTypes\"\nimport { Obj, StringValued, entries } from \"../../fe/Object\"\nimport { padding } from \"../../fe/Pad\"\nimport { pluralize } from \"../../fe/Pluralize\"\nimport { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\nimport { Thunk, tot } from \"../../fe/Thunk\"\nimport { toA } from \"../../fe/toA\"\nimport { CaseInsensitiveValued } from \"../CaseInsensitiveValued\"\nimport { wrap } from \"../String\"\nimport { env } from \"../env/Env\"\nimport { caseInsensitiveEnv } from \"../env/GetEnv\"\nimport { ee } from \"../event/EventEmitter\"\nimport { envFromName } from \"./PsEnvNames\"\nimport { wrapTomlToLines } from \"./TomlStringify\"\nimport { WrapComments } from \"./WrapComments\"\n\n// LIMIT DEPS TO FE AND BASE CLASSES! #NODEPLOOPS NO DE PLOOPS!\n\nexport const SettingCategories = strEnum(\n  // System settings:\n  \"Paths\",\n  \"Desktops\",\n  \"Filesystem\",\n  \"Cache\",\n  \"Logging\",\n  \"Networking\",\n  \"Processes\",\n  \"Security\",\n  \"Tools\",\n  \"Updates\",\n  // Library settings:\n  \"Auth\",\n  \"Color\",\n  \"Db\",\n  \"Deduping\",\n  \"Events\",\n  \"Filters\",\n  \"HealthChecks\",\n  \"Parsing\",\n  \"Previews\",\n  \"Reporting\",\n  \"Sidecars\",\n  \"Subscriptions\",\n  \"Sync\",\n  \"Tagging\",\n  \"Video\",\n  \"Volumes\",\n  \"Web\"\n)\nexport type SettingCategory = StrEnumKeys<typeof SettingCategories>\n\nexport const LibraryCategories: ReadonlyArray<SettingCategory> = Object.freeze([\n  // we include reporting in the library because their email won't change\n  SettingCategories.Auth,\n  SettingCategories.Color,\n  SettingCategories.Db,\n  SettingCategories.Deduping,\n  SettingCategories.Events,\n  SettingCategories.Filters,\n  SettingCategories.HealthChecks,\n  SettingCategories.Parsing,\n  SettingCategories.Previews,\n  SettingCategories.Reporting,\n  SettingCategories.Sidecars,\n  SettingCategories.Subscriptions,\n  SettingCategories.Sync,\n  SettingCategories.Tagging,\n  SettingCategories.Video,\n  SettingCategories.Volumes,\n  SettingCategories.Web\n])\n\n// System is everything not library:\nexport const SystemCategories: ReadonlyArray<SettingCategory> = Object.freeze(\n  SettingCategories.values.filter(ea => !LibraryCategories.includes(ea))\n)\n\nexport interface BaseSettingOpts<T> {\n  aliases?: string[]\n  envAliases?: string[]\n  category: SettingCategory\n  description: string\n  exampleValue?: Thunk<Maybe<T>>\n  transient?: boolean // defaults to false\n  advanced?: Thunk<boolean>\n  deprecated?: boolean // be sure to add a migrator to MetaSettings!\n  sensitive?: boolean\n}\n\nexport interface SettingConverters<T> {\n  readonly toEnv: (value: Maybe<T>) => Maybe<string>\n  readonly fromEnv: (value: Maybe<string>) => Maybe<T>\n}\n\nexport interface DefaultValued<T> {\n  defaultValue: T | Thunk<T>\n}\n\nexport type SettingOpts<T> = BaseSettingOpts<T> & DefaultValued<T>\n\nexport interface SavedSetting {\n  key: string\n  value: any\n}\n\nexport function settingsToObj(arr: Setting[]): Obj {\n  const obj: Obj = {}\n  for (const ea of arr) {\n    if (ea.hasValue()) obj[ea.name] = ea.value\n  }\n  return obj\n}\n\nexport interface SettingState<T> {\n  user: Maybe<T>\n  env: Maybe<T>\n  file: Maybe<T>\n  tmp: Maybe<T>\n}\n\n/**\n * Supports env-overridden preferences that can be persisted to a file.\n *\n * 1. Setting an environment variable or command-line argument must not be\n *    persisted to the settings file, as that would become the default value.\n * 2. Settings file values should not override the command-line or environment's\n *    values, as that would cause the env or CLI value to be ignored.\n *\n * SO: we have to be able to distinguish between env or cli values and persisted\n * values.\n */\nexport class Setting<T = any> {\n  protected _name!: string\n  protected _names!: string[]\n  protected _key!: string\n  protected _keys!: string[]\n  protected _userValue: Maybe<T>\n  // This lets us only parse values out of the env when we actually need the\n  // value. We get circular dependency errors if we do this on construction\n  // time:\n  _envValue = lazy(() => this.readFromEnv())\n  protected _fileValue: Maybe<T>\n  protected _tmpValue: Maybe<T>\n  protected readonly watchers: ChangeListener<T>[] = []\n  protected optsOverrides: Partial<SettingOpts<T> & SettingConverters<T>> = {}\n\n  constructor(readonly opts: SettingOpts<T> & SettingConverters<T>) {}\n\n  getState(): SettingState<T> {\n    return {\n      user: this._userValue,\n      env: this.envValue,\n      file: this._fileValue,\n      tmp: this._tmpValue\n    }\n  }\n\n  dump() {\n    return {\n      name: this.name,\n      key: this.key,\n      ...this.getState(),\n      hasValue: this.hasValue(),\n      isUnset: this.isUnset(),\n      defaultValue: this.defaultValue\n    }\n  }\n\n  /**\n   * Used for testing: supports changing and restoring state without firing\n   * change observers.\n   */\n  setState(s: Partial<SettingState<T>>) {\n    if (s != null) {\n      this._userValue = s.user\n      this.envValue = s.env\n      this._fileValue = s.file\n      this._tmpValue = s.tmp\n    }\n  }\n\n  // TODO: Doesn't work. I don't know why it doesn't.\n  // runAndRestore<L>(newValue: T, l: () => L): L {\n  //   const priorState = this.getState()\n  //   try {\n  //     this.value = newValue\n  //     return l()\n  //   } finally {\n  //     this.setState(priorState)\n  //   }\n  // }\n\n  normalizeValue(v: Maybe<T>): Maybe<T> {\n    return v == null ? undefined : this.opts.fromEnv(this.opts.toEnv(v))\n  }\n\n  /**\n   * @return the value that should be persisted in a settings.toml. Ignores env\n   * and tmp values.\n   */\n  get fileValue(): Maybe<T> {\n    return this._userValue ?? this._fileValue\n  }\n\n  set fileValue(value: Maybe<T>) {\n    this.onChange(value, ea => (this._fileValue = ea))\n  }\n\n  get envValue(): Maybe<T> {\n    return this._userValue ?? this._envValue()\n  }\n\n  /**\n   * - Set the value for the current process and child processes.\n   * - Don't persist this value in the settings.toml.\n   */\n  set envValue(value: Maybe<T>) {\n    this.onChange(value, ea => {\n      this._envValue.set(ea)\n      this.addToEnv()\n    })\n  }\n\n  refreshEnvValue(args: { broadcastChange?: boolean } = {}) {\n    // if the env value doesn't change valueOrDefault, don't bother the watchers:\n    const prior = shallowClone(this.valueOrDefault)\n    this._envValue.unset()\n    if (true === args?.broadcastChange) this.maybeBroadcastChange(prior)\n  }\n\n  get tmpValue(): Maybe<T> {\n    return this._userValue ?? this._tmpValue\n  }\n\n  /**\n   * - Set the value for the current process (not child processes).\n   * - Don't persist this value in the settings.toml.\n   */\n  set tmpValue(value: Maybe<T>) {\n    this.onChange(value, ea => (this._tmpValue = ea))\n  }\n\n  /**\n   * @return the first set value from user, env, file, or tmp.\n   */\n  get value(): Maybe<T> {\n    return (\n      this._userValue ?? this._envValue() ?? this._fileValue ?? this._tmpValue\n    )\n  }\n\n  set value(value: MaybeNull<T>) {\n    this.userValue = value == null ? undefined : value\n  }\n\n  /**\n   * If there is a \"human-friendly\" version of the value, return that.\n   */\n  get humanValue(): Maybe<T | string> {\n    return this.value\n  }\n\n  set userValue(value: Maybe<T>) {\n    this.onChange(value, ea => (this._userValue = ea))\n  }\n\n  get valueOrThrow(): Defined<T> {\n    const v = this.value\n    if (v == null) {\n      throw new Error(\"Missing value for setting \" + this.name)\n    } else {\n      return v as any\n    }\n  }\n\n  hasValue() {\n    return this.value != null\n  }\n\n  isUnset() {\n    return this.value == null\n  }\n\n  /**\n   * Read the value from the given `Obj` or the ENV.\n   *\n   * THIS DOESN'T CHANGE ANY STATE. If you want to import from the env, use\n   * `importFromEnv`.\n   */\n  readFromEnv(obj?: StringValued): Maybe<T> {\n    const civ =\n      obj == null ? caseInsensitiveEnv() : new CaseInsensitiveValued(obj)\n    // Support PS_LOG_LEVEL and logLevel:\n    for (const k of [...this.keys, ...this.names]) {\n      const v = map(civ.get(k), ea => this.opts.fromEnv(ea))\n      if (v != null) return v\n    }\n    return\n  }\n\n  /**\n   * Should only be used directly by tests, as env shouldn't be wiggling around\n   * after a process starts.\n   */\n  setFromEnv(environment: StringValued = env()): Maybe<T> {\n    return (this.envValue = this.readFromEnv(environment))\n  }\n\n  setValueIfDefined(value: Maybe<T>) {\n    if (value != null) this.value = value\n  }\n\n  watchLater(l: ChangeListener<T>) {\n    this.watchers.push(l)\n  }\n\n  watch(l: ChangeListener<T>) {\n    this.watchLater(l)\n    // setImmediate allows the call to addListener() reference classes or\n    // instances that haven't been parsed yet:\n    setImmediate(() => this.broadcastChange())\n  }\n\n  unWatch(l: ChangeListener<T>) {\n    filterInPlace(this.watchers, ea => ea === l)\n  }\n\n  broadcastChange() {\n    const curr = this.valueOrDefault\n    for (const ea of this.watchers) {\n      ea(curr)\n    }\n    ee().emitDebounced(\"settingsChanged\")\n  }\n\n  /**\n   * @param mutateFunc may change this.value via one of the delegates\n   */\n  protected onChange(v: Maybe<T>, mutateFunc: (ea: Maybe<T>) => any) {\n    // We have to shallow clone prior if it's an array or object, because\n    // mutateFunc may modify prior directly, and then eql() will false-positive.\n    const prior = shallowClone(this.valueOrDefault)\n    mutateFunc(this.normalizeValue(v))\n    this.maybeBroadcastChange(prior)\n  }\n\n  protected maybeBroadcastChange(prior: T) {\n    if (!eql(this.valueOrDefault, prior)) this.broadcastChange()\n  }\n\n  /**\n   * This is the camelCasedVersionOfTheSettingName\n   */\n  get name(): string {\n    return this._name\n  }\n\n  get names(): string[] {\n    return this._names\n  }\n\n  // this is public so Settings can push field names down to instances\n  _setName(name: string) {\n    if (this._name != null) throw new Error(\"cannot set name twice\")\n    this._name = name\n    this._names = uniq([name, ...toA(this.opts.aliases)])\n    this._key = envFromName(name)\n    this._keys = uniq([\n      ...this._names.map(envFromName),\n      this._key,\n      ...toA(this.opts.envAliases)\n    ])\n  }\n\n  /**\n   * This is the environment variable name for this setting:\n   */\n  get key(): string {\n    return this._key\n  }\n\n  /**\n   * This is a list of all environment keys for this setting. It will always\n   * include `this.key`.\n   */\n  get keys(): string[] {\n    return this._keys\n  }\n\n  get altKeys(): string[] {\n    return this._keys.filter(ea => ea !== this._key)\n  }\n\n  get category(): SettingCategory {\n    return this.opts.category\n  }\n\n  get categoryType(): \"system\" | \"library\" {\n    return LibraryCategories.includes(this.category) ? \"library\" : \"system\"\n  }\n\n  get transient(): boolean {\n    return this.opts.transient === true\n  }\n\n  /**\n   * Is this setting an \"advanced\" option (and can be initially hidden)?\n   */\n  get advanced(): boolean {\n    return mapOr(\n      this.opts.advanced,\n      ea => ea(),\n      () => true\n    )\n  }\n\n  /**\n   * @return the env value encoding `this.valueOrDefault`\n   */\n  get envValueOrDefault(): Maybe<string> {\n    return this.opts.toEnv(this.valueOrDefault)\n  }\n\n  set tmpValueIfUnset(t: Maybe<T>) {\n    if (this.isUnset()) this.tmpValue = t\n  }\n\n  get defaultValue(): T {\n    return tot(this.optsOverrides.defaultValue ?? this.opts.defaultValue)\n  }\n\n  set defaultValue(t: T | Thunk<T>) {\n    const prior = shallowClone(this.valueOrDefault)\n    this.optsOverrides.defaultValue = t\n    this.maybeBroadcastChange(prior)\n  }\n\n  resetDefaultValue() {\n    this.optsOverrides.defaultValue = undefined\n  }\n\n  get exampleValue(): Maybe<T> {\n    return tot(this.optsOverrides.exampleValue ?? this.opts.exampleValue)\n  }\n\n  set exampleValue(t: Maybe<T>) {\n    this.optsOverrides.exampleValue = t as any\n  }\n\n  get valueOrDefault(): T {\n    return this.value ?? this.defaultValue\n  }\n\n  /**\n   * no-op if unset\n   */\n  addToEnvMaybe<SV extends StringValued>(obj?: SV, overrideValue?: T): SV {\n    const e: any = obj ?? env()\n    // If we don't have a value, let the child take the default, or the\n    // persisted value. This fixes\n    // https://gitlab.com/photostructure/photostructure/issues/202\n    const v = this.envValue ?? overrideValue\n    if (v != null) {\n      e[this.key] = this.opts.toEnv(v)\n    }\n    if (obj == null) {\n      caseInsensitiveEnv.unset()\n    }\n    return e as SV\n  }\n\n  toEnvValue(overrideValue?: T): Maybe<string> {\n    return this.opts.toEnv(overrideValue ?? this.valueOrDefault)\n  }\n\n  addToEnv<SV extends StringValued>(obj?: SV, overrideValue?: T): SV {\n    const e: any = obj ?? env()\n    const value = this.toEnvValue(overrideValue)\n    if (value != null) {\n      e[this.key] = value\n      if (obj == null) {\n        caseInsensitiveEnv.unset()\n      }\n    }\n    return e as SV\n  }\n\n  deleteFromEnv<SV extends StringValued>(obj?: SV): SV {\n    const cie =\n      map(obj, ea => new CaseInsensitiveValued(ea)) ?? caseInsensitiveEnv()\n    for (const ea of [...this.names, ...this.keys]) {\n      cie.delete(ea)\n    }\n    return cie.obj as SV\n  }\n\n  /**\n   * Removes tmp, env, and user-set values\n   */\n  unset() {\n    this.onChange(undefined, () => {\n      this._userValue = undefined\n      this._envValue.unset()\n      this._fileValue = undefined\n      this._tmpValue = undefined\n      this.optsOverrides = {}\n      this.deleteFromEnv()\n    })\n    return this\n  }\n\n  addToJSON(): Obj {\n    return {}\n  }\n\n  toJSON() {\n    return {\n      key: this.key,\n      value: this.value,\n      defaultValue: this.opts.defaultValue\n    }\n  }\n\n  toCommentedLines() {\n    const title = this.name + \" or \" + this.key\n    const lines = wrap(\n      [\n        padding(\"-\", title.length),\n        title,\n        padding(\"-\", title.length),\n        \"\",\n        ...(this.opts.deprecated === true\n          ? [\n              \"NOTE: this setting has been deprecated and will be removed in a future version of PhotoStructure.\",\n              \"\"\n            ]\n          : []),\n        // make all newlines double-spaced:\n        `${this.opts.description.replace(/\\n+/g, \"\\n\\n\")}`\n      ],\n      WrapComments\n    )\n\n    function maybeAddList(key: string, arr: Maybe<string[]>) {\n      if (!isEmpty(arr)) {\n        lines.push(\n          ...wrap(\n            [\n              \"\",\n              (arr.length === 1 ? key : pluralize(key)) +\n                \": \" +\n                orList(arr.map(ea => stringify(ea)))\n            ],\n            WrapComments\n          )\n        )\n      }\n    }\n    maybeAddList(\"alias\", this.opts.aliases)\n    maybeAddList(\"environment alias\", this.altKeys)\n\n    for (const [key, value] of entries(this.addToJSON())) {\n      const v = Array.isArray(value)\n        ? orList(value.map(ea => stringify(ea)))\n        : stringify(value)\n      lines.push(...wrap([\"\", key + \": \" + v], WrapComments))\n    }\n\n    return lines\n  }\n\n  toEnvLine(value?: T): string {\n    return (\n      this.key +\n      \"=\" +\n      (map(value, ea => this.opts.toEnv(ea)) ?? this.envValueOrDefault)\n    )\n  }\n\n  toTomlLines(): string[] {\n    const lines: string[] = this.toCommentedLines()\n\n    wrapTomlToLines({\n      lines,\n      wrap: WrapComments,\n      key: \"example value\",\n      value: tot(this.exampleValue)\n    })\n\n    wrapTomlToLines({\n      lines,\n      wrap: WrapComments,\n      prepend: [\"Default value:\"],\n      key: this.name,\n      value: tot(this.defaultValue)\n    })\n\n    wrapTomlToLines({\n      lines,\n      key: this.name,\n      value: tot(this.fileValue)\n    })\n\n    return lines\n  }\n}\n","import { BatchClusterOptions } from \"batch-cluster\"\nimport { delimiter } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { diff, uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { FitSizes } from \"../../fe/ImageSizes\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { entries, values } from \"../../fe/Object\"\nimport { GB, KB, fmtBytes } from \"../../fe/Units\"\nimport { toS } from \"../../fe/toS\"\nimport { CaseInsensitiveMap } from \"../CaseInsensitiveMap\"\nimport { CaseInsensitiveValued } from \"../CaseInsensitiveValued\"\nimport { DefaultSensitiveEnvRegexPattern } from \"../DefaultSensitiveEnvRegexPattern\"\nimport { noColor } from \"../NoColor\"\nimport { isProd as _isProd } from \"../NodeEnv\"\nimport { channel } from \"../PhotoStructureVersion\"\nimport { PriorityClasses } from \"../PriorityClass\"\nimport { DefaultDateTimeFormats } from \"../date/DefaultDateTimeFormats\"\nimport { encodeDuration } from \"../date/DurationCodec\"\nimport { AutoVacuumModes } from \"../db/AutoVacuumModes\"\nimport { CheckpointTypes } from \"../db/CheckpointTypes\"\nimport { RepairModes } from \"../db/RepairModes\"\nimport { SynchronousModes } from \"../db/SynchronousModes\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { HealthCheckIds } from \"../health/HealthCheckIds\"\nimport { CropStrategies } from \"../img/CropStrategies\"\nimport { SharpFailOns } from \"../img/SharpFailOn\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { isElectron, isLinux, isMac, isWin } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { isRaspberryPi } from \"../platform/isRaspberryPi\"\nimport { DateTagFormats } from \"../tags/DateTagFormats\"\nimport {\n  DefaultCapturedAtTagsConst,\n  ProblematicCapturedAtTags\n} from \"../tags/DefaultCapturedAtTags\"\nimport { DefaultIncludedPreviewTags } from \"../tags/DefaultIncludedPreviewTags\"\nimport { DefaultLensMakes } from \"../tags/DefaultLensMakes\"\nimport { KeywordReparentingStrategies } from \"../tags/KeywordReparentingStrategies\"\nimport { NameTagFormats } from \"../tags/NameTagFormats\"\nimport { NameTagOrders } from \"../tags/NameTagOrders\"\nimport {\n  DefaultExcludedLinuxMountpointNames as DefaultExcludedLinuxMountpointBasenames,\n  DefaultExcludedLinuxMountpointPaths,\n  DefaultExcludedLinuxRoots\n} from \"../volumes/DefaultExcludedLinuxRoots\"\nimport { DefaultExcludedFilesystemTypes } from \"../volumes/DefaultIgnorableFilesystemTypes\"\nimport { HelmetPlugins } from \"../web/HelmetPlugins\"\nimport { cpuCount } from \"../work/CpuInfo\"\nimport { AggregateTypes } from \"./AggregateTypes\"\nimport { AssetFileSortCriteria } from \"./AssetFileSortCriteria\"\nimport { BooleanSetting } from \"./BooleanSetting\"\nimport { BoundedFloatSetting } from \"./BoundedFloatSetting\"\nimport { BoundedIntegerSetting } from \"./BoundedIntegerSetting\"\nimport { ColorDistanceFunctions } from \"./ColorDistanceFunctions\"\nimport { DominantColorKmeansRunsDefault } from \"./DominantColorKmeansRunsDefault\"\nimport { DominantColorPixelsDefault } from \"./DominantColorPixelsDefault\"\nimport { DurationSetting } from \"./DurationSetting\"\nimport { FloatSetting } from \"./FloatSetting\"\nimport { IntegerSetting } from \"./IntegerSetting\"\nimport { OptionalFileSetting } from \"./OptionalFileSetting\"\nimport { OptionalFloatSetting } from \"./OptionalFloatSetting\"\nimport { OptionalIntegerSetting } from \"./OptionalIntegerSetting\"\nimport { OptionalStringSetting } from \"./OptionalStringSetting\"\nimport {\n  LibraryCategories,\n  Setting,\n  SettingCategories,\n  SystemCategories\n} from \"./Setting\"\nimport { StringArraySetting } from \"./StringArraySetting\"\nimport { StringEnumSetting } from \"./StringEnumSetting\"\nimport { StringEnumsSetting } from \"./StringEnumsSetting\"\nimport { StringSetting } from \"./StringSetting\"\nimport { TagInferenceSettingValues } from \"./TagInferenceSettingValues\"\nimport { UpgradeChannels } from \"./UpgradeChannels\"\n\n// lazy so tests can isProd.set() us into production:\nexport const isProd = lazy(() => _isProd)\nconst isTest = () => !isProd()\n\n// WTH, amirite? This lets TypeScript not swoon over the Settings typings.\nfunction exposeNetworkWithoutAuth(): boolean {\n  return Settings.exposeNetworkWithoutAuth.valueOrDefault\n}\n\nexport const DefaultMaxEmbeddedBuffer = 250000\n\n// Most all Setting instances have keys that are prefixed with `PS_`, which let\n// them be used in environment variables without colliding with other\n// environment variables. The `PS_` prefix isn't needed otherwise.\n\n// Only Setting instances should be included in this namespace:\nexport const Settings = {\n  configDir: new OptionalStringSetting({\n    category: SettingCategories.Paths,\n    description: [\n      \"This is the system configuration directory. This can't be overridden in the system settings.toml, as it's used to _find_ the system settings.toml! This setting is here for documentation, and to allow the PS_CONFIG_DIR environment variable to override the default setting.\",\n      \"PhotoStructure's system configuration directory defaults to:\",\n      \"- Windows: %APPDATA%\\\\PhotoStructure (%APPDATA% is normally set to %HOME%/AppData/Roaming)\",\n      \"- macOS: ~/Library/Application Support/PhotoStructure\",\n      \"- Linux: ${XDG_CONFIG_DIR:$HOME/.config}/PhotoStructure.\"\n    ].join(\"\\n\"),\n    defaultValue: () => \"\", // < set by setSettingsDefaults()\n    advanced: () => false,\n    transient: true\n  }),\n\n  libraryDir: new OptionalFileSetting({\n    aliases: [\"libraryPath\", \"library\"],\n    category: SettingCategories.Paths,\n    description:\n      \"This is the absolute path to your PhotoStructure library. If missing, or set to an empty string, the welcome page will be shown when PhotoStructure launches. Use native file separators (so on windows, use back-slashes).\",\n    defaultValue: () => \"\", // < set by setSettingsDefaults()\n    advanced: () => false\n  }),\n\n  copyAssetsToLibrary: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description: `Should PhotoStructure copy photos and videos to your PhotoStructure Library? This setting holds the value for the welcome page's \"May PhotoStructure organize your photos and videos?\" section, and is called \"automatic organization\" on the website.\\nRead more about this setting here: https://photostructure.com/getting-started/automatic-library-organization/ .`,\n    defaultValue: true,\n    advanced: () => false\n  }),\n\n  // todo: add new \"organize\" StringEnumSetting that is \"copy\", \"move\", \"softlink\", \"hardlink\"\n\n  previewsDir: new StringSetting({\n    category: SettingCategories.Paths,\n    description: `This is the directory that PhotoStructure uses to store preview images. This defaults to the \".photostructure/previews\" directory inside your PhotoStructure library. Absolute paths here are supported, but if you keep your library and previews directory separated, take care when you open your library on different computers, as this setting needs to be adjusted for those computers as well.\\nNOTE: \"originalDirs\" is recommended instead of this setting; If you get \"previewsDir\" wrong, your library won't work. If you get \"originalsDir\" wrong, you just break full-screen asset zooming and playback for non-transcoded videos.\\nSee https://forum.photostructure.com/t/hybrid-photostructure-libraries/775 .`,\n    defaultValue: () => \".photostructure/previews\"\n  }),\n\n  originalsDir: new StringSetting({\n    aliases: [\"originalDir\"],\n    category: SettingCategories.Paths,\n    description: `This is the directory that PhotoStructure uses to store original images when \"copyAssetsToLibrary\" is enabled. Absolute paths are supported. Relative paths are evaluated from your libraryDir. This setting defaults to \".\", which is the same as your PhotoStructure library directory, unless you are on docker, and a /ps/originals directory exists.\\nIf you open your PhotoStructure library on a different computer, and that computer doesn't have access to your originals volume, full-screen zoom won't work, and non-transcoded videos will not play.\\nThis system setting needs to be set appropriately on different computers (it won't be set automatically!)\\nIf you have a large library and want to use an SSD, we recommend you set your libraryDir to your SSD, and use this setting to store your originals on a larger volume, rather than using the \"previewsDir\" setting.\\nSee https://forum.photostructure.com/t/hybrid-photostructure-libraries/775 and https://forum.photostructure.com/t/new-easy-mode-for-docker-coming-in-v2-1/1278/6?u=mrm .`,\n    defaultValue: \"\" // < set by setSettingsDefaults()\n  }),\n\n  scanAllDrives: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description:\n      \"Should PhotoStructure scan all folders on all drives available to this computer for photos and videos?\",\n    defaultValue: true,\n    advanced: () => false\n  }),\n\n  /**\n   * @deprecated\n   */\n  scanMyPictures: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description: `If set, PhotoStructure will automatically add your pictures directory to your \"scanPaths\" setting and then flip this setting back to false. Add your Pictures directory directly to your scanPaths setting instead.`,\n    defaultValue: false,\n    deprecated: true\n  }),\n\n  scanPaths: new StringArraySetting({\n    aliases: [\"scanPath\"],\n    category: SettingCategories.Paths,\n    description: `This holds an array of absolute paths to scan for assets. If you are setting this via an environment variable, you may use either standard PATH formatting, like \\`PS_SCAN_PATHS=\"/path/one:/path/two\"\\`, or use JSON encoding, like \\`PS_SCAN_PATHS='[\"/path/one\",\"/path/two\"]'\\`.`,\n    advanced: () => false\n  }),\n\n  argvScanPaths: new StringArraySetting({\n    category: SettingCategories.Paths,\n    description: `This holds an array of absolute paths provided on the command line to import. This overrides \"scanPaths\", and should always be scanned for changes. See https://forum.photostructure.com/t/1597/4 . For internal use only.`,\n    transient: true,\n    advanced: () => true\n  }),\n\n  // TODO:\n\n  // watchPaths: new StringArraySetting({\n  //   aliases: [\"watchPath\"],\n  //   category: SettingCategories.Paths,\n  //   description: `This holds an array of absolute paths to directories that should be watched for changes recursively. Files added, deleted, or updated will be synchronized immediately.`,\n  //   advanced: () => true\n  // }),\n\n  pidFile: new OptionalStringSetting({\n    category: SettingCategories.Paths,\n    envAliases: [\"PIDFILE\"],\n    description:\n      \"This is the absolute path to the PID file for the main process. This is optional and only used by PhotoStructure for Servers. Make sure the UID/GID that PhotoStructure runs as can read and write to this file.\",\n    exampleValue: () => \"/var/run/photostructure.pid\"\n  }),\n\n  cacheDir: new StringSetting({\n    category: SettingCategories.Paths,\n    description:\n      \"Where would you like PhotoStructure's scratch file directory? This must be a fast, local disk with several gigabytes free.\\nNote that if PS_FORCE_LOCAL_DB_REPLICA is enabled, the local DB replica will be stored in this directory while PhotoStructure is running: don't delete it!\\nIf this is set to /tmp PhotoStructure will write to a user-specific /tmp/.photostructure-cache-$UID directory.\",\n    defaultValue: () => \"\" // < set by setSettingsDefaults()\n  }),\n\n  //\n  // Cache\n  //\n\n  fsCacheSlowMs: new DurationSetting({\n    category: SettingCategories.Cache,\n    description: `If a cache entry takes longer than this value to compute, cache results for later reuse to the filesystem.\\nThe default is very short, under the assumption that cache filesystem read/writes are <10ms.\\nSet this to 0 to never cache to the filesystem.`,\n    defaultValue: () => (isTest() ? \"1\" : \"25\")\n  }),\n\n  imageCacheMs: new DurationSetting({\n    category: SettingCategories.Cache,\n    description:\n      \"Assets requiring conversion may need intermediary file storage as they are imported. These intermediary files only need to live as long as the import process for that asset. Too short of a time will result in this conversion work being re-done during import. Too long of a time will result in additional diskspace in your cache directory being consumed.\",\n    defaultValue: \"15m\"\n  }),\n\n  readdirCacheMs: new DurationSetting({\n    category: SettingCategories.Cache,\n    description:\n      \"readdir() can take a long time over slow network shares and when directories are very large. This setting controls how long to cache readdir results that are slow (which take >= .5 seconds). Too short of a time will result in low cache hit rates, and very slow imports for these problematic directories. Too long of a time will result in PhotoStructure not seeing changes made to these directories.\\nSet to 0 to disable readdir() caching.\",\n    defaultValue: \"5m\"\n  }),\n\n  readdirSizeCacheThresh: new IntegerSetting({\n    category: SettingCategories.Cache,\n    description: `If readdir() has more than this number of child elements, always cache it.\\nSet to 0 to disable readdir() caching.`,\n    defaultValue: () => (isTest() ? 32 : 1024)\n  }),\n\n  //\n  // LOGGING\n  //\n\n  quiet: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"If true, the main service won't emit lifecycle messages to stdout. Note that logStdout=true or logTail=true will override quiet=true.\",\n    defaultValue: false\n  }),\n\n  logLevel: new StringSetting({\n    envAliases: [\"PS_LOG\", \"LOG\", \"LOG_LEVEL\"],\n    category: SettingCategories.Logging,\n    description: `Determines which level of log messages are emitted to log files. May be \"debug\", \"info\", \"warn\", \"error\", \"fatal\", or several log level directives followed by a context (like \"debug:web\").`,\n    defaultValue: () => (isProd() ? \"warn\" : \"info\")\n  }),\n\n  logDir: new StringSetting({\n    category: SettingCategories.Logging,\n    description: \"Determines the directory that log files will be written to.\",\n    defaultValue: () => \"\" // < set by setSettingsDefaults()\n  }),\n\n  logCompression: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description: \"Should log files be compressed as they are rotated?\",\n    defaultValue: () => isProd() // don't compress in test or dev so logtail is happy\n  }),\n\n  logWebRequests: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description: \"Write an access log for all web requests?\",\n    defaultValue: false\n  }),\n\n  logWebDir: new OptionalStringSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"Determines the directory that log files will be written to. If unset, will use logDir.\"\n  }),\n\n  logStdout: new BooleanSetting({\n    envAliases: [\"LOG_STDOUT\", \"PS_STDOUT\"],\n    category: SettingCategories.Logging,\n    description:\n      \"Log to stdout? This should be false unless you're running a service by hand.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  tailLogs: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"Output all logs from currently running PhotoStructure processes? This should be false unless you're running a service by hand.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  logColor: new BooleanSetting({\n    // we can't alias NO_COLOR, because according to no-color.org, it's true if\n    // it has _any_ value\n    category: SettingCategories.Logging,\n    description:\n      \"Output all logs with terminal escape codes to colorize output. If NO_COLOR=1 or TERM=dumb or TERM=unknown, this defaults to false. See https://no-color.org/ .\",\n    defaultValue: () => !noColor()\n  }),\n\n  logContextLimit: new IntegerSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"PhotoStructure will only log, at most, this number of elements or key/value pairs.\",\n    defaultValue: () => 64\n  }),\n\n  logSql: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"Log SQL queries to the default log level. **Enabling this negatively impacts performance.**.\\nThis defaults to false.\",\n    defaultValue: () => false\n  }),\n\n  logServer: new OptionalStringSetting({\n    category: SettingCategories.Logging,\n    description: `Format as hostname:port or ip_address:port.\\nIf set, processes will emit log entries, formatted as GELF and separated by null bytes, via TCP.\\nIf this is set, the default PS_LOG_LEVEL drops from \"error\" to \"info\".\\nSee https://docs.greylog.org/v1/docs/gelf .`,\n    exampleValue: () => \"localhost:12201\"\n  }),\n\n  logServerLevel: new StringSetting({\n    category: SettingCategories.Logging,\n    description: `If set, this will be the log level used to filter logs before sending them to \"logServer\".`,\n    defaultValue: () => LogLevels.info\n  }),\n\n  //\n  // Filesystem\n  //\n\n  useFsWatch: new BooleanSetting({\n    category: SettingCategories.Filesystem,\n    description: `If true, PhotoStructure will use the native filesystem watch APIs to detect file changes. This is the default and recommended setting. If false, PhotoStructure will poll the filesystem for changes instead. This is not recommended, but may be useful if you're running PhotoStructure on an OS or filesystem that doesn't support change notifications, like some network filesystems.\\nSee https://nodejs.org/api/fs.html#availability for more information.`,\n    defaultValue: () => true\n  }),\n\n  allowFilesystemSleep: new BooleanSetting({\n    category: SettingCategories.Filesystem,\n    description: `If true, PhotoStructure will set disable a handful of other settings which will allow the OS to put the filesystem to sleep when it's idle. This can save power, but can also cause PhotoStructure to miss file changes.\\nThis sets sharedStatePollMs=0 and dbFsLockStaleMs=0.`,\n    defaultValue: () => false\n  }),\n\n  statTimeoutMs: new DurationSetting({\n    category: SettingCategories.Filesystem,\n    description: `Filesystem traversal can be dangerous business with scratched CDROMs and old busted hard drives. To prevent PhotoStructure from getting \"stuck\" when trying to read these devices, it will timeout directory iteration if stat() or readdir() exceeds this value. The default of 30 seconds should cover most issues with spun-down hard drives and NAS/WAN latency.`,\n    defaultValue: () => \"30s\"\n  }),\n\n  watchDebounceMs: new DurationSetting({\n    category: SettingCategories.Filesystem,\n    description: `How long to wait for a file to \"settle down\" and stop changing before the file watcher notifies listeners that the file changed. Some applications (like PhotoStructure) use work-in-progress \"atomic\" writes, but many applications overwrite in-place, which can cause the file watcher to see incomplete results until the write process is complete.\\nThe default is 500ms (½ second) to handle slow remote NASes and slow-writing applications.\\nSet to 0 to disable.`,\n    defaultValue: () => \"500ms\"\n  }),\n\n  excludedFilesystemTypes: new StringArraySetting({\n    aliases: [\"ignoredFilesystemTypes\"],\n    category: SettingCategories.Filesystem,\n    description:\n      \"Volumes with these filesystem types will never be scanned or imported.\\nThese are only relevant to Linux and macOS systems.\",\n    defaultValue: () => DefaultExcludedFilesystemTypes\n  }),\n\n  excludedRootDirectories: new StringArraySetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"PhotoStructure won't descend into these root directories looking for assets.\",\n    defaultValue: () => DefaultExcludedLinuxRoots\n  }),\n\n  excludedMountpointPaths: new StringArraySetting({\n    aliases: [\"ignoredMountpoints\"],\n    category: SettingCategories.Filesystem,\n    description:\n      \"PhotoStructure won't descend into mountpoints that match these paths.\",\n    defaultValue: () => DefaultExcludedLinuxMountpointPaths\n  }),\n\n  excludedMountpointBasenames: new StringArraySetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"PhotoStructure won't descend into mountpoints that match these names.\",\n    defaultValue: () => DefaultExcludedLinuxMountpointBasenames\n  }),\n\n  validateMountpoints: new BooleanSetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"When true, PhotoStructure ignores volumes whose mountpoints do not exist. If any volumes are unhealthy, though, this may wedge volume handlers.\",\n    defaultValue: true\n  }),\n\n  mountpoints: new StringArraySetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"If set, this value will be used instead of the cross-platform mountpoints() method. Normally only for internal use.\"\n  }),\n\n  mountpointsTtlMs: new DurationSetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"How frequently should PhotoStructure scan for new volumes (so PhotoStructure can detect when drives are inserted or ejected)? Shorter than 10-15 seconds may cause issues on Windows. A value of 0 will cache indefinitely. This defaults to 15 minutes on Windows, which relies on polling. On Linux and macOS this is set to 0 because findmnt/gio and diskutil notify mountpoint changes without polling.\",\n    defaultValue: () => (isWin ? \"15m\" : \"0\") // docker should definitely be 0\n  }),\n\n  remoteFilesystemTypes: new StringArraySetting<string>({\n    category: SettingCategories.Filesystem,\n    description: `Filesystems with these types should always be considered \"remote\".`,\n    defaultValue: [\"sshfs\", \"s3fs\"]\n  }),\n\n  retainFileBirthtimes: new BooleanSetting({\n    category: SettingCategories.Filesystem,\n    description: `Should PhotoStructure try to retain file \"birth\" times (also known as \"creation\" times) when it copies files? If enabled, note that this is a best-effort approach--Linux and some remote filesystems (like SMB) do not support this feature.`,\n    defaultValue: () => true\n  }),\n\n  //\n  // Volumes\n  //\n\n  volumeUuidFilePaths: new StringArraySetting({\n    category: SettingCategories.Volumes,\n    description:\n      'PhotoStructure will append these paths to all mountpoints to look for previously-set volume universally unique identifiers (UUIDs). The first item in this list that exists will be used, and if \"writeVolumeUuidFiles\" is true, the first item in this list will be used to write the volume UUID (which will be the partition UUID, if available, or a random UUID if not available). Windows users should use a forward slash as a path separator.',\n    defaultValue: () => [\".uuid\", \"System Volume Information/IndexerVolumeGuid\"]\n  }),\n\n  readVolumeUuidFiles: new BooleanSetting({\n    category: SettingCategories.Volumes,\n    description: `When true, PhotoStructure uses \".uuid\" files found in the root directory of volumes as the volume universally unique identifier (UUID), which supports cross-host and cross-OS library portability. Set this to false if you don't want PhotoStructure to read these \".uuid\" files.\\nNote that \"globally unique identifier,\" or \"GUID,\" is synonymous with \"UUID\" in this case. Microsoft tends to use the term \"GUID\" instead of \"UUID.\"\\nSee https://photostructure.com/faq/what-is-a-volume for more information.`,\n    defaultValue: true\n  }),\n\n  writeVolumeUuidFiles: new BooleanSetting({\n    category: SettingCategories.Volumes,\n    description: `When true, PhotoStructure (tries to) write files with universally unique identifiers into the root directory of volumes, which enables cross-host library portability. Set this to false if you don't want PhotoStructure to try to write these \".uuid\" files. See https://photostructure.com/faq/what-is-a-volume for more information.`,\n    defaultValue: true\n  }),\n\n  writeVolumeUuidMountpointBlocklist: new StringArraySetting<string>({\n    category: SettingCategories.Volumes,\n    description: `Never try to write a volume UUID file to these directories.`,\n    defaultValue: [\"sshfs\", \"s3fs\"]\n  }),\n\n  volumeMetadataTtlMs: new DurationSetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"How frequently should PhotoStructure reload volume metadata (like bytes-free, which is used in a health check)? Values less than a minute are not necessary. A value of 0 will cache indefinitely.\",\n    defaultValue: \"15m\"\n  }),\n\n  //\n  // Networking\n  //\n\n  hostname: new OptionalStringSetting({\n    category: SettingCategories.Networking,\n    description:\n      \"If set, this overrides the local hostname. Useful under docker and when OSes change hostnames due to networking bugs (see macOS).\"\n  }),\n\n  localhost: new StringSetting({\n    category: SettingCategories.Networking,\n    description: `If \"exposeNetworkWithoutAuth\" is false, what value should PhotoStructure use for localhost? (Some firewalls are OK with \"127.0.0.1\", some require \"localhost\"). See https://letsencrypt.org/docs/certificates-for-localhost/ and https://photostructure.com/faq/troubleshooting/#windows-firewall-issues .`,\n    // See https://letsencrypt.org/docs/certificates-for-localhost/\n    // and https://tools.ietf.org/html/draft-ietf-dnsop-let-localhost-be-localhost-02\n    defaultValue: () => \"127.0.0.1\"\n  }),\n\n  httpPort: new IntegerSetting({\n    category: SettingCategories.Networking,\n    description: \"Network port for HTTP access to your PhotoStructure library.\",\n    defaultValue: 1787\n  }),\n\n  //\n  // Security\n  //\n\n  trustProxy: new StringSetting({\n    category: SettingCategories.Security,\n    description: `What reverse proxies should PhotoStructure \"trust\"? See <http://expressjs.com/en/guide/behind-proxies.html>.\\nThis setting should either be \"false\" (don't trust any proxies), \"loopback\", (only trust loopback/localhost), a single subnet (like \"192.168.1.0/24\"), or a comma-delimited set of subnets.`,\n    defaultValue: \"loopback\"\n  }),\n\n  exposeNetworkWithoutAuth: new BooleanSetting({\n    category: SettingCategories.Security,\n    description:\n      \"Normally the web service is only accessible to the computer running PhotoStructure. Setting this to true will expose your library to all computers on your network. You should own or trust all systems on that network, as there is no auth in PhotoStructure currently. Future versions of PhotoStructure will add authorization mechanisms, at which point this setting will be deleted.\\n**Don't enable this unless you know what you are doing**.\",\n    defaultValue: () => isDocker()\n  }),\n\n  cspReportOnly: new BooleanSetting({\n    category: SettingCategories.Security,\n    description:\n      \"DANGEROUS: do not enforce, and only report CSP violations. This should only be set to true temporarily to assist in debugging. See https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP .\",\n    defaultValue: () => false\n  }),\n\n  upgradeInsecureRequests: new BooleanSetting({\n    category: SettingCategories.Security,\n    description: `May PhotoStructure send the Upgrade-Insecure-Requests header? PhotoStructure will set the default to true automatically if it sees _any_ request is via https.\\nSet this explicitly to false if you access PhotoStructure via both http (inside your LAN) and https (outside your LAN).`,\n    defaultValue: () => false\n  }),\n\n  cspDirective: new OptionalStringSetting({\n    category: SettingCategories.Security,\n    description:\n      \"If you're seeing CSP errors with older browsers, add your externally-available base URL to this setting, and it will be appended to the CSP directives. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src .\",\n    exampleValue: () => \"https://myphotos.example.com\"\n  }),\n\n  disabledHelmetMiddleware: new StringEnumsSetting({\n    category: SettingCategories.Security,\n    description: `What Helmet middleware should PhotoStructure disable?\\nBy default, PhotoStructure enables all middleware, but if your reverse proxy is handling HTTP headers, you may want to remove some of Helmet's functionality.\\nDisable all middleware by using the value \"all\", but know that CSP management is handled by the \"cspDirective\" and \"cspReportOnly\" settings.\\nSee https://github.com/helmetjs/helmet#reference .`,\n    defaultValue: [],\n    strEnum: HelmetPlugins\n  }),\n\n  //\n  // Process management\n  //\n\n  // TODO:\n  // webProcs: new BoundedIntegerSetting({\n  //   category: SettingCategories.Processes,\n  //   description:\n  //     \"How many webservers should PhotoStructure spin up?\",\n  //   min: 1,\n  //   max: 8,\n  //   defaultValue: () => isTest() ? 2 : cpuInfo().length < 4 ? 1 : 2\n  // }),\n\n  shortProcessNames: new BooleanSetting({\n    category: SettingCategories.Processes,\n    description: `Should PhotoStructure name its own processes \"PhotoStructure\" + the name of the sub-process, or abbreviated \"phstr\"? This defaults to false on PhotoStructure for Desktops and true everywhere else.`,\n    defaultValue: () => !isElectron\n  }),\n\n  commandTimeoutMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"How long should PhotoStructure wait for a command that touches the filesystem (and doesn't do anything computationally expensive)? Note that external hard drives can take 10-15 seconds to spin up, and antivirus apps can hang for tens of seconds on slow machines, so values less than the default may result in undesired timeouts.\",\n    // There were filesystem timeout errors with 25 seconds:\n    defaultValue: () => \"16s\"\n  }),\n\n  minDelayBetweenSpawnMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"minDelayBetweenSpawnMillis\"],\n    description:\n      \"The shorter this time is, the faster PhotoStructure will ramp up parallelism at the start of a sync. Having a larger value here mitigates initial system load from forking. See https://photostructure.github.io/batch-cluster.js/classes/BatchClusterOptions.html#minDelayBetweenSpawnMillis .\",\n    defaultValue: () =>\n      encodeDuration(new BatchClusterOptions().minDelayBetweenSpawnMillis)!\n  }),\n\n  minDelayBetweenRetriesMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"minDelayBetweenSpawnMillis\"],\n    description:\n      \"If a task has an error, should we wait a bit before retrying? This may help temper error cascades.\",\n    defaultValue: () => \"250ms\"\n  }),\n\n  maxRetries: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"If a task has an error, how many times should we retry before giving up?\\nIf you have a flaky network, this can help ensure imports are comprehensive.\\nSet this to 0 to disable retries.\",\n    defaultValue: () => 1\n  }),\n\n  streamFlushMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"streamFlushMillis\"],\n    description:\n      \"See https://photostructure.github.io/batch-cluster.js/classes/BatchClusterOptions.html#streamFlushMillis .\",\n    defaultValue: () => (isMac ? \"100ms\" : isWin ? \"200ms\" : \"30ms\")\n  }),\n\n  exiftoolProcsPerChild: new OptionalIntegerSetting({\n    category: SettingCategories.Processes,\n    description: `Each PhotoStructure process spins up an ExifTool when needed. Note that the \"web\" and \"sync\" services use exiftool, so the total number of exiftool processes will be several times larger than this value. If this is unset, this will default to roughly 50% of the number of supported concurrent imports.`\n  }),\n\n  sensitiveEnvRegExp: new StringSetting({\n    category: SettingCategories.Processes,\n    description: `PhotoStructure spawns several external processes, including \"exiftool\" and \"ffmpeg\".\\nPhotoStructure filters out environment keys  that are likely to contain sensitive information (like API access tokens or passwords) from these child processes so they aren't accidentally logged or accessible by external tools.\\nThis regex is applied case-insensitively.`,\n    defaultValue: () => DefaultSensitiveEnvRegexPattern\n  }),\n\n  syncExitTimeoutMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    description: `Wait at most this time for sync to shut down cleanly. This needs to be long enough to possibly copy the library database back to the remote filesystem if your library is stored on a network drive. Set to 0 to disable this timeout.`,\n    defaultValue: \"2m\"\n  }),\n\n  // TODO: delete this #smpfy\n  probationMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"Normally when subsystems crash, PhotoStructure restarts them after a delay. Unfortunately, if there is a persistent error, this means PhotoStructure keeps trying something that won't ever work; it looks busy, but it's just busy failing. To prevent this situation, PhotoStructure will shut down if there are high error rates within 2 minutes of starting. (2 minutes should be long enough to spin up the web process, sync process, and import at least one pending file). Setting this to 0 will prevent PhotoStructure from exiting due to high error rates.\",\n    defaultValue: \"2m\"\n  }),\n\n  minTimeBetweenServiceRestartsMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"If a service (like web or sync) is restarted due to an error, how many milliseconds must elapse before another restart is allowed? This helps prevent system load due to service flapping.\",\n    defaultValue: \"7s\"\n  }),\n\n  fatalErrorRatePerMinute: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"If PhotoStructure sees errors at a higher rate per minute than this setting, PhotoStructure will shut down. If this value is too high, PhotoStructure may look busy, but it's just busy failing. If this value is set too low, temporary errors (due to network flakiness or USB hiccups) might shut down PhotoStructure needlessly.\",\n    defaultValue: 20\n  }),\n\n  minDiskFreeGb: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure will pause processing if the GB free on the disk that your library is stored on drops below this value. The value provided here will be multiplied by 1000^3. Note that many OSes will corrupt themselves when disks fill up, and SSDs can fail as they approach full capacity. A value of less than 8 may be unsafe (due to hibernation and OS update files).\\nSet this value to 0 to disable free disk space health checks.\",\n    defaultValue: 16\n  }),\n\n  cpuLoadPercent: new BoundedIntegerSetting({\n    category: SettingCategories.Processes,\n    description: `This setting is a rough goal for PhotoStructure to load the system during library synchronization. A higher value here will allow PhotoStructure to run more tasks in parallel, but may impact your system's responsiveness. Setting this value to 0 will still allow 1 import to run.\\nThis setting is ignored if \"maxConcurrentImports\" and \"sharpThreadsPerProcess\" are set.`,\n    defaultValue: 75,\n    min: 0,\n    max: 200\n  }),\n\n  timeoutThrottleCoeff: new FloatSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"When timeouts are detected, PhotoStructure throttles back concurrency automatically, with the assumption that some system is currently being overwhelmed and that less load should result in fewer failures due to timeouts.\\nSpecifically, concurrency will be set to 1 / current rate of timeouts per minute over the past several minutes.\\nThrottling will be more aggressive as this value approaches 0. For example a value of 0.1 will be very aggressive throttling. A value of 8 will only slow down sync after many soft timeouts.\\nDisable throttling by setting to 0.\",\n    defaultValue: 1\n  }),\n\n  maxConcurrentImports: new OptionalIntegerSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"maxSyncFileJobs\"],\n    advanced: () => true,\n    description: `How many imports can PhotoStructure schedule concurrently? This will be clamped between 1 and 32.\\nIf not set, a sensible value will be computed based on \"cpuLoadPercent\".\\nIf set explicitly, this and \"sharpThreadsPerProcess\" will override \"cpuLoadPercent\" and \"maxConcurrentImportsWhenRemote\" settings.`\n  }),\n\n  maxConcurrentImportsWhenRemote: new IntegerSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"maxSyncFileJobsWhenRemote\"],\n    description: `How many concurrent files can be imported if the library is on a remote volume? This defaults to 2 to try to avoid overwhelming HDD I/O on the remote NAS. If this is larger than (cpus.length * cpuLoadPercent) or max child processes given available memory, this value will be ignored.`,\n    defaultValue: 2\n  }),\n\n  sharpThreadsPerProcess: new BoundedIntegerSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"sharpThreadsPerJob\"],\n    advanced: () => true,\n    description: `How many image processing threads can be spun per process?\\nIf set to 0 (the default), PhotoStructure will pick an optimal value based on available memory and CPU cores.`,\n    min: 0,\n    max: 8, // we don't get faster throughput with > 8 gfx threads\n    defaultValue: 0\n  }),\n\n  processPriority: new StringEnumSetting({\n    category: SettingCategories.Processes,\n    description: `By default, PhotoStructure runs child processes with a \"below normal\" priority, so your system remains usable while imports run. Changing this value to \"normal\" or \"above normal\" may speed up imports but cause your system to be unresponsive. Changing this value to \"idle\" may prevent imports from running at all.\\nFor Linux and macOS systems, see https://en.wikipedia.org/wiki/Nice_%28Unix%29 .\\nFor Windows, see https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.processpriorityclass?view=netframework-4.8 .`,\n    defaultValue: () => PriorityClasses.BelowNormal,\n    strEnum: PriorityClasses\n  }),\n\n  maxMemoryMb: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure will restart services if they use more than this value (measured in megabytes, or 1,000,000 bytes). Note that this is not the allocated memory. See maxRssMemoryMb for total allocated.\\nSet to 0 to deactivate this check.\",\n    defaultValue: () => 2048\n  }),\n\n  maxTasksPerProcess: new BoundedIntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure will recycle threads and worker processes after they handle this number of requests. Smaller values may reduce overall memory pressure. Larger values amortize startup costs over fewer restarts.\",\n    defaultValue: () => (isTest() ? 50 : 500),\n    min: 1,\n    max: 5000\n  }),\n\n  //\n  // Auth\n  //\n\n  enableArchive: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, the \"Archive\" button in Asset views will be visible and enabled for all visitors.`,\n    defaultValue: () => true\n  }),\n\n  enableDelete: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, the \"Delete\" button in Asset views will be visible and enabled for all visitors.\\nThis is a temporary setting until PhotoStructure enforces authentication/authorization.`,\n    defaultValue: () => true\n  }),\n\n  enableEmptyTrash: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, the \"Empty Trash\" button will be enabled for all visitors.\\nUntil PhotoStructure has visitor user levels, if you don't trust all your users, disable this!\\nThis setting is disabled by default if exposeNetworkWithoutAuth is true.\\nThis is a temporary setting until PhotoStructure enforces authentication/authorization.`,\n    defaultValue: () => !exposeNetworkWithoutAuth()\n  }),\n\n  enableRemove: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, the \"Remove asset\" button in Asset views will be visible and enabled for all visitors.\\nThis is a temporary setting until PhotoStructure enforces authentication/authorization.`,\n    defaultValue: () => true\n  }),\n\n  enableRemoveAssets: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, the \"Remove Assets\" buttons will be visible and enabled for all visitors.\\nUntil PhotoStructure has visitor user levels, if you don't trust all your users, disable this!\\nThis setting is disabled by default if exposeNetworkWithoutAuth is true.\\nThis is a temporary setting until PhotoStructure enforces authentication/authorization.`,\n    defaultValue: () => !exposeNetworkWithoutAuth()\n  }),\n\n  argon2TimeCost: new IntegerSetting({\n    category: SettingCategories.Auth,\n    description: `PhotoStructure encrypts user passwords with Argon2. This value sets the Argon2 \"time\" cost parameter.`,\n    // NOTE! Keep in sync with MetaSettings.setQuickSyncMode:\n    defaultValue: 8\n  }),\n\n  argon2MemoryCostMB: new IntegerSetting({\n    category: SettingCategories.Auth,\n    description: `PhotoStructure encrypts user passwords with Argon2. This value sets the Argon2 \"memory\" cost parameter, and is specified in megabytes. Each parallel thread will consume this amount of RAM: don't exceed your system memory.`,\n    // NOTE! Keep in sync with MetaSettings.setQuickSyncMode:\n    defaultValue: 64\n  }),\n\n  argon2Parallelism: new IntegerSetting({\n    category: SettingCategories.Auth,\n    description: `PhotoStructure encrypts user passwords with Argon2. This value sets the Argon2 \"parallelism\" parameter. RAM consumption will be ((this value) × argon2MemoryCost) KB of RAM: don't exceed your system memory.`,\n    // NOTE! Keep in sync with MetaSettings.setQuickSyncMode:\n    defaultValue: 1\n  }),\n\n  //\n  // DB\n  //\n\n  // Use primary/replica terminology:\n\n  forceLocalDbReplica: new BooleanSetting({\n    category: SettingCategories.Paths, // NOT .Db! The location may be local or remote depending on configuration.\n    description:\n      \"Libraries on remote filesystems can suffer from bad performance and inconsistent transactions due to slow file I/O and missing file locking mechanics. When opening libraries on remote filesystems, or if this setting is `true`, PhotoStructure will copy the library database to the `cacheDir` and perform I/O against this local replica. Changes made to the local db replica are then periodically copied back to the remote library.\\nIf you've overridden this value in the past, know that v23.5 and after should automatically set this to the correct value for you.\\nFor more details, see https://forum.photostructure.com/t/whats-force-local-db-replica/837 and https://photostructure.com/about/2023-release-notes/#-sqlite-improvements .\",\n    defaultValue: () => false\n  }),\n  dbRetries: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"If SQLITE_BUSY is encountered, how many times should an operation be retried before giving up?\",\n    advanced: () => true,\n    defaultValue: 20\n  }),\n\n  // From https://sqlite.org/pragma.html#pragma_optimize\n\n  // \"Long-running applications might also benefit from setting a timer to run\n  // \"PRAGMA optimize\" every few hours.\"\n\n  dbBackupRetentionCount: new BoundedIntegerSetting({\n    aliases: [\"dbBackupsCount\"],\n    category: SettingCategories.Db,\n    description:\n      \"How many prior backups should PhotoStructure retain? These will typically be 10-500 MB, depending on the size of your library.\\nWe don't retain that many backups by default because they get stale pretty quickly, as they fall out of sync with your filesystem and previews directory contents.\",\n    advanced: () => true,\n    defaultValue: 3,\n    max: 128,\n    min: 1\n  }),\n\n  dbAutoVacuumMode: new StringEnumSetting({\n    category: SettingCategories.Db,\n    description:\n      \"SQLite can auto-vacuum your library database, which ensures the database stays performant. If this is set to NONE, PhotoStructure will periodically run vacuum and optimizations from the sync process. For details, https://sqlite.org/pragma.html#pragma_auto_vacuum .\",\n    advanced: () => true,\n    strEnum: AutoVacuumModes,\n    defaultValue: AutoVacuumModes.INCREMENTAL\n  }),\n\n  dbWalCheckpointType: new StringEnumSetting({\n    category: SettingCategories.Db,\n    description:\n      \"The write-ahead log of your PhotoStructure library database is checkpointed periodically.\\n- Choosing 0 will disable SQLite's built-in automatic PASSIVE checkpointing.\\n- PASSIVE, FULL, RESTART, and TRUNCATE values will enable.\\nSee https://sqlite.org/pragma.html#pragma_wal_checkpoint .\",\n    strEnum: CheckpointTypes,\n    defaultValue: CheckpointTypes.TRUNCATE\n  }),\n\n  dbWalAutoCheckpoint: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"The write-ahead log of your PhotoStructure library database is checkpointed periodically by the sync subprocess.\\n- Choosing 0 will disable SQLite's built-in automatic PASSIVE checkpointing.\\nSee https://sqlite.org/pragma.html#pragma_wal_autocheckpoint .\",\n    defaultValue: 1000\n  }),\n\n  dbInvalidFKThreshold: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"When PhotoStructure runs a database recovery, it will check for foreign key violations. If there are fewer than this number of invalid rows, PhotoStructure will drop those rows, with the hope that the next sync will finish the recovery.\\nSet this to 0 to disable this recovery step, which will make any foreign key violation fatal.\",\n    defaultValue: 64\n  }),\n\n  dbSynchronousMode: new StringEnumSetting({\n    category: SettingCategories.Db,\n    description: `Change SQLite's synchronous mode.\\n\"OFF\" will cause data corruption. \"FULL\" and \"EXTRA\" may be required if you're seeing dataloss.\\nSee https://sqlite.org/pragma.html#pragma_synchronous .`,\n    strEnum: SynchronousModes,\n    defaultValue: SynchronousModes.NORMAL\n  }),\n\n  dbRepairMode: new StringEnumSetting({\n    category: SettingCategories.Db,\n    description: `PhotoStructure will automatically attempt to repair library databases that don't pass validation tests. SQLite has two repair strategies:\\n- \"dump\", which will recover from minor errors and normally retains the current schema\\n- \"recover\", which will recover as much data as possible from corrupt db. Unfortunately, this can result in an invalid and unusable schema, which is why PhotoStructure defaults to \"dump\".\\nNote that PhotoStructure validates the schema after a repair, and will report via logs and the health check system if there are any issues.`,\n    strEnum: RepairModes,\n    defaultValue: RepairModes.dump\n  }),\n\n  maxBusyDbMs: new DurationSetting({\n    category: SettingCategories.Db,\n    description:\n      \"SQLite supports concurrent readers but concurrent writers may collide, causing a LOCKED or BUSY error. PhotoStructure will retry the db operation for maxBusyDbMs milliseconds. This defaults to 45 seconds to accommodate slow hard drive spinups and VACUUM write locks.\",\n    advanced: () => true,\n    defaultValue: () => \"45s\"\n  }),\n\n  dbBusyTimeoutMs: new DurationSetting({\n    category: SettingCategories.Db,\n    description:\n      \"SQLite can time out requests if the db file is unavailable. PhotoStructure will retry those requests (up to `maxBusyDbMs`). A shorter time may help overall throughput, but may require more work done in retry logic. A longer time may be better for slower machines and slower disks. Note that setting this value to be lower than disk I/O latency (~1ms-100ms) will cause all database queries to fail.\",\n    advanced: () => true,\n    defaultValue: () => \"2s\"\n  }),\n\n  dbBackupIntervalMs: new DurationSetting({\n    category: SettingCategories.Db,\n    description:\n      \"How frequently should PhotoStructure backup your library database?\",\n    advanced: () => true,\n    defaultValue: () => (isTest() ? \"15s\" : \"30m\")\n  }),\n\n  // We're using a bounded float so we can get fractional minutes for test, and\n  // users don't have to think in milliseconds.\n  dbBackupIntervalMinutes: new BoundedFloatSetting({\n    category: SettingCategories.Db,\n    description: `This setting was replaced by \"dbBackupIntervalMs\".`,\n    min: isTest() ? 0.5 : 1, // < force a backup in the middle of the SyncService and ModelDbUpdater tests to exercise pause-for-vacuum\n    max: 60 * 24,\n    advanced: () => true,\n    defaultValue: () => (isTest() ? 0.5 : 30)\n  }),\n\n  dbPageSizeBytes: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"This value will be used for SQLite's page_size PRAGMA. A default of 4k should be OK. This must be a power of 2. See https://sqlite.org/pragma.html#pragma_page_size for more information.\",\n    advanced: () => true,\n    defaultValue: 4096\n  }),\n\n  dbCacheSizeMb: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"This value will be used for SQLite's cache_size PRAGMA. The cache_size pragma should ideally be set such that the whole DB can be in memory. Note that PhotoStructure automatically increases this value to accommodate your library as it gets larger, if there is sufficient memory, so this setting is only a lower bound. See https://sqlite.org/pragma.html#pragma_cache_size for more information.\",\n    advanced: () => true,\n    defaultValue: 128\n  }),\n\n  dbBatchSelectSize: new BoundedIntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"How many objects can be selected at at time? The default should be fine. (Exposed for performance tests).\",\n    advanced: () => true,\n    defaultValue: 128,\n    min: 1,\n    max: 900\n  }),\n\n  dbBatchUpsertSize: new BoundedIntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"How many objects can be upserted at at time? The default should be fine. (Exposed for performance tests).\",\n    advanced: () => true,\n    defaultValue: 16,\n    min: 1,\n    max: 500\n  }),\n\n  dbForceRecover: new BooleanSetting({\n    category: SettingCategories.Db,\n    aliases: [\"dbForceRebuild\"],\n    transient: true,\n    description:\n      \"SQLite databases can sometimes be repaired with SQLite's .recover tooling. Set this to true to have PhotoStructure attempt a .recover on startup.\\nThis can take a while to perform, especially on large libraries or slow computers: don't set this value to true normally.\\nSee https://sqlite.org/recovery.html .\",\n    defaultValue: () => false\n  }),\n\n  dbBackupRemoteOnSuspend: new BooleanSetting({\n    aliases: [\"backupRemoteDbOnSuspend\"],\n    category: SettingCategories.Db,\n    description:\n      \"Run a database backup when system suspend is requested and the database is on a remote volume.\",\n    defaultValue: () => true\n  }),\n\n  // dbFtsTokenizer: new StringSetting({\n  //   category: SettingCategories.Db,\n  //   description: `PhotoStructure uses SQLite's full-text search index to support queries. The value provided here will be fed to the \"tokenize\" option. You may want to try the new \"trigram\" tokenizer, if you want substring tag path matches. Restart PhotoStructure to make this take affect.`,\n  //   defaultValue: \"unicode61\"\n  // }),\n\n  //\n  // Files\n  //\n\n  trySoftDeletes: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, \"Empty Trash\" will _try_ to move files into the \"Trash can\" or \"Recycle bin\", when possible. If moving a file into the trash can fails (due to permissions or filesystem functionality), the file will be \"hard\" deleted (or \"unlinked\"). This setting defaults to false on docker.`,\n    defaultValue: () => (isTest() ? true : !isDocker())\n  }),\n\n  //\n  // Health checks\n  //\n\n  skipHealthCheckIds: new StringEnumsSetting({\n    category: SettingCategories.HealthChecks,\n    description:\n      \"List of health check IDs to skip. Note that windows skips the 'proc-not-superuser' check by default, as most people on Windows run as an admin user.\",\n    defaultValue: isWin ? [\"proc-not-superuser\"] : [],\n    strEnum: HealthCheckIds\n  }),\n\n  //\n  // Video\n  //\n\n  ffmpegHwaccel: new StringSetting({\n    category: SettingCategories.Video,\n    description: `FFmpeg supports both software and hardware encoders. Valid values include \"auto\" which should work for everyone, \"cuda\" for NVIDIA GPUs, or use \"disable\", \"no\", \"false\", or \"\" to disable. Run \"ffmpeg -hwaccels\" to see supported acceleration methods. See https://forum.photostructure.com/t/hardware-accelerated-encoding-transcoding/166>, https://trac.ffmpeg.org/wiki/HWAccelIntro , and <https://github.com/NVIDIA/nvidia-docker for more details.`,\n    defaultValue: \"disable\"\n  }),\n\n  ffmpegThreads: new OptionalIntegerSetting({\n    category: SettingCategories.Video,\n    advanced: () => true,\n    description: `When transcoding videos, what value should we give to \"ffmpeg -threads\"?\\nThis defaults to min(1, <# of cpus> * cpuLoadPercent / 4).\\nNote that \"ffmpeg -threads\" _most likely doesn't do what you expect_: a value of 0 will consume all CPUs (which is why it isn't allowed). A value of N will actually mean > N CPUs are used (due to demux threading and other details). See https://stackoverflow.com/a/41010102 .`\n  }),\n\n  ffmpegAvcTranscodeArgs: new StringArraySetting({\n    category: SettingCategories.Video,\n    aliases: [\"ffmpegTranscodeArgs\"],\n    description: `The following are the default arguments added to transcode requests made to ffmpeg, when ffmpeg is available. The following arguments will follow \"ffmpeg -loglevel error -threads T -i INPUT_FILE_PATH\" (where T is replaced by ~half the available CPU threads, and INPUT_FILE_PATH is the full native pathname to the source video).\\nIf your videos are in high colorspace like bt2020, you may want to remove the \"-vf\" and \"colorspace=all=bt2020:iall=bt601-6-625:fast=1\" options, but this may cause rendering issues on SDR displays. See https://forum.photostructure.com/t/1003/3 for more details.\\nCAUTION: this is an advanced setting. Invalid values may cause videos that require transcoding to not be imported, or not be viewable on some browsers.`,\n    defaultValue: [\n      \"-c:a\",\n      \"aac\",\n      \"-c:v\",\n      \"libx264\",\n      // pix_fmt and profile are required by firefox (!!)\n      \"-pix_fmt\",\n      \"yuv420p\",\n      \"-vf\",\n      \"colorspace=all=bt709:iall=bt601-6-625:fast=1\",\n      \"-colorspace\",\n      \"bt709\",\n      // See\n      // https://forum.photostructure.com/t/trouble-transcoding-iphone8-video-possibly-stalling-progress-of-library-import/1003/3?u=mrm\n      // and\n      // https://medium.com/invideo-io/talking-about-colorspaces-and-ffmpeg-f6d0b037cc2f\n      // \"-color_trc\", \"smpte2084\", \"-color_primaries\", \"bt2020\",\n      // https://ffmpeg.org/ffmpeg-filters.html#colorspace\n      // https://ffmpeg.org/ffmpeg-formats.html#Options-11\n\n      // https://discord.com/channels/818905168107012097/818907922767544340/872836920948961381\n      // Zirro — 08/05/2021 A suggestion in case you haven't heard of it - you\n      // might want to look into using -movflags +faststart as part of the\n      // default ffmpeg transcoding arguments. It places the moov atom which\n      // contains essential metadata for streaming the video at the start rather\n      // than the end of the MP4 file. Otherwise browsers (and other streaming\n      // clients) have to download the whole file before they can start playing\n      // it, sometimes delaying playback significantly. The option is widely\n      // used and recommended, so I don't believe there are any concerns with\n      // regards to compatibility from using it. ( for the curious, looks like\n      // there's been some movement on supporting more pixel formats in Firefox\n      // within recent months:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1459526 )\n      \"-movflags\",\n      \"+faststart\"\n      // \"-profile:v\",\n      // \"high\"\n    ]\n  }),\n\n  transcodeMaxResolution: new IntegerSetting({\n    category: SettingCategories.Video,\n    description: `If a video that needs transcoding exceeds this total pixel resolution, the transcoded version will be downsampled to be at most this resolution, preserving the original aspect ratio.\\nVideos that are smaller than this resolution will not be downsampled.\\nThis setting does not work with VLC (use ffmpeg instead--it's faster!).\\nUse 2073600 for \"Full HD\", or 1080P.\\nUse 921600 for 720P (1280 × 720).\\nNote that in any case, videos that don't need transcoding will not be downsampled.\\nSet this to 0 to disable this setting.`,\n    defaultValue: 0\n  }),\n\n  transcodeVideos: new BooleanSetting({\n    category: SettingCategories.Video,\n    description: `Should videos that are not in a browser-supported format be transcoded during import? Note that this is a plus-only feature. FFmpeg or VLC must be installed. Note that this *dramatically* slows down imports, and *dramatically* increases the disk space your library will need to use, but allows you to see videos that aren't directly supported by your browser. If this is set to false, your browser will only render videos directly supported by your OS.`,\n    defaultValue: true\n  }),\n\n  transcodeBitrateQVGA: new IntegerSetting({\n    category: SettingCategories.Video,\n    description:\n      \"What max bitrate should PhotoStructure encode QVGA (320 × 240) videos? Videos with resolutions between QVGA and UHD will use an interpolated value between these two settings, and will not exceed the encoded bitrate of the original video. This value is in kilobytes per second.\",\n    defaultValue: 800\n  }),\n\n  transcodeBitrateUHD: new IntegerSetting({\n    category: SettingCategories.Video,\n    description:\n      \"What max bitrate should PhotoStructure encode UHD (3840 × 2160) videos? Videos with resolutions between QVGA and UHD will use an interpolated value between these two settings, and will not exceed the encoded bitrate of the original video. This value is in kilobytes per second.\",\n    defaultValue: 18_000\n  }),\n\n  doNotTranscodeMimeTypes: new StringArraySetting({\n    category: SettingCategories.Video,\n    description: `Videos are transcoded when the \"transcodeVideos\" is set to true and is not one of the following MIME types.\\nSee https://www.iana.org/assignments/media-types/media-types.xhtml#video for a complete list.\\nIf you are setting this via an environment variable, you can separate the values either like a PATH (like \"video/quicktime:video/mp4\") or use JSON encoding (like \"['video/quicktime','video/mp4']\").`,\n    defaultValue: () => [\n      \"video/quicktime\",\n      \"video/mp4\",\n      \"video/mpv\",\n      \"video/mp2t\"\n    ]\n  }),\n\n  doNotTranscodeVideoCodecs: new StringArraySetting({\n    category: SettingCategories.Video,\n    description: `Videos are transcoded when the \"transcodeVideos\" is set to true and is not one of the following video codecs. The video codec may be stored in the \"VideoCodec\", \"CompressorID\", or \"CompressorName\" tags.`,\n    defaultValue: () => [\"avc1\"] // CompressorID: \"hvc1\" is HEVC.\n  }),\n\n  doNotTranscodeAudioCodecs: new StringArraySetting({\n    category: SettingCategories.Video,\n    description: `Videos are transcoded when the \"transcodeVideos\" is set to true and is not one of the following audio codecs. The audio codec is stored in the \"AudioCodec\" tag.`,\n    defaultValue: () => [\"mp4a\", \"sowt\"]\n  }),\n\n  //\n  // TOOLS\n  //\n\n  enableSIMD: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `Should PhotoStructure enable SIMD extensions when running image operations? This defaults to false on macOS and Raspberry Pis due to instability on those platforms.`,\n    // isTest() to make the result consistent across CI:\n    defaultValue: () => (isRaspberryPi() ? false : true)\n  }),\n\n  enableVipsCache: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `Should PhotoStructure enable VIPS caching, which may help speed up image operations? Note that this increases memory usage, and cache hit rates are low.`,\n    defaultValue: () => false\n  }),\n\n  showFileInFolderUsesThunar: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `If we're on Linux, should we use Thunar (via dbus) to \"show file in folder\"?`,\n    defaultValue: false\n  }),\n\n  showFileInFolderUsesFileUri: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `Does the showFileInFolderCommand expect a file: URI to the file? If this is false, the native path will be appended instead.`,\n    exampleValue: () => true,\n    defaultValue: () => isLinux\n  }),\n\n  showFileInFolderCommand: new StringArraySetting({\n    category: SettingCategories.Tools,\n    description: `If set, the first argument will be used as a command (or path to command), and the subsequent arguments (if present) will be used as arguments. The native path to the file or the file: URI will be appended, based on the value given to the \"showFileInFolderUsesFileUri\" setting. If this is set to an empty array, the default tool for your platform will be used instead: \"nautilus -s\" on linux, \"open -R\" on mac, and \"explorer /select\" on Windows.\\nThis is provided to support Linux desktops that don't use Gnome.`,\n    defaultValue: []\n  }),\n\n  dcraw_emuPath: new StringSetting({\n    category: SettingCategories.Tools,\n    description: `This should be the absolute, native path to the \"dcraw_emu\" binary on this system. If this is set to \"dcraw_emu\", PhotoStructure will search your $PATH. See https://www.libraw.org/docs/Samples-LibRaw.html .`,\n    defaultValue: \"dcraw_emu\"\n  }),\n\n  ffmpegPath: new StringSetting({\n    category: SettingCategories.Tools,\n    description: `This should be the absolute, native path to the \"ffmpeg\" binary on this system. If this is set to \"ffmpeg\", PhotoStructure will search your $PATH. PhotoStructure prefers using ffmpeg to vlc. See https://photostructure.com/getting-started/video-support/ .`,\n    defaultValue: \"ffmpeg\"\n  }),\n\n  heifConvertPath: new StringSetting({\n    category: SettingCategories.Tools,\n    description: `This should be the absolute, native path to the \"heif-convert\" binary on this system. If this is set to \"heif-convert\", PhotoStructure will search your $PATH. See https://photostructure.com/getting-started/heif-support/ .`,\n    defaultValue: \"heif-convert\"\n  }),\n\n  powerShellArgs: new StringArraySetting({\n    category: SettingCategories.Tools,\n    description: `The following are the default arguments added to spin up PowerShell on Windows devices.\\nSee https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_exe?view=powershell-5.1 for all arguments that PowerShell.exe accepts.\\nSee https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-5.1 for a description of Bypass.\\nSee https://forum.photostructure.com/t/eliminate-powershell-profile-and-execution-policy-related-errors/184 for more details about why this needs to be configurable.\\n(Versions prior to v1.0.0 only specified \"-NoLogo\").`,\n    defaultValue: [\"-NoLogo\", \"-NoProfile\", \"-ExecutionPolicy\", \"Bypass\"]\n  }),\n\n  powerShellCulture: new StringSetting({\n    category: SettingCategories.Tools,\n    description:\n      \"If set to a non-blank value, PhotoStructure on Windows machines will set PowerShell's `[System.Threading.Thread]::CurrentThread.CurrentCulture` to this value. This allows PhotoStructure to parse PowerShell output reliably.\",\n    defaultValue: () => \"en-US\"\n  }),\n\n  powerShellProcs: new IntegerSetting({\n    category: SettingCategories.Tools,\n    description:\n      \"How many PowerShell child processes may each PhotoStructure process run? Defaults to max(2, (maxCpus() / 4)).\",\n    defaultValue: () => 2\n  }),\n\n  toolPaths: new StringArraySetting({\n    category: SettingCategories.Tools,\n    description: `These paths are appended to the PATH to ensure PhotoStructure can find and run external tools like ffmpeg. Use your operating system's separator to separate paths (\":\" for mac and linux, \";\" for windows).`,\n    defaultValue: () => [] as string[] // < set by setSettingsDefaults()\n  }),\n\n  vlcPath: new StringSetting({\n    category: SettingCategories.Tools,\n    description: `This should be the absolute, native path to the \"vlc\" binary on this system. If this is set to \"vlc\", PhotoStructure will search your $PATH.`,\n    defaultValue: \"vlc\"\n  }),\n\n  //\n  // Electron\n  //\n\n  updateChannel: new StringEnumSetting({\n    category: SettingCategories.Desktops,\n    description:\n      'TL:DR; keep this on \"stable.\" This setting only applies to PhotoStructure for Desktops, and controls which builds of PhotoStructure you are eligible to automatically update to. Please note that \"prealpha\" and \"alpha\" builds may not even launch, and \"beta\" builds have not been thoroughly tested. See https://forum.photostructure.com/t/alpha-beta-stable-and-latest-what-should-you-use/274 .',\n    defaultValue: () => (isTest() ? \"stable\" : channel()),\n    strEnum: UpgradeChannels\n  }),\n\n  updateOnLaunch: new BooleanSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"If true, PhotoStructure will check for updates automatically on launch.\",\n    defaultValue: true\n  }),\n\n  updateCheckMinutes: new IntegerSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"While running, PhotoStructure will check periodically for updates. The default is daily.\\nSet this to 0 to disable automatic updates.\",\n    defaultValue: 60 * 24\n  }),\n\n  autoHideMenuBar: new BooleanSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"If true, PhotoStructure for Desktops on Windows and Linux will auto hide the menu bar unless the Alt key is pressed.\",\n    defaultValue: false\n  }),\n\n  hideOnLaunch: new BooleanSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"If true, PhotoStructure for Desktops will not open the main window when launched. The tray icon will still be visible.\\nThis setting is ignored by PhotoStructure for Server editions.\",\n    defaultValue: false\n  }),\n\n  pauseSyncOnBattery: new BooleanSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"If true, PhotoStructure for Desktops will pause sync when the system is on battery power.\\nThis setting is ignored by PhotoStructure for Server editions.\",\n    defaultValue: false\n  }),\n\n  //\n  // Reporting\n  //\n\n  email: new OptionalStringSetting({\n    category: SettingCategories.Reporting,\n    description:\n      \"If set, this email will be used for license subscriptions and added to error reports, so we can contact you to help debug the issue. It is not required. Setting a value here does not subscribe you to any marketing emails.\",\n    exampleValue: () => \"email@example.com\",\n    advanced: () => false\n  }),\n\n  reportErrors: new BooleanSetting({\n    category: SettingCategories.Reporting,\n    description:\n      \"If true, PhotoStructure will send crash reports when it encounters errors. Crash reports may include the path to the file that caused an error, system metadata, and recent log messages.\",\n    defaultValue: true,\n    advanced: () => false\n  }),\n\n  maxErrorsPerDay: new IntegerSetting({\n    category: SettingCategories.Reporting,\n    description:\n      \"Set this to zero to remove all bugs in PhotoStructure.\\nHUR HUR #DADJOKE\\nIf your system generates more than this number of errors in the course of a day, the subsequent error reports will not be reported.\",\n    defaultValue: 3\n  }),\n\n  //\n  // WEB\n  //\n\n  minStreamCorrPct: new BoundedIntegerSetting({\n    category: SettingCategories.Web,\n    description: `Streams (shown on the asset page) are coalesced when the dice coefficient of their contents are greater than this value. A value of 100 requires streams to match exactly. A value of ~50 allows streams with a couple differences to be considered the \"same\" stream.`,\n    defaultValue: () => 50,\n    max: 100,\n    min: 1\n  }),\n\n  lazyLoadExtraVh: new IntegerSetting({\n    category: SettingCategories.Web,\n    description: `PhotoStructure only loads photos as they come close to the viewport. This setting determines what \"close to the viewport\" means, and is measured in \"vh\" units, or percentage points of your visitor's browsers view height.\\nThe default is 50, so approximately the next 50% of the screen will be pre-loaded before the user scrolls.\\nIf you have fast hardware and fast network, you could try bumping this up to 200.\\nIf you have very slow network, you might want to set this to 0.`,\n    defaultValue: 50\n  }),\n\n  hiddenHomeTags: new StringArraySetting({\n    category: SettingCategories.Web,\n    description: `The given root tags will be omitted from the home page. (Valid values include \"When\", \"Camera\", \"Lens\", \"Type\", \"Fs\", and \"Keyword\").`,\n    defaultValue: () => [\"Type\"]\n  }),\n\n  placeholderThumbs: new BooleanSetting({\n    category: SettingCategories.Web,\n    description:\n      \"Render missing asset previews as placeholder images (only useful for customer support).\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  fastForwardEmptyTags: new BooleanSetting({\n    category: SettingCategories.Web,\n    description: `When browsing tags in the UI, should tags that only have one child tag and no direct assets be skipped, or \"fast-forwarded,\" over? See https://forum.photostructure.com/t/volume-id-shows-as-a-tag/754/5 for context.`,\n    defaultValue: true\n  }),\n\n  // TODO:\n\n  // sessionTimeoutHours: new BoundedIntegerSetting({\n  //   category: SettingCategories.Web,\n  //   description:\n  //     \"How long should unused HTTP sessions exist before requiring visitors to log back in? This defaults to 180 days, just to maximize convenience.\",\n  //   defaultValue: 24 * 30 * 6,\n  //   max: 24 * 365,\n  //   min: 1\n  // }),\n\n  //\n  // Sync\n  //\n\n  syncReportsDir: new StringSetting({\n    category: SettingCategories.Sync,\n    description: `Detailed reports for every sync are stored in this directory, which defaults to \".photostructure/sync-reports\" within your PhotoStructure library. Absolute paths here are supported.`,\n    defaultValue: () => \".photostructure/sync-reports\"\n  }),\n\n  syncReportMaxRows: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"Some software can't open large CSVs, so PhotoStructure will start a new sync report if the rows exceed this value. Excel and LibreOffice can open million-row CSVs, so that's our default.\",\n    defaultValue: () => 1_000_000\n  }),\n\n  quickSyncMode: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should PhotoStructure disable a bunch of features to make imports faster? Note that this disables image validation, video transcoding, image hashing (required for good deduplication), metadata inference, and more efficient preview encoding. It is true by default on Raspberry Pis and false everywhere else.`,\n    defaultValue: () => isRaspberryPi()\n  }),\n\n  taskTimeoutMs: new DurationSetting({\n    category: SettingCategories.Sync,\n    aliases: [\"taskTimeoutMillis\"],\n    description:\n      \"What's the longest time it can validly take to fetch a file SHA, generate image previews for an asset, compute an image hash, or extract tags for a file?\\nOn a reasonable server and disk, these tasks should take a handful of seconds, but the default allows for a (busy!) RPi on a slow, remote disk to not timeout.\",\n    defaultValue: () => \"2m\"\n  }),\n\n  // it's \"scanPaths\", so \"scan\" should match here (rather than the \"sync\" prefix):\n  scanLibraryFirst: new BooleanSetting({\n    aliases: [\"syncLibraryFirst\"],\n    category: SettingCategories.Sync,\n    description:\n      \"Should PhotoStructure scan your library before all other paths are synchronized?\\nThis defaults to true if you are using automatic organization, to make sure existing files in your library are in sync with your library database. This prevents additional copies of the same SHA being copied into your library directory if you have automatic organization enabled.\",\n    defaultValue: true\n  }),\n\n  scanLibraryLast: new BooleanSetting({\n    aliases: [\"syncLibraryLast\"],\n    category: SettingCategories.Sync,\n    description:\n      \"Should PhotoStructure scan your library after all other paths are synchronized?\",\n    defaultValue: false\n  }),\n\n  progressRetentionDays: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"How many days of sync progress should we keep around in the database before it's removed?\",\n    defaultValue: 180\n  }),\n\n  progressStaleDays: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When sync starts, it tries to pick up where it was previously, but this doesn't make sense if the prior work was done a while ago, as it is more likely that the filesystem has changed since.\",\n    defaultValue: 6\n  }),\n\n  copyToLibraryMimeTypes: new StringArraySetting({\n    category: SettingCategories.Sync,\n    description: `When \"automatic organization\" is enabled, files whose mimetypes are included in this list will be copied into your originals directory.\\nNote that MIME types can include an asterisk to do glob-matching.\\nSee the related system setting \"copyAssetsToLibrary\".\\nA list of MIME types are here: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types .`,\n    defaultValue: () => [\"image/*\", \"video/*\"]\n  }),\n\n  onlyNativeFileCopy: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should PhotoStructure skip the built-in file copy code, and only use the \"OS native\" file copy mechanism?\\nPhotoStructure is typically faster than native file copies by 2x or more.\\nIf true, PhotoStructure will use \"cp\" on macOS and Linux, and PowerShell \"Copy-Item\" on Windows.`,\n    defaultValue: false\n  }),\n\n  verifyFileCopies: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should PhotoStructure verify all file copies by comparing SHAs of the source and destination? This shouldn't be necessary on most OSes and filesystems, and slows down library imports.`,\n    defaultValue: true\n  }),\n\n  assetPathnameFormat: new StringSetting({\n    category: SettingCategories.Sync,\n    description: `If you opt into \"automatic organization\" (see the setting \"copyAssetsToLibrary\"), they will be copied into <originals directory>/<result of assetPathnameFormat>.\\n- See the originalsDir system setting for what your <originals directory> is (it defaults to your library root directory).\\n- Please encode this path with forward-slashes, even if you're on Windows.\\n- If any patterns resolve to including forward-slashes, know that will be interpreted as subdirectories.\\n- If you want to add a static path, escape the pathname with single quotes (like \"'photos'/y/MM/dd\").\\n- The result of this will always be interpreted as a relative path from your PhotoStructure originals directory.\\n- Use token \"BASE\" as a shorthand for the original basename (\"photo.jpg\" for \"/path/to/photo.jpg\").\\n- Use token \"NAME\" as a shorthand for the original filename, without the file extension (\"photo\" for \"/path/to/photo.jpg\").\\n- Use token \"PARENT\" as a shorthand for the original file's parent directory name (\"to\" for \"/path/to/photo.jpg\").\\n- Use token \"GRANDPARENT\" as a shorthand for the original file's grandparent directory name (\"path\" for \"/path/to/photo.jpg\").\\n- Use token \"EXT\" for the filename's extension without the \".\" prefix (like \"jpg\" for \"/path/to/photo.jpg\").\\n- Use token \"ISO\" as a shorthand for \"yyyy-MM-dd'T'HH:mm:ss.SSSZZ\".\\n- You can escape other static text by wrapping with single quotes.\\n- For other tokens, see https://moment.github.io/luxon/#/formatting?id=table-of-tokens .\\n- See https://forum.photostructure.com/t/how-to-change-the-naming-structure/1184/2?u=mrm for more details.`,\n    defaultValue: \"y/y-MM-dd/BASE\"\n  }),\n\n  writeSourceTagToLibraryCopies: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should PhotoStructure write to the \"Source\" tag add metadata to assets copied into your library that includes the path where the file was originally found? This defaults to false to prevent adding sidecars to every file in your library.`,\n    defaultValue: false\n  }),\n\n  /**\n   * @deprecated\n   */\n  assetSubdirectoryDatestampFormat: new StringSetting({\n    category: SettingCategories.Sync,\n    envAliases: [\"PS_ASSET_SUBDIR_FORMAT\"],\n    description: `This setting has been replaced by \"assetPathnameFormat\".\\nIf this setting is provided, and assetPathnameFormat is _not_ provided, we will give assetPathnameFormat the value of this setting + \"/BASE\".`,\n    defaultValue: \"\",\n    deprecated: true\n  }),\n\n  startPaused: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"Should processing be paused by default when PhotoStructure starts? You'll have to manually resume processing via the system tray or nav menu.\",\n    defaultValue: false\n  }),\n\n  /**\n   * @deprecated\n   */\n  syncIntervalHours: new OptionalIntegerSetting({\n    category: SettingCategories.Sync,\n    description: `This setting has been replaced by \"syncNewIntervalMs\" and \"syncChangedIntervalMs\".`,\n    deprecated: true\n  }),\n\n  syncNewIntervalMs: new DurationSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"This value controls both how often the sync process discovers new files for any given volume.\\nNote that this value is the duration between the last completion time and when the next sync should be scheduled.\\nWARNING: Setting this value to a small value will mean PhotoStructure is constantly scanning your disks, which will add wear and tear and possibly reduce the lifespan of your storage media.\",\n    defaultValue: \"1d\"\n  }),\n\n  syncChangedIntervalMs: new DurationSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"This value controls both how often the sync process discovers new or changed files for any given volume.\\nNote that this value is the duration between the last completion time and when the next sync should be scheduled.\\nWARNING: Setting this value to a small value will mean PhotoStructure is constantly scanning your disks, which will add wear and tear and possibly reduce the lifespan of your storage media.\",\n    defaultValue: \"7d\"\n  }),\n\n  retryEnqueued: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `After finishing a directory sync, should PhotoStructure look at recent sync-reports and retry files that are \"stuck\" in \"enqueued\" state?\\nThis shouldn't be necessary, but it's a backstop to ensure syncs are comprehensive.`,\n    defaultValue: true\n  }),\n\n  forceRebuildLibrary: new BooleanSetting({\n    category: SettingCategories.Sync,\n    aliases: [\"rebuild\"],\n    description:\n      \"When set, all files in your library will be re-imported (caution: slow!).\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  dropWorkQueues: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, all files will be visited, even if the asset seems in sync with the filesystem.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  forceSync: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, all files will be visited, even if the asset seems in sync with the filesystem.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  forceRebuildPreviews: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, previews and transcoded videos will always be rebuilt.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  noModelUpdates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, skip any pending library database updates (only used for tests).\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  exitWhenDone: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, the sync process will exit after jobs are completed (used internally and for tests).\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  overwriteOriginal: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should changes made through the UI, like rotations, captions, and keywords, overwrite the original file? This is potentially dangerous, as your original may be lost if the disk has errors, or there are issues in rewriting the file contents. If this is set to false, the original file will be retained in the same directory. \"image.jpg\" will be stored as \"image_original.jpg\".`,\n    defaultValue: false\n  }),\n\n  maxDuplicatePathElements: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"How many times can a given path element exist in a directory before it is considered within an infinite filesystem loop, and should be skipped from import?\",\n    defaultValue: 7\n  }),\n\n  noAssetFileUpdates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should outdated AssetFiles be ignored on startup? (Only used for tests).`,\n    defaultValue: false,\n    transient: true\n  }),\n\n  noAssetUpdates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should outdated Assets be ignored on startup? (Only used for tests).`,\n    defaultValue: false,\n    transient: true\n  }),\n\n  resyncAssetOnVisit: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should Assets be automatically re-synchronized whenever their info panel is viewed? This can make sure Assets are in-sync with the filesystem, but this can slow down current imports, and add load to slower computers. This defaults to true only if the current machine has >= 8 CPUs.`,\n    defaultValue: () => (isTest() ? true : cpuCount() >= 8)\n  }),\n\n  excludeNoMediaAssetsOnRebuild: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should previously-imported assets that are found to have *any* files in NoMedia directories be excluded from your library?`,\n    defaultValue: () => true\n  }),\n\n  //\n  // Sidecars\n  //\n\n  matchSidecarsCaseInsensitively: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will look for sidecar files that match file basenames (with or without the file extension), regardless of case (for example: \"IMAGE.XMP\" will be a sidecar for \"image.jpg\").\\nIf set to false, sidecars must match case (so only \"image.jpg.xmp\" and \"image.xmp\" will match for \"image.jpg\").`,\n    defaultValue: true\n  }),\n\n  matchSidecarsFuzzily: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will look for sidecar files that match the basename of the asset, plus some common suffixes (like \"-edit\", \"-edited\", or variant copies, like \"-2\").\\nThis setting only impacts .XMP, .MIE, and .EXIF sidecars.\\nNote that PhotoStructure always matches .JSON files fuzzily, as that is required to handle Google Takeouts properly.`,\n    defaultValue: false\n  }),\n\n  defaultSidecarType: new StringSetting({\n    category: SettingCategories.Sidecars,\n    description: `What type of sidecar file do you want to generate for non-destructive edits?\\n- \"XMP\" is a popular and well-adopted format.\\n-\"MIE\" is defined at https://exiftool.org/TagNames/MIE.html .\\n- \"EXIF\" and \"EXV\" should only be used if required, as they have substantial limitations.\\nCase is preserved.`,\n    defaultValue: \"xmp\"\n  }),\n\n  writeMetadataToSidecarsIfImage: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will write metadata changes made to images into sidecars. If set to false, PhotoStructure will overwrite original images with metadata changes.`,\n    defaultValue: true\n  }),\n\n  sidecarTagBlocklist: new StringArraySetting<string>({\n    category: SettingCategories.Sidecars,\n    description: `Many applications don't read metadata from sidecars, which can make some tags, like Orientation or Rating, not seem to work properly in other applications. This setting is ignored if writeMetadataToSidecarsIfImage, writeMetadataToSidecarsIfVideo, and writeMetadataToSidecarsIfSidecarExists are all set to false.`,\n    defaultValue: () => [\"Orientation\"]\n  }),\n\n  writeMetadataToSidecarsIfVideo: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will write metadata changes made to videos into sidecars. If set to false, PhotoStructure will overwrite original videos with metadata changes. This defaults to false, as most software does not use sidecars except for images.`,\n    defaultValue: false\n  }),\n\n  writeMetadataToSidecarsIfSidecarExists: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will write metadata changes into sidecars if the file already has a sidecar and the tag is not in the sidecarTagBlocklist.`,\n    defaultValue: true\n  }),\n\n  // mergeLibrarySidecars: new BooleanSetting({\n  //   category: SettingCategories.Sidecars,\n  //   description: `If this and \"copyAssetsToLibrary\" are set to true, PhotoStructure will merge tag values found in variations into a single sidecar per asset. `,\n  //   defaultValue: true\n  // }),\n\n  // TODO: noMediaAssetAction (hide in library, exclude from library, trash from filesystem)\n\n  //\n  // Deduping\n  //\n\n  strictDeduping: new BooleanSetting({\n    category: SettingCategories.Deduping,\n    description: `How strict should PhotoStructure de-duplicate files? If this is false, we consider files to be equivalent if sufficient metadata matches (even if the image hash is different). If this is true, we will always compare image hashes. NOTE: This will most likely cause RAW and JPEG pairs to not always merge to the same asset, especially if your camera uses extensive computational imagery. ALSO NOTE: If this is true, \"useImageHashes\" will be forced to true, and the \"*corr*\" and \"*coeffPct\" settings will be set to 95.`,\n    defaultValue: false\n  }),\n\n  assetAggregation: new StringEnumSetting({\n    category: SettingCategories.Deduping,\n    description: `How should assets be aggregated?\\n- \"union\" will allow asset file variants to join an asset if they match *any* existing variant.\\n- \"intersection\" will only allow asset file variants to join an asset if they match *all* existing variants.\\nVersions prior to 2.1 defaulted to \"union\" behavior.`,\n    defaultValue: AggregateTypes.intersection,\n    strEnum: AggregateTypes\n  }),\n\n  useImageHashes: new BooleanSetting({\n    category: SettingCategories.Deduping,\n    description: `Building image hashes slows down imports, but supports more robust asset merging heuristics, and allows for dominant color tagging and browsing. If you set this from false to true, and you'd previously imported new assets, you may want to rebuild your library to re-aggregate your assets.`,\n    defaultValue: true\n  }),\n\n  allowFuzzyDateImageHashMatches: new BooleanSetting({\n    category: SettingCategories.Deduping,\n    description: `For images that don't have a reliable precise captured-at time (say, from \"stat\" or datestamp from pathname), can we aggregate assets purely by exact image hash matches?\\nSee https://forum.photostructure.com/t/deduplicate-shenanigans/1732/11 for more details.`,\n    defaultValue: false\n  }),\n\n  minMatchesWithoutImageHashes: new IntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `If \"useImageHashes\" is true, this is ignored. This is a \"backstop\" that allows files to be aggregated together if their metadata is equal \"enough.\" As of Sept 2022, there are 5 metadata classes to match: \"cameraId\", \"lensId\", \"imageId\", \"exposureSettings\", and \"geohash\". All of these \"classes\" pull from several individual tags. Note that if any of these classes _don't_ match, the files will always be considered to be from different assets.`,\n    defaultValue: 3\n  }),\n\n  maxContemporaryAdoptionAssets: new IntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `To handle photos and videos with \"fuzzy\" captured-at times (those that are missing second, minute, hour, or even day resolution), how many previously-imported assets with nearby captured-at times should PhotoStructure look for in your library to find an adoption candidate?\\nMonitor the \"sync.AssetFileFinder.assetByCapturedAtOrImageHash\" timer to see how long adoption is taking on your machine.\\nHigher values will slow down imports, but may result in more accurate de-duplication results.`,\n    defaultValue: 512\n  }),\n\n  // UUIDTags: new StringArraySetting({\n  //   category: SettingCategories.Deduping,\n  //   description: `What tags should be used to extract a \"UUID\" that PhotoStructure can trust for asset aggregation?\\nSee https://forum.photostructure.com/t/support-for-iphone-live-photos/87/6 for details.`,\n  //   defaultValue: () => [\"ContentIdentifier\", \"MediaGroupUUID\"]\n  // }),\n\n  datesBeforeAreEstimated: new StringSetting({\n    category: SettingCategories.Deduping,\n    description: `PhotoStructure automatically interprets captured-at timestamps before this ISO-formatted datestamp as \"estimated.\" PhotoStructure also considers timestamps whose minutes, seconds, and milliseconds are all 0 as \"estimated.\"\\nWhen assets have an estimated captured-at time, tighter image correlation is required to prevent different images as being incorrectly aggregated into the same asset.\\nThe default value is the release date for the Nikon Coolpix 950, which was one of the first prosumer digital cameras with ~2MP resolution.`,\n    defaultValue: \"1999-02-15\"\n  }),\n\n  // Note for future me: \"coefficient\" versus \"correlation\":\n\n  // Correlation relates to how well a set of points fit a line.\n  // https://en.wikipedia.org/wiki/Correlation\n\n  // \"Similarity coefficient\" is referenced in Jaccard Similarity, which is\n  // why I went with \"coefficient\" here.\n  // https://en.wikipedia.org/wiki/Jaccard_index\n\n  minExposureSettingsCoeffPct: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description:\n      \"This is the minimum similarity coefficient between exposure setting values two images must be to be considered equivalent. Many cameras actually report different exposure setting values between JPG and RAW: values within 90% of each other should avoid false-positives.\",\n    defaultValue: () => 90,\n    max: 100,\n    min: 0\n  }),\n\n  minImageCoeffPct: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `This setting controls how aggressively images are merged with each other, and is the minimum image hash similarity coefficient for images to be considered equivalent when their date is accurate, their mimetypes match, and are in color.\\nThis value is applied when the captured-at date has a non-zero minute, second, or millisecond, and was captured after \"datesBeforeAreEstimated,\" so the timestamp is considered to have high precision.\\n100 (or 100%) requires exact image correlation is not recommended due to causing false negative matches.\\nA value of less than 50% is fairly low image correlation, and can lead to false positive matches.`,\n    defaultValue: () => 70,\n    max: 100,\n    min: 0\n  }),\n\n  imageHashFuzzyDateDelta: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `This setting's value is added to \"minImageCoeffPct\" and \"minColorCoeffPct\" when captured-at dates have low precision. It defaults to a positive value so we are more strict about merging images with inaccurate dates. Set to 0 to disable this delta.`,\n    defaultValue: () => 12,\n    max: 100,\n    min: -100\n  }),\n\n  imageHashDifferentMimetypesDelta: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `This setting's value is added to \"minImageCoeffPct\" and \"minColorCoeffPct\" when file mimetypes don't match. It defaults to a negative value because RAW and JPEG formats frequently raster slightly different image hashes, requiring a more lax threshold to match JPG+RAW pairs. Set to 0 to disable this delta.`,\n    defaultValue: () => -15, // this is pretty high, but RAW+JPG pairs are often quite different\n    max: 100,\n    min: -100\n  }),\n\n  imageHashGreyscaleDelta: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `This setting's value is added to \"minImageCoeffPct\" when either image is essentially greyscale. It defaults to a positive value so we are more strict about merging greyscale images. We also don't have color correlation to help us, so a more strict threshold is warranted.`,\n    defaultValue: () => 10,\n    max: 100,\n    min: -100\n  }),\n\n  // imageHashBlur: new BooleanSetting({\n  //   category: SettingCategories.Deduping,\n  //   description: `PhotoStructure can apply a light blur between the dominant color pixel resample and the final image hash downsample, which can improve image hash matching of noisy or high frequency images. This adds 5-100ms to building image hashes.\\nSet to 0 to disable this blurring step.`,\n  //   defaultValue: true\n  // }),\n\n  minColorCoeffPct: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description:\n      \"Given two sets of dominant colors, this is the average percent that those sets correlate with eachother. A higher number requires stronger dominant color correlation. 100 (or 100%) requires exact dominant color correlation. A value of less than 50% indicates fairly low correlation of dominant colors, and can lead to false positives.\",\n    defaultValue: () => 73,\n    max: 100,\n    min: 0\n  }),\n\n  greyscaleColorThreshold: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `Many \"black and white\" images, which scanned, actually include color information, especially if the source has yellowed with age. PhotoStructure determines if an image is \"greyscale\" if the standard deviation of a* plus the standard deviation of b* values is less than this value. By only looking at standard deviation, we can categorize sepia photos as \"greyscale.\" Smaller values are stricter.`,\n    defaultValue: 3,\n    max: 128,\n    min: 0\n  }),\n\n  gpsErrorMeters: new IntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `What's the maximum number of meters between GPS fixpoints that should be considered equivalent locations? Note that JPG+RAW pairs from smartphones frequently have different GPS locations due to one being recorded from a rough WiFi fix, and another from aGPS.\\nGPS position error is ~10-100m. Cellular position error is ~500-750m.`,\n    defaultValue: 500\n  }),\n\n  minCapturedAtPrecisionDifferentMimetypes: new IntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `Some cameras store JPEG+RAW pairs with slightly different captured-at times (!!). To ensure these are merged properly, we need to allow for these discrepancies. This setting controls how many milliseconds of difference we allow between captured-at times for different mimetypes. Set to 0 to disable this feature.`,\n    defaultValue: () => 1500\n  }),\n\n  fuzzyDatePrecisionCoeff: new FloatSetting({\n    category: SettingCategories.Deduping,\n    description: `When comparing \"captured-at\" dates that aren't from reliable metadata tags, what coefficient should be applied to the inferred precision of those dates? Larger values will mean PhotoStructure will consider these \"fuzzy\" dates to be less precise, and expand the date range when searching for matching assets. Set to 1 to disable this feature.`,\n    defaultValue: 2\n  }),\n\n  // TODO: FINISH! See core/img/ImageDataHash.ts\n\n  // useImageDataHashes: new BooleanSetting({\n  //   category: SettingCategories.Deduping,\n  //   description: `Should PhotoStructure match files using a cryptographic hash of the image data (without metadata)? This will allow files with the same image content to match after metadata changes, but takes longer to compute.`,\n  //   defaultValue: true\n  // }),\n\n  // imageDataHashTags: new StringArraySetting({\n  //   category: SettingCategories.Deduping,\n  //   description: `Should PhotoStructure save image data cryptographic hashes into files copied into your library? These values must be valid tag names. When writing, PhotoStructure will write into the first tag that doesn't already have a value (to avoid clobbering prior values).\\nSet to an empty array to disable this feature.`,\n  //   defaultValue: [\n  //     \"DocumentId\",\n  //     \"OriginalDocumentID\",\n  //     \"BurstUUID\",\n  //     \"BurstId\",\n  //     \"CameraBurstID\",\n  //     \"MediaGroupUUID\",\n  //     \"InstanceId\"\n  //   ]\n  // }),\n\n  //\n  // Color\n  //\n\n  dominantColorPixels: new BoundedIntegerSetting({\n    category: SettingCategories.Color,\n    aliases: [\"modePixels\"],\n    description: `PhotoStructure downsamples images to contain this number of pixels, converts each pixel into CIELAB space, and then runs k-means clustering to extract dominant colors. Larger values will be slower to process, but will result in more accurate dominant colors. Smaller values will be faster, but may result in inaccurate dominant colors.`,\n    defaultValue: DominantColorPixelsDefault,\n    max: 4096,\n    min: 256\n  }),\n\n  dominantColorDeltaE: new StringEnumSetting({\n    aliases: [\"delta_e\"],\n    category: SettingCategories.Color,\n    description: `What delta_e algorithm should PhotoStructure use to determine color differences? cie76 is quick but inaccurate. cie94 is more accurate than cie76 but 6x more computationally expensive than cie76. ciede2000 is best, but 4-6x more expensive than cie94.`,\n    defaultValue: ColorDistanceFunctions.ciede2000,\n    strEnum: ColorDistanceFunctions\n  }),\n\n  dominantColorKmeansRuns: new BoundedIntegerSetting({\n    category: SettingCategories.Color,\n    aliases: [\"modeRuns\"],\n    description: `PhotoStructure uses k-means clustering to extract dominant colors from your images.\\nLarger values will allow PhotoStructure to run k-means with more random seeds and different pre-merged k values, which should result in higher quality results.\\nUsing 0 will revert to posterizing the image and using the top-n colors, which is fast and deterministic, but has lower quality results.\\nChanging this value will subtly change many image's dominant color lists.\\nThis defaults to 0 run when \"quickSyncMode\" is enabled.`,\n    defaultValue: DominantColorKmeansRunsDefault,\n    max: 64,\n    min: 0\n  }),\n\n  dominantColorMergeThreshold: new BoundedIntegerSetting({\n    category: SettingCategories.Color,\n    description: `The best dominant color cluster centroids may be quite similar. PhotoStructure will merge centroids if their Δe is less than this value. Larger values will result in more different dominant colors, but those may not be as accurate.`,\n    defaultValue: 10,\n    max: 32,\n    min: 0\n  }),\n\n  dominantColorGreyThreshold: new BoundedIntegerSetting({\n    category: SettingCategories.Color,\n    aliases: [\"modeGrey\"],\n    description: `May PhotoStructure ignore pixels that are greyscale, or \"desaturated,\" when looking for dominant colors? Larger values will result in only saturated colors being considered for dominant colors. A pixel color will be removed if its absolute a* and b* values in CIELAB space sum to less than this value.\\nSet this to 0 to include greys in dominant colors, but note that this tends to reduce image deduplication effectiveness, as most natural-tone images contain a good deal of greyscales, which results in false matches.`,\n    defaultValue: 11,\n    max: 80,\n    min: 0\n  }),\n\n  //\n  // Shared-state events\n  //\n\n  sharedStateDir: new OptionalStringSetting({\n    category: SettingCategories.Events,\n    description:\n      \"PhotoStructure uses a set of JSON files to relay messages between processes (rather than an RPC mesh, socket, or named pipe, whose device types isn't supported on some filesystem types). This directory must be readable and writable.\",\n    defaultValue: () => \"\" // < set by setSettingsDefaults()\n  }),\n\n  sharedStatePollMs: new DurationSetting({\n    category: SettingCategories.Events,\n    description: `The \"sharedStateFile\" is watched for changes using your OS'es filesystem watch functionality: for most setups, this will result in almost instantaneous event propagation. Some filesystems don't support filesystem watching, or miss file edits, so we _also_ manually check for file changes every \"sharedStatePollMs\" milliseconds. This defaults to 7 seconds, but know that this will prevent the \"PS_CONFIG_DIR\" hard drive from spinning down and going to sleep.\\nSee the \"allowFilesystemSleep\" for other related settings.\\nSet this setting to 0 to disable state polling.`,\n    defaultValue: () => \"7s\"\n  }),\n\n  sharedStateTaskTimeoutMs: new DurationSetting({\n    category: SettingCategories.Events,\n    description: `How long should PhotoStructure wait for shared-state tasks to be completed before timing out and giving up?`,\n    defaultValue: () => \"5m\"\n  }),\n\n  //\n  // Previews\n  //\n\n  previewQuality: new BoundedIntegerSetting({\n    aliases: [\"jpegQuality\"],\n    category: SettingCategories.Previews,\n    description:\n      \"JPEG output quality for previews. Smaller values produce smaller images with lower quality. The default value of 80 strikes a balance that has almost no noticeable compression artifacts, yet still compresses images reasonably well. Depending on image content, values less than 50-70 can produce noticeable artifacts.\",\n    defaultValue: () => 80,\n    max: 100,\n    min: 10\n  }),\n\n  previewProgressive: new BooleanSetting({\n    category: SettingCategories.Previews,\n    aliases: [\"progressive\", \"jpegProgressive\"],\n    description: `Should preview JPEGs be progressively encoded? If set, thumbnails will take ~15% longer to generate, but FHD/QHD/UHD previews will be smaller.`,\n    defaultValue: true\n  }),\n\n  previewMinimized: new BooleanSetting({\n    aliases: [\"jpegMinimized\"],\n    category: SettingCategories.Previews,\n    description: `Should preview JPEGs be optimized? If set, preview generation can take 50% longer, but can result in up to ~30% smaller images. This saves disk space and network transport time.\\nThis setting controls the \"mozjpeg\" option: see https://sharp.pixelplumbing.com/api-output#jpeg for details.\\nThis automatically defaults to true if at least 4 CPU cores are present.`,\n    defaultValue: () => (isTest() ? true : cpuCount() >= 4)\n  }),\n\n  dcrawEmuArgs: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `What options do you want to pass to dcraw_emu? Note that \"-T -o 1 -j -Z -\" will always be added (as we need TIFF, sRGB, raw pixels send to stdout). The \"-h\" arg will be added if the preview image needed is less than half the resolution of the original.\\nRun \"dcraw_emu\" with no arguments to get usage help.\\n\"-q 1\" sets interpolation quality to \"0\".\\n\"-H 2\" turns on highlight blending.\\n\"-w\" uses the camera-set white balance.\\nNote: changing these values can dramatically (> 10x!) increase the time it takes to render RAW images.`,\n    defaultValue: [\"-q\", \"0\", \"-w\"]\n  }),\n\n  iccProfileMappings: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `Maps an original image profile to a filename stored in the \"icc\" directory. See that directory's _info.md for more information about this settings.`,\n    defaultValue: [\n      \"Display P3:DisplayP3Compat-v2-magic.icc\",\n      \"Adobe RGB:AdobeCompat-v2.icc\"\n    ]\n  }),\n\n  squareThumbStrategy: new StringEnumSetting({\n    category: SettingCategories.Previews,\n    description:\n      'When PhotoStructure crops images and videos to square thumbnails, it needs to crop non-square images to a square. The default, \"attention,\" focuses on faces and higher image energy, but is more expensive than simply cropping to the center of the image (which is faster, but will mean less-nice cropping, where faces are chopped in half). More details are available here: https://sharp.pixelplumbing.com/api-resize .',\n    defaultValue: CropStrategies.attention,\n    strEnum: CropStrategies\n  }),\n\n  videoFrameAtSec: new FloatSetting({\n    category: SettingCategories.Previews,\n    description: `When capturing a frame from videos for thumbnails, how many seconds should be passed over before capturing a frame? A value of 0 means capture from the start of the video. Frequently, though, videos start out of focus, so we default to 1.5 for better frame clarity.\\nNote that if a video is shorter than this value, the frame will be captured from the middle of the video.`,\n    defaultValue: 1.5\n  }),\n\n  // TODO: add this to the settings page:\n  previewSharpen: new BooleanSetting({\n    aliases: [\"sharpen\"],\n    category: SettingCategories.Previews,\n    description: `Should previews be sharpened? This can make the images \"pop\" a bit more, but almost doubles the time it takes to make the thumbnails.`,\n    defaultValue: false\n  }),\n\n  // TODO: add this to the settings page:\n  previewResolutions: new StringEnumsSetting({\n    category: SettingCategories.Previews,\n    description:\n      \"This controls the resolutions that PhotoStructure creates for every asset. Note that resolutions will be skipped if there already is a preview value with <= 2.5x pixel count, so even though there are a lot of sizes here, you'll only see 3-4 images on your disk per asset.\\nSee https://en.wikipedia.org/wiki/Graphics_display_resolution for a description of these resolution codes.\",\n    defaultValue: diff(FitSizes.values, [\"uhd8k\", \"uhd5k\"]),\n    strEnum: FitSizes\n  }),\n\n  embeddedPreviews: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `For larger source images that are greater than 15MP, what embedded image preview tags should be used when present? Using these embedded images speeds up image preview generation, but if the embedded image doesn't match the full-sized image, the image preview will be incorrect.\\nSet this to an empty array to disable using embedded previews.`,\n    defaultValue: [\"PreviewImage\", \"PreviewTIFF\", \"JpgFromRaw\"]\n  }),\n\n  embeddedThumbnails: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `Should embedded image thumbnails be used when available? This speeds up image hashing, but if the embedded image thumbnail doesn't match the full-sized image, the image hash will be incorrect.\\nSet this to an empty array to disable using embedded previews.`,\n    defaultValue: [\"ThumbnailImage\", \"ThumbnailTIFF\"]\n  }),\n\n  maxEmbeddedBuffer: new IntegerSetting({\n    category: SettingCategories.Previews,\n    description: `PhotoStructure tries to use embedded images for preview generation to minimize work. For smaller images, we can directly pipe the buffer from the embedded image into our image pipeline, but for larger images, it can be faster to use an intermediary file stored on the cache drive. Larger values will reduce disk I/O but increase memory and CPU consumption. Set this to 0 to force all previews to be written to the cache dir.\\nThis defaults to ${fmtBytes(\n      DefaultMaxEmbeddedBuffer * 4\n    )} on Windows due to slow disk I/O on that platform.`,\n    defaultValue: () => (isWin ? 4 : 1) * DefaultMaxEmbeddedBuffer\n  }),\n\n  skipPreviews: new BooleanSetting({\n    category: SettingCategories.Previews,\n    description: `Only used for tests.`,\n    advanced: () => true,\n    defaultValue: false\n  }),\n\n  variantSortCriteria: new StringEnumsSetting({\n    category: SettingCategories.Previews,\n    aliases: [\"assetFileSortCriteria\"],\n    description: `How should PhotoStructure pick the \"best\" asset file variant for a given asset? You may reorder the default fields. Only \"resolution\", \"fileSize\", \"mtime\", \"schemeIdx\", \"isCover\", \"count\", and \"isBrowserSupported\" are understood: other field names will be ignored. Details about these fields are here: https://photostructure.com/faq/what-do-you-mean-by-dedupe/#how-does-photostructure-pick-which-file-to-show .`,\n    strEnum: AssetFileSortCriteria\n  }),\n\n  variantSortCriteriaPower: new BoundedFloatSetting({\n    category: SettingCategories.Previews,\n    description: `Variant sort criteria \"resolution\" and \"fileSize\" are scaled down to ignore irrelevant differences. Scalars are raised to this power to reduce them, so a value of 1 means the criterion is unchanged from the \"raw\" value. Smaller values for this setting let _larger_ differences be ignored.`,\n    defaultValue: () => 1 / 6,\n    max: 1,\n    min: 1e-6\n  }),\n\n  includePreviewTags: new BooleanSetting({\n    category: SettingCategories.Previews,\n    description: `By default, PhotoStructure strips all metadata from preview images. This both saves space, and reduces disk I/O during preview generation. If this setting is enabled, all \"includedPreviewTags\" will be restored in preview images that are more than 1 megapixel. If this setting is enabled, each preview image will be written to twice (once for the image and once for the metadata), so imports will be slower.`,\n    defaultValue: false\n  }),\n\n  includedPreviewTags: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `If \"includePreviewTags\" is true, what tags should PhotoStructure retain when building preview images? A partial list of tags is here: https://photostructure.github.io/exiftool-vendored.js/interfaces/Tags.html . Note that not all files contain all (or even some!) of those tags.\\n- \"capturedAt\" is a special meta-tag which will retain whatever tag contains the \"best\" time that PhotoStructure could find that encoded the date and time when the image was captured, and will store that value in DateTimeOriginal.\\n- \"exposureSettings\" is a special meta-tag that will retain shutter time (ExposureTime), aperture (FNumber), and ISO (ISOSpeed) metadata (but may be encoded with different values).\\n- including \"GPSLatitude\" and \"GPSLongitude\" will mean previews will contain location metadata if the source image had location metadata.`,\n    defaultValue: () => DefaultIncludedPreviewTags\n  }),\n\n  //\n  // Filters\n  //\n\n  disableAllFilters: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"Setting this to true will force all other filter settings to their most permissive value. Note that this also disables file validation tests and the file SHA blocklist, so corrupt files and previously removed files will be attempted to be imported as well.\",\n    defaultValue: false\n  }),\n\n  excludeGlobsAdd: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `This setting adds glob patterns for files and directories that should be excluded from your library.\\nThese patterns will be added to PhotoStructure's default set of (several hundred!) exclusion globs.\\nSee https://forum.photostructure.com/t/1458 for details.`,\n    exampleValue: () => [\"**/tmp\"],\n    defaultValue: () => []\n  }),\n\n  excludeGlobsOmit: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `PhotoStructure has several hundred default \"exclusion globs\" to avoid scanning system and application directories and otherwise irrelevant files.\\nThe patterns provided here are removed from that default set.\\nSee https://forum.photostructure.com/t/1458 for details.`,\n    defaultValue: () => []\n  }),\n\n  globsCaseInsensitive: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Should \"globs\" match case-insensitively?`,\n    defaultValue: true\n  }),\n\n  respectFileExtensions: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Normally PhotoStructure uses file extensions (like .JPEG or .MP4) to perform initial file filtering, rather than examining the content of the file to determine the file format (or \"mimetype\"). If you have files that don't use valid file extensions, you can set this to false, but know that file imports will be much slower.`,\n    defaultValue: true\n  }),\n\n  disableIgnorableFilters: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"PhotoStructure has a (ton) of patterns used to avoid scanning system, cache, and application directory hierarchies. See the 'excludeGlobs*' settings for more precise editing of exclusion patters.\",\n    defaultValue: false\n  }),\n\n  requireMakeModel: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"PhotoStructure can require images to have EXIF tags for Make and Model. This prevents unwanted preview images from other photo apps and screenshots from being imported. If you have images you want in your library that don't have these tags, set this to false. Note that this is ignored for video files, as those files seldom have Make and Model set (and would prevent most video files from being imported).\",\n    defaultValue: false\n  }),\n\n  rejectRatingsLessThan: new IntegerSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"Files with a metadata rating that is less than this value will not be imported into your library. Set to -100 to disable this filter.\",\n    defaultValue: 0\n  }),\n\n  keywordBlocklist: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `Any asset that contains any of these keywords will be excluded from your library. Set this to an empty array to disable this feature.`,\n    defaultValue: [\"private\"]\n  }),\n\n  minImageDimension: new IntegerSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum number of pixels an image's dimensions must meet or exceed to be imported? Note that this value is applied to both the height and width of the image. The default comes from the VGA standard of 640x480. If this is set to 0, no minimum resolution filter will be applied to photos.\",\n    defaultValue: 480\n  }),\n\n  minVideoDimension: new IntegerSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum number of pixels a video's dimensions must meet or exceed to be imported? Note that this value is applied to both the height and width of the video. The default comes from the QVGA standard of 320x240. If this is set to 0, no minimum resolution filter will be applied to videos.\",\n    defaultValue: 240\n  }),\n\n  minVideoDurationSec: new OptionalFloatSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum number of seconds for a video to be imported? If this is set to 0 or unset, no minimum duration limit will be applied.\",\n    defaultValue: 2\n  }),\n\n  maxVideoDurationSec: new OptionalIntegerSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the maximum length a video can be and still be imported? If this is set to 0 or unset, no maximum duration limit will be applied.\"\n  }),\n\n  minAssetFileSizeBytes: new IntegerSetting({\n    aliases: [\"minAssetSizeBytes\", \"minAssetSize\", \"minFileSizeBytes\"],\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum photo or video size you want imported into your library?\\nThis setting can prevent small GIFs and screenshots from being imported.\\nValues less than 1000 will be ignored.\\nA 20-year-old 1600x1200 JPEG at 50% quality is more than 150k, so 50k is a very conservative default.\",\n    defaultValue: 50 * KB\n  }),\n\n  maxAssetFileSizeBytes: new IntegerSetting({\n    aliases: [\"maxAssetSizeBytes\", \"maxAssetSize\", \"maxFileSizeBytes\"],\n    category: SettingCategories.Filters,\n    description:\n      \"What's the maximum photo or video size you want imported into your library? (This can prevent movies from being pulled into and filling up your library). A value of 0 will disable this filter.\",\n    defaultValue: 0.5 * GB\n  }),\n\n  // TODO: add this to the settings page:\n  validateJpegImages: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Should JPEG photos be validated before importing? If a JPEG has any decoding errors, and this setting is true, that file will not be imported into your library. Enabling this feature slows down imports.`,\n    defaultValue: true\n  }),\n\n  imageFailOn: new StringEnumSetting({\n    category: SettingCategories.Filters,\n    description: `How sensitive should PhotoStructure be with warnings or errors when loading images?\\nUse \"none\" to try loading images with best efforts, even if the file may be corrupt.\\nUse \"warning\" to be conservative--any defects in the image will prevent it from being imported. \\nThe default, \"truncated,\" will allow images with minor encoding defects to be imported.`,\n    defaultValue: SharpFailOns.truncated,\n    strEnum: SharpFailOns\n  }),\n\n  // TODO: add this to the settings page:\n  validateRawImages: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Should raw-format images (like NEF, CR2, ARW, and ORF) be validated before importing? If an image has any decoding errors, and this setting is true, that file will not be imported into your library. Enabling this feature slows down imports.`,\n    defaultValue: true\n  }),\n\n  // TODO: add this to the settings page:\n  validateVideos: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Should videos be validated before importing? If a video has any decoding errors, and this setting is true, that file will not be imported into your library. Enabling this feature slows down imports, as videos must be fully decoded (or \"played\") to be validated. Only ffmpeg currently supports video validation; if you use VLC, this setting is ignored.`,\n    defaultValue: () => false\n  }),\n\n  validationErrorBlocklist: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `If any of the following patterns match a validation error found in a photo or video, and *doesn't* match any of the patterns in the validationErrorAllowlist, the file will be considered corrupt and not be imported into your library.\\nNote the patterns are case-insensitive, will be converted into a regular expression, and only need to partially match the error message, so, for example, a value of \"caution\" will ignore any error message that contains the string (not the word!) \"caution\".\\nAlso see \"validationErrorAllowlist\".`,\n    defaultValue: () => [\n      \"cannot decode\",\n      \"cannot determine format of input stream\",\n      \"corrupt\", // matches \"data corrupted\"\n      \"error while decoding\", // ffmpeg from truncations\n      // \"error\", maybe too lax?\n      \"failed\", // not specific enough?\n      \"invalid\",\n      \"not a jpeg file\", // Not a JPEG file\n      \"not raw file\",\n      \"nothing was written into output file\",\n      \"partial file\",\n      \"premature end of .+ file\", // Premature end of JPEG file\n      \"unsupported file format\" // corrupt or invalid RAW files\n    ]\n  }),\n\n  validationErrorAllowlist: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `All validation errors that match any of these values they will be ignored, EVEN IF they match a \"validationErrorBlocklist\" pattern, so all of these patterns should be specific enough to not cause false-negatives.\\nNote the patterns are case-insensitive, will be converted into a regular expression, and only need to partially match the error message.\\nAlso see \"validationErrorBlocklist\".`,\n    defaultValue: () => [\n      \"invalid SOS parameters for sequential jpeg\",\n      \"referenced qt chapter track not found\",\n      \"non monotonically increasing dts\" // don't care about timestamps\n    ]\n  }),\n\n  //\n  // Parsing\n  //\n\n  capturedAtTags: new StringArraySetting({\n    category: SettingCategories.Parsing,\n    description: `The following tags are examined to determine when a file was captured at.\\nThe tag with the oldest valid value is returned: order here doesn't matter.\\nIf none of these tags have a valid datetime stamp, PhotoStructure will fall back to \"capturedAtTagsFallback\" tags.\\nSee https://photostructure.com/faq/captured-at/ for details.`,\n    defaultValue: DefaultCapturedAtTagsConst as any as string[]\n  }),\n\n  capturedAtTagsFallback: new StringArraySetting({\n    category: SettingCategories.Parsing,\n    description: `If none of the \"capturedAtTags\" have a valid value, PhotoStructure will fallback to look at these tags. These tags are only \"fallbacks\" as they sometimes contain spurious values.\\nSee https://photostructure.com/faq/captured-at/ for details.`,\n    defaultValue: ProblematicCapturedAtTags as any as string[]\n  }),\n\n  badDates: new StringArraySetting({\n    category: SettingCategories.Parsing,\n    description: `The following ISO values will be ignored when extracting a file's captured-at time. See https://forum.photostructure.com/t/photostructure-ignored-the-date-metadata-of-some-photos-marked-them-as-taken-in-2002/340/8 and https://forum.photostructure.com/t/incorrect-date-assigned-to-photo/419 .`,\n    defaultValue: () => [\"2002-12-08T12:00:00\"]\n  }),\n\n  defaultVideosToUTC: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `Should video created-at times be assumed to be in UTC? Most cameras use UTC (even if the timezone is set in the camera!). Set this to false to revert to pre-v2.1 behavior.`,\n    defaultValue: () => true\n  }),\n\n  defaultCopyright: new OptionalStringSetting({\n    category: SettingCategories.Parsing,\n    description: `If PhotoStructure doesn't find a value for Copyright in a source image or source video, it will apply the given string as the copyright holder.\\nThis has no default.`\n  }),\n\n  likeRating: new IntegerSetting({\n    category: SettingCategories.Parsing,\n    description: `What's the minimum \"rating\" for an asset to be considered \"liked\"?\\nKnow that metadata \"ratings\" are stored in both EXIF and XMP \"Rating\" and \"RatingPercent\" tags. Ratings are typically encoded as a value between -1 and 5 (where -1 is used by some DAMs to mark \"rejected\").\\nPhotoStructure will prefer the XMP Rating tag.\\nIf the only tag with a rating is a \"RatingPercent\", it will be converted to a 5-point scale.\\nIf you want only ratings of 5 to be considered a \"liked\" asset, set this to 5.\\nThis value will be used when assets are liked via the PhotoStructure UI.\\nNote that PhotoStructure doesn't import assets with a negative Rating (to respect the \"rejected\" rating).`,\n    defaultValue: () => 3\n  }),\n\n  lensMakes: new StringArraySetting({\n    category: SettingCategories.Parsing,\n    description: `Used to extract and parse lens metadata (useful when Google Takeout has stripped metadata).`,\n    defaultValue: () => DefaultLensMakes\n  }),\n\n  extraDateTimeFormats: new StringArraySetting({\n    category: SettingCategories.Parsing,\n    description: `These formats are used to parse datetime strings in EXIF metadata and in file pathnames. See https://moment.github.io/luxon/#/formatting?id=table-of-tokens for a description of these tokens.`,\n    defaultValue: () => DefaultDateTimeFormats\n  }),\n\n  fuzzyDateParsing: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, PhotoStructure will first attempt to parse datetime strings with strict ISO-compliant parsers, and then use additional, \"fuzzy\" datetime parsers. When disabled, only ISO-compliant parsers are used.`,\n    defaultValue: true\n  }),\n\n  fuzzyYearParsing: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, PhotoStructure will use directories starting with a number that looks year-like (four digits, 1826-the present) to infer the captured-at time, if all other date parsers have failed. Note that setting this to true \"forces\" the \"fuzzyDateParsing\" setting to be true.\\nTo elaborate: PhotoStructure first looks for metadata with a date, then looks for an ISO-compliant YMD timestamp in the filename or path, and then, if \"fuzzyDateParsing\" or this setting is enabled, a YMD or YM datestamp, and then finally, if this setting is enabled, it looks for a directory that begins with a number that is between 1826-2020.`,\n    defaultValue: false\n  }),\n\n  twoDigitCutoffYear: new IntegerSetting({\n    category: SettingCategories.Parsing,\n    description: `If \"yy\" is used in extraDateTimeFormats, and a year is only 2 digits, what threshold value should be used to consider the date to be in the 1900s vs 2000s?\\nAs an example, a value of \"50\" would make \"49\" be interpreted as 1949, and \"50\" as 2050.\\nSee https://moment.github.io/luxon/api-docs/index.html#settingstwodigitcutoffyear for details.\\nThis defaults to 3 years in the future (modulus 100) and is updated automatically.`,\n    defaultValue: () => (new Date().getFullYear() + 3) % 100\n  }),\n\n  minValidYear: new IntegerSetting({\n    category: SettingCategories.Parsing,\n    description: `If PhotoStructure encounters a year that is less than this value, it will consider it invalid and look elsewhere for dates. The default value, 1826, is the first year a photograph was captured, as per https://en.wikipedia.org/wiki/History_of_photography . If you have paintings or other imagery from before this time, you'll want to make this value less than the earliest image in your library.`,\n    defaultValue: 1826\n  }),\n\n  useStatToInferDates: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, and the \"captured-at\" time isn't found in metadata, PhotoStructure will also look for the captured-at datetime encoded in the file \"birthtime\" (on Windows), or the lesser value of \"mtime\" and \"ctime\" (on macOS and Linux). Note that these values are not very reliable, as file transfers and backups frequently don't retain these values correctly.`,\n    defaultValue: true\n  }),\n\n  usePathsToInferDates: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, and the \"captured-at\" time isn't found in metadata, PhotoStructure will also look for the captured-at datetime encoded in file paths.`,\n    defaultValue: true\n  }),\n\n  useLibraryDirsToInferDates: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, and the \"captured-at\" time isn't found in metadata, PhotoStructure will also look for the captured-at datetime encoded in file paths *for files that are in your PhotoStructure library. This defaults to false, as prior versions of PhotoStructure may have placed files into incorrect datestamped directories.`,\n    defaultValue: false\n  }),\n\n  /**\n   * @deprecated\n   */\n  enableSiblingInference: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `This setting has been replaced by the \"siblingInference\" setting. \"true\" is equivalent to \"auto\", and \"false\" is equivalent to \"never\".`,\n    defaultValue: true,\n    deprecated: true\n  }),\n\n  siblingInference: new StringEnumSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, and the \"captured-at\" time, Make, or Model isn't found in metadata, PhotoStructure will try to use nearby files to \"fill in the blanks.\" If this is set to \"auto\", this is disabled automatically for slow directories. If this is set to \"always\", even files in slow directories will have tag inference, when necessary. Set to \"never\" to disable.`,\n    strEnum: TagInferenceSettingValues,\n    defaultValue: TagInferenceSettingValues.auto\n  }),\n\n  siblingInferenceBasenameCoeff: new FloatSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum case-insensitive Sørensen–Dice similarity index between file basenames, without the extension, to be used for sibling inference?\\n0 will accept all siblings, 1 will only accept exact matches.\",\n    defaultValue: 0.6 // tests fail with 0.65\n  }),\n\n  writeInferredTagsToLibraryCopies: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, inferred metadata will be stored as _actual_ metadata in the library copy.`,\n    defaultValue: true\n  }),\n\n  //\n  // Tagging\n  //\n\n  recountAllTags: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should all tags be recounted? PhotoStructure normally only recounts tags that have had assets recently added or removed, unless there are more than 20 changed tags.`,\n    defaultValue: false,\n    transient: true\n  }),\n\n  tagCamera: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with cameras' make and model?`,\n    defaultValue: true\n  }),\n\n  tagLens: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with lens' make and model?`,\n    defaultValue: true\n  }),\n\n  tagFullLensModel: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should PhotoStructure tag assets with the full lens model (like \"Canon EF-M 15-45mm f/3.5-6.3 IS STM\") or a just the lens information (\"15-45mm f/3.5-6.3\")? (If you change this value, you'll need to \"Rebuild\" your library to make the setting take effect).`,\n    defaultValue: true\n  }),\n\n  tagYMD: new StringEnumSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with \"When > Year\" (the \"y\" option), or \"When > Year > Month\" (the \"ym\" option), or \"When > Year > Month > Day\" (the \"ymd\" option)? Setting this to \"\" will disable date tagging.`,\n    defaultValue: DateTagFormats.ym,\n    strEnum: DateTagFormats\n  }),\n\n  tagDateFromStat: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should PhotoStructure tag assets with a date if the captured at time was only found in filesystem metadata? Filesystem metadata is not as reliable as EXIF metadata, as it can be changed arbitrarily when files are backed up.`,\n    defaultValue: () => (isTest() ? false : true)\n  }),\n\n  tagKeywordsFromPath: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with keywords extracted from file pathnames?`,\n    defaultValue: true\n  }),\n\n  tagKeywordsFromMetadata: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with keywords extracted from file metadata, as well as sidecar metadata?`,\n    defaultValue: true\n  }),\n\n  keywordTags: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure should look in the following tags for keywords. Note that these values are case-sensitive.`,\n    defaultValue: () => [\n      \"CatalogSets\",\n      \"Categories\",\n      \"HierarchicalSubject\",\n      \"Keywords\",\n      \"LastKeywordXMP\",\n      \"Subject\",\n      \"TagsList\",\n      \"XPKeywords\"\n    ]\n  }),\n\n  keywordReparenting: new StringEnumSetting({\n    category: SettingCategories.Tagging,\n    description: `How should PhotoStructure handle hierarchical keywords?\\nIf this is set to \"move\", PhotoStructure will try to put hierarchical keywords into their \"correct\" root tag, like \"Who,\" \"Album,\" or \"Where.\"\\nIf this is set to \"retain,\" PhotoStructure will always place hierarchical keywords under the \"Keyword\" root tag.\\nIf this is set to \"copy,\" PhotoStructure will add both the \"correct\" root tag _and_ the \"Keyword\" tag. For example, \"Person|Doe|Jane\" will be tagged as \"Who|Doe|Jane\" as well as \"Keyword|Person|Doe|Jane\".\\nSee https://forum.photostructure.com/t/prefix-for-keywords-tag/499 for details.`,\n    defaultValue: KeywordReparentingStrategies.move,\n    strEnum: KeywordReparentingStrategies\n  }),\n\n  rootTagAlbumsAliases: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List hierarchical tag roots that PhotoStructure should interpret to be album names. This is matched case-insensitively.`,\n    defaultValue: () => [\"Album\", \"Albums\"]\n  }),\n\n  rootTagKeywordsAliases: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List hierarchical tag roots that PhotoStructure should interpret to be keywords. This is matched case-insensitively.`,\n    defaultValue: () => [\"Keyword\", \"Keywords\", \"Tag\", \"Tags\"]\n  }),\n\n  rootTagWhoAliases: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    aliases: [\"tagWhoSynonyms\"],\n    description: `When hierarchical tag values are found with any of these root names PhotoStructure will replace the root with \"Who\".\\nFor example, using default values, \"People/Jane Doe\" will be replaced with \"Who/Jane Doe\" (or \"Who/Doe/Jane\", if tagNamesFormatter=\"family/given\").\\nDigicam uses \"People\". This is matched case-insensitively.`,\n    defaultValue: () => [\"Person\", \"People\", \"Face\", \"Faces\"]\n  }),\n\n  keywordDelimiters: new OptionalStringSetting({\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure splits apart keywords, by default, when they are delimited by a comma or semicolon. For example, \"car, blue, tree\" will be interpreted as having the keywords \"car\", \"blue\", and \"tree\".\\nNote that some software doesn't encode lists of keywords properly, so we have to include the comma and semicolon by default to handle these cases: but this makes keywords that contain a comma be split incorrectly. If the files in your library don't have this encoding issue, you can replace this setting with just an empty string to disable splitting.\\nSee https://forum.photostructure.com/t/incorrect-handling-of-keywords-with-comma/992 for more discussion.\\nAfter changing this value, you must force-resync your library for the changes to take affect.`,\n    defaultValue: \",;\"\n  }),\n\n  keywordPathSeparators: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure interprets keywords as hierarchical if a path separator character is found in a keyword. This allows for tags like \"Family/Einstein/Albert\", \"Flora|Fruit|Orange\", \"Objects⊃Tools⊃Hammer\", or \"Fauna>Oceanic>Pelican\". By default, these separators are the forward-slash, vertical-bar, and greater-than characters. If you don't want to interpret keywords as hierarchical, change this value to an empty string (\"\"). After changing this value, you must force-resync your entire library for the changes to take affect.`,\n    defaultValue: \"/|>⊃\" // 20200307: thought about and discarded the idea of including \"›\" and \"»\". \"⸧\" isn't in iOS. 20201201: Also deleted \"≻\".\n  }),\n\n  tagFileType: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    aliases: [\"tagType\"],\n    description: `Should assets be tagged with their file type (like \"Type/Image/JPEG\")?`,\n    defaultValue: true\n  }),\n\n  tagJsonFaces: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Google Takeout provides .json sidecars that may contain the names of the people (or pets) found in the image. Should PhotoStructure import these tags under \"Who\"?.`,\n    defaultValue: true\n  }),\n\n  tagFaceRegions: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Picasa and other software supports embedding face names within \"RegionInfo.RegionList.Name\" metadata. If this setting is enabled, and \"RegionInfo.RegionList.Type\" is \"Face\", PhotoStructure will import these tags under \"Who\".`,\n    defaultValue: true\n  }),\n\n  whoTags: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    aliases: [\"tagWhoNames\"],\n    description: `This is a list of tags that will be examined for strings or string arrays. All values associated to these fields will be interpreted as names. Note that \"dotted notation\" is supported.`,\n    defaultValue: [\n      \"People\",\n      \"PersonInImage\",\n      \"PersonInImageWDetails.PersonName\",\n      \"PersonInImageName\",\n      \"RegionInfoMP.Regions.PersonDisplayName\"\n    ]\n  }),\n\n  tagNamesFormatter: new StringEnumSetting({\n    category: SettingCategories.Tagging,\n    description: `How should PhotoStructure format the \"Who\" tags for assets whose files are tagged with \"people\" strings?\\n- \"as-is\" will tag names directly to \"Who\", so, \"Who/Albert Einstein\".\\n- \"family/given\" will tag \"Who/Einstein/Albert\" (for regions that provide given names first).\\n- \"family/fullname\" will tag \"Who/Einstein/Albert Einstein\".\\nThe default is \"as-is,\" because discerning given and family names aren't reliably inferable.\\nSee https://en.wikipedia.org/wiki/Personal_name#Name_order .`,\n    defaultValue: NameTagFormats[\"as-is\"],\n    strEnum: NameTagFormats\n  }),\n\n  tagNamesDefaultFamily: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If a name is missing a family name, if this value is not blank, it will be provided as a default. If this value is blank, the name tag will be Who/given. Note that this setting is only used if \"tagNamesFormatter\" is set to \"family/given\".`,\n    defaultValue: \"-\"\n  }),\n\n  tagNamesCapitalizedAsFamily: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Assume uppercased names are family names (this is common practice in geneology).`,\n    defaultValue: true\n  }),\n\n  tagNamesOrder: new StringEnumSetting({\n    category: SettingCategories.Tagging,\n    description: `How should PhotoStructure parse people's names? Note that this setting is only used if \"tagNamesFormatter\" is set to \"family/given\". See https://en.wikipedia.org/wiki/Personal_name#Name_order .`,\n    defaultValue: \"western\",\n    strEnum: NameTagOrders\n  }),\n\n  tagNamesSurnamePrefixes: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List all family name prefixes to be considered part of the family name. These are matched case-insensitively. This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: () => [\n      \"A\",\n      \"D’\",\n      \"Da\",\n      \"De la\",\n      \"De las\",\n      \"De\",\n      \"Del\",\n      \"Della\",\n      \"Den\",\n      \"Des\",\n      \"Di\",\n      \"Du\",\n      \"La\",\n      \"Las\",\n      \"Le\",\n      \"Li\",\n      \"Lo\",\n      \"Mc\",\n      \"Mac\",\n      \"op de\",\n      \"ten\",\n      \"ter\",\n      \"Van ‘t\",\n      \"van de\",\n      \"van der\",\n      \"van\",\n      \"von der\",\n      \"von\",\n      \"z\",\n      \"zu\"\n    ]\n  }),\n\n  tagNamesSurnames: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List all family names you expect in tags that are not single words that are found at the end of a tagged name. Hyphenated family names (like \"Ocasio-Cortez\") do not need to be listed here: only compound family names, and if your language doesn't separate family names with whitespace. In the latter case, either include all family names, or include all givenNames (whatever's easier for you). This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: () => []\n  }),\n\n  tagNamesGiven: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List all given names you expect in tags that are not single words. Hyphenated given names (like \"Rose-Ann\") do not need to be listed here. If your language doesn't separate family names and given names with whitespace, either include all given names, or include all familyNames (whatever's easier for you). This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: () => []\n  }),\n\n  // TODO:\n\n  // tagNamesGivenIgnored: new StringArraySetting({\n  //   category: SettingCategories.Tagging,\n  //   description: `These given names will always be ignored. This setting is case-insensitive.`,\n  //   defaultValue: () => []\n  // }),\n\n  // tagNamesFamilyIgnoredPrefixes: new StringArraySetting({\n  //   category: SettingCategories.Tagging,\n  //   description: `These strings will be stripped from family names, so \"Michelle LaVaughn Obama (née Robinson)\" doesn't get interpreted as having a maiden name of \"née Robinson\". This setting is case-insensitive.`,\n  //   defaultValue: () => [\"née\", \"nee\"]\n  // }),\n\n  tagNamesFamilySurrounds: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `This setting contains pairs of characters. When name portions are surrounded by these pairs, the contents will be added as a family name. As an example, if you use the default \"()\", then \"Michelle LaVaughn (Robinson) Obama\" will be name tagged with both \"Who/Robinson/Michelle LaVaughn\" and \"Who/Obama/Michell LaVaugn\". This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: [\"()\"]\n  }),\n\n  tagNamesGivenSurrounds: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `This setting contains pairs of characters. When name portions are surrounded by these pairs, the contents will be added to the end of the given name with the surrounds retained. As an example, if you use the defaults of \"[]\" and double-quotes, then \"Joe \"Joey\" Smith\" will be name tagged with Who/Smith/Joe \"Joey\". This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: [\"[]\", '\"\"']\n  }),\n\n  tagNamesLexical: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Assume any name with a comma is in \"lexical name order\", which is always \"lastname, given name(s)\". If the given name is found to be \"sr.\", \"senior\", \"jr.\", or \"junior\", the name will be considered to be in western order ($givenNames $familyName, $modifier), and the $modifier will be added to the $givenNames. If this is set to false, commas are ignored.`,\n    defaultValue: true\n  }),\n\n  excludedRootTags: new StringArraySetting<string>({\n    category: SettingCategories.Tagging,\n    description: `Keywords starting with the given roots will be omitted from your PhotoStructure library. Changing this value requires a library rebuild.`,\n    defaultValue: () => [\"http:\", \"https:\", \"file:\"]\n  }),\n\n  tagDisplayNameFS: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `What should PhotoStructure call the \"root\" tag for browsing by filesystem paths? Note that this value is only for the UI, and will update the \"_displayName\" of the /fs/ tag: this value won't change the URL path from be \"/tag/fs/.../\". Reasonable options that have been suggested include \"Folder\", \"Directory\", \"Drive\", \"File\", \"Path\", \"Volume\", or \"Computer\".`,\n    defaultValue: \"Folder\"\n  }),\n\n  tagDisplayNameFSRoot: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `On POSIX systems, how should PhotoStructure reference the \"root\" directory (/)? \"/\" is a bit confusing, so \"root\" may be less confusing? Also see \"tagDisplayNameFSRootWithHostname\".`,\n    defaultValue: \"root\"\n  }),\n\n  tagDisplayNameFSRootWithHostname: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `On non-docker hosts (which typically don't have reliable hostnames), should the root directory tag have the hostname appended?`,\n    defaultValue: () => (isTest() ? true : !isDocker())\n  }),\n\n  tagDisplayNameFSLabels: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should PhotoStructure use volume labels, if available, as display names for filesystem tags? As an example, instead of showing \"Folder / D:\", you'd see \"Folder / Photo backup #3\" (or whatever the label D: has).`,\n    defaultValue: true\n  }),\n\n  tagAlbumFilenames: new StringArraySetting({\n    aliases: [\"tagAlbumJsonFilenames\"],\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure will look for files in the same directory with these names for album metadata. This can be JSON, XMP, MIE, or EXIF encoded, and is case-sensitive.\\nSet this to an empty array (\"[]\") to disable this feature.`,\n    defaultValue: [\"metadata.json\"] as string[]\n  }),\n\n  tagAlbumTitle: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If you have enabled \"tagAlbumFromJson\", what's the name of the field encoded in the album file? Object hierarchies are separated with a \".\".`,\n    defaultValue: \"albumData.title\"\n  }),\n\n  tagAlbumTitleHierarchies: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `If true, album titles will be split as hierarchical keywords. If false, album titles will not be split, and all albums will be under the \"Albums\" root tag.`,\n    defaultValue: false\n  }),\n\n  tagAlbumDescription: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If you have enabled \"tagAlbumFromJson\", what's the name of the field encoded in the album file? Object hierarchies are separated with a \".\".`,\n    defaultValue: \"albumData.description\"\n  }),\n\n  tagAlbumDate: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If you have enabled \"tagAlbumFromJson\", what's the name of the field encoded in the album file? Object hierarchies are separated with a \".\".`,\n    defaultValue: \"albumData.date\"\n  }),\n\n  tagAlbumsExcluded: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `For \"metadata.json\" albums, some are automatically generated. If the title or description includes any given string, it will be ignored.`,\n    defaultValue: [\"Album for automatically uploaded content\"]\n  }),\n\n  omitAncestorTags: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure's hierarchical tags assume implicit inheritance: that is, if you tag an asset with \"nature/sky\", \"nature\" is implicitly assumed.\\nIf this setting is true, PhotoStructure will omit tags that are already inferred from deeper descendant tags--that is, if an asset is tagged with \"nature/sky\" and \"nature\", and this setting is true, the \"nature\" tag will be omitted.`,\n    defaultValue: true\n  }),\n\n  // TODO:\n  // tagColor: new BooleanSetting({\n  //   name: \"tagColor\",\n  //   key: \"PS_TAG_COLOR\",\n  //   category: SettingCategories.Tagging,\n  //   description: `Should assets be tagged with their dominant color (like \"Color/Yellow\")?`,\n  //   defaultValue: true,\n  //   persisted: true\n  // }),\n\n  //\n  // Subscriptions\n  //\n\n  subscriptionTimeoutMs: new DurationSetting({\n    category: SettingCategories.Subscriptions,\n    description: `How long can PhotoStructure spend trying to gather system metadata and validating subscription licenses? This is fairly short, as the user is presumably waiting for PhotoStructure to spin up. If you have a slow system, you may want to increase this value.`,\n    defaultValue: () => \"7s\"\n  }),\n\n  pickPlanOnWelcome: new BooleanSetting({\n    category: SettingCategories.Subscriptions,\n    description: `If set to true, the welcome page flow will redirect to https://account.photostructure.com/plans to have you pick between a \"PLUS\" and \"LITE\" plan. If set to false, the welcome page will continue directly to the settings page with a \"LITE\" plan. You can still upgrade to a paid plan later from the main menu or the about page, even if this is false.`,\n    defaultValue: true\n  }),\n\n  coupon: new OptionalStringSetting({\n    category: SettingCategories.Subscriptions,\n    description: `Coupon to automatically apply during subscription setup. This value will be ignored if you've already gone through the subscription setup flow.\\nThe example value is a valid coupon code: thanks for reading!)\\nNote that you can apply a coupon after your free trial starts by visiting https://account.photostructure.com .`,\n    exampleValue: () => \"RTFM15\"\n  }),\n\n  autoRefreshLicense: new BooleanSetting({\n    category: SettingCategories.Subscriptions,\n    description: `PhotoStructure uses cryptographically signed licenses to locally store your current plan subscription status. These licenses are only valid for the current subscription period, and must be refreshed when your subscription renews or converts from a free trial to a paid subscription. To minimize the hassle of license renewals, PhotoStructure can automatically renew expired licenses in the background.\\nIf the current license has expired and this value is true, PhotoStructure will make one secure POST request to https://account.photostructure.com/ that contains several lossy one-way hashes of current system metadata. We hash all identifying metadata to only 15 characters to alleviate any privacy concerns. If your plan subscription is active, a new license will be added to your library.\\nSet this to false and set the \"reportErrors\" setting to false if you don't want PhotoStructure \"phoning home\" for any reason.\\nNote that if this is disabled, license renewals will require manual intervention: click \"Upgrade\" from the main menu, pick your plan, authenticate, and the license will automatically refresh.`,\n    defaultValue: true\n  }),\n\n  license: new OptionalStringSetting({\n    category: SettingCategories.Subscriptions,\n    sensitive: true,\n    description: `Subscription licenses are normally saved automatically into both your library and system configuration directories. This setting just provides users with an alternative way to provide a license, if it's more convenient. Any value provided to this setting will be considered in addition to existing license files when PhotoStructure is trying to find the \"best\" license available.`\n  })\n}\n\n// First set everyone's name:\nfor (const [k, v] of entries(Settings)) {\n  v._setName(k)\n}\n\n/**\n * Force the given path-separated paths to be the suggested values on the\n * welcome page.\n */\nexport const SuggestedDirsEnvKey = \"SUGGESTED_DIRS\"\n\n// Only exported for testing:\nexport function withDefaultPaths(paths: Maybe<string>): string {\n  const arr = (blank(paths) ? \"\" : paths).split(delimiter)\n  if (isDocker()) {\n    arr.unshift(\"/opt/photostructure/tools/bin\")\n  }\n  arr.push(...Settings.toolPaths.valueOrDefault)\n  return uniq(arr).filter(notBlank).join(delimiter)\n}\n\n// use getEnv(), not env().PATH, because Windows can use \"Path\"\nexport const pathWithDefaults = lazy(() => withDefaultPaths(getEnv(\"PATH\")))\n\nexport const allSettings = lazy(() => {\n  return sortBy(values(Settings), settingsSorter)\n})\n\nexport const persistedSettings = lazy(() => {\n  return allSettings().filter(ea => !ea.transient)\n})\n\nexport const transientSettings = lazy(() => {\n  return allSettings().filter(ea => ea.transient)\n})\n\nexport const persistedSystemSettings = lazy(() => {\n  return persistedSettings().filter(ea =>\n    SystemCategories.includes(ea.category)\n  )\n})\n\nexport const persistedLibrarySettings = lazy(() => {\n  return persistedSettings().filter(ea =>\n    LibraryCategories.includes(ea.category)\n  )\n})\n\nfunction settingsSorter(s: Setting<any>) {\n  return [\n    s.categoryType === \"system\" ? 0 : 1,\n    SettingCategories.indexOf(s.category) ?? SettingCategories.length + 1,\n    s.advanced,\n    s.name\n  ]\n}\n\nconst SettingsByNameOrKey = lazy(() => {\n  const settings = new CaseInsensitiveMap<Setting>()\n  for (const s of persistedSettings()) {\n    // Support both logLevel, log_level, and PS_LOG_LEVEL:\n    for (const ea of s.names) {\n      settings.set(ea, s)\n    }\n    for (const ea of s.keys) {\n      settings.set(ea, s)\n    }\n  }\n  return settings\n})\n\nexport function getSettingByNameOrKey(s: string) {\n  return SettingsByNameOrKey().get(toS(s).toLowerCase())\n}\n\nexport const ciSettings = lazy(\n  () => new CaseInsensitiveValued(Settings, (_, s) => [...s.names, ...s.keys])\n)\n\n// later(() => {\n//   if (isTest) {\n//   caseInsensitiveEnv.watchLater(() =>\n//     values(Settings).forEach(ea => ea.refreshEnvValue())\n//   )\n// })\n","import { lazy } from \"../../core/Lazy\"\nimport { isProd, isTest } from \"../NodeEnv\"\nimport { defaultCacheDir } from \"../dir/CacheDir\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { DefaultDockerLibraryDir } from \"../dir/DefaultDockerLibraryDir\"\nimport {\n  defaultLibraryDir,\n  defaultOriginalsDir\n} from \"../dir/DefaultLibraryDir\"\nimport { defaultLogDir_ } from \"../dir/LogDir\"\nimport { defaultPicturesDir } from \"../dir/PicturesDir\"\nimport { isEnvTrue } from \"../env/GetEnv\"\nimport { DefaultSharedStateDir } from \"../event/DefaultSharedStateDir\"\nimport { useFsWatch } from \"../fs/BaseFile\"\nimport { DefaultPaths, DefaultPosixPaths } from \"../fs/DefaultPaths\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { maxCpus } from \"../work/MaxCpus\"\nimport { Settings } from \"./Settings\"\n\n// This file was extracted to prevent Settings-related dependency loops.\n\n// Note that we're actually changing .opts.defaultValue here--it's the \"real\"\n// default.\n\nexport const setSettingsDefaults = lazy(() => {\n  Settings.configDir.opts.defaultValue = configDir\n\n  Settings.logDir.opts.defaultValue = defaultLogDir_\n\n  Settings.cacheDir.opts.defaultValue = defaultCacheDir\n\n  Settings.sharedStateDir.opts.defaultValue = () =>\n    DefaultSharedStateDir()?.nativePath\n\n  Settings.toolPaths.opts.defaultValue = () =>\n    (isEnvTrue(\"SETTINGS_IO_TEST\" as any)\n      ? DefaultPosixPaths\n      : DefaultPaths) as string[]\n\n  Settings.libraryDir.opts.exampleValue = () =>\n    isProd && isDocker()\n      ? DefaultDockerLibraryDir\n      : isTest\n      ? \"/home/test/Pictures\"\n      : defaultPicturesDir()\n\n  Settings.libraryDir.opts.defaultValue = defaultLibraryDir\n\n  Settings.originalsDir.opts.defaultValue = defaultOriginalsDir\n\n  Settings.scanPaths.opts.exampleValue = () => [defaultPicturesDir()]\n\n  Settings.powerShellProcs.opts.defaultValue = () =>\n    Math.max(2, Math.round(maxCpus() / 4))\n\n  // This breaks a deploop between Settings and BaseFile:\n  Settings.useFsWatch.watch(useFsWatch)\n})\n","export const SettingsToml = \"settings.toml\"\n","import { delimiter } from \"path\"\nimport {\n  compact,\n  compactBlankish,\n  isEmpty,\n  isNotEmpty,\n  uniq\n} from \"../../fe/Array\"\nimport { notBlankToS } from \"../../fe/Blank\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toA } from \"../../fe/toA\"\nimport {\n  BaseSettingOpts,\n  DefaultValued,\n  Setting,\n  SettingConverters\n} from \"./Setting\"\n\nexport function _join(arr: Maybe<string[]>): Maybe<string> {\n  return arr == null ? undefined : stringify(arr)\n}\n\nfunction _split(s: Maybe<string>): Maybe<string[]> {\n  const str = notBlankToS(s)\n  if (str == null) return\n  if (str.startsWith(\"[\") && str.endsWith(\"]\")) {\n    try {\n      return compact(toA(JSON.parse(str)).map(notBlankToS))\n    } catch {\n      //\n    }\n  }\n  // broken pipe kept for backward compatibility:\n  for (const ea of [\"¦\", delimiter]) {\n    if (str.includes(ea)) {\n      return compactBlankish(str.split(ea))\n    }\n  }\n  return [str]\n}\n\nexport function splitStringArray(s: Maybe<string>): Maybe<string[]> {\n  return map(_split(s), compactBlankish)\n}\n\nexport class StringArraySetting<T extends string = string> extends Setting<\n  T[]\n> {\n  constructor(\n    opts: BaseSettingOpts<T[]> &\n      Partial<DefaultValued<T[]>> &\n      Partial<SettingConverters<T[]>>\n  ) {\n    super({\n      defaultValue: [],\n      fromEnv: splitStringArray as any,\n      toEnv: _join,\n      ...opts\n    })\n  }\n\n  protected toValidValue(s: Maybe<string>): Maybe<T> {\n    return notBlankToS(s) as T\n  }\n\n  protected toValidValues(arr: Maybe<string[]>): Maybe<T[]> {\n    return arr == null ? undefined : uniq(arr.map(ea => this.toValidValue(ea)))\n  }\n\n  push(...values: string[]) {\n    if (isEmpty(values)) return\n    this.value = this.toValidValues([...toA(this.value), ...toA(values)])\n  }\n\n  has(value: string) {\n    return toA(this.values).includes(value as any)\n  }\n\n  /**\n   * valueOrDefault for arrays\n   *\n   * @todo replace callers with valueOrDefault? This method as it stands isn't\n   * safe, as it could be modified by a caller.\n   */\n  get values(): T[] {\n    return this.value ?? this.defaultValue\n  }\n\n  set values(arr: Maybe<string[]>) {\n    this.userValue = this.toValidValues(arr)\n  }\n\n  /**\n   * @return if `this.values` is an empty array. Note that this.values delegates to this.defaultValue if this.value is nullish.\n   */\n  isEmpty() {\n    return isEmpty(this.values)\n  }\n\n  isNotEmpty() {\n    return isNotEmpty(this.values)\n  }\n}\n","import { StrEnum } from \"../../fe/StrEnum\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class StringEnumSetting<T extends string> extends Setting<T> {\n  readonly strEnum: StrEnum<T>\n  constructor(opts: SettingOpts<T> & { strEnum: StrEnum<T> }) {\n    super({\n      toEnv: s => opts.strEnum.getCI(s),\n      fromEnv: s => opts.strEnum.getCI(s),\n      ...opts\n    })\n    this.strEnum = opts.strEnum\n    // NOTE: do not compactBlanks! A blank may be a valid value!\n    const dv = this.defaultValue\n    // Allow defaultValue to be undefined:\n    if (!this.strEnum.has(dv)) {\n      throw new Error(\n        `${this.strEnum.values}, doesn't include defaultValue, ${opts.defaultValue}`\n      )\n    }\n  }\n  addToJSON() {\n    return { \"valid values\": this.strEnum.values }\n  }\n}\n","import { compact, uniq } from \"../../fe/Array\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { StrEnum } from \"../../fe/StrEnum\"\nimport { BaseSettingOpts } from \"./Setting\"\nimport { StringArraySetting, splitStringArray } from \"./StringArraySetting\"\n\nfunction parseStringEnum<T extends string>(\n  str: Maybe<string>,\n  strEnum: StrEnum<T>\n): Maybe<T[]> {\n  return compact(splitStringArray(str)?.map(ea => strEnum.getCI(ea)))\n}\n\nexport class StringEnumsSetting<T extends string> extends StringArraySetting {\n  readonly strEnum: StrEnum<T>\n  constructor(\n    opts: BaseSettingOpts<string[]> & {\n      defaultValue?: T[]\n      strEnum: StrEnum<T>\n    }\n  ) {\n    super({\n      toEnv: arr => map(arr, ea => stringify(uniq(ea))),\n      fromEnv: s => parseStringEnum(s, opts.strEnum),\n      defaultValue: opts.defaultValue ?? opts.strEnum.values,\n      ...opts\n    })\n    this.strEnum = opts.strEnum\n  }\n\n  protected override toValidValue(s: string): Maybe<T> {\n    return this.strEnum.getCI(s)\n  }\n\n  override addToJSON() {\n    return { \"valid values\": this.strEnum.values }\n  }\n}\n","import { notBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class StringSetting extends Setting<string> {\n  constructor(opts: SettingOpts<string>) {\n    super({\n      toEnv: trim,\n      fromEnv: trim,\n      ...opts\n    })\n  }\n\n  hasValue() {\n    return notBlank(this.value)\n  }\n}\nfunction trim(s: Maybe<string>) {\n  return s == null ? undefined : s.trim()\n}\n","import { join } from \"path\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { SettingsToml } from \"./SettingsToml\"\n\nexport function systemSettingsFile(): Maybe<string> {\n  return map(configDir(), ea => join(ea, SettingsToml))\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const TagInferenceSettingValues = strEnum(\"never\", \"always\", \"auto\")\nexport type TagInferenceSettingValue = StrEnumKeys<\n  typeof TagInferenceSettingValues\n>\n","import { JsonMap, parse } from \"@iarna/toml\"\nimport { readFile, readFileSync, writeFile } from \"fs-extra\"\nimport { blank, mapNotBlank } from \"../../fe/Blank\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { Obj } from \"../../fe/Object\"\nimport { debom } from \"../Buffer\"\nimport { mkLogger } from \"../Logger\"\nimport { dumbquote } from \"../String\"\nimport { joinLines } from \"../fs/CRLF\"\nimport { SimpleFileOrString, toNativePath_ } from \"../fs/SimpleFile\"\nimport { isFileSync } from \"../fs/StatSync\"\nimport { stringifyToml } from \"./TomlStringify\"\n\nfunction parseToml(s: Maybe<string>) {\n  return blank(s) ? undefined : parse(dumbquote(s))\n}\n\nfunction parseTomlBuffer(buf: Buffer) {\n  return parseToml(debom(buf))\n}\n\nexport function readTomlFileSync(\n  file: Maybe<SimpleFileOrString>\n): Maybe<JsonMap> {\n  const nativePath = mapNotBlank(file, toNativePath_)\n  if (nativePath == null) return\n  try {\n    return isFileSync(nativePath)\n      ? parseTomlBuffer(readFileSync(nativePath))\n      : undefined\n  } catch (error) {\n    mkLogger(\"settings.Toml\").warn(\"readTomlFileSync() failed\", {\n      nativePath,\n      error\n    })\n    return\n  }\n}\n\nexport async function readTomlFile_(\n  file: Maybe<SimpleFileOrString>\n): PromiseMaybe<JsonMap> {\n  return mapNotBlank(file, async ea =>\n    parseTomlBuffer(await readFile(toNativePath_(ea)))\n  )\n}\n\nexport function writeTomlFile_(file: SimpleFileOrString, data: Obj) {\n  return writeFile(toNativePath_(file), joinLines(...stringifyToml(data)))\n}\n","import { blank } from \"../../fe/Blank\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { Obj, entries } from \"../../fe/Object\"\nimport { wrap } from \"../../fe/String\"\nimport { toA } from \"../../fe/toA\"\nimport { splitLines } from \"../fs/CRLF\"\nimport { WrapComments } from \"./WrapComments\"\n\nexport function stringifyToml(obj: Obj) {\n  return splitLines(...entries(obj).map(([k, v]) => kvToToml(k, v)))\n}\n\nfunction kvToToml(k: string, v: any) {\n  // We add 2 spaces here to make long array values wrap:\n  return k + \" = \" + stringify(v, undefined, 2)\n}\n\nexport function wrapTomlToLines(args: {\n  lines: string[]\n  wrap?: typeof WrapComments\n  key: Maybe<string>\n  value: any\n  prepend?: string[]\n}) {\n  if (blank(args.key) || args.value == null) return args.lines\n  const lines = [...toA(args.prepend), kvToToml(args.key, args.value)]\n  if (args.lines.length > 0) lines.unshift(\"\")\n  args.lines.push(...wrap(lines, args.wrap))\n  return args.lines\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const UpgradeChannels = strEnum(\"prealpha\", \"alpha\", \"beta\", \"stable\")\nexport type UpgradeChannel = StrEnumKeys<typeof UpgradeChannels>\n","export const WrapComments = { maxLineLen: 78, prefix: \"# \" }\n","import { stripCopySuffixFromName, stripDSC } from \"../fs/FuzzyNames\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { isString, trimLeftPadding } from \"../String\"\n\n/**\n * Pull out the basename, remove prefixes like \"IMG_\", \"VID_\", and \"MOV_\",\n * strip any count suffixes, then downcase.\n */\nexport function bname(f: SimpleFile | string, stripCounts = true): string {\n  let name = isString(f) ? f : f.name\n  if (stripCounts) {\n    name = stripCopySuffixFromName(name)\n  }\n  name = trimLeftPadding(stripDSC(name))\n  return name.toLowerCase().normalize()\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const DateTagFormats = strEnum(\"y\", \"ym\", \"ymd\", \"\")\nexport type DateTagFormat = StrEnumKeys<typeof DateTagFormats>\n","import { Tags } from \"exiftool-vendored\"\n\ntype TagKeys = keyof Tags | \"creationTime\" | \"photoTakenTime\" | \"HistoryWhen\"\n\nexport const IgnoredCapturedAtTags = [\n  \"creationTime\", // Google Photos upload time\n  \"HistoryWhen\", // is when history records happen, NOT when the file was captured!\n  \"MediaModifyDate\", // is the last media edit time\n  \"MetadataDate\", // is the last time the _metadata was edited_. See https://forum.photostructure.com/t/combining-images/524/8 for details\n  \"SubSecTime\", // is fractional seconds (not the full date and time) for ModifyDate\n  \"TrackModifyDate\"\n] as const satisfies readonly TagKeys[]\n\n/**\n * These tags should only be used if \"standard\" captured-at tags have no valid\n * values. The first valid ExifDateTime value will be used.\n */\nexport const ProblematicCapturedAtTags = [\n  // (called DateTimeDigitized by the EXIF spec)\n  // https://forum.photostructure.com/t/incorrect-date-assigned-to-photo/419\n  // and\n  // https://forum.photostructure.com/t/photostructure-ignored-the-date-metadata-of-some-photos-marked-them-as-taken-in-2002/340\n  // Note that this tag may have an incorrect zone offset (it may incorrectly\n  // be UTC or local system time), so it's \"problematic\".\n  \"SubSecCreateDate\",\n  \"SubSecMediaCreateDate\",\n  \"SubSecModifyDate\",\n\n  \"CreateDate\",\n  \"MediaCreateDate\", // < may have incorrect timezone like CreateDate\n  \"ModifyDate\", // is called DateTime by the EXIF spec, and may be the last edit time, or the actual captured-at (see the QuickTake DC50 example)\n  \"DateTime\",\n  \"DateTimeCreated\", // composite tag, sometimes has wrong timezone.\n\n  \"photoTakenTime\", // < Google Takeout (not really reliable, though)\n\n  \"TrackCreateDate\", // < may not have correct timezone\n\n  \"CreationTime\" // < set by some screenshot software, and _MAY INCLUDE DATETIME!_ . May be rendered as \"Wed 16 Jun 2021 03:34:46 PM PDT\"\n] as const satisfies readonly Exclude<\n  TagKeys,\n  (typeof IgnoredCapturedAtTags)[number] // < prevents duplicate keys\n>[]\n\nexport const DefaultCapturedAtTagsConst = [\n  // By the specification, DateTimeOriginal should be the time of the\n  // shutter actuation, and CreateDate should be the time that the file\n  // was written to the memory card (but not all mfrs follow the spec)\n  // http://u88.n24.queensu.ca/exiftool/forum/index.php?topic=2568.0\n\n  // https://exiftool.org/TagNames/EXIF.html\n\n  \"CreationDate\", // only found on iPhone movies, but they include timezone offsets, which we really want. See https://exiftool.org/forum/index.php?topic=12837.msg69410#msg69410\n\n  \"DateTimeOriginal\", // date/time when original image was taken. Quicktime:DateTimeOriginal will also include the timezone offset.\n  \"SubSecDateTimeOriginal\", // (fractional seconds for DateTimeOriginal)\n\n  \"DateTimeDigitized\",\n\n  \"OriginalCreateDateTime\",\n\n  \"DigitalCreationDateTime\" // composite tag\n] as const satisfies readonly Exclude<\n  TagKeys,\n  | (typeof IgnoredCapturedAtTags)[number] // < prevents duplicate keys\n  | (typeof ProblematicCapturedAtTags)[number] // < prevents duplicate keys\n>[]\n","import { ExifTags } from \"./ExifTags\"\n\nexport const DefaultIncludedPreviewTags: (keyof ExifTags)[] = [\n  \"AttributionName\",\n  \"AttributionURL\",\n  \"capturedAt\",\n  \"Copyright\",\n  \"exposureSettings\",\n  \"GPSLatitude\",\n  \"GPSLongitude\",\n  \"License\",\n  \"Make\",\n  \"Model\",\n  // NO: \"Orientation\", because we always raster correctly-rotated images\n  \"Permits\",\n  \"Prohibits\",\n  \"Rating\",\n  \"Requires\",\n  // NO: \"Rotation\", because we always raster correctly-rotated images.\n  \"Source\"\n]\n\n// OriginalDirectory and OriginalFilename are obscure GettyImagesGIFT XMP tags\n","// https://en.wikipedia.org/wiki/List_of_photographic_equipment_makers#Manufacturers_of_cameras_or_lenses_and_filters\n// Don't use this directly! Use Settings.lensMakes!\nexport const DefaultLensMakes = [\n  \"7artisans\",\n  \"Bower\",\n  \"Canon\",\n  \"Carl Zeiss\",\n  \"Cosina\",\n  \"Fuji\",\n  \"Fujifilm\",\n  \"Goerz\",\n  \"Hasselblad\",\n  \"Hirox\",\n  \"Hoya\",\n  \"Kodak\",\n  \"Konica\",\n  \"Leica\",\n  \"Leidolf\",\n  \"Lensbaby\",\n  \"Lumix\",\n  \"Meike\",\n  \"Meopta\",\n  \"Minolta\",\n  \"Neewer\",\n  \"Nikon\",\n  \"Olympus\",\n  \"Opteka\",\n  \"Panasonic\",\n  \"Pentacon\",\n  \"Pentax\",\n  \"Ricoh\",\n  \"Rodenstock\",\n  \"Rokinon\",\n  \"Ross\",\n  \"Samsung\",\n  \"Samyang\",\n  \"Seiko\",\n  \"Sigma\",\n  \"Silor\",\n  \"Soligor\",\n  \"Sony\",\n  \"Sunpak\",\n  \"Tamron\",\n  \"Tiffen\",\n  \"Tokina\",\n  \"Topcon\",\n  \"Venus\",\n  \"Voigtländer\",\n  \"Wray\",\n  \"Yongnuo\",\n  \"Zeiss\",\n  \"Zhong Yi\",\n  \"Zuiko\"\n]\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const KeywordReparentingStrategies = strEnum(\"move\", \"copy\", \"retain\")\nexport type KeywordReparentingStrategy = StrEnumKeys<\n  typeof KeywordReparentingStrategies\n>\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const NameTagFormats = strEnum(\n  \"as-is\",\n  \"family/given\",\n  \"family/fullname\"\n)\nexport type NameTagFormat = StrEnumKeys<typeof NameTagFormats>\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const NameTagOrders = strEnum(\"western\", \"eastern\")\nexport type NameTagOrder = StrEnumKeys<typeof NameTagOrders>\n","export const DefaultExcludedLinuxRoots = [\n  \"boot\",\n  \"efi\",\n  \"etc\",\n  \"lib\", // don't exclude /net, that's used for nfs mounts!\n  \"proc\",\n  \"snap\",\n  \"sys\",\n  \"tmp\"\n]\n\nexport const DefaultExcludedLinuxMountpointPaths = [\n  \"/dev/shm\",\n  \"/run\",\n  \"/run/lock\",\n  \"/run/qemu\",\n  \"/run/snapd/ns\",\n  \"/tmp\",\n  \"/var/tmp\"\n]\n\nexport const DefaultExcludedLinuxMountpointNames = [\"#snapshot\"]\n","export const DefaultExcludedFilesystemTypes = [\n  \"cgmfs\",\n  \"cgroup\",\n  \"debugfs\",\n  \"devfs\",\n  \"devtmpfs\",\n  \"sunrpc\",\n  \"sysfs\",\n  \"tracefs\",\n  \"udev\"\n]\n","import { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { mkLogger } from \"../Logger\"\nimport { memoize } from \"../MemoizedFunc\"\nimport { isTest } from \"../NodeEnv\"\nimport { toPathnames } from \"../fs/Path\"\nimport { isLinux, isPosix, isWin } from \"../platform/Platform\"\nimport { Settings } from \"../settings/Settings\"\n\nconst logger = lazy(() => mkLogger(\"volumes.PosixVolumes\"))\n\n// https://www.pathname.com/fhs/pub/fhs-2.3.html\n\n// NOTE: DO NOT EXCLUDE \"/dev/mapper/ubuntu--vg-root\", that may be the root (and\n// only!) filesystem\n\n// rootfs             8064632   738996    7325636      10% /\n// devtmpfs           8064644        0    8064644       0% /dev\n// tmpfs              8139340        0    8139340       0% /dev/shm\n// cgroup_root           8192        0       8192       0% /sys/fs/cgroup\n// tmpfs               131072      236     130836       1% /var/log\n// /dev/sda1         15000224   257824   14742400       2% /boot\n// overlay            8064632   738996    7325636      10% /lib/modules\n// overlay            8064632   738996    7325636      10% /lib/firmware\n// tmpfs                 1024        0       1024       0% /mnt/disks\n// tmpfs                 1024        0       1024       0% /mnt/remotes\n// /dev/md1        9764349900 68111704 9696238196       1% /mnt/disk1\n// /dev/sdc1        244197560 22023600  222164096      10% /mnt/cache\n// shfs            9764349900 68111704 9696238196       1% /mnt/user0\n// shfs            9764349900 68111704 9696238196       1% /mnt/user\n// /dev/loop2        20971520     3960   20429576       1% /var/lib/docker\n// /dev/loop3         1048576     3852     926164       1% /etc/libvirt\n\n// Filesystem              1024-blocks       Used  Available Capacity Mounted on\n// udev                       32857360          0   32857360       0% /dev\n// tmpfs                       6584180       4908    6579272       1% /run\n// /dev/nvme0n1p2            479152840  321307948  133435500      71% /\n// tmpfs                      32920884     212868   32708016       1% /dev/shm\n// tmpfs                          5120          4       5116       1% /run/lock\n// tmpfs                      32920884          0   32920884       0% /sys/fs/cgroup\n// /dev/loop1                    56832      56832          0     100% /snap/core18/2066\n// /dev/loop2                    56832      56832          0     100% /snap/core18/2074\n// /dev/loop3                   101760     101760          0     100% /snap/core/11316\n// /dev/loop4                    66688      66688          0     100% /snap/gtk-common-themes/1515\n// /dev/nvme1n1              960381672  786958628  124568532      87% /mnt/c24fdf53-fc92-43ae-a1a5-9342d067b4a5\n// /dev/loop5                    52352      52352          0     100% /snap/snap-store/518\n// /dev/loop0                   101760     101760          0     100% /snap/core/11187\n// /dev/loop6                    66432      66432          0     100% /snap/gtk-common-themes/1514\n// /dev/loop8                   166784     166784          0     100% /snap/gnome-3-28-1804/145\n// /dev/loop9                   183936     183936          0     100% /snap/spotify/46\n// /dev/loop10                  259200     259200          0     100% /snap/dbeaver-ce/136\n// /dev/loop11                  224256     224256          0     100% /snap/gnome-3-34-1804/72\n// /dev/loop12                   89344      89344          0     100% /snap/sqlitebrowser/3233\n// /dev/loop13                   33152      33152          0     100% /snap/snapd/12159\n// /dev/loop14                   52224      52224          0     100% /snap/snap-store/547\n// /dev/loop15                  224256     224256          0     100% /snap/gnome-3-34-1804/66\n// /dev/loop16                  183808     183808          0     100% /snap/spotify/45\n// /dev/loop17                   33152      33152          0     100% /snap/snapd/12398\n// /dev/nvme0n1p1               523248       8036     515212       2% /boot/efi\n// 10.1.1.9:/volume1/homes  7496824320 4121892736 3374931584      55% /rusty2-homes-nfs\n// //10.1.1.9/homes         7496824260 4121892788 3374931472      55% /media/mrm/rusty2-home\n// //10.1.1.7/homes         5809423160 4979412148  830011012      86% /media/mrm/rusty-home\n// tmpfs                       6584176          8    6584168       1% /run/user/1002\n// tmpfs                       6584176         20    6584156       1% /run/user/125\n// tmpfs                       6584176       1528    6582648       1% /run/user/1000\n// /dev/loop18                  168832     168832          0     100% /snap/gnome-3-28-1804/161\n// /dev/loop19                  259200     259200          0     100% /snap/dbeaver-ce/137\n\nexport function isExcludedFilesystem(filesystem: string) {\n  if (blank(filesystem)) return false\n  return isPosix && Settings.excludedFilesystemTypes.values.includes(filesystem)\n}\n\nconst LinuxDevMapperRE =\n  isLinux || isTest ? /^\\/dev(?!\\/mapper)(?:\\/|\\/?$)/i : undefined\n\nconst LinuxVarSnapRE = isLinux || isTest ? /^\\/var\\/snap(?:$|\\/)/ : undefined\n\nconst LinuxRunUserGVFSRE =\n  isLinux || isTest ? /^\\/run\\/user\\/\\d+\\/gvfs\\/.+?$/i : undefined\n\nconst LinuxDockerRE = isLinux || isTest ? /^\\/var\\/lib\\// : undefined\n\n// Avoid stuff like\n\n// mrm@m1 % mount | grep /System\n// /dev/disk3s6 on /System/Volumes/VM (apfs, local, noexec, journaled, noatime, nobrowse)\n// /dev/disk3s2 on /System/Volumes/Preboot (apfs, local, journaled, nobrowse)\n// /dev/disk3s4 on /System/Volumes/Update (apfs, local, journaled, nobrowse)\n// /dev/disk1s2 on /System/Volumes/xarts (apfs, local, noexec, journaled, noatime, nobrowse)\n// /dev/disk1s1 on /System/Volumes/iSCPreboot (apfs, local, journaled, nobrowse)\n// /dev/disk1s3 on /System/Volumes/Hardware (apfs, local, journaled, nobrowse)\n// /dev/disk3s1 on /System/Volumes/Data (apfs, local, journaled, nobrowse, protect)\n// map auto_home on /System/Volumes/Data/home (autofs, automounted, nobrowse)\n\n// mrm@mini ~ % mount | grep System\n// /dev/disk6s4 on /System/Volumes/VM (apfs, local, noexec, journaled, noatime, nobrowse)\n// /dev/disk6s2 on /System/Volumes/Preboot (apfs, local, journaled, nobrowse)\n// /dev/disk6s6 on /System/Volumes/Update (apfs, local, journaled, nobrowse)\n// /dev/disk6s1 on /System/Volumes/Data (apfs, local, journaled, nobrowse)\n// map auto_home on /System/Volumes/Data/home (autofs, automounted, nobrowse)\n\n// DO NOT AVOID \"/System/Volumes/Data\": that's where people's home dir is!\n\n// (memoized mostly to avoid all the duplicate log messages)\nexport const isExcludedMountpoint = memoize(\n  (mountpoint: Maybe<string>) => {\n    if (isWin) return false // no excluded drive letters\n    const why = whyExcludedMountpoint(mountpoint)\n    return logger().tap({\n      msg: \"isExcludedMountpoint\",\n      result: why != null,\n      meta: { mountpoint, why }\n    })\n  },\n  { maxSize: 512 }\n)\n\nexport function whyExcludedMountpoint(\n  mountpoint: Maybe<string>\n): Maybe<string> {\n  if (blank(mountpoint)) {\n    return \"blank\"\n  }\n  const arr = toPathnames(mountpoint)\n  const root = arr[0]\n  const basename = arr[arr.length - 1]\n  if (Settings.excludedRootDirectories.has(root)) {\n    return \"ExcludedRootDirectory\"\n  }\n  if (Settings.excludedMountpointPaths.has(mountpoint)) {\n    return \"excludedMountpointPaths\"\n  }\n  if (Settings.excludedMountpointBasenames.has(basename)) {\n    return \"excludedMountpointBasenames\"\n  }\n  if (LinuxDevMapperRE?.test(mountpoint) === true) {\n    return \"LinuxDevMapperRE\"\n  }\n  if (LinuxVarSnapRE?.test(mountpoint) === true) {\n    return \"LinuxVarSnapRE\"\n  }\n  if (root === \"run\" && LinuxRunUserGVFSRE?.test(mountpoint) === false) {\n    return \"LinuxRunRE\"\n  }\n  if (LinuxDockerRE?.test(mountpoint) === true) {\n    return \"LinuxDockerRE\"\n  }\n  return\n}\n","import { secondMs } from \"../../fe/Date\"\nimport { MiB } from \"../../fe/Units\"\nimport { Settings } from \"../settings/Settings\"\n\n/**\n * This needs to be short enough to pick up when drives are inserted or\n * ejected in reasonable-ish time, but not so often it breaks the OS\n */\nexport function mountpointsTtlMs() {\n  return Settings.mountpointsTtlMs.valueOrDefault\n}\n\n/**\n * Update frequently enough to detect substantive changes in available bytes\n */\nexport function volumeMetadataTtlMs() {\n  return Settings.volumeMetadataTtlMs.valueOrDefault\n}\n\n// TODO: MOVE to .. (this isn't a volume-specific thing!)\n/**\n * How long the `df` or `wmic` should be allowed to run before timing out.\n * Note that external hard drives can take longer than 10 seconds to spin\n * up...\n */\nexport function commandTimeoutMs() {\n  return Settings.commandTimeoutMs.valueOrDefault\n}\n\n/**\n * The worst-expected transfer rate for file I/O:\n */\nexport const MinIoRate = MiB / secondMs\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const HelmetPlugins = strEnum(\n  \"all\",\n  \"contentSecurityPolicy\",\n  \"crossOriginEmbedderPolicy\",\n  \"crossOriginOpenerPolicy\",\n  \"crossOriginResourcePolicy\",\n  \"dnsPrefetchControl\",\n  \"expectCt\",\n  \"frameguard\",\n  \"hidePoweredBy\",\n  \"hsts\",\n  \"ieNoOpen\",\n  \"noSniff\",\n  \"originAgentCluster\",\n  \"permittedCrossDomainPolicies\",\n  \"referrerPolicy\",\n  \"xssFilter\"\n)\n\nexport type HelmetPlugin = StrEnumKeys<typeof HelmetPlugins>\n","import os from \"os\"\nimport { lazy } from \"../../core/Lazy\"\nimport { gt0 } from \"../../fe/Number\"\nimport { intFromFileSync } from \"../fs/ReadFile\"\nimport { isDocker } from \"../platform/isDocker\"\n\n// cpu() can take 500ms!\nexport const cpuInfo = lazy(() => os.cpus())\n\nexport const cpuCount = lazy(() => {\n  if (isDocker()) {\n    // Are we in a pod?\n    // See https://www.reddit.com/r/PhotoStructure/comments/sn68f9/initial_scan_not_adding_everything/hw4bqmj/\n    const quota = intFromFileSync(\"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\")\n    const period =\n      quota != null\n        ? intFromFileSync(\"/sys/fs/cgroup/cpu/cpu.cfs_period_us\")\n        : undefined\n    if (gt0(quota) && gt0(period)) {\n      return quota / period\n    }\n\n    const shares = intFromFileSync(\"/sys/fs/cgroup/cpu/cpu.shares\")\n    if (gt0(shares)) {\n      return (cpuInfo().length * shares) / 1024\n    }\n  }\n  return cpuInfo().length\n})\n","import os from \"os\"\nimport { lazy } from \"../../core/Lazy\"\nimport { gt0 } from \"../../fe/Number\"\nimport { fmtBytes } from \"../../fe/Units\"\nimport { mkLogger } from \"../Logger\"\nimport { intFromFileSync } from \"../fs/ReadFile\"\nimport { isDocker } from \"../platform/isDocker\"\n\nconst logger = lazy(() => mkLogger(\"work.FreeMem\"))\n\n// lazy for tests:\n\nexport const estimatedFreeMem = lazy(() => {\n  const freemem = os.freemem()\n  const totalmem = os.totalmem()\n  // By using both free and total memory, we don't ignore\n  // current system load, but aren't borked if all memory is used currently (by\n  // filesystem cache, presumably)\n  const result = (freemem * 2 + totalmem) / 3\n  if (isDocker()) {\n    // See\n    // https://www.reddit.com/r/PhotoStructure/comments/sn68f9/initial_scan_not_adding_everything/hw4bqmj/\n\n    const mem = intFromFileSync(\"/sys/fs/cgroup/memory/memory.limit_in_bytes\")\n    // k8s may return 9223372036854771712 if memory isn't limited (which means use the system memory...)\n    if (gt0(mem))\n      return logger().tap({\n        msg: \"estimatedFreeMem() (docker mode)\",\n        result: Math.min(mem, result),\n        meta: { freemem, totalmem }\n      })\n  }\n  return logger().tap({\n    msg: \"estimatedFreeMem() \",\n    result,\n    meta: {\n      result: fmtBytes(result),\n      freemem: fmtBytes(freemem),\n      totalmem: fmtBytes(totalmem)\n    }\n  })\n})\n","import { lazy } from \"../../core/Lazy\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { clamp, gt0, sigFigs, toGt0 } from \"../../fe/Number\"\nimport { MB } from \"../../fe/Units\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { ee } from \"../event/EventEmitter\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { lerp2d } from \"../math/Lerp\"\nimport { Settings } from \"../settings/Settings\"\nimport { cpuCount } from \"./CpuInfo\"\nimport { estimatedFreeMem } from \"./FreeMem\"\nimport { timeoutRate } from \"./WorkTimeout\"\n\nconst logger = lazy(() => mkLogger(\"work.MaxCpus\"))\n\nlater(() => {\n  if (isTest) {\n    ee().on(\"clearCache\", () =>\n      // we actually set() some of these in some specs:\n      clearMaxWorkCaches()\n    )\n  }\n  ee().on(\"settingsChanged\", clearMaxWorkCaches)\n  Settings.cpuLoadPercent.watchLater(clearMaxWorkCaches)\n  Settings.maxConcurrentImports.watchLater(clearMaxWorkCaches)\n})\n\nexport function clearMaxWorkCaches() {\n  estimatedFreeMem.unset()\n  maxCpus.unset()\n  maxConcurrentImports.unset()\n  timeoutRate.prior()?.clear()\n  sharpThreadsPerProcess.unset()\n  cpuCount.unset()\n}\n\nconst maxProcsForMem = lazy(() => {\n  // they may bloat, but they'll recycle if they get too big.\n  const worstCaseMemPerProc = Settings.maxMemoryMb.valueOrDefault * MB\n  // We don't want to over-subscribe system memory, but we need to run at\n  // least one:\n  return logger().tap({\n    msg: \"maxProcsForMem\",\n    result: Math.max(1, Math.floor(estimatedFreeMem() / worstCaseMemPerProc)),\n    meta: {\n      estFreeMemMb: Math.round(estimatedFreeMem() / MB),\n      worstCaseMemPerProcMb: Math.round(worstCaseMemPerProc / MB)\n    }\n  })\n}, minuteMs)\n\nexport function timeoutPenalization() {\n  const timeoutsPerMinute = Math.round(\n    timeoutRate.prior()?.eventsPerMinute ?? 0\n  )\n  const timeoutThrottleCoeff = Settings.timeoutThrottleCoeff.valueOrDefault\n\n  const result =\n    timeoutsPerMinute === 0 || timeoutThrottleCoeff === 0\n      ? 1 // < timeouts are disabled\n      : sigFigs(timeoutThrottleCoeff / timeoutsPerMinute, 2)\n\n  return logger().tap({\n    msg: \"timeoutPenalization()\",\n    level: result > 1 ? LogLevels.warn : LogLevels.debug,\n    result,\n    meta: {\n      timeoutsPerMinute,\n      timeoutThrottleCoeff\n    }\n  })\n}\n\nexport function targetCpuLoadPct() {\n  return (toGt0(Settings.cpuLoadPercent.valueOrDefault) ?? 1) / 100\n}\n\nexport function singleThreadMode() {\n  return (\n    Math.round(targetCpuLoadPct() * cpuCount()) <= 1 ||\n    Settings.cpuLoadPercent.valueOrDefault <= 1 ||\n    maxCpus() === 1\n  )\n}\n\n// We don't need a timeout TTL here: if we get a timeout, that will get set. See\n// WorkTimeout.ts\nexport const maxCpus = lazy(_maxCpus)\n\nfunction _maxCpus() {\n  const cpuPortion = Math.max(1, Math.floor(targetCpuLoadPct() * cpuCount()))\n\n  // maxCpus must be at least 1, and not more than min(cpuPortion, maxProcsForMem)\n  let result = cpuPortion\n\n  const timeoutsPerSecond = timeoutRate.prior()?.eventsPerMinute ?? 0\n\n  // Make the lazy estimation that most work takes about a second:\n  const penalization = timeoutPenalization()\n\n  if (penalization !== 1) {\n    // we don't need to go below this setting\n    const resultBeforePenalization = result\n    result = result * penalization\n    logger().warn(\"Recent timeouts! Throttling down.\", {\n      penalization,\n      resultBeforePenalization,\n      resultAfterPenalization: result\n    })\n  }\n\n  // We don't want to over-subscribe system memory, but we need to run at\n  // least one:\n  result = clamp(1, Math.min(cpuPortion, maxProcsForMem()), Math.ceil(result))\n\n  return logger().tap({\n    msg: \"maxCpus()\",\n    level: LogLevels.info,\n    result,\n    meta: {\n      cpuLoadPct: targetCpuLoadPct(),\n      cpuCount: cpuCount(),\n      cpuPortion,\n      penalization,\n      timeoutsPerSecond,\n      maxProcsForMem: maxProcsForMem()\n    }\n  })\n}\n\nexport const maxConcurrentImports = lazy(_maxConcurrentImports)\n\nfunction _maxConcurrentImports() {\n  if (gt0(Settings.maxConcurrentImports.valueOrDefault)) {\n    return clamp(1, maxCpus(), Settings.maxConcurrentImports.valueOrDefault)\n  }\n  return maxCpus()\n}\n\nexport const sharpThreadsPerProcess = lazy(() => {\n  const i = Settings.sharpThreadsPerProcess.valueOrDefault\n  return i > 0\n    ? i\n    : clamp(\n        1,\n        Math.min(maxCpus(), Settings.sharpThreadsPerProcess.max),\n        // bigger second x scales down sharp threads\n        Math.floor(lerp2d(maxCpus(), { x: 1, y: 1 }, { x: 6, y: 2 }))\n      )\n})\n","import { Rate } from \"batch-cluster\"\nimport { setInterval } from \"timers\"\nimport { lazy } from \"../../core/Lazy\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { ee } from \"../event/EventEmitter\"\nimport { rateStats } from \"../math/Rate\"\nimport { maxConcurrentImports, maxCpus } from \"./MaxCpus\"\n\nconst logger = lazy(() => mkLogger(\"work.WorkTimeout\"))\n\nexport const timeoutRate = lazy(\n  () => new Rate(5 * minuteMs, isTest ? 100 : ShortCommandTimeoutMs)\n)\n\nconst refreshEveryMinute = lazy(() =>\n  // Make sure if we recover, we throttle back up:\n  // (this was an EndableInterval, but that caused a deploop (!?))\n  setInterval(refresh, minuteMs).unref()\n)\n\nfunction refresh() {\n  // we need to update these every minute if we've had any (soft or hard)\n  // timeouts.\n\n  // We want .refresh(), not just .unset(), so .watchLater() listeners gets\n  // invoked:\n  maxCpus.refresh()\n  maxConcurrentImports.refresh()\n  refreshEveryMinute()\n}\n\nexport function onTimeout() {\n  const r = timeoutRate()\n  r.onEvent()\n  logger().warn(\"onTimeout()\", rateStats(r))\n  refresh()\n}\n\nlater(() => {\n  ee().on(\"clearCache\", () => {\n    maxCpus.unset()\n    maxConcurrentImports.unset()\n    timeoutRate.unset()\n  })\n})\n","import { sortBy } from \"./ArraySort\"\nimport { notBlankish } from \"./Blank\"\nimport { eql } from \"./Eql\"\nimport { stringify } from \"./JSON\"\nimport { List } from \"./List\"\nimport { getOrSet } from \"./Map\"\nimport { Defined } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport {\n  Comparable,\n  Primitivable,\n  Primitivables,\n  Primitive,\n  isPrimitive,\n  isPrimitiveArray,\n  lt\n} from \"./Primitive\"\nimport { randomInt } from \"./Random\"\nimport { MaybeReadonlyArray } from \"./Readonly\"\nimport { MaybeNullSyncOrAsync } from \"./SyncOrAsync\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { isFunction } from \"./isFunction\"\nimport { toA } from \"./toA\"\nimport { toS } from \"./toS\"\n\n// Added isNotEmpty so I can make the arr is not null assertion:\nexport function isNotEmpty<L extends List<any>>(arr: MaybeNull<L>): arr is L {\n  return arr != null && toA(arr).length > 0\n}\n\nexport function toNotEmpty<L extends List<any>>(arr: MaybeNull<L>): Maybe<L> {\n  return isNotEmpty(arr) ? arr : undefined\n}\n\nexport function notEmptyOr<L extends List<any>>(\n  arr: Maybe<L>,\n  defaultValue: ThunkOrT<L>\n): L {\n  return isNotEmpty(arr) ? arr : tot(defaultValue)\n}\n\nexport function isEmpty(arr: MaybeNull<List<any>>): arr is undefined {\n  return arr == null || toA(arr).length === 0\n}\n\nexport function mapArray<T, U>(\n  arr: MaybeNull<T[]>,\n  f: (t: T[]) => U\n): Maybe<U> {\n  return Array.isArray(arr) ? f(arr) : undefined\n}\n\nexport function mapNotEmpty<L extends List<any>, R>(\n  arr: Maybe<L>,\n  f: (ea: L) => R\n): Maybe<R> {\n  return isNotEmpty(arr) ? f(arr) : undefined\n}\n\nexport function mapNotEmptyOr<L extends List<any>, R>(\n  arr: Maybe<L>,\n  f: (ea: L) => R,\n  defaultValue: ThunkOrT<R>\n): R {\n  return isNotEmpty(arr) ? f(arr) : tot(defaultValue)\n}\n\nexport function toPrimitive(\n  a: Primitive | Primitive[] | Primitivable | Primitivables\n): Primitive | Primitive[] {\n  return isPrimitive(a) || isPrimitiveArray(a) ? a : a.valueOf()\n}\n\n// only deals with primitive arrays. use isEqlArray() instead.\nfunction eqlArray<T extends Primitive>(a: T[], b: T[]): boolean {\n  return (\n    a != null &&\n    b != null &&\n    a.length === b.length &&\n    a.every((ea, idx) => ea === b[idx])\n  )\n}\n\n/**\n * @return true if `prefix` == `haystack.slice(0, prefix.length)`.\n */\nexport function startsWith<T extends Primitive>(\n  haystack: T[],\n  prefix: T[]\n): boolean {\n  return eqlArray(haystack.slice(0, prefix.length), prefix)\n}\n\n/**\n * Retain all items from `arr` where the `keepIfTrue` returns `true`.\n * @return true if `arr` was changed.\n */\nexport function filterInPlace<T>(\n  arr: T[],\n  keepIfTrue: (item: T, index: number, ea: T[]) => boolean\n): T[] {\n  for (let i = 0; i < arr.length; ) {\n    if (keepIfTrue(arr[i], i, arr)) {\n      i++\n    } else {\n      arr.splice(i, 1)\n    }\n  }\n  return arr\n}\n\n/**\n * Retain all items from `arr` where the `keepIfTrue` returns `true`.\n * @return true if `arr` was changed.\n */\nexport async function filterInPlaceAsync<T>(\n  arr: T[],\n  keepIfTrue: (item: T, index: number, ea: T[]) => MaybeNullSyncOrAsync<boolean>\n): Promise<T[]> {\n  for (let i = 0; i < arr.length; ) {\n    if (true === (await keepIfTrue(arr[i], i, arr))) {\n      i++\n    } else {\n      arr.splice(i, 1)\n    }\n  }\n  return arr\n}\n\nexport function move<T>(arr: T[], fromIndex: number, toIndex: number): T[] {\n  if (\n    fromIndex === toIndex ||\n    fromIndex < 0 ||\n    toIndex < 0 ||\n    fromIndex >= arr.length ||\n    toIndex >= arr.length\n  ) {\n    return arr\n  }\n  const ea = arr[fromIndex]\n  arr.splice(fromIndex, 1)\n  arr.splice(toIndex, 0, ea)\n  return arr\n}\n\n// ES2016 polyfill that also supports Iterable\nexport function includes(\n  haystack: MaybeNull<any[] | Iterable<any>>,\n  needle: any\n): boolean {\n  if (haystack == null) return false\n  for (const ea of haystack) {\n    if (needle.valueOf() === ea.valueOf()) return true\n  }\n  return false\n}\n\nexport function indexOf<T>(\n  iter: Maybe<Iterable<T>>,\n  f: (t: T, index: number) => boolean\n): Maybe<number> {\n  if (iter == null) return\n  let index = 0\n  for (const ea of iter) {\n    if (f(ea, index)) return index\n    index++\n  }\n  return\n}\n\nexport function indexOfPrimitive<T>(\n  iter: Maybe<Iterable<T>>,\n  t: T\n): Maybe<number> {\n  if (iter == null) return\n  let index = 0\n  for (const ea of iter) {\n    if (ea === t) return index\n    index++\n  }\n  return\n}\n\nexport function includesAny(\n  haystack?: Primitive[],\n  needles?: Primitive[]\n): boolean {\n  return (\n    isNotEmpty(haystack) &&\n    isNotEmpty(needles) &&\n    haystack.some(ea => needles.includes(ea))\n  )\n}\n\n/**\n * @returns true iff all `needles` are found in `haystack`\n */\nexport function includesAll(\n  haystack?: Primitive[],\n  needles?: Primitive[]\n): boolean {\n  if (isEmpty(haystack) || isEmpty(needles)) return false\n  for (const needle of needles) {\n    if (!haystack.includes(needle)) return false\n  }\n  return true\n}\n\nexport function eqlPrimitiveUnordered(a: Primitive[], b: Primitive[]): boolean {\n  if (a == null || b == null || a.length !== b.length) return false\n  const a1 = sortBy(a, toPrimitive)\n  const b1 = sortBy(b, toPrimitive)\n  return a1.every((ea, idx) => ea === b1[idx])\n}\n\nexport function pushUniq<T>(arr: T[], ...items: T[]): T[] {\n  for (const item of items) {\n    if (item != null && !arr.some(ea => eql(ea, item))) {\n      arr.push(item)\n    }\n  }\n  return arr\n}\n\nexport function pushUniqBy<T>(\n  arr: T[],\n  items: T[],\n  valueOf: (t: T) => Comparable\n): T[] {\n  const vArr = arr.map(valueOf)\n  for (const item of items) {\n    const v = valueOf(item)\n    if (!vArr.includes(v)) {\n      arr.push(item)\n      vArr.push(v)\n    }\n  }\n  return arr\n}\n\nexport function insertAt<T>(arr: T[], index: number, ...items: T[]): T[] {\n  arr.splice(index, 0, ...items)\n  return arr\n}\n\n/**\n * Insert `item` into `arr` only if `item` is not in `arr` (according to `cmp`).\n *\n * Assumes `arr` is ascending-sorted.\n */\nexport function insertUniq<T>(\n  arr: T[],\n  item: T,\n  cmp_: (a: T, b: T) => number\n): T[] {\n  // verify the array is already in proper sort-order\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (cmp_(arr[i], arr[i + 1]) > 0) {\n      throw new Error(\"badly sorted array: \" + arr)\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    const ea = arr[i]\n    const c = cmp_(ea, item)\n    if (c === 0) return arr\n    // if item is greater than ea, insert right before ea\n    if (c > 0) {\n      arr.splice(i, 0, item)\n      return arr\n    }\n  }\n  arr.push(item)\n  return arr\n}\n\n// Can't call this delete, as that's a javascript keyword\nexport function remove<T>(arr: T[], ...element: T[]): boolean {\n  const before = arr.length\n  filterInPlace(arr, ea => element.every(ea2 => !eql(ea, ea2)))\n  return before !== arr.length\n}\n\nexport function removeSame<T>(arr: T[], ...element: T[]): boolean {\n  const before = arr.length\n  filterInPlace(arr, ea => element.every(ea2 => ea !== ea2))\n  return before !== arr.length\n}\n\nexport function compact<T>(iter: MaybeNull<Iterable<T>>): Defined<T>[] {\n  // SITS: don't remove the toA: some callers may not give a proper iterable!\n  return iter == null ? [] : (filterInPlace(toA(iter), ea => ea != null) as any)\n}\n\nexport function compactBlanks<T>(iter: MaybeNull<Iterable<T>>): string[] {\n  // trim() to fix https://gitlab.com/mceachen/photostructure/issues/58\n  return iter == null\n    ? []\n    : toA(iter)\n        .map(ea => toS(ea).trim())\n        .filter(ea => ea.length > 0)\n}\n\nexport function compactBlankish<T>(iter: MaybeNull<Iterable<T>>): Defined<T>[] {\n  return iter == null ? [] : [...iter].filter(notBlankish)\n}\n\nexport function uniq<T>(arr: Maybe<Iterable<Maybe<T>>>): Defined<T>[] {\n  // PERF: if `arr` is empty or only 1 or 2 elements, maybe we don't have to\n  // call uniqBy:\n  if (arr == null) return []\n  const c = compact(arr)\n  if (c.length <= 1) return c\n  if (c.length < 10) {\n    const f = c[0]\n    if (c.every(ea => ea === f)) {\n      return [f]\n    }\n  }\n  return uniqBy(c, ea => (isPrimitive(ea) ? ea : stringify(ea)))\n}\n\nexport function uniqFirst<T>(arr: Maybe<Iterable<Maybe<T>>>): NonNullable<T>[] {\n  if (arr == null) return []\n  const result: NonNullable<T>[] = []\n  for (const ea of arr) {\n    if (ea != null && !eql(result[result.length - 1], ea)) {\n      result.push(ea as any)\n    }\n  }\n  return result\n}\n\nexport function uniqSubstrings(arr: Maybe<string>[]): string[] {\n  if (arr == null) return []\n  const strings = compact(arr)\n  if (arr.length === 0) return []\n  const result: string[] = []\n  for (const str of sortBy(strings, ea => [-ea.length, ea.toLowerCase()])) {\n    if (!result.some(ea => ea.includes(str))) {\n      result.push(str)\n    }\n  }\n  return sortBy(result, ea => strings.indexOf(ea))\n}\n\n/**\n * First-one-in-wins\n */\nexport function uniqBy<T, V extends Primitive>(\n  arr: Iterable<Maybe<T>>,\n  f: (t: T) => Maybe<V> = ea => stringify(ea) as V\n): T[] {\n  const m = new Map<V, T>()\n  for (const ea of arr) {\n    if (ea != null) {\n      const v = f(ea)\n      if (v != null) {\n        getOrSet(m, v, () => ea)\n      }\n    }\n  }\n  return [...m.values()]\n}\n\n/**\n * Last-one-in-wins\n */\nexport function uniqByLast<T, V extends Primitive>(\n  arr: Iterable<Maybe<T>>,\n  f: (t: T) => Maybe<V> = ea => stringify(ea) as V\n): T[] {\n  const m = new Map<V, T>()\n  for (const ea of arr) {\n    if (ea != null) {\n      const key = f(ea)\n      if (key != null) {\n        m.set(key, ea)\n      }\n    }\n  }\n  return [...m.values()]\n}\n\n/**\n * First-one-in-wins\n */\nexport function uniqBy2<T>(\n  arr: Maybe<T>[],\n  equals: (a: T, b: T) => boolean\n): T[] {\n  const result: T[] = []\n  for (const a of arr) {\n    if (a != null && result.every(b => !equals(a, b))) {\n      result.push(a)\n    }\n  }\n  return result\n}\n\nexport function clear<T>(arr: T[]): T[] {\n  arr.length = 0\n  return arr\n}\n\n/**\n * Equivalent to filtering all items in an array to a new array and calling\n * length. This method avoids creating the intermediate array.\n *\n * @return the number of elements in `arr` that `predicate` returns `true`.\n */\nexport function count<T>(\n  arr: T[],\n  predicate: (t: T, idx: number) => boolean\n): number {\n  return arr.reduce((acc, ea, idx) => acc + (predicate(ea, idx) ? 1 : 0), 0)\n}\n\n/**\n * Equivalent to mapping all items in an array to a new number array and calling\n * Vector.sum(). This method avoids creating the intermediate array.\n *\n * @return the sum of elements of `f`-transmuted numbers from `arr`.\n */\nexport function sum<T>(\n  arr: T[],\n  f: (t: T, currentIndex: number) => number\n): number {\n  return arr.reduce((acc, ea, idx) => acc + f(ea, idx), 0)\n}\n\nexport function firstMatch(\n  re: RegExp,\n  arr: Maybe<string>[]\n): Maybe<RegExpExecArray> {\n  for (const s of compact(arr)) {\n    const m = re.exec(s)\n    if (m != null) return m\n  }\n  return\n}\n\nexport function commonPrefixLength<T extends Primitive>(\n  a: Maybe<T[] | string>,\n  b: Maybe<T[] | string>\n): number {\n  if (a == null || b == null) return 0\n  if (a === b) return a.length\n  if (typeof a === \"string\") a = [...a] as T[]\n  if (typeof b === \"string\") b = [...b] as T[]\n  if (eqlArray(a, b)) return a.length\n  let result = 0\n  while (a[result] === b[result]) result++\n  return result\n}\n\n/**\n * Make random perturbations to `array` to minimize the given expense function\n */\nexport function anneal<T>({\n  array,\n  expense,\n  allowedDelta\n}: {\n  array: T[]\n  expense: (arr: T[], fromIndex: number, toIndex: number) => Comparable\n  allowedDelta: number\n}): T[] {\n  const delta = Math.round(allowedDelta)\n  if (delta < 2) return array\n  for (let mid = 0; mid < array.length - 1; mid++) {\n    const newPos = randomInt(\n      Math.max(0, mid - delta),\n      Math.min(array.length, mid + delta),\n      [mid]\n    )\n    if (newPos == null) continue\n    // the range is either [mid - 1, newPos + 1] or [newPos - 1, mid + 1]\n    const i = Math.max(0, Math.min(newPos, mid) - 1)\n    const j = Math.min(array.length, Math.max(newPos, mid) + 1)\n    const currentExpense = expense(array, i, j)\n    move(array, mid, newPos)\n    const newExpense = expense(array, i, j)\n    // undo the move if newExpense isn't better:\n    if (lt(currentExpense, newExpense)) {\n      move(array, newPos, mid)\n    }\n  }\n  return array\n}\n\n/**\n * @param from inclusive\n * @param to exclusive\n * @param f\n */\nexport function range<T = number>(\n  from: number,\n  to: number,\n  f: (i: number) => T = ea => ea as any\n): T[] {\n  return stepRange(from, to, 1, f)\n}\n\n/**\n * @param to return an array up to but not including `to`\n * @see https://docs.python.org/2/library/functions.html#range\n */\nexport function stepRange<T = number>(\n  from: number,\n  to: number,\n  step: number = 1,\n  f: (i: number) => T = ea => ea as any\n): T[] {\n  const r: T[] = []\n  if (from < to) {\n    for (let i = from; i < to; i += step) {\n      r.push(f(i))\n    }\n  } else {\n    for (let i = from; i > to; i -= step) {\n      r.push(f(i))\n    }\n  }\n  return r\n}\n\nexport const primitiveValueOfOrElse = (a: any) => {\n  if (isPrimitive(a)) {\n    return a\n  }\n  // [].valueOf() is worthless, so use json\n  if (Array.isArray(a)) {\n    return stringify(a)\n  }\n  if (isFunction(a.valueOf)) {\n    return a.valueOf()\n  } else {\n    throw new Error(\"Cannot get primitive value for \" + JSON.stringify(a))\n  }\n}\n\n/**\n * `minuend - subtrahend`.\n *\n * @template T must have a .valueOf() implementation\n * @param {T[]} minuend (haystack)\n * @param {T[]} subtrahend (needles)\n * @returns {T[]} values in `minuend` that, according to `.valueOf()`, are\n * not in `subtrahend`. Neither arg is mutated.\n */\nexport function diff<T>(\n  minuend: MaybeReadonlyArray<T>,\n  subtrahend: T[],\n  valueOf: (t: T) => Primitive = primitiveValueOfOrElse\n): T[] {\n  const s = new Set(subtrahend.map(valueOf))\n  return minuend.filter(ea => !s.has(valueOf(ea)))\n}\n\nexport function last<T>(arr: Maybe<T[]>): Maybe<T> {\n  return arr != null ? arr[arr.length - 1] : undefined\n}\n\nexport function commaList(arr: string[], finalJoin = \"or\"): string {\n  if (arr.length <= 1) return arr.join(\"\")\n  if (arr.length === 2) return arr.join(\" \" + finalJoin + \" \")\n  return (\n    arr.slice(0, -1).join(\", \") + \", \" + finalJoin + \" \" + arr[arr.length - 1]\n  )\n}\n\nexport function arrToIterator<T>(arr: T[]): IterableIterator<T> {\n  return arr[Symbol.iterator]()\n}\n\nexport function arrayEndsWith<T extends Comparable>(\n  arr: T[],\n  suffix: T[]\n): boolean {\n  if (arr.length < suffix.length) return false\n  for (let i = 0; i < suffix.length; i++) {\n    // PERF: avoids the slice (and subsequent GC)\n    if (arr[arr.length - suffix.length + i] !== suffix[i]) return false\n  }\n  return true\n}\n","export function copyArrayTo<T>(source: T[], destination: T[]): T[] {\n  for (let i = 0; i < source.length; i++) {\n    destination[i] = source[i]\n  }\n  destination.length = source.length\n  return destination\n}\n","import { compact, toPrimitive } from \"./Array\"\nimport { copyArrayTo } from \"./ArrayCopy\"\nimport { isIterable } from \"./Iterable\"\nimport { stringify } from \"./JSON\"\nimport { getOrSet } from \"./Map\"\nimport { Defined, map } from \"./Maybe\"\nimport { Maybe } from \"./MaybeTypes\"\nimport {\n  Comparable,\n  Primitivable,\n  Primitivables,\n  Primitive,\n  cmp\n} from \"./Primitive\"\nimport { toA } from \"./toA\"\n\nexport function sort<\n  T extends Primitive | Primitive[] | Primitivable | Primitivables\n>(arr: Maybe<T>[] | ReadonlyArray<Maybe<T>>): Defined<T>[] {\n  return sortByInPlace(compact(arr), toPrimitive)\n}\n\nexport function sortByInPlace<T>(arr: T[], f: (t: T) => Comparable): T[] {\n  return copyArrayTo(sortBy(arr, f), arr)\n}\n\nexport function sortUniqBy<T>(arr: T[], f: (t: T) => Comparable): T[] {\n  const m = new Map<string, T>()\n  for (const ea of arr) {\n    getOrSet(m, stringify(f(ea)), () => ea)\n  }\n  return sortBy(m.values(), f)\n}\n\nexport function sortUniq<T extends Comparable>(arr: T[]): T[] {\n  return sortUniqBy(arr, ea => ea)\n}\n\nexport function sortUniqByInPlace<T>(arr: T[], f: (t: T) => Comparable): T[] {\n  return copyArrayTo(sortUniqBy(arr, f), arr)\n}\n\nexport function isSorted(arr: Primitivable[]): boolean {\n  return arr.every((ea, idx) => idx === 0 || ea > arr[idx - 1])\n}\n\nexport function sortedBy<T>(arr: T[], f: (t: T) => Primitive): boolean {\n  return arr.every((ea, idx) => idx === 0 || f(ea) > f(arr[idx - 1]))\n}\n/**\n * Returns a copy of arr, stable sorted by the given constraint. Note that false\n * < true, and that `f` may return an array for sort priorities, or undefined if\n * the item should be skipped from the returned result.\n *\n * Note: localeSort() thinks lower case should come before upper case (!!)\n */\n\nexport function sortBy<T>(\n  arr: Iterable<Maybe<T>> | Maybe<T>[],\n  f: (t: T, index: number) => Maybe<Comparable | Comparable[]>\n): T[] {\n  return (toA(arr).filter(ea => ea != null) as T[])\n    .map((item, idx) => ({\n      item,\n      cmp: map(f(item, idx), ea => [ea, idx])\n    }))\n    .filter(ea => ea.cmp != null)\n    .sort((a, b) => cmp(a.cmp!, b.cmp!))\n    .map(ea => ea.item)\n}\n\nexport function deepSortBy<T, V extends Primitive | Primitive[]>(\n  arr: Iterable<T> | T[],\n  f: (t: T) => Maybe<V>\n): T[] {\n  return sortBy(arr, f).map(ea =>\n    isIterable(ea) ? deepSortBy(ea, f) : ea\n  ) as any // SITS typing\n}\n\nexport function pushSorted<T>(\n  arr: T[],\n  item: T,\n  f: (t: T) => Comparable | Comparable[]\n): T[] {\n  const idx = arr.findIndex(ea => f(item) < f(ea))\n  if (idx === -1) {\n    arr.push(item)\n  } else {\n    arr.splice(idx, 0, item)\n  }\n  return arr\n}\n","import { delay } from \"./Delay\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { gt0 } from \"./Number\"\nimport { SyncOrAsync } from \"./SyncOrAsync\"\nimport { thenOrTimeoutError } from \"./ThenOrTimeout\"\nimport { toErr } from \"./toErr\"\n\nexport async function retryOnReject<T>(\n  f: () => SyncOrAsync<T>,\n  opts: {\n    maxRetries: number\n    timeoutMs?: number\n    retryDelay?: number\n    onRetryWaitUntil?: (retryCount: number) => any\n    errorIsRetriable?: (error: Error) => Maybe<boolean>\n  }\n): Promise<T> {\n  const g = gt0(opts.timeoutMs)\n    ? () => thenOrTimeoutError(f(), opts.timeoutMs!)\n    : f\n\n  if (opts.maxRetries <= 0) {\n    return g()\n  }\n  const onRetryWaitUntil =\n    opts.onRetryWaitUntil ??\n    ((retry: number) =>\n      delay(Math.max(250, (opts.retryDelay ?? 250) * (retry ?? 1))))\n\n  let retryCount = 0\n  const h: () => Promise<T> = async () => {\n    try {\n      return await g()\n    } catch (err) {\n      const error = toErr(err)!\n      if (\n        false === opts.errorIsRetriable?.(error) ||\n        retryCount > opts.maxRetries\n      ) {\n        throw error\n      } else {\n        retryCount++\n        await onRetryWaitUntil(retryCount)\n        return h()\n      }\n    }\n  }\n  return h()\n}\n","import { Maybe } from \"./MaybeTypes\"\n\n/**\n * @see https://github.com/tc39/proposal-relative-indexing-method#polyfill\n */\nexport function at<T>(arr: Maybe<T[]>, i: number) {\n  if (arr == null) return\n  // ToInteger() abstract op\n  i = Math.trunc(i) || 0\n  // Allow negative indexing from the end\n  if (i < 0) i += arr.length\n  // OOB access is guaranteed to return undefined\n  if (i < 0 || i >= arr.length) return undefined\n  // Otherwise, this is just normal property access\n  return arr[i]\n}\n","import { Defined, orElse } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toS } from \"./toS\"\n\n/**\n * @return true if o is nullish, an empty string, or only whitespace.\n */\nexport function blank(o: any): o is undefined {\n  // PERF: unrolled from Opt\n  return o == null || o === \"\"\n    ? true\n    : typeof o === \"string\"\n    ? o.trim() === \"\"\n    : false\n}\n\nexport function notBlank<T>(s: T): s is Defined<T> {\n  return !blank(s)\n}\n\nexport function notBlankToS(s: Maybe<any>) {\n  return notBlank(s) && s !== \"undefined\" ? toS(s).trim() : undefined\n}\n\n/** aka \"trimToUndefined\" */\nexport function toNotBlank(o: any): Maybe<string> {\n  if (o == null) return\n  const s = toS(o)\n  return s.length === 0 || s.trim().length === 0 ? undefined : s\n}\n\n/**\n * Equivalent to `Opt(s).flatMap(toS).filter(notBlank).getOrElse(() => orElse)`\n */\nexport function notBlankOr(s: any, ifBlank: ThunkOrT<string>): string {\n  if (s == null) return tot(ifBlank)\n  const str = toS(s).trim()\n  return str.length > 0 ? str : tot(ifBlank)\n}\n\nexport function notBlankAnd(s: any, f: (ea: string) => boolean): boolean {\n  return !blank(s) ? f(s) : false\n}\n\nexport function mapNotBlank<T>(arg: any, f: (s: string) => T): Maybe<T> {\n  if (arg === false || arg == null || arg === \"\") {\n    return undefined\n  }\n  const s = toS(arg)\n  return notBlank(s) ? f(s!) : undefined\n}\n\nexport function mapNotBlankOr<T>(\n  arg: any,\n  f: (s: string) => T,\n  defaultValue: T | (() => T)\n): T {\n  return orElse(mapNotBlank(arg, f), defaultValue)\n}\n\nexport function firstNotBlank(...arr: MaybeNull<string>[]): Maybe<string> {\n  // PERF: unrolled\n  for (const ea of arr) {\n    if (typeof ea === \"string\" && ea.trim().length > 0) return ea\n  }\n  return\n}\n\nconst BlankishRE = /^\\s*(?:null|undefined)?\\s*$/i\n\nexport function blankish(s: any): s is undefined {\n  return s == null || BlankishRE.exec(toS(s)) != null\n}\n\nexport function notBlankish<T>(s: T): s is Defined<T> {\n  return !blankish(s)\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\n\nexport function isBoolean(object: any): object is boolean {\n  return typeof object === \"boolean\"\n}\n\n/**\n * (Fairly) strict coercion to true.\n *\n * @return false unless `o` is `true` or `1` (or stringifies to \"true\" or \"1\")\n */\nexport function isTrue(o: any): boolean {\n  if (typeof o === \"boolean\") {\n    return o\n  } else if (o == null) {\n    return false\n  } else if (o === 1) {\n    return true\n  } else {\n    const s = String(o).toLowerCase().trim()\n    return [\"true\", \"1\"].includes(s)\n  }\n}\n\n/**\n * (Fairly) strict coercion to boolean. If parsing fails, returns undefined.\n */\nexport function toBoolean(o: any): Maybe<boolean> {\n  return isTrue(o) ? true : isFalse(o) ? false : undefined\n}\n\nexport function boolToInt(o: any) {\n  return isTrue(o) ? 1 : 0\n}\n\n/**\n * (Fairly) strict coercion to false.\n *\n * @return false unless `o` is `false` or `0` (or stringifies to \"false\" or\n * \"0\")\n */\nexport function isFalse(o: any, ...synonyms: string[]): boolean {\n  if (typeof o === \"boolean\") return !o\n  if (o == null) return false\n  if (o === 0) return true\n  const s = String(o).toLowerCase()\n  return [\"false\", \"0\", ...synonyms].map(ea => ea.toLowerCase()).includes(s)\n}\n\nexport function isDisabled(o: any): boolean {\n  return isFalse(o, \"no\", \"disable\", \"disabled\")\n}\n\nexport function or(arr: any[]): boolean {\n  return arr.some(ea => isTrue(ea))\n}\n\nexport function and(arr: any[]): boolean {\n  return arr.every(ea => isTrue(ea))\n}\n\n/**\n * @return true if `arr` has at least one `true` and no `false` entries\n */\nexport function maybeAnd(arr: Maybe<boolean>[]): Maybe<boolean> {\n  let result: Maybe<boolean>\n  for (const ea of arr) {\n    if (ea === false) return false\n    if (ea === true) result = true\n  }\n  return result\n}\n\nexport function mapBoolean<T>(obj: any, f: (b: boolean) => T): Maybe<T> {\n  return isTrue(obj) ? f(true) : isFalse(obj) ? f(false) : undefined\n}\n\nexport function mapTrue<T>(b: any, f: () => T): Maybe<T> {\n  return isTrue(b) ? f() : undefined\n}\n","import { stringify } from \"./JSON\"\n\nexport function clone<T>(obj: T): T {\n  return obj == null ? obj : JSON.parse(stringify(obj))\n}\n\nexport function shallowClone<T>(obj: T): T {\n  return Array.isArray(obj)\n    ? [...obj]\n    : typeof obj === \"object\"\n    ? { ...obj }\n    : (obj as any)\n}\n","import { isEmpty } from \"./Array\"\nimport { blank } from \"./Blank\"\nimport { lazy } from \"./Lazy\"\nimport { map, mapOr } from \"./Maybe\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { isNumber, toFixedStr } from \"./Number\"\nimport { pad2, pad3 } from \"./Pad\"\nimport { ensurePrefix } from \"./String\"\nimport { plur } from \"./Units\"\n\nexport const secondMs = 1000\nexport const minuteMs = 60 * secondMs\nexport const hourMs = 60 * minuteMs\nexport const dayMs = 24 * hourMs\nexport const weekMs = 7 * dayMs\n/** TRY TO AVOID USING THIS (it's 32 * dayMs) */\nexport const monthMs = 32 * dayMs\nexport const yearMs = 365.25 * dayMs\n\nconst shortDateTimeFormat = lazy(\n  () =>\n    new Intl.DateTimeFormat(undefined, {\n      // weekday: \"short\",\n      year: \"numeric\",\n      month: \"short\",\n      day: \"numeric\",\n      hour: \"numeric\",\n      minute: \"numeric\",\n      second: \"numeric\"\n    })\n)\nconst shortDateFormat = lazy(\n  () =>\n    new Intl.DateTimeFormat(undefined, {\n      day: \"numeric\",\n      year: \"numeric\",\n      month: \"short\"\n    })\n)\n\nexport function toDate(d: Date | number): Date {\n  return d instanceof Date ? d : new Date(d)\n}\n\nexport function fmtDateShort(d: Date | number) {\n  if (d == null) return\n  return d instanceof Date &&\n    d.getHours() === 0 &&\n    d.getMinutes() === 0 &&\n    d.getSeconds() === 0\n    ? shortDateFormat().format(d)\n    : shortDateTimeFormat().format(d)\n}\n\n/**\n * split an HMS string into a (possibly empty) prefix of zeroes and the remaining suffix.\n */\nexport function splitHMS(hms: string): string[] {\n  return mapOr(\n    /^[0:]{1,4}/.exec(hms),\n    m => [m[0], hms.slice(m[0].length)],\n    () => [\"\", hms]\n  )\n}\n\nexport function isDate(obj: any): obj is Date {\n  return obj instanceof Date\n}\n\nexport function thisYear() {\n  return new Date().getFullYear()\n}\n\n/**\n * @return Date `deltaMs` in the past\n */\nexport function ago(deltaMs: number, from?: Date): Date {\n  return new Date((from?.getTime() ?? Date.now()) - deltaMs)\n}\n\n/**\n * @return Date `deltaMs` in the future\n */\nexport function hence(deltaMs: number, from?: Date): Date {\n  return ago(-deltaMs, from)\n}\n\nexport function unixtime(d?: Date | number): number {\n  const ms = isDate(d) ? d.getTime() : isNumber(d) ? d : Date.now()\n  return Math.floor(ms / secondMs)\n}\n\n/**\n * Appropriate for filenames: yMMddHHmmss\n */\nexport function fmtYMDHMS(arg: Date | number): string {\n  const d = toDate(arg)\n  return (\n    d.getFullYear() +\n    pad2(d.getMonth() + 1) +\n    pad2(d.getDate()) +\n    pad2(d.getHours()) +\n    pad2(d.getMinutes()) +\n    pad2(d.getSeconds())\n  )\n}\n\n/**\n * Format millis duration in HH:MM:SS.sss\n */\nexport function fmtHMS(\n  ms: number,\n  opts: { includeMs: boolean } = { includeMs: true }\n): string {\n  const h = Math.floor(ms / hourMs)\n  ms -= h * hourMs\n  const m = Math.floor(ms / minuteMs)\n  ms -= m * minuteMs\n  const s = Math.floor(ms / secondMs)\n  const millis = Math.floor(ms - s * secondMs)\n  return (\n    pad2(h) +\n    \":\" +\n    pad2(m) +\n    \":\" +\n    pad2(s) +\n    (opts.includeMs ? \".\" + pad3(millis) : \"\")\n  )\n}\n\nconst Units = [\n  { ms: yearMs, s: \"Y\" },\n  { ms: weekMs, s: \"W\" },\n  { ms: dayMs, s: \"D\" },\n  { ms: hourMs, s: \"H\" },\n  { ms: minuteMs, s: \"M\" }\n]\n\nexport function fmtIsoDuration(ms: number): string {\n  if (ms === 0) return \"PT0S\"\n  const dateParts: string[] = []\n  const timeParts: string[] = []\n  for (const unit of Units.slice(Units.findIndex(ea => ea.ms <= ms!))) {\n    const i = Math.floor(ms / unit.ms)\n    ms -= i * unit.ms\n    if (i > 0) (unit.ms >= dayMs ? dateParts : timeParts).push(i + unit.s)\n  }\n  if (ms > 0) {\n    timeParts.push(toFixedStr(ms / secondMs, 3) + \"S\")\n  }\n  return (\n    \"P\" +\n    dateParts.join(\"\") +\n    (isEmpty(timeParts) ? \"\" : \"T\" + timeParts.join(\"\"))\n  )\n}\n\n/**\n * ISO-formatted datestamp: y-MM-dd\n */\nexport function fmtIsoDate(ts: Date | number): string {\n  const d = isDate(ts) ? ts : new Date(ts)\n  return (\n    d.getFullYear() + \"-\" + pad2(d.getMonth() + 1) + \"-\" + pad2(d.getDate())\n  )\n}\n\nexport function localToDate(local: Maybe<number>): Maybe<Date> {\n  if (local == null || local < 0) return\n  let i = local\n  const pop2 = () => {\n    const result = i % 100\n    i = Math.floor(i / 100)\n    return result\n  }\n  const millisecond = 10 * pop2()\n  const second = pop2()\n  const minute = pop2()\n  const hour = pop2()\n  const day = pop2()\n  const month = pop2()\n  const year = i\n  return new Date(year, month - 1, day, hour, minute, second, millisecond)\n}\n\nexport function fmtLocalToShort(cs: number): Maybe<string> {\n  return map(localToDate(cs), fmtDateShort)\n}\n\nexport function nextMidnightTs() {\n  return new Date().setHours(24, 0, 0, 0)\n}\n\nexport function msUntilMidnight() {\n  // .setHours() returns getTime() (!?!)\n  return nextMidnightTs() - Date.now()\n}\n\nexport function fmtAgo(ts: number, suffix = \"ago\"): string {\n  return fmtElapsedMs(Date.now() - ts, suffix)\n}\n\nexport function fmtElapsedMs(ms: number, suffix = \"ago\"): string {\n  if (ms < 1000) return \"just now\"\n  suffix = blank(suffix) ? \"\" : ensurePrefix(suffix, \" \")\n  if (ms < minuteMs) return plur(Math.floor(ms / secondMs), \"second\") + suffix\n  if (ms < hourMs) return plur(Math.floor(ms / minuteMs), \"minute\") + suffix\n  if (ms < dayMs) return plur(Math.floor(ms / hourMs), \"hour\") + suffix\n  if (ms < weekMs) return plur(Math.floor(ms / dayMs), \"day\") + suffix\n  if (ms < yearMs) return plur(Math.floor(ms / weekMs), \"week\") + suffix\n  return plur(Math.floor(ms / yearMs), \"year\") + suffix\n}\n","/* globals Symbol: false, Uint8Array: false, WeakMap: false */\n/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nimport { isBoolean } from \"./Boolean\"\n\nconst type_detect = require(\"type-detect\")\n\nexport interface MemoizeMap extends WeakMap<object, WeakMap<object, boolean>> {}\n\nexport interface DeepEqlOptions<T1 = unknown, T2 = unknown> {\n  /**\n   * Override default algorithm, determining custom equality.\n   */\n  comparator?: (\n    leftHandOperand: T1,\n    rightHandOperand: T2,\n    keyname?: string | symbol\n  ) => boolean | null\n\n  /**\n   * Provide a custom memoization object which will cache the results of\n   * complex objects for a speed boost.\n   *\n   * By passing `false` you can disable memoization, but this will cause circular\n   * references to blow the stack.\n   */\n  memoize?: MemoizeMap | false\n}\n\n/*!\n * Check to see if the MemoizeMap has recorded a result of the two operands\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @returns {Boolean|null} result\n */\nfunction memoizeCompare(\n  leftHandOperand: any,\n  rightHandOperand: any,\n  memoizeMap?: MemoizeMap\n): boolean | null {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (\n    memoizeMap == null ||\n    isPrimitive(leftHandOperand) ||\n    isPrimitive(rightHandOperand)\n  ) {\n    return null\n  }\n  const result = memoizeMap.get(leftHandOperand)?.get(rightHandOperand)\n  if (typeof result === \"boolean\") {\n    return result\n  }\n  return null\n}\n\n/*!\n * Set the result of the equality into the MemoizeMap\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @param {Boolean} result\n */\nfunction memoizeSet(\n  leftHandOperand: any,\n  rightHandOperand: any,\n  memoizeMap: MemoizeMap | undefined,\n  result: boolean\n) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (\n    memoizeMap == null ||\n    isPrimitive(leftHandOperand) ||\n    isPrimitive(rightHandOperand)\n  ) {\n    return\n  }\n  let leftHandMap = memoizeMap.get(leftHandOperand)\n  if (leftHandMap != null) {\n    leftHandMap.set(rightHandOperand, result)\n  } else {\n    leftHandMap = new WeakMap()\n    leftHandMap.set(rightHandOperand, result)\n    memoizeMap.set(leftHandOperand, leftHandMap)\n  }\n}\n\n/**\n * Assert deeply nested sameValue equality between two objects of any type.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm,\n * determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization\n    object which will cache the results of complex objects for a speed boost.\n    By passing `false` you can disable memoization, but this will cause\n    circular references to blow the stack.\n * @return {Boolean} equal match\n */\nexport function deepEql<T1 = unknown, T2 = unknown>(\n  leftHandOperand: T1,\n  rightHandOperand: T2,\n  options?: DeepEqlOptions<T1, T2> | undefined\n): boolean {\n  options ??= {}\n  if (false !== options.memoize) {\n    options.memoize ??= new WeakMap()\n  }\n  return _deepEqual(leftHandOperand, rightHandOperand, options)\n}\n\nfunction _deepEqual<T1 = unknown, T2 = unknown>(\n  leftHandOperand: T1,\n  rightHandOperand: T2,\n  options?: DeepEqlOptions<T1, T2> | undefined,\n  key?: string | symbol\n): boolean {\n  // If we have a comparator, we can't assume anything; so bail to its check first.\n  if (options?.comparator != null) {\n    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options, key)\n  }\n\n  const simpleResult = simpleEqual(leftHandOperand, rightHandOperand)\n  if (simpleResult !== null) {\n    return simpleResult\n  }\n\n  // Deeper comparisons are pushed through to a larger function\n  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options)\n}\n\n/**\n * Many comparisons can be canceled out early via simple equality or primitive checks.\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @return {Boolean|null} equal match\n */\nfunction simpleEqual(leftHandOperand: any, rightHandOperand: any) {\n  // Equal references (except for Numbers) can be returned early\n  if (leftHandOperand === rightHandOperand) {\n    // Handle +-0 cases\n    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand\n  }\n\n  // handle NaN cases\n  if (\n    leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare\n    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare\n  ) {\n    return true\n  }\n\n  // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,\n  // strings, and undefined, can be compared by reference.\n  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    // Easy out b/c it would have passed the first equality check\n    return false\n  }\n  return null\n}\n\n/*!\n * The main logic of the `deepEqual` function.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n*/\nfunction extensiveDeepEqual<T1 = unknown, T2 = unknown>(\n  leftHandOperand: T1,\n  rightHandOperand: T2,\n  options: DeepEqlOptions<T1, T2> | undefined,\n  key?: string | symbol\n): boolean {\n  options ??= {}\n  const memoize: MemoizeMap | undefined =\n    options.memoize === false\n      ? undefined\n      : (options.memoize ??= new WeakMap() as any)\n  const comparator = options?.comparator\n\n  // Check if a memoized result exists.\n  const memoizeResultLeft = memoizeCompare(\n    leftHandOperand,\n    rightHandOperand,\n    memoize\n  )\n  if (memoizeResultLeft !== null) {\n    return memoizeResultLeft\n  }\n  const memoizeResultRight = memoizeCompare(\n    rightHandOperand,\n    leftHandOperand,\n    memoize\n  )\n  if (memoizeResultRight !== null) {\n    return memoizeResultRight\n  }\n\n  // If a comparator is present, use it.\n  if (comparator) {\n    const comparatorResult = comparator(leftHandOperand, rightHandOperand, key)\n    // Comparators may return null, in which case we want to go back to default behavior.\n    if (comparatorResult === false || comparatorResult === true) {\n      memoizeSet(leftHandOperand, rightHandOperand, memoize, comparatorResult)\n      return comparatorResult\n    }\n    // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide\n    // what to do, we need to make sure to return the basic tests first before we move on.\n    const simpleResult = simpleEqual(leftHandOperand, rightHandOperand)\n    if (simpleResult !== null) {\n      // Don't memoize this, it takes longer to set/retrieve than to just compare.\n      return simpleResult\n    }\n  }\n\n  const leftHandType = type_detect(leftHandOperand)\n  if (leftHandType !== type_detect(rightHandOperand)) {\n    memoizeSet(leftHandOperand, rightHandOperand, memoize, false)\n    return false\n  }\n\n  // Temporarily set the operands in the memoize object to prevent blowing the stack\n  memoizeSet(leftHandOperand, rightHandOperand, memoize, true)\n\n  const result = extensiveDeepEqualByType(\n    leftHandOperand,\n    rightHandOperand,\n    leftHandType,\n    options as any\n  )\n  memoizeSet(leftHandOperand, rightHandOperand, memoize, result)\n  return result\n}\n\nfunction extensiveDeepEqualByType(\n  leftHandOperand: any,\n  rightHandOperand: any,\n  leftHandType: string,\n  options?: DeepEqlOptions | undefined\n) {\n  switch (leftHandType) {\n    case \"String\":\n    case \"Number\":\n    case \"Boolean\":\n    case \"Date\":\n      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values\n      return _deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf())\n    case \"Promise\":\n    case \"Symbol\":\n    case \"function\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return leftHandOperand === rightHandOperand\n    case \"Error\":\n      return keysEqual(\n        leftHandOperand,\n        rightHandOperand,\n        [\"name\", \"message\", \"code\"],\n        options\n      )\n    case \"Arguments\":\n    case \"Int8Array\":\n    case \"Uint8Array\":\n    case \"Uint8ClampedArray\":\n    case \"Int16Array\":\n    case \"Uint16Array\":\n    case \"Int32Array\":\n    case \"Uint32Array\":\n    case \"Float32Array\":\n    case \"Float64Array\":\n    case \"Array\":\n      return iterableEqual(leftHandOperand, rightHandOperand, options)\n    case \"RegExp\":\n      return regexpEqual(leftHandOperand, rightHandOperand)\n    case \"Generator\":\n      return generatorEqual(leftHandOperand, rightHandOperand, options)\n    case \"DataView\":\n      return iterableEqual(\n        new Uint8Array(leftHandOperand.buffer),\n        new Uint8Array(rightHandOperand.buffer),\n        options\n      )\n    case \"ArrayBuffer\":\n      return iterableEqual(\n        new Uint8Array(leftHandOperand),\n        new Uint8Array(rightHandOperand),\n        options\n      )\n    case \"Set\":\n      return entriesEqual(leftHandOperand, rightHandOperand, options)\n    case \"Map\":\n      return entriesEqual(leftHandOperand, rightHandOperand, options)\n    case \"Temporal.PlainDate\":\n    case \"Temporal.PlainTime\":\n    case \"Temporal.PlainDateTime\":\n    case \"Temporal.Instant\":\n    case \"Temporal.ZonedDateTime\":\n    case \"Temporal.PlainYearMonth\":\n    case \"Temporal.PlainMonthDay\":\n      return leftHandOperand.equals(rightHandOperand)\n    case \"Temporal.Duration\":\n      return (\n        leftHandOperand.total(\"nanoseconds\") ===\n        rightHandOperand.total(\"nanoseconds\")\n      )\n    case \"Temporal.TimeZone\":\n    case \"Temporal.Calendar\":\n      return leftHandOperand.toString() === rightHandOperand.toString()\n    default:\n      return objectEqual(leftHandOperand, rightHandOperand, options)\n  }\n}\n\n/*!\n * Compare two Regular Expressions for equality.\n *\n * @param {RegExp} leftHandOperand\n * @param {RegExp} rightHandOperand\n * @return {Boolean} result\n */\n\nfunction regexpEqual(leftHandOperand: RegExp, rightHandOperand: RegExp) {\n  return leftHandOperand.toString() === rightHandOperand.toString()\n}\n\n/*!\n * Compare two Sets/Maps for equality. Faster than other equality functions.\n *\n * @param {Set} leftHandOperand\n * @param {Set} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction entriesEqual(\n  leftHandOperand: Set<any> | Map<any, any>,\n  rightHandOperand: Set<any> | Map<any, any>,\n  options?: DeepEqlOptions | undefined\n): boolean {\n  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach\n  if (leftHandOperand.size !== rightHandOperand.size) {\n    return false\n  }\n  if (leftHandOperand.size === 0) {\n    return true\n  }\n  const leftHandItems: any[] = []\n  const rightHandItems: any[] = []\n  leftHandOperand.forEach(function gatherEntries(key, value) {\n    leftHandItems.push([key, value])\n  })\n  rightHandOperand.forEach(function gatherEntries(key, value) {\n    rightHandItems.push([key, value])\n  })\n  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options)\n}\n\n/*!\n * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction iterableEqual(\n  leftHandOperand: ArrayLike<any>,\n  rightHandOperand: ArrayLike<any>,\n  options?: DeepEqlOptions | undefined\n): boolean {\n  const length = leftHandOperand.length\n  if (length !== rightHandOperand.length) {\n    return false\n  }\n  if (length === 0) {\n    return true\n  }\n  let index = -1\n  while (++index < length) {\n    if (\n      _deepEqual(leftHandOperand[index], rightHandOperand[index], options) ===\n      false\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/*!\n * Simple equality for generator objects such as those returned by generator functions.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction generatorEqual(\n  leftHandOperand: Iterator<any>,\n  rightHandOperand: Iterator<any>,\n  options?: DeepEqlOptions | undefined\n): boolean {\n  return iterableEqual(\n    getGeneratorEntries(leftHandOperand),\n    getGeneratorEntries(rightHandOperand),\n    options\n  )\n}\n\n/*!\n * Determine if the given object has an @@iterator function.\n *\n * @param {Object} target\n * @return {Boolean} `true` if the object has an @@iterator function.\n */\nfunction hasIteratorFunction(target: any): boolean {\n  return (\n    typeof Symbol !== \"undefined\" &&\n    typeof target === \"object\" &&\n    typeof Symbol.iterator !== \"undefined\" &&\n    typeof target[Symbol.iterator] === \"function\"\n  )\n}\n\n/*!\n * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.\n * This will consume the iterator - which could have side effects depending on the @@iterator implementation.\n *\n * @param {Object} target\n * @returns {Array} an array of entries from the @@iterator function\n */\nfunction getIteratorEntries(target: any): any[] {\n  if (hasIteratorFunction(target)) {\n    try {\n      return getGeneratorEntries(target[Symbol.iterator]())\n    } catch (iteratorError) {\n      return []\n    }\n  }\n  return []\n}\n\n/*!\n * Gets all entries from a Generator. This will consume the generator - which could have side effects.\n *\n * @param {Generator} target\n * @returns {Array} an array of entries from the Generator.\n */\nfunction getGeneratorEntries(generator: Iterator<any>): any[] {\n  let generatorResult = generator.next()\n  const accumulator = [generatorResult.value]\n  while (generatorResult.done === false) {\n    generatorResult = generator.next()\n    accumulator.push(generatorResult.value)\n  }\n  return accumulator\n}\n\n/*!\n * Gets all own and inherited enumerable keys from a target.\n *\n * @param {Object} target\n * @returns {Array} an array of own and inherited enumerable keys from the target.\n */\nfunction getEnumerableKeys(target: any): string[] {\n  const keys = []\n  for (const key in target) {\n    if (target[key] !== undefined) keys.push(key)\n  }\n  return keys\n}\n\nfunction getEnumerableSymbols(target: any): symbol[] {\n  const keys = []\n  const allKeys = Object.getOwnPropertySymbols(target)\n  for (let i = 0; i < allKeys.length; i += 1) {\n    const key = allKeys[i]\n    if (Object.getOwnPropertyDescriptor(target, key)?.enumerable === true) {\n      keys.push(key)\n    }\n  }\n  return keys\n}\n\n/*!\n * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of\n * each key. If any value of the given key is not equal, the function will return false (early).\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\nfunction keysEqual(\n  leftHandOperand: any,\n  rightHandOperand: any,\n  keys: (string | symbol)[],\n  options?: DeepEqlOptions | undefined\n): boolean {\n  const length = keys.length\n  if (length === 0) {\n    return true\n  }\n  for (let i = 0; i < length; i += 1) {\n    const key = keys[i]\n    const lhs = leftHandOperand[key]\n    const rhs = rightHandOperand[key]\n    if (typeof lhs === \"function\" && typeof rhs === \"function\") {\n      if (lhs.toString() !== rhs.toString()) {\n        return false\n      }\n    } else {\n      const eql = _deepEqual(lhs, rhs, options, key)\n      if (eql === false) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/*!\n * Recursively check the equality of two Objects. Once basic sameness has been\n * established it will defer to `deepEqual` for each enumerable key in the\n * object.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\nfunction objectEqual(\n  leftHandOperand: Record<string | symbol, any>,\n  rightHandOperand: Record<string | symbol, any>,\n  options?: DeepEqlOptions | undefined\n): boolean {\n  if (typeof leftHandOperand.eql === \"function\") {\n    const result = leftHandOperand.eql(rightHandOperand)\n    if (isBoolean(result)) return result\n  }\n\n  if (typeof rightHandOperand.eql === \"function\") {\n    const result = rightHandOperand.eql(leftHandOperand)\n    if (isBoolean(result)) return result\n  }\n\n  if (typeof leftHandOperand.toJSON === \"function\") {\n    return objectEqual(leftHandOperand.toJSON(), rightHandOperand, options)\n  }\n\n  if (typeof rightHandOperand.toJSON === \"function\") {\n    return objectEqual(leftHandOperand, rightHandOperand.toJSON(), options)\n  }\n\n  if (\n    typeof leftHandOperand === \"object\" &&\n    typeof rightHandOperand === \"object\" &&\n    typeof leftHandOperand.constructor === \"function\" &&\n    typeof rightHandOperand.constructor === \"function\"\n  ) {\n    if (\n      false ===\n      objectEqual(\n        leftHandOperand.constructor,\n        rightHandOperand.constructor,\n        options\n      )\n    ) {\n      return false\n    }\n  }\n\n  const leftHandKeys = [\n    ...getEnumerableKeys(leftHandOperand),\n    ...getEnumerableSymbols(leftHandOperand)\n  ]\n  const rightHandKeys = [\n    ...getEnumerableKeys(rightHandOperand),\n    ...getEnumerableSymbols(rightHandOperand)\n  ]\n\n  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {\n    if (\n      iterableEqual(\n        mapSymbols(leftHandKeys).sort(),\n        mapSymbols(rightHandKeys).sort()\n      ) === false\n    ) {\n      return false\n    }\n    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options)\n  }\n\n  const leftHandEntries = getIteratorEntries(leftHandOperand)\n  const rightHandEntries = getIteratorEntries(rightHandOperand)\n  if (\n    leftHandEntries.length &&\n    leftHandEntries.length === rightHandEntries.length\n  ) {\n    leftHandEntries.sort()\n    rightHandEntries.sort()\n    return iterableEqual(leftHandEntries, rightHandEntries, options)\n  }\n\n  if (\n    leftHandKeys.length === 0 &&\n    leftHandEntries.length === 0 &&\n    rightHandKeys.length === 0 &&\n    rightHandEntries.length === 0\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/*!\n * Returns true if the argument is a primitive.\n *\n * This intentionally returns true for all objects that can be compared by reference,\n * including functions and symbols.\n *\n * @param {Mixed} value\n * @return {Boolean} result\n */\nfunction isPrimitive(value: any) {\n  return value === null || typeof value !== \"object\"\n}\n\nfunction mapSymbols(arr: any) {\n  return arr.map(function mapSymbol(entry: any) {\n    if (typeof entry === \"symbol\") {\n      return entry.toString()\n    }\n\n    return entry\n  })\n}\n","import { secondMs } from \"./Date\"\nimport { isBrowser, isNode } from \"./NodeOrBrowser\"\nimport { gt0 } from \"./Number\"\nimport { maybeCall } from \"./Object\"\n\nexport function delayUntil(date: Date | number) {\n  const t = gt0(date) ? date : date.getTime()\n  const delayMs = t - Date.now()\n  if (delayMs < 0) {\n    if (delayMs > -500) {\n      // meh close enough\n      return\n    } else {\n      throw new Error(\n        \"Mr. Fusion not found, cannot time travel back \" + -delayMs + \"ms\"\n      )\n    }\n  }\n  return delay(delayMs).then(() => delayMs)\n}\n\nexport function delay(millis: number, unref: boolean = true) {\n  // On windows at least, setTimeout() only ensures N-1 millis have passed.\n  return new Promise<void>(resolve => {\n    if (millis <= 0) {\n      resolve()\n    } else {\n      // ceil(+0.5) to make sure we wait enough time:\n\n      // SITS: any casting shenanigans to make this work on the frontend and\n      // backend:\n      const t: any = setTimeout(() => resolve(), Math.ceil(millis + 0.5))\n      if (millis > secondMs && unref && isNode) {\n        // if the millis is trivial, don't bother to unref\n        t.unref() // < only node has unref!\n      }\n    }\n  })\n}\n\nexport function later(f: () => any, delayMs: number = 1) {\n  const ms = Math.max(1, Math.ceil(delayMs))\n  const t = isNode && ms <= 1 ? setImmediate(f) : setTimeout(f, ms)\n  return isBrowser || delayMs <= secondMs ? t : maybeCall(t, \"unref\") ?? t\n}\n","import { deepEql } from \"./DeepEql\"\nimport { isFunction } from \"./isFunction\"\n\nexport function eql(a: any, b: any): boolean {\n  return deepEql(a, b, { comparator })\n}\n\n// export function isEqlSimple(a: any, b: any): boolean | undefined {\n//   // same pointer or primitive value is eql\n//   if (a === b) return true\n\n//   // undefined != null\n//   if (a == null || b == null) return false\n\n//   // a and b must be the same type\n//   if (typeof a !== typeof b) return false\n\n//   // typeof's match, so if either is a string, both are\n//   if (isString(a)) {\n//     return eqlStrings(a, b)\n//   }\n\n//   if (isPrimitive(a)) {\n//     return a === b\n//   }\n\n//   return undefined\n// }\n\n// const DefaultMaxDepth = 10\n\n// export function eql2(a: any, b: any, maxDepth = DefaultMaxDepth): boolean {\n//   if (maxDepth < 0) return true\n\n//   const simpleEql = isEqlSimple(a, b)\n//   if (simpleEql != null) return simpleEql\n\n//   // typeof [] === 'object' (!!!!), so don't test for isObject before isArray!\n//   if (Array.isArray(a) || Array.isArray(b)) {\n//     return isEqlArray(a, b, maxDepth - 1) ?? false\n//   }\n\n//   if (isFunction(a) && isFunction(b)) {\n//     // toString() returns the function implementation\n//     return a.toString() === b.toString()\n//   }\n\n//   if (typeof a === \"object\" && typeof b === \"object\") {\n//     return isEqlObject(a, b, maxDepth - 1)\n//   }\n//   return false\n// // }\n\n// export function isEqlArray(\n//   a: any,\n//   b: any,\n//   maxDepth = DefaultMaxDepth\n// ): boolean | undefined {\n//   if (!Array.isArray(a) || !Array.isArray(b)) return undefined\n//   if (a.length !== b.length) return false\n//   for (let i = 0; i < a.length; i++) {\n//     if (!eql(a[i], b[i], maxDepth - 1)) return false\n//   }\n//   return true\n// }\n\nexport function dateComparator(a: any, b: any): undefined | boolean {\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime()\n  }\n  return undefined\n}\n\nexport function functionComparator(a: any, b: any): undefined | boolean {\n  return isFunction(a) && isFunction(b)\n    ? a.toString() === b.toString()\n    : undefined\n}\n\nexport type Comparator = (a: any, b: any) => undefined | boolean\n\nconst objComparators: Comparator[] = [dateComparator, functionComparator]\nconst fieldComparators = new Map<string | symbol, Comparator>()\n\nexport function pushObjComparator(c: Comparator) {\n  objComparators.push(c)\n}\n\nexport function unshiftObjComparator(c: Comparator) {\n  objComparators.unshift(c)\n}\n\nexport function setFieldComparator(fieldName: string | symbol, c: Comparator) {\n  fieldComparators.set(fieldName, c)\n}\n\nfunction comparator(a: any, b: any, key?: string | symbol): boolean | null {\n  if (a == null || b == null) return a === b // null should not eql undefined\n  if (key != null) {\n    const c = fieldComparators.get(key)\n    if (c != null) return c(a, b) ?? null\n  }\n  for (const ea of objComparators) {\n    const r = ea(a, b)\n    if (r != null) return r\n  }\n  return null\n}\n\n// export function fieldEql(\n//   fieldName: string,\n//   a: any,\n//   b: any,\n//   maxDepth = DefaultMaxDepth\n// ): boolean {\n//   return maxDepth < 0\n//     ? true\n//     : fieldComparators?.get(fieldName)?.(a, b) ?? eql(a, b, maxDepth - 1)\n// }\n\n// export function isEqlObject(\n//   a: Record<string, unknown>,\n//   b: Record<string, unknown>,\n//   maxDepth = DefaultMaxDepth\n// ): boolean {\n//   if (maxDepth < 0 || typeof a !== \"object\" || typeof b !== \"object\")\n//     return false\n//   if (a === b) return true\n\n//   for (const c of objComparators) {\n//     const result = c(a, b)\n//     if (result != null) return result\n//   }\n\n//   if (isFunction(a.eql)) {\n//     const r = a.eql(b)\n//     if (isBoolean(r)) return r\n//   }\n\n//   if (isFunction(b.eql)) {\n//     const r = b.eql(a)\n//     if (isBoolean(r)) return r\n//   }\n\n//   const aObj = isFunction(a.toJSON) ? a.toJSON() : a\n//   const bObj = isFunction(b.toJSON) ? b.toJSON() : b\n\n//   const e = isEqlSimple(aObj, bObj)\n//   if (e != null) return e\n\n//   // the order of keys\n//   const aKeys = sort(keysWithDefinedValues(aObj))\n//   const bKeys = sort(keysWithDefinedValues(bObj))\n\n//   if (true !== isEqlArray(aKeys, bKeys, maxDepth)) return false\n\n//   for (const key of aKeys) {\n//     if (fieldEql(key, aObj[key], bObj[key], maxDepth - 1) === false) {\n//       return false\n//     }\n//   }\n//   return true\n// }\n","import { compact, compactBlankish, isEmpty, uniq } from \"./Array\"\nimport { blank, notBlank, toNotBlank } from \"./Blank\"\nimport { flatten } from \"./Flatten\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { toInt } from \"./Number\"\nimport { assignFields, compactValues, omit } from \"./Object\"\nimport { toS } from \"./toS\"\n\n// the space after the colon prevents URLs from being split:\nexport const ErrorDelimiter = \": \"\n\nexport const IgnoredErrorNames = [\"Error\", \"String\", \"Object\", \"WrappedError\"]\n\n/**\n * @return the `.name` or class name of the Error, or undefined if not\n * informative (like \"Error\" or \"WrappedError\")\n */\nexport function errorName(\n  err: Maybe<Error | { name?: string }>\n): Maybe<string> {\n  return err == null\n    ? undefined\n    : [err?.name, err?.constructor?.name]\n        .find(ea => ea != null && !IgnoredErrorNames.includes(ea))\n        ?.toString()\n}\n\nexport function errorCode(err: any): Maybe<string> {\n  return err == null ? undefined : toNotBlank(err?.code) // like \"EBUSY\"\n}\n\nexport function errorErrno(err: any): Maybe<number> {\n  return err == null ? undefined : toInt(err?.errno)\n}\n\n// We should skip over the stack frames that are created from creating frames:\nconst FramesToIgnoreRE = /shortStack|errorToVerbose/\n\nexport function shortStack(stack?: string, maxLines = 9): string[] {\n  try {\n    if (blank(stack)) {\n      const err = new Error()\n      // captureStackTrace may not be a function on some browsers\n      Error.captureStackTrace?.(err)\n      stack = err.stack\n    }\n\n    const result = toS(stack)\n      .split(\"\\n\")\n      .filter(\n        ea =>\n          !blank(ea) &&\n          ea.trim().startsWith(\"at \") &&\n          FramesToIgnoreRE.exec(ea) == null\n      )\n      .slice(0, maxLines)\n      .map(ea => ea.replace(/^\\s*at /i, \"\"))\n\n    return isEmpty(result) ? [\"(missing stack)\"] : result\n  } catch (err) {\n    return [\"Failed to captured stacktrace: \" + err]\n  }\n}\n\nexport function asError(reason?: any): Error {\n  if (blank(reason)) {\n    throw new Error(\"undefined error\")\n  } else if (reason instanceof Error) {\n    return reason\n  } else if (Array.isArray(reason)) {\n    const first = reason[0]\n    if (first instanceof Error) {\n      if (reason.length > 1) {\n        ;(first as any).errors = reason.slice(1)\n      }\n      return first\n    } else {\n      return new Error(\n        reason\n          .map(ea => toS(ea))\n          .filter(notBlank)\n          .join(\", \")\n      )\n    }\n  } else {\n    // Errors render as \"Error: something bad happened\". If you create a new\n    // Error from that string, you'll get an Error that toString's to \"Error:\n    // Error: something bad happened\", so strip the name of the error and give\n    // it to the return value:\n    const s = errorToS(reason).replace(/^Error: /i, \"\")\n    return new Error(s)\n  }\n}\n\nexport function errorToJson(error: Error) {\n  return compactValues({\n    _ctor: \"Error\",\n    message: error.message ?? String(error),\n    stack: error.stack,\n    name: errorName(error),\n    code: errorCode(error),\n    errno: errorErrno(error),\n    ...omit(error as any, \"name\", \"message\", \"code\", \"errno\")\n  })!\n}\n\nexport function errorFromJson(obj: any) {\n  return assignFields(new Error(), omit(obj, \"_ctor\"))\n}\n\n// core has a fancier version of this:\nexport function errorToArr(...errors: any[]): string[] {\n  const arr = []\n  for (const ea of errors) {\n    if (ea == null) continue\n    if (ea instanceof Error) {\n      arr.push(errorName(ea), errorCode(ea), ea?.message)\n    } else {\n      arr.push(toS(ea))\n    }\n  }\n  return uniq(\n    compactBlankish(flatten(compact(arr).map(ea => ea.split(ErrorDelimiter))))\n  )\n}\n\n// core has a fancier version of this:\nexport function errorToS(...errors: any[]): string {\n  return errorToArr(...errors).join(ErrorDelimiter)\n}\n","import { MaybeNull } from \"./MaybeTypes\"\nimport { toA } from \"./toA\"\n\n/**\n * Compacts and flattens ONE LEVEL\n */\nexport function flatten<T>(\n  arr: (MaybeNull<T> | MaybeNull<T>[])[],\n  result: T[] = []\n): T[] {\n  for (const ea1 of toA(arr)) {\n    if (ea1 != null) {\n      for (const ea2 of toA(ea1)) {\n        if (ea2 != null) result.push(ea2)\n      }\n    }\n  }\n  return result\n}\n","import { compactBlanks, uniq } from \"./Array\"\n\nexport function fmtList(arr: string[], joinWord: string): string {\n  arr = uniq(compactBlanks(arr))\n  return arr == null || arr.length === 0\n    ? \"\"\n    : arr.length === 1\n    ? arr.join(\"\")\n    : arr.slice(0, -1).join(\", \") +\n      \" \" +\n      joinWord.trim() +\n      \" \" +\n      arr[arr.length - 1]\n}\n\nexport function orList(arr: string[]): string {\n  return fmtList(arr, \"or\")\n}\n\nexport function andList(arr: string[]): string {\n  return fmtList(arr, \"and\")\n}\n","import { strEnum, StrEnumKeys } from \"./StrEnum\"\n\n/**\n * @see https://en.wikipedia.org/wiki/Graphics_display_resolution\n */\nexport const FitSizes = strEnum(\n  \"uhd8k\",\n  \"uhd5k\",\n  \"uhd4k\",\n  \"qhd\",\n  \"fhd\",\n  \"hd\",\n  \"wvga\",\n  \"qvga\",\n  \"qqvga\"\n)\nexport type FitSize = StrEnumKeys<typeof FitSizes>\nexport const FitSizeValues = FitSizes.values\n\nexport const SqSizes = strEnum(\"s480\", \"s240\", \"s120\", \"s60\")\nexport type SqSize = StrEnumKeys<typeof SqSizes>\n\nexport const SqWidths = [60, 120, 240, 480]\n\nexport type ImageSizeName = FitSize | SqSize\n","import { gt0, gte0, lt0 } from \"./Number\"\n\n/**\n * @return true if obj is both Iterable *and not a string* (because srsly wth)\n */\nexport function isIterable(obj: any): obj is Iterable<any> {\n  return (\n    obj != null &&\n    typeof obj !== \"string\" &&\n    typeof obj[Symbol.iterator] === \"function\"\n  )\n}\n\n// export function max<T>(i: Iterable<T>, f: (t: T) => Comparable): Maybe<T> {\n//   let result = undefined\n//   let m = undefined\n//   for (const ea of i) {\n//     const r = f(ea)\n//     if (m == null || m < r) {\n//       m = r\n//       result = ea\n//     }\n//   }\n//   return result\n// }\n\nexport function sliceIterable<T>(\n  iterable: Iterable<T>,\n  start: number,\n  end?: number\n): T[] {\n  // If start is negative, we have to iterate the whole thing anyway, so\n  // delegate to Array.slice():\n  if (lt0(start)) {\n    return [...iterable].slice(start, end)\n  }\n\n  const iter = iterable[Symbol.iterator]()\n  if (gt0(start)) {\n    for (let i = 0; i < start; i++) {\n      iter.next()\n    }\n  }\n  const result: T[] = []\n\n  // if end is null, run until .done:\n  for (let i = start; gte0(end) ? i < end : true; i++) {\n    const next = iter.next()\n    // This is pretty lame of the iterator interface, IMHO. Don't return an\n    // object with a value if it doesn't have a value!\n    if (next.value != null || next.done !== true) {\n      result.push(next.value)\n    }\n    if (next.done === true) {\n      break\n    }\n  }\n  // don't splice! This may change the underlying iterable!\n  if (lt0(end)) {\n    return result.slice(0, end)\n  }\n  return result\n}\n\nexport function countIterable(i: Iterable<any>): number {\n  // Avoids GC from creating an array\n  let c = 0\n  const iter = i[Symbol.iterator]()\n  while (true !== iter.next().done) c++\n  return c\n}\n","import { denull } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { isFunction } from \"./isFunction\"\n\nexport type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | { [property: string]: Json }\n  | Json[]\n\nexport type DatedJson =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | Date\n  | { [property: string]: DatedJson }\n  | DatedJson[]\n\n/**\n * Work-alike to JSON.stringify, except that circular dependencies are replaced\n * with a string reference.\n */\nexport function stringify(\n  ea: any,\n  replacer?: (this: any, key: string, value: any) => any,\n  space?: string | number\n): string {\n  return JSON.stringify(decycle(ea), replacer, denull(space))\n}\n\nexport interface JsonReviver {\n  name: string\n  fromJSON(ea: any): any\n}\n\nconst Revivers = new Map<string, JsonReviver>()\n\nexport function addJsonRevivers(...arr: JsonReviver[]) {\n  for (const ea of arr) {\n    Revivers.set(ea.name, ea)\n  }\n}\n\nexport function parseJSON_<T>(s: string): T {\n  return retrocycle(JSON.parse(s, reviver)) as any\n}\n\nexport function parseJSON<T = any>(s: MaybeNull<string | Buffer>): Maybe<T> {\n  try {\n    const s2 = s?.toString().trim()\n    if (s2 != null && s2.length > 0) {\n      return parseJSON_(s2)\n    }\n  } catch {\n    //\n  }\n  return\n}\n\nexport function JSON_<T>(s: string): T {\n  return retrocycle(JSON.parse(s, reviver)) as any\n}\n\nfunction reviver(_key: string, value: any) {\n  // PERF: map inlined\n  const r = Revivers.get(value?._ctor)\n  return r == null ? value : r.fromJSON(value)\n}\n\n// https://github.com/douglascrockford/JSON-js/blob/master/cycle.js\n\n/**\n * Make a deep copy of an object or array, assuring that there is at most\n * one instance of each object or array in the resulting structure. The\n * duplicate references (which might be forming cycles) are replaced with\n * an object of the form\n *      {\"$ref\": PATH}\n * where the PATH is a JSONPath string that locates the first occurrence.\n * So,\n *      var a = [];\n *      a[0] = a;\n *      return JSON.stringify(JSON.decycle(a));\n * produces the string '[{\"$ref\":\"$\"}]'.\n * If a replacer function is provided, then it will be called for each value.\n * A replacer function receives a value and returns a replacement value.\n * JSONPath is used to locate the unique object. $ indicates the top level of\n * the object or array. [NUMBER] or [STRING] indicates a child element or\n * property.\n */\nfunction decycle(object: any) {\n  const objects: any[] = [] // Keep a reference to each unique object or array\n  const paths: string[] = [] // Keep the path to each unique object or array\n\n  return (function derez(value, path): any {\n    // The derez recurses through the object, producing the deep copy.\n\n    if (isFunction(value)) return undefined\n\n    let i: number // The loop counter\n    let name: string // Property name\n    let nu: any // The new object or array\n\n    let _value = value\n\n    try {\n      _value = value.toJSON()\n    } catch (error) {\n      //\n    }\n\n    // typeof null === 'object', so go on if this value is really an object but not\n    // one of the weird builtin objects.\n\n    if (typeof _value === \"object\" && _value != null) {\n      // Remove all fields that shouldn't be serialized:\n      for (const k in _value) {\n        if (k.startsWith(\"__\")) {\n          if (value === _value) {\n            _value = { ..._value }\n          }\n          delete _value[k]\n        }\n      }\n\n      // If the value is an object or array, look to see if we have already\n      // encountered it. If so, return a $ref/path object. This is a hard way,\n      // linear search that will get slower as the number of unique objects grows.\n\n      for (i = 0; i < objects.length; i += 1) {\n        if (objects[i] === _value) {\n          return { $ref: paths[i] }\n        }\n      }\n\n      // Otherwise, accumulate the unique value and its path.\n\n      objects.push(_value)\n      paths.push(path)\n\n      // If it is an array, replicate the array.\n\n      if (Array.isArray(_value)) {\n        nu = []\n\n        for (i = 0; i < _value.length; i += 1) {\n          nu[i] = derez(_value[i], path + \"[\" + i + \"]\")\n        }\n      } else {\n        // If it is an object, replicate the object.\n\n        nu = {}\n\n        for (name in _value) {\n          if (Object.prototype.hasOwnProperty.call(_value, name)) {\n            nu[name] = derez(\n              _value[name],\n              path + \"[\" + JSON.stringify(name) + \"]\"\n            )\n          }\n        }\n      }\n\n      return nu\n    }\n\n    return _value\n  })(object, \"$\")\n}\n\n/**\n  * Restore an object that was reduced by decycle. Members whose values are\n  * objects of the form\n  *      {$ref: PATH}\n  * are replaced with references to the value found by the PATH. This will\n  * restore cycles. `value` will be mutated.\n\n  * The eval function is used to locate the values described by a PATH. The\n  * root object is kept in a $ variable. A regular expression is used to\n  * assure that the PATH is extremely well formed. The regexp contains nested\n  * * quantifiers. That has been known to have extremely bad performance\n  * problems on some browsers for very long strings. A PATH is expected to be\n  * reasonably short. A PATH is allowed to belong to a very restricted subset of\n  * Goessner's JSONPath.\n\n  * So,\n  *      const s = '[{\"$ref\":\"$\"}]';\n  *      return JSON.retrocycle(JSON.parse(s));\n  * produces an array containing a single element which is the array itself.\n*/\nfunction retrocycle($: any) {\n  const px =\n    /^\\$(?:\\[(?:\\d+|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/\n\n  ;(function rez(value) {\n    // The rez function walks recursively through the object looking for $ref\n    // properties. When it finds one that has a value that is a path, then it\n    // replaces the $ref object with a reference to the value that is found by\n    // the path.\n\n    let i, item, name, path\n\n    if (value && typeof value === \"object\") {\n      if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n        for (i = 0; i < value.length; i += 1) {\n          item = value[i]\n\n          if (item != null && typeof item === \"object\") {\n            path = item.$ref\n\n            if (typeof path === \"string\" && px.test(path)) {\n              value[i] = eval(path)\n            } else {\n              rez(item)\n            }\n          }\n        }\n      } else {\n        for (name in value) {\n          if (typeof value[name] === \"object\") {\n            item = value[name]\n\n            if (item != null) {\n              path = item.$ref\n\n              if (typeof path === \"string\" && px.test(path)) {\n                value[name] = eval(path)\n              } else {\n                rez(item)\n              }\n            }\n          }\n        }\n      }\n    }\n  })($)\n\n  return $\n}\n","import { PromiseState } from \"./PromiseState\"\n\n// This is used by logging, so it can't have any dependencies.\n\n/**\n * Simple one-count concurrent barrier\n */\nexport class Latch implements Promise<void> {\n  // required by lib.es2015:\n  readonly [Symbol.toStringTag] = \"Latch\"\n  // Expose `promise` so we can have a honest-to-goodness Promise\n  readonly promise: Promise<void>\n  private _state: PromiseState = \"pending\"\n  error?: Error\n  private _resolve!: () => void\n  private _reject!: (err?: Error) => void\n\n  constructor(readonly id?: any) {\n    this.promise = new Promise<void>((resolve, reject) => {\n      this._resolve = resolve\n      this._reject = reject\n    })\n  }\n\n  // This is used by LogMeta for logging:\n  toLogJSON() {\n    return {\n      _ctor: \"Latch\",\n      id: this.id,\n      state: this.state()\n    }\n  }\n\n  resolve(): Latch {\n    if (this.isPending()) {\n      this._resolve()\n      this._state = \"resolved\"\n    }\n    return this\n  }\n\n  reject(error?: Error): Latch {\n    if (this.isPending()) {\n      this._reject(error)\n      this._state = \"rejected\"\n      this.error = error\n    }\n    return this\n  }\n\n  observe(p: Promise<any>): this {\n    p.then(\n      () => this.resolve(),\n      err => this.reject(err)\n    )\n    return this\n  }\n\n  observeQuietly(p: Promise<any>): this {\n    p.then(\n      () => this.resolve(),\n      () => this.resolve()\n    )\n    return this\n  }\n\n  isPending(): boolean {\n    return this._state === \"pending\"\n  }\n\n  isSettled() {\n    return !this.isPending()\n  }\n\n  isResolved() {\n    return this._state === \"resolved\"\n  }\n\n  isRejected() {\n    return this._state === \"rejected\"\n  }\n\n  state(): PromiseState {\n    return this._state\n  }\n\n  then<T1, T2>(\n    onfulfilled?: ((v: void) => T1 | PromiseLike<T1>) | undefined | null,\n    onrejected?: ((reason: any) => T2 | PromiseLike<T2>) | undefined | null\n  ): Promise<T1 | T2> {\n    return this.promise.then(onfulfilled, onrejected)\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: any) => TResult | PromiseLike<TResult>)\n      | undefined\n      | null\n  ): Promise<void | TResult> {\n    return this.promise.catch(onrejected)\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<void> & this {\n    void this.promise.finally(onfinally)\n    return this\n  }\n}\n","import { isEmpty } from \"./Array\"\nimport { ChangeListener } from \"./ChangeListener\"\nimport { eql } from \"./Eql\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { gt0 } from \"./Number\"\nimport { setUnrefTimeout } from \"./UnrefTimeout\"\nimport { UnwrapPromiseLike } from \"./UnwrapPromiseLike\"\n\n// USED BY LOG: DON'T DEPEND ON ANYTHING (much)\n\nexport interface MemoizedLazy<T> {\n  /**\n   * Force the prior value to be `t`\n   */\n  set(t: T): void\n  /**\n   * clears the prior value\n   * @return the prior value\n   */\n  clear(): Maybe<T>\n  /**\n   * Clears the prior value but doesn't return it (so we don't have to\n   * explicitly ignore unawaited promises)\n   */\n  unset(): void\n  /**\n   * Forces the underlying thunk or later to be applied\n   */\n  refresh(): T\n  /**\n   * @return the milliseconds a prior result may be returned by `apply`, or\n   * undefined if no TTL is set\n   */\n  ttl(): Maybe<number>\n  /**\n   * @param ttl undefined to remove TTL expirations\n   */\n  setTTL(ttl: number | undefined): void\n  /**\n   * Immediately calls the listener with current value, and calls the listener\n   * if the result changes.\n   */\n  watch(watcher: ChangeListener<T>): void\n  /**\n   * Calls the listener if the result changes later. The underlying thunk is\n   * not applied now (like with {@link MemoizedThunk.watch}).\n   */\n  watchLater(watcher: ChangeListener<T>): void\n  lastSetAgoMs(): Maybe<number>\n  /**\n   * Was this applied and not cleared or unset?\n   */\n  hasPrior(): boolean\n  /**\n   * @return the previously-memoized value, if it isn't stale (according to\n   * `ttl()`)\n   */\n  prior(): Maybe<T>\n\n  /**\n   * Has a result not been calculated, or was calculated more than `ttl()` ms\n   * ago?\n   */\n  isStale(): boolean\n\n  toString(): string\n}\n\nexport interface MemoizedThunk<T> extends MemoizedLazy<T> {\n  (): T\n}\n\nexport type UnwrapLazy<T> = T extends MemoizedThunk<infer U> ? U : T\nexport type UnwrapLazyAsync<T> = T extends MemoizedThunk<infer U>\n  ? UnwrapPromiseLike<U>\n  : T\n\n// HEY, FUTURE ME: yeah, I know you think something here should call\n// ee().on(\"clearCache\",), but DON'T DO IT, MAN. lazy is used by lots of\n// instances that we want to be garbage collected, and that would create a huge\n// memory leak.\n\n/**\n * @param ttlMs if 0 or null, the result of `thunk` will be cached forever.\n */\nexport function lazy<T>(thunk: () => T, ttlMs?: number): MemoizedThunk<T> {\n  let lastSetTs: number | undefined\n  let result: T | undefined\n  const watchers: ChangeListener<T>[] = []\n\n  // HEY FUTURE ME: We're using named functions here, instead of fat arrows,\n  // so they show up properly in stacktraces.\n\n  function Lazy() {\n    if (Lazy.isStale()) {\n      // NO PROMISE AWAITING HERE. Otherwise N calls would go through while we\n      // wait for the promise to resolve.\n      Lazy.setResult(thunk())\n    }\n    return result!\n  }\n  // REMEMBER: function `.name` is not allowed to be overridden!\n\n  async function onSetResult(priorP: Maybe<T>, currentP: T) {\n    if (isEmpty(watchers)) return\n    // prior and current could be a promise!\n\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const _prior = await priorP\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const current = await currentP\n    if (!eql(_prior, current)) {\n      for (const ea of watchers) ea(current)\n    }\n    // We're interpreting undefined as unset, and `null` as a valid set value.\n    if (ttlMs != null && ttlMs > 0 && current !== undefined) {\n      // help the garbage collector:\n      setUnrefTimeout(() => Lazy.vacuum(), ttlMs)\n    }\n  }\n\n  Lazy.vacuum = function vacuum() {\n    if (Lazy.isStale()) Lazy.unset()\n  }\n\n  Lazy.setResult = function setResult(t: T) {\n    lastSetTs = Date.now()\n    void onSetResult(result, t)\n    return (result = t)\n  }\n\n  Lazy.isStale = function isStale() {\n    return lastSetTs == null || (gt0(ttlMs) && lastSetTs + ttlMs < Date.now())\n  }\n\n  Lazy.set = function set(t: T) {\n    Lazy.setResult(t)\n  }\n\n  Lazy.unset = function unset() {\n    Lazy.setResult(undefined as any)\n    lastSetTs = undefined\n  }\n\n  Lazy.clear = function clear() {\n    const _prior = result\n    Lazy.unset()\n    return _prior\n  }\n\n  Lazy.prior = function prior() {\n    Lazy.vacuum()\n    return result\n  }\n\n  Lazy.refresh = function refresh() {\n    return Lazy.setResult(thunk())\n  }\n\n  Lazy.ttl = function ttl() {\n    return ttlMs\n  }\n\n  Lazy.setTTL = function setTTL(ttl: number | undefined) {\n    ttlMs = gt0(ttl) ? ttl : undefined\n  }\n\n  Lazy.watchLater = function watchLater(watcher: ChangeListener<T>) {\n    watchers.push(watcher)\n  }\n\n  Lazy.watch = function watch(watcher: ChangeListener<T>) {\n    watcher(Lazy())\n    Lazy.watchLater(watcher)\n  }\n\n  Lazy.toString = function toString() {\n    return \"[Lazy]\"\n  }\n\n  Lazy.toJSON = function toJSON() {\n    // We don't support JSON encode/decode:\n    return undefined\n  }\n\n  Lazy.lastSetAgoMs = function lastSetAgoMs() {\n    return lastSetTs == null ? undefined : Date.now() - lastSetTs\n  }\n\n  Lazy.hasPrior = function hasPrior() {\n    return lastSetTs != null\n  }\n\n  return Lazy\n}\n","export function getOrSet<K, V>(\n  m: Map<K, V> | WeakMap<any, V>,\n  k: K,\n  valueThunk: () => V\n): V {\n  if (k == null) throw new Error(\"null key\")\n  if (m.has(k)) {\n    return m.get(k)!\n  } else {\n    const v = valueThunk()\n    if (v != null) m.set(k, v)\n    return v\n  }\n}\n\nexport function deleteIf<K, V>(\n  m: Map<K, V>,\n  predicate: (key: K, value: V) => boolean\n) {\n  for (const [k, v] of m.entries()) {\n    if (predicate(k, v)) {\n      m.delete(k)\n    }\n  }\n}\n","import { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toS } from \"./toS\"\n\nexport function map<T, U>(obj: MaybeNull<T>, f: (t: T) => U): Maybe<U> {\n  // isNaN({a:1}) === true\n  return obj == null ? undefined : f(obj)\n}\n\nexport function mapTry<T, U>(f: () => MaybeNull<T>, g: (t: T) => U): Maybe<U> {\n  try {\n    return map(f(), g)\n  } catch {\n    return\n  }\n}\n\nexport function map2<T1, T2, U>(\n  t1: MaybeNull<T1>,\n  t2: MaybeNull<T2>,\n  f: (ea1: T1, ea2: T2) => U\n): Maybe<U> {\n  return t1 == null || t2 == null ? undefined : f(t1, t2)\n}\n\nexport function map3<T1, T2, T3, U>(\n  t1: MaybeNull<T1>,\n  t2: MaybeNull<T2>,\n  t3: MaybeNull<T3>,\n  f: (ea1: T1, ea2: T2, ea3: T3) => U\n): Maybe<U> {\n  return t1 == null || t2 == null || t3 == null ? undefined : f(t1, t2, t3)\n}\n\nexport function orElse<T>(obj: MaybeNull<T>, defaultValue: ThunkOrT<T>): T {\n  return obj != null ? obj : tot(defaultValue)\n}\n\nexport function mapOr<T, U>(\n  obj: MaybeNull<T>,\n  f: (t: T) => U,\n  defaultValue: ThunkOrT<U>\n): U {\n  return obj != null ? f(obj) : tot(defaultValue)\n}\n\nexport function map2Or<T1, T2, U>(\n  t1: MaybeNull<T1>,\n  t2: MaybeNull<T2>,\n  f: (ea1: T1, ea2: T2) => U,\n  defaultValue: () => U\n): U {\n  return orElse(map2(t1, t2, f), defaultValue)\n}\n\n// https://www.typescriptlang.org/docs/handbook/advanced-types.html#predefined-conditional-types\n\nexport type Diff<T, U> = T extends U ? never : T\n\nexport type Unpick<T, U> = { [P in keyof T]: P extends U ? never : T[P] }\n\nexport type Defined<T> = Diff<T, null | undefined | void>\n\n/**\n * @return true iff all `objects` are not `null` or `undefined`\n */\nexport function defined<T>(object: T): object is Defined<T> {\n  return object != null\n}\n\n/**\n * Like `map`, but calls `f` if `obj` is not `undefined`.\n *\n * To clarify, if `obj` is `null`, `f` will be called with `null`.\n */\nexport function ifDefined<T, U>(obj: T | undefined, f: (t: T) => U): Maybe<U> {\n  return obj === undefined ? undefined : f(obj)\n}\n\nexport function allDefined<T>(arr: T[]): arr is Defined<T>[] {\n  return arr != null && arr.every(defined)\n}\n\nexport function firstDefined<T>(...objects: MaybeNull<T>[]): Maybe<T> {\n  return objects.find(defined)\n}\n\nexport function denull<T>(t: T | undefined | null): T | undefined {\n  return t == null || toS(t) === \"null\" ? undefined : t\n}\n\nexport function nulled<T>(t: T | undefined | null): T | null {\n  return t == null ? null : t\n}\n","import {\n  filterInPlace,\n  isEmpty,\n  isNotEmpty,\n  pushUniq,\n  sum,\n  uniq\n} from \"./Array\"\nimport { sortBy } from \"./ArraySort\"\nimport { eql } from \"./Eql\"\nimport { stringify } from \"./JSON\"\nimport { getOrSet } from \"./Map\"\nimport { map } from \"./Maybe\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { Primitive } from \"./Primitive\"\nimport { isString } from \"./String\"\nimport { toA } from \"./toA\"\n\n/**\n * Multi-valued Map.\n */\nexport class MultiMap<K, V> {\n  readonly store: Map<K, V[]>\n\n  constructor(store = new Map<K, V[]>()) {\n    this.store = store\n  }\n\n  get(key: K): V[] | undefined {\n    return this.store.get(key)\n  }\n\n  has(key: K): boolean {\n    return this.store.has(key)\n  }\n\n  includes(key: K, value: V): boolean {\n    return this.store.get(key)?.includes(value) === true\n  }\n\n  /**\n   * @return the number of unique keys in this store\n   */\n  keyCount(): number {\n    return this.store.size\n  }\n\n  /**\n   * @return the number of values in this store\n   */\n  valueCount(): number {\n    return sum(\n      [...this.store.values()].map(ea => ea.length),\n      ea => ea\n    )\n  }\n\n  add(key: K, ...values: V[]): V[] {\n    const store = getOrSet(this.store, key, () => [])\n    store.push(...values)\n    return store\n  }\n\n  addUniq(key: K, ...values: V[]): V[] {\n    return pushUniq(\n      getOrSet(this.store, key, () => []),\n      ...values\n    )\n  }\n\n  set(key: K, values: V[]) {\n    this.store.set(key, values)\n  }\n\n  delete(key: K, value?: V): boolean {\n    if (value == null) {\n      return this.store.delete(key)\n    } else {\n      const arr = this.store.get(key)\n      if (arr == null) {\n        return false\n      } else {\n        const result = arr.filter(ea => !eql(ea, value))\n        if (result.length === 0) {\n          this.store.delete(key)\n        } else {\n          this.store.set(key, result)\n        }\n        return arr.length !== result.length\n      }\n    }\n  }\n\n  clear(): this {\n    this.store.clear()\n    return this\n  }\n\n  keys(): IterableIterator<K> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<K> {\n      for (const [k, v] of self.store.entries()) {\n        if (v.length > 0) {\n          yield k\n        }\n      }\n    }\n    return iter()\n  }\n\n  values(): IterableIterator<V[]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<V[]> {\n      for (const [, v] of self.store.entries()) {\n        if (v.length > 0) {\n          yield v\n        }\n      }\n    }\n    return iter()\n  }\n\n  vacuum(f: (key: K, values: V[]) => Maybe<V[]> = (_k, v) => uniq(v)) {\n    for (const k of this.keys()) {\n      const prior = this.store.get(k)\n      const arr = prior == null ? [] : f(k, prior)\n      if (isEmpty(arr)) {\n        this.store.delete(k)\n      } else {\n        this.store.set(k, arr)\n      }\n    }\n  }\n\n  flatValues(): IterableIterator<V> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<V> {\n      for (const [, arr] of self.store.entries()) {\n        if (arr.length > 0) {\n          for (const ea of arr) {\n            yield ea\n          }\n        }\n      }\n    }\n    return iter()\n  }\n\n  entriesArray(): [K, V[]][] {\n    return [...this.store.entries()].filter(([, v]) => isNotEmpty(v))\n  }\n\n  entries(): IterableIterator<[K, V[]]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<[K, V[]]> {\n      for (const [k, v] of self.store.entries()) {\n        if (v.length > 0) {\n          yield [k, v]\n        }\n      }\n    }\n    return iter()\n  }\n\n  tuples(): IterableIterator<[K, V]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<[K, V]> {\n      for (const [k, v] of self.store.entries()) {\n        for (const ea of toA(v)) {\n          if (ea != null) yield [k, ea]\n        }\n      }\n    }\n    return iter()\n  }\n\n  filterInPlace(predicate: (key: K, value: V) => boolean): boolean {\n    let changed = false\n    for (const [k, arr] of this.store.entries()) {\n      const len = arr.length\n      filterInPlace(arr, v => predicate(k, v))\n      changed = changed || len !== arr.length\n      if (arr.length === 0) {\n        this.store.delete(k)\n      }\n    }\n    return changed\n  }\n\n  inverse(): MultiMap<V, K> {\n    const m = new MultiMap<V, K>()\n    for (const [k, v] of this.store.entries()) {\n      for (const ea of v) {\n        m.add(ea, k)\n      }\n    }\n    return m\n  }\n\n  findKeyByTuple(predicate: (key: K, value: V) => boolean): Maybe<K> {\n    for (const [k, v] of this.tuples()) {\n      if (predicate(k, v)) return k\n    }\n    return\n  }\n\n  filterKeysByTuple(predicate: (key: K, value: V) => boolean): K[] {\n    const result: K[] = []\n    for (const [k, arr] of this.entries()) {\n      if (arr.some(v => predicate(k, v))) result.push(k)\n    }\n    return result\n  }\n\n  toJSON(): Record<string, V[]> {\n    const result: Record<string, V[]> = {}\n    for (const [k, v] of this.entries()) {\n      result[isString(k) ? k : stringify(k)] = v\n    }\n    return result\n  }\n}\n\n/**\n * Groups the given enumeration\n * @return a copy of arr, sorted by the given constraint\n */\nexport function groupBy<K extends Primitive, V>(\n  arr: V[],\n  f: (t: V) => Maybe<K>\n): MultiMap<K, V> {\n  const m = new MultiMap<K, V>()\n  arr.forEach(ea => map(f(ea), k => m.add(k, ea)))\n  return m\n}\n\nexport function groupByValues<K extends Primitive, V>(\n  arr: V[],\n  f: (t: V) => Maybe<K>\n): V[][] {\n  const g = groupBy(arr, f)\n  return sortBy(toA(g.values()), ea => f(ea[0]))\n}\n","const g = globalThis as any\n\nexport const isBrowser =\n  typeof g?.window === \"object\" && typeof g?.document === \"object\"\n\nexport const isNode = typeof g?.process?.versions?.node === \"string\"\n","import { sort } from \"./ArraySort\"\nimport { blank } from \"./Blank\"\nimport { orElse } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toS } from \"./toS\"\n\nexport function isNumber(o: any): o is number {\n  return typeof o === \"number\" && !isNaN(o) && isFinite(o)\n}\n\nexport function isInvalidNumber(o: any): o is number {\n  return typeof o === \"number\" && (isNaN(o) || !isFinite(o))\n}\n\n// thinking about adding toNumber? Please use toInt or toFloat instead.\n\nconst numeralRE = /^\\d+$/\nexport function isDigits(o: any): boolean {\n  return toS(o).match(numeralRE) != null\n}\n\nconst nonNumericRE = /[^-\\.0-9\\s]/\n\nexport function isNumeric(o: any): boolean {\n  return toS(o).match(nonNumericRE) == null && toFloat(o) != null\n}\n\nexport function isBigInt(o: any): o is bigint {\n  return typeof o === \"bigint\"\n}\n\nexport function mapFinite<T>(i: Maybe<number>, f: (ea: number) => T): Maybe<T> {\n  return isNumber(i) ? f(i) : undefined\n}\n\nconst mapPredicate =\n  (f: (lhs: number, rhs: number) => boolean) =>\n  (lhs: MaybeNull<number>, rhs: MaybeNull<number>) =>\n    isNumber(lhs) && isNumber(rhs) && f(lhs, rhs)\n\nexport const lt = mapPredicate((i, j) => i < j)\nexport const lte = mapPredicate((i, j) => i <= j)\nexport const gt = mapPredicate((i, j) => i > j)\nexport const gte = mapPredicate((i, j) => i >= j)\n\nexport function finiteOrElse<T>(i: Maybe<number>, defaultValue: T): number | T {\n  return isNumber(i) ? i : defaultValue\n}\n\nexport function diff(i: Maybe<number>, j: Maybe<number>): Maybe<number> {\n  return isNumber(i) && isNumber(j) ? i - j : undefined\n}\n\nexport function absdiff(i: Maybe<number>, j: Maybe<number>): Maybe<number> {\n  return isNumber(i) && isNumber(j) ? Math.abs(i - j) : undefined\n}\n\nexport function safeDivide(numerator: number, denominator: number): number {\n  return numerator / (denominator === 0 ? 1e-8 : denominator)\n}\n\n/**\n * @return true iff a is within ((1-minCoeff)*b)±b\n */\nexport function approximates(\n  a: MaybeNull<number>,\n  b: MaybeNull<number>,\n  minCoeff: number = 0.95\n): boolean {\n  if (!isNumber(a) || !isNumber(b)) return false\n  if (a === b) return true\n  if (minCoeff >= 1) return false // it doesn't match!\n  const delta = (b === 0 ? 1e-5 : b) * (1 - minCoeff)\n  return within(b - delta, b + delta, a)\n}\n\n/**\n * @param min inclusive\n * @param max inclusive\n */\nexport function within(min: number, max: number, n: any): n is number {\n  if (n == null || !isNumber(n)) return false\n  ;[min, max] = sort([min, max])\n  return lte(min, n) && gte(max, n)\n}\n\nexport function max_(...arr: Maybe<number>[]): number {\n  let max: Maybe<number>\n  for (const ea of arr) {\n    if (isNumber(ea) && (max == null || max < ea)) max = ea\n  }\n  if (max == null) throw new Error(\"no numbers given to max()\")\n  else return max\n}\n\n/**\n * @return true iff expected is within ±delta of actual\n */\nexport function closeTo(\n  expected: MaybeNull<number>,\n  actual: MaybeNull<number>,\n  delta: number\n): boolean {\n  return isNumber(expected) && isNumber(actual)\n    ? // if the delta is _less than or equal to_, pass.\n      Math.abs(expected - actual) <= delta\n    : false\n}\n\nexport function trunc(n: Maybe<number>): Maybe<number> {\n  if (!isNumber(n)) return undefined\n  const i = Math.trunc(n)\n  return i === 0 ? Math.abs(i) : i\n}\n\nexport interface ToNumber {\n  toNumber(): number\n}\n\nexport function isToNumber(v: any): v is ToNumber {\n  return typeof v?.toNumber === \"function\"\n}\n\nfunction toNumber(\n  value: MaybeNull<number | bigint | string | ToNumber>,\n  opts: {\n    defaultValue: Maybe<number>\n    nton: (n: number) => number\n    ston: (s: string) => Maybe<number>\n  }\n): Maybe<number> {\n  if (blank(value)) return opts.defaultValue\n  if (isNumber(value)) return opts.nton(value)\n  if (isBigInt(value)) {\n    // CAREFUL! Old Safari will keel over due to lack of BigInt support: it's\n    // OK here, because the value typeof is \"bigint\", which would only be true\n    // where BigInt *is* supported.\n    if (\n      value > BigInt(Number.MAX_SAFE_INTEGER) ||\n      value < BigInt(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new Error(\"precision loss for \" + value)\n    }\n    return opts.nton(Number(value))\n  }\n  if (isToNumber(value)) return opts.nton(value.toNumber())\n  try {\n    const i = opts.ston(toS(value).trim())\n    return isNumber(i) ? opts.nton(i) : opts.defaultValue\n  } catch {\n    return opts.defaultValue\n  }\n}\n\nexport function toInt(\n  value: MaybeNull<number | bigint | string | ToNumber>,\n  opts?: { defaultValue?: number }\n): Maybe<number> {\n  return toNumber(value, {\n    defaultValue: undefined,\n    nton: i => trunc(i)!,\n    ston: parseInt,\n    ...opts\n  })\n}\n\nexport function toFloat(\n  value: MaybeNull<number | string>,\n  opts?: { defaultValue?: number }\n): Maybe<number> {\n  return toNumber(value, {\n    defaultValue: undefined,\n    nton: i => i,\n    ston: parseFloat,\n    ...opts\n  })\n}\n\n/**\n * @return `Math.trunc(n)` if n is a positive integer, else undefined\n */\nexport function toGt0(n: any): Maybe<number> {\n  const i = toInt(n)\n  return i != null && i > 0 ? i : undefined\n}\n\nexport function toGt0f(n: any): Maybe<number> {\n  const i = toFloat(n)\n  return i != null && i > 0 ? i : undefined\n}\n\nexport function lt0(n: any): n is number {\n  return isNumber(n) && n < 0\n}\n\nexport function gt0(n: any): n is number {\n  return isNumber(n) && n > 0\n}\n\nexport function firstGt0(...arr: any[]): Maybe<number> {\n  for (const ea of arr) {\n    if (gt0(ea)) return ea\n    const i = toInt(ea)\n    if (gt0(i)) return i\n  }\n  return\n}\n\nexport function gtOrElse(\n  n: Maybe<number>,\n  mustBeGreaterThan: number\n): Maybe<number> {\n  return isNumber(n) && isNumber(mustBeGreaterThan) && n > mustBeGreaterThan\n    ? n\n    : undefined\n}\n\nexport function lte0(n: any): n is number {\n  return isNumber(n) && n <= 0\n}\n\nexport function gte0(n: any): n is number {\n  return isNumber(n) && n >= 0\n}\n\nexport function toGte0(n: any): Maybe<number> {\n  return gte0(n) ? n : undefined\n}\n\nexport function mapInt<T>(o: any, f: (i: number) => T): Maybe<T> {\n  // PERF: UNROLLED FROM opt()\n  const i = toInt(o)\n  return i == null ? undefined : f(i)\n}\n\nexport function mapFloat<T>(o: any, f: (i: number) => T): Maybe<T> {\n  // PERF: UNROLLED FROM opt()\n  const i = toFloat(o)\n  return i == null ? undefined : f(i)\n}\n\n/**\n * @return a stringified `value` iff `value` is a positive integer\n */\nexport function id(value: Maybe<number | string>): Maybe<string> {\n  const i = toInt(value)\n  return gt0(i) ? String(i) : undefined\n}\n\nexport function mapIntOr<T>(o: any, f: (i: number) => T, orElseF: () => T): T {\n  return orElse(mapInt(o, f), orElseF)\n}\n\nexport function mapNumeric<T>(o: any, f: (i: number) => T): Maybe<T> {\n  return isNumber(o) ? f(o) : undefined\n}\n\nexport function map2Numeric<T>(\n  i: any,\n  j: any,\n  f: (ea1: number, ea2: number) => T\n): Maybe<T> {\n  return mapNumeric(i, ea1 => mapNumeric(j, ea2 => f(ea1, ea2)))\n}\n\nexport function mapNumericOr<T>(\n  o: any,\n  f: (i: number) => T,\n  defaultValue: T\n): T {\n  return isNumber(o) ? f(o) : defaultValue\n}\n\nexport function numericOr(o: any, defaultValue: ThunkOrT<number>): number {\n  return isNumber(o) ? o : tot(defaultValue)\n}\n\nexport function round(i: number): number {\n  // Workaround for bug in javascript (Math.round(-1.5) === -1 (!!)):\n  return !isNumber(i) ? 0 : i < 0 ? -Math.round(-i) : Math.round(i)\n}\n\n/**\n * @see Number#toFixed\n */\nexport function toFixed(i: Maybe<number>, decimals: number): Maybe<number> {\n  try {\n    return mapNumeric(i, ea => round(ea * 10 ** decimals) / 10 ** decimals)\n  } catch (err) {\n    return\n  }\n}\n\n/**\n * Just like Number.toFixed, without extraneous padded zeroes\n *\n * @see Number#toFixed\n */\nexport function toFixedStr(i: number, fractionDigits: number) {\n  // this is NOT a general-purpose zero-stripper-RegExp!\n  return i.toFixed(fractionDigits).replace(/(\\.0*$)|(?<=\\d+\\.\\d+)0+$/, \"\")\n}\n\n/**\n * @see Number#toPrecision\n */\nexport function toPrecision(i: number, decimalPlaces: number): number {\n  if (i == null) return 0\n  // pow should be 1 for decimalPlaces = 0\n  const pow = Math.pow(10, decimalPlaces)\n  return round(i * pow) / pow\n}\n\nexport function toPrecisionMaybe(\n  i: Maybe<number>,\n  decimalPlaces: number\n): Maybe<number> {\n  return mapFinite(i, ea => toPrecision(ea, decimalPlaces))\n}\n\nexport function sigFigs(i: number, digits: number): number {\n  if (i === 0 || digits === 0) {\n    return 0\n  }\n  const exp = digits - round(Math.ceil(Math.log10(Math.abs(i))))\n  const pow = Math.pow(10, Math.abs(exp))\n  // Prevent 120.000000001:\n  return exp < 0 ? round(i / pow) * pow : round(i * pow) / pow\n}\n\nexport function base2Ceil(i: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(i)))\n}\n\nexport function base10Ceil(i: number): number {\n  return Math.pow(10, Math.ceil(Math.log10(i)))\n}\n\nexport function clamp(min: number, max: number, value: number): number {\n  if (min > max || !isNumber(min) || !isNumber(max))\n    throw new Error(`invalid clamp(${min}, ${max}, ${value})`)\n  if (!isNumber(value)) return (min + max) / 2\n  return value < min ? min : value > max ? max : value\n}\n\n/**\n * Accumulate the result of `f`, called `count` times. `f` receives a\n * zero-indexed argument.\n */\nexport function times<T>(count: number, f: (i: number) => T): T[] {\n  if (!gt0(count)) return []\n  const c = Math.round(count)\n  if (c <= 0) return []\n  return [...Array(c)].map((_, i) => f(i))\n}\n\nexport function pct(numerator: Maybe<number>, denominator: number): number {\n  return clamp(\n    0,\n    100,\n    gt0(denominator)\n      ? round((100 * (gt0(numerator) ? numerator : 0)) / denominator)\n      : 0\n  )\n}\n\nexport function fmtPct(i: Maybe<number>): Maybe<string> {\n  const rnd = Math.round(i ?? -1)\n  return within(0, 100, rnd) ? rnd + \"%\" : undefined\n}\n\nconst _factorials: number[] = [1, 1]\n\n/**\n * @return the factorial of `n`\n */\nexport function factorial(n: number): number {\n  if (!gte0(n) || Math.round(n) !== n)\n    throw new Error(`factorial(${n}): must be non-negative integer`)\n  // Number.MAX_VALUE < 171!\n  if (n > 170) return Infinity\n\n  // TODO: replace with ??= when fe is upgraded to TS 3.7+\n  return _factorials[n] != null\n    ? _factorials[n]\n    : (_factorials[n] = factorial(n - 1) * n)\n}\n\n/**\n * @return the number of ways to choose `r` items from `n` items\n */\nexport function choose(n: number, r: number) {\n  return factorial(n) / (factorial(r) * factorial(n - r))\n}\n","import { compact, isEmpty, uniq } from \"./Array\"\nimport { sort } from \"./ArraySort\"\nimport { blank, notBlank } from \"./Blank\"\nimport { isFunction } from \"./isFunction\"\nimport { Defined, defined, map, Unpick } from \"./Maybe\"\nimport {\n  DefinedValued,\n  Maybe,\n  MaybeNull,\n  MaybeValued,\n  ReqValued\n} from \"./MaybeTypes\"\nimport { MultiMap } from \"./MultiMap\"\nimport { isPrimitive } from \"./Primitive\"\nimport { toS } from \"./toS\"\n\nexport type Valued<T> = Record<string, T>\n\nexport type KeyOf<T> = string & keyof T\n// export type KeyOf<T> = Extract<keyof T, string>\n\nexport type StringValued = Valued<Maybe<string>>\nexport type StrBoolValued = Valued<Maybe<string | boolean>>\nexport type NativeValued = Valued<Maybe<string | boolean | number>>\n\nexport type Obj = Record<string, any>\n\nexport function isObject(o: any): o is object {\n  return o != null && typeof o === \"object\"\n}\n\nexport function tap<T>(o: T, block?: (t: T) => void): T {\n  if (block != null) {\n    block(o)\n  } else {\n    if (typeof o === \"string\") {\n      console.log(o)\n    } else {\n      console.dir(o, { depth: null })\n    }\n  }\n  return o\n}\n\nexport function keys<T extends Obj>(obj: Maybe<T>): KeyOf<T>[] {\n  // `typeof null === \"object\"` because js wants to F*CK YOU UP\n  if (obj == null || typeof obj !== \"object\") return []\n  return Object.keys(obj).filter(\n    k =>\n      typeof k === \"string\" &&\n      (obj[\"propertyIsEnumerable\"] == null ||\n        obj[\"propertyIsEnumerable\"](k) === true)\n  )\n}\n\nexport function keysWithDefinedValues<T extends Obj>(\n  obj: Maybe<T>\n): KeyOf<T>[] {\n  return obj == null ? [] : keys(obj).filter(k => obj[k] !== undefined)\n}\n\n/**\n * @return true iff o is null, undefined, or only has keys associated to an\n * `undefined` value\n */\nexport function isEmptyObj(o: any): o is undefined {\n  if (typeof o !== \"object\") return true\n  for (const k in o) {\n    if (o[k] !== undefined) return false\n  }\n  return true\n}\n\nexport function notEmptyObj(o: any): o is Obj {\n  return !isEmptyObj(o)\n}\n\nexport function mapCompactObj<T>(o: Maybe<Obj>, f: (_o: Obj) => T): Maybe<T> {\n  const c = compactValues(o)\n  return notEmptyObj(c) ? f(c) : undefined\n}\n\nexport function values<T extends Obj>(o: T): T[KeyOf<T>][] {\n  return keys(o).map(k => o[k]) as any\n}\n\n// polyfill for Object.entries. Does no nullish-value compaction!\nexport function entries<T extends Obj>(obj: T): [KeyOf<T>, T[KeyOf<T>]][] {\n  return obj == null\n    ? []\n    : Object.entries?.(obj) ?? keys(obj ?? {}).map(ea => [ea, obj[ea]])\n}\n\nexport function fromEntries(\n  arr: MaybeNull<Iterable<Maybe<[Maybe<string>, any]>>>,\n  obj?: any\n): any {\n  if (arr == null) return obj\n  // don't use Object.create(null), json stringify will break!\n  for (const ea of arr) {\n    if (ea != null && Array.isArray(ea)) {\n      const [k, v] = ea\n      // allow NULL fields:\n      if (k != null && v !== undefined) {\n        if (typeof obj !== \"object\") obj = {}\n        obj[k] = v\n      }\n    }\n  }\n  return obj\n}\n\nexport function assignFields<T>(\n  dest: T,\n  src: Maybe<Partial<T>>,\n  opts?: { omitKeys?: string[]; assignNullish?: boolean }\n): T {\n  if (src == null) {\n    return dest\n  }\n  for (const [k, v] of entries(src)) {\n    if (opts?.omitKeys?.includes(k) === true) continue\n    if (v != null || true === opts?.assignNullish) (dest as any)[k] = v\n  }\n  return dest\n}\n\n/**\n * Only overwrite fields from src that are undefined in dest.\n */\nexport function assignUndefinedFields<T>(\n  dest: T,\n  src: Maybe<Pick<T, any>>,\n  ...srcKeys: KeyOf<T>[]\n): T {\n  if (src == null) {\n    return dest\n  }\n  for (const ea of srcKeys) {\n    const v = src[ea]\n    if (v !== undefined && dest[ea] === undefined) dest[ea] = v\n  }\n  return dest\n}\n\n/**\n * Assigns all keys from src to dest, even if they are null or undefined.\n */\nexport function assignAllFields<T>(dest: T, src: Maybe<Pick<T, any>>): T {\n  for (const [k, v] of entries(src ?? {})) {\n    ;(dest as any)[k] = v\n  }\n  return dest\n}\n\nexport function definedValues<T extends Obj>(\n  t: Maybe<T>\n): Maybe<DefinedValued<Partial<T>>> {\n  if (t == null) return undefined\n  const arr = entries(t)\n  if (arr.every(([, v]) => v !== undefined)) return t\n  const pairs = arr.filter(([, v]) => v !== undefined)\n  return isEmpty(pairs) ? undefined : fromEntries(pairs)\n}\n\nexport function compactValues<T extends Obj>(\n  t: Maybe<T>\n): Maybe<ReqValued<Partial<T>>> {\n  if (t == null) return undefined\n  const arr = entries(t)\n  if (arr.every(([, v]) => v != null)) return t\n  const pairs = arr.filter(([, v]) => v != null)\n  return isEmpty(pairs) ? undefined : fromEntries(pairs)\n}\n\nexport function compactValuesDeep(o: any): any {\n  if (o == null) return\n  if (isPrimitive(o)) return o\n  if (Array.isArray(o)) {\n    return compact(o.map(compactValuesDeep))\n  } else {\n    const arr = compact(\n      entries(o).map(([k, v]) => map(compactValuesDeep(v), ea => [k, ea]))\n    )\n    return arr.length === 0 ? undefined : fromEntries(arr as any)\n  }\n}\n\nexport function compactBlankValues<T extends Obj>(\n  t: Maybe<T>\n): Maybe<ReqValued<Partial<T>>> {\n  if (t == null) return undefined\n  const pairs = entries(t).filter(([k, v]) => k != null && notBlank(v))\n  return isEmpty(pairs) ? undefined : fromEntries(pairs)\n}\n\nexport function mapFields(\n  o: Obj,\n  f: (key: string, value: any) => Maybe<[string, any]>,\n  obj = {}\n): Obj {\n  // DON'T DELETE THIS SORT! This makes model upserts have the same prepared\n  // statements:\n\n  const arr = compact(sort(keys(o)).map(k => f(k, o[k])))\n  return fromEntries(\n    arr.filter(([k, v]) => k != null && v !== undefined), // < allow NULL values!\n    obj\n  )\n}\n\nexport function pick<T, K extends keyof T>(\n  obj: T,\n  ...keyNames: K[]\n): Pick<T, K> {\n  if (obj == null) return obj\n  const result = {} as any\n  for (const key of keyNames) {\n    const v = obj[key]\n    if (v !== undefined) result[key] = obj[key]\n  }\n  return result\n}\n\nexport function pickCompact<T, K extends keyof T>(\n  obj: T,\n  ...keyNames: K[]\n): Maybe<Pick<T, K>> {\n  if (obj == null) return\n  const result = {} as any\n  for (const key of keyNames) {\n    const v = obj[key]\n    if (v !== undefined) result[key] = obj[key]\n  }\n  return result\n}\n\n/**\n * @param keynames can be \"key.child.grandchild\" format to pick deep objects.\n */\nexport function pickDeep<T, K extends keyof T>(\n  obj: T,\n  ...keyNames: (K | string)[]\n): Pick<T, K> {\n  if (obj == null) return obj\n  if (Array.isArray(obj)) return obj.map(ea => pickDeep(ea, ...keyNames)) as any\n  const flat: string[] = []\n  const mm = new MultiMap<string, string>()\n  for (const key of keyNames.map(toS)) {\n    const indexOf = key.indexOf(\".\")\n    if (indexOf === -1) {\n      flat.push(key)\n    } else {\n      mm.add(key.slice(0, indexOf) as any, key.slice(indexOf + 1))\n    }\n  }\n  const result = {} as any\n  for (const key of flat) {\n    const v = obj[key as K]\n    // allow NULL values:\n    if (v !== undefined) {\n      result[key as K] = v\n    }\n  }\n  const deepKeysByLocalField = [...mm.entries()]\n  for (const [key, arr] of deepKeysByLocalField) {\n    const v = obj[key as K]\n    if (v != null) {\n      const ea = pickDeep(v as any, ...(arr as any))\n      // allow NULL values:\n      if (ea !== undefined) {\n        result[key] = ea\n      }\n    }\n  }\n  return result\n}\n\nexport function pickNonBlank<T, K extends keyof T>(\n  obj: T,\n  ...keyNames: K[]\n): Pick<T, K> {\n  if (obj == null) return obj\n  const result = {} as any\n  for (const key of keyNames) {\n    const v = obj[key as K]\n    if (notBlank(v)) {\n      result[key as K] = v\n    }\n  }\n  return result\n}\n\n/**\n * @return the first value in `obj` associated to `keyNames` that `predicate` returns true.\n */\nexport function pickFirst<T, K extends keyof T>(\n  obj: T,\n  keyNames: K[],\n  predicate: (v: T[K]) => boolean = defined\n): Maybe<T[K]> {\n  if (obj == null) return\n  for (const key of keyNames) {\n    if (predicate(obj[key])) return obj[key]\n  }\n  return\n}\n\nexport function omit<T extends Record<string, any>, S extends keyof T>(\n  t: Maybe<T>,\n  ...keysToOmit: S[]\n): Unpick<T, S> {\n  if (t == null || keysToOmit.every(ea => blank(t[ea]))) {\n    return t as any\n  }\n  const pairs = entries(t).filter(([k]) => !keysToOmit.includes(k as any))\n  return isEmpty(pairs) ? undefined : fromEntries(pairs)\n}\n\nexport function isReqValued<T>(t: MaybeValued<T>): t is ReqValued<T> {\n  return values(t as any).every(ea => ea != null)\n}\n\nexport function allKeysDefined<T, K extends keyof T>(\n  obj: Maybe<T>,\n  ...keyNames: K[]\n): obj is Defined<T> {\n  return obj != null && keyNames.every(k => obj[k] != null)\n}\n\n/**\n * @return t if it `isReqValued()`, otherwise undefined\n */\nexport function toReqValued<T>(t: MaybeValued<T>): Maybe<ReqValued<T>> {\n  return isReqValued(t) ? t : undefined\n}\n\nexport function reqValuedOrElse<T>(t: MaybeValued<T>): Maybe<ReqValued<T>> {\n  return isReqValued(t) ? t : undefined\n}\n\nexport function mapReqValued<T, U>(\n  t: MaybeValued<T>,\n  f: (ea: ReqValued<T>) => U\n): Maybe<U> {\n  return isReqValued(t) ? f(t) : undefined\n}\n\nexport function onlyReqValued<T>(arr: MaybeValued<T>[]): ReqValued<T>[] {\n  return arr.filter(isReqValued)\n}\n\nexport function filter<T extends Obj, K extends string & keyof T>(\n  obj: T,\n  predicate: (k: K, value: T[K]) => boolean\n): Partial<T> {\n  if (obj == null) return obj\n  return fromEntries(\n    entries(obj).filter(([k, v]) => predicate(k as K, v as T[K]))\n  )\n}\n\n/**\n * As opposed to .keys() which only returns fields directly associated to the\n * given Obj, `allKeys` returns all direct *and inherited* properties (if\n * `obj` is a class instance, for example)\n */\nexport function allKeys(obj: any): string[] {\n  const methods: string[] = keys(obj)\n  while (null != (obj = Reflect.getPrototypeOf(obj))) {\n    methods.push(\n      ...(Reflect.ownKeys(obj).filter(\n        key => typeof key === \"string\"\n      ) as string[])\n    )\n  }\n  return uniq(methods)\n}\n\nexport function maybeCall(o: any, method: string, ...args: any[]) {\n  const f = o?.[method]\n  return isFunction(f) ? f.bind(o)(...args) : undefined\n}\n\nexport function firstValueCaseInsensitive(o: any, key: string): any {\n  if (blank(key)) return\n  if (o[key] != null) return o[key]\n  const lckey = key.toLowerCase().normalize()\n  for (const k of keys(o)) {\n    if (lckey === k.toLowerCase().normalize() && o[k] != null) return o[k]\n  }\n  return\n}\n\n/**\n * Recursively reduce single-value objects to only their value, and retain\n * multi-value objects.\n */\nexport function flattenObject(o: any): any {\n  if (Array.isArray(o)) return o.map(flattenObject)\n  if (typeof o !== \"object\") return o\n  const f = mapFields(o, (key, value) => [key, flattenObject(value)])\n  const v = values(f)\n  return v.length === 1 ? v[0] : f\n}\n","import { Maybe, MaybeNull } from \"./MaybeTypes\"\n\n// Scala got a Some things right.\n// HUR HUR I AM HILLLARIOUS\n\n// \"Opt\" instead of \"Option\" due to Option being an html entity already\n\nexport type MaybeOpt<T> = Opt<T> | MaybeNull<T>\n\n/**\n * @see http://www.scala-lang.org/api/current/scala/Option.html\n */\nexport interface Opt<A> {\n  /**\n   * @return true if the option is an instance of Some, false otherwise\n   */\n  isDefined: boolean\n  /**\n   * @return true if the option is None, false otherwise\n   */\n  isEmpty: boolean\n  /**\n   * @return the option's value.\n   */\n  get(): Maybe<A>\n  /**\n   * @return true if this option is nonempty and the predicate `p` returns true\n   * when applied to this Option's value.\n   */\n  exists(p: (a: A) => boolean): boolean\n  /**\n   * @return a `Some` containing the result of applying `f` to this `Option`'s value\n   * if this `Option` is nonempty.\n   */\n  map<B>(f: (a: A) => B): Opt<B>\n  /**\n   * @return the result of applying `f` to this `Option`'s value if this\n   * `Option` is nonempty. By supporting `undefined` or `B`, we make caller's\n   * lives a little easier--we'll wrap the result in an `Option` for you.\n   */\n  flatMap<B>(f: (a: A) => MaybeOpt<B>): Opt<B>\n  /**\n   * @return this `Option` if it is both nonempty\n   * and applying the predicate `p` to this `Option`'s value returns true.\n   */\n  filter(p: (a: A) => boolean): Opt<A>\n  /**\n   * Apply the given procedure `f` to the `Option`'s value\n   * if this `Option` is nonempty.\n   * @return this (for fluent or chaining calls)\n   */\n  forEach(f: (a: A) => void): Opt<A>\n  /**\n   * @return this `Option`'s value if this `Option` is nonempty,\n   * otherwise return the result of evaluating `f`.\n   */\n  getOrElse(f: () => A): A\n  /**\n   * @return this `Option`'s value if this `Option` is nonempty,\n   * otherwise return the result of evaluating `f`.\n   */\n  orElse(f: () => MaybeOpt<A>): Opt<A>\n\n  /**\n   * @param f will only be invoked if both `this` and `b` are defined\n   */\n  zip1<B, T>(b: MaybeOpt<B>, f: (_a: A, _b: B) => MaybeOpt<T>): Opt<T>\n\n  zip2<B, C, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    f: (_a: A, _b: B, _c: C) => MaybeOpt<T>\n  ): Opt<T>\n\n  zip3<B, C, D, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    d: MaybeOpt<D>,\n    f: (_a: A, _b: B, _c: C, _d: D) => MaybeOpt<T>\n  ): Opt<T>\n}\n\nnamespace NoneImpl {\n  export const isDefined = false\n  export const isEmpty = true\n  export const get = () => undefined\n  export const exists = () => false\n  const noop = () => NoneImpl\n  export const map = noop\n  export const flatMap = noop\n  export const filter = noop\n  export const forEach = noop\n  export const getOrElse = <A>(f: () => A): A => f()\n  export const orElse = <A>(f: () => MaybeOpt<A>): Opt<A> => opt(f())\n  export const zip1 = noop\n  export const zip2 = noop\n  export const zip3 = noop\n}\n\nexport const None: Opt<any> = NoneImpl\n\nexport class Some<A> implements Opt<A> {\n  readonly isDefined = true\n  readonly isEmpty = false\n\n  constructor(private readonly a: A) {}\n\n  get(): A {\n    return this.a\n  }\n\n  exists(f: (a: A) => boolean): boolean {\n    return f(this.a)\n  }\n\n  map<B>(f: (a: A) => B): Opt<B> {\n    return new Some(f(this.a))\n  }\n\n  flatMap<B>(f: (a: A) => Opt<B> | MaybeNull<B>): Opt<B> {\n    const b = f(this.a)\n    return isOpt(b) ? b : opt(b)\n  }\n\n  filter(f: (a: A) => boolean): Opt<A> {\n    return opt(f(this.a) ? this.a : undefined)\n  }\n\n  forEach(f: (a: A) => void): this {\n    f(this.a)\n    return this\n  }\n\n  getOrElse(): A {\n    return this.a\n  }\n\n  orElse(): Opt<A> {\n    return this\n  }\n\n  zip1<B, T>(b: MaybeOpt<B>, f: (_a: A, _b: B) => MaybeOpt<T>): Opt<T> {\n    return opt(b).flatMap(eb => f(this.a, eb))\n  }\n\n  zip2<B, C, T>(\n    b: Opt<B>,\n    c: Opt<C>,\n    f: (_a: A, _b: B, _c: C) => MaybeOpt<T>\n  ): Opt<T> {\n    return opt(b).flatMap(eb => opt(c).flatMap(ec => f(this.a, eb, ec)))\n  }\n\n  zip3<B, C, D, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    d: MaybeOpt<D>,\n    f: (_a: A, _b: B, _c: C, _d: D) => MaybeOpt<T>\n  ): Opt<T> {\n    return opt(b).flatMap(eb =>\n      opt(c).flatMap(ec => opt(d).flatMap(ed => f(this.a, eb, ec, ed)))\n    )\n  }\n}\n\nexport function isOpt<A>(a: MaybeOpt<A>): a is Opt<A> {\n  return a instanceof Some || a === None\n}\n\n/**\n * @see http://www.scala-lang.org/api/current/scala/Option.html\n */\nexport function opt<A>(a: MaybeOpt<A>): Opt<A> {\n  return isOpt(a) ? a : a != null ? new Some(a) : None\n}\n","import { gte, isNumber, lt, round } from \"./Number\"\nimport { StringValued } from \"./Object\"\nimport { toS } from \"./toS\"\n\nconst pads: StringValued = {}\n\nexport function padding(char: string, length: number): string {\n  if (length < 1) return \"\"\n  if (!gte(pads[char]?.length, length)) {\n    let s = pads[char] ?? char\n    while (s.length < length) {\n      s += char\n    }\n    pads[char] = s\n  }\n  return pads[char]!.substring(0, length)\n}\n\n// first added for irony, then used nonironically:\nexport function leftPad(s: any, minLength: number, padChar: string): string {\n  if (padChar.length === 0) throw new Error(\"leftPad() given empty pad\")\n  if (lt(s, 0)) {\n    return \"-\" + leftPad(String(Math.abs(s)), minLength - 1, padChar)\n  }\n  const str = toS(s)\n  return padding(padChar, minLength - str.length) + str\n}\n\n/**\n * Left-zero-pad\n */\nexport function padNumeric(i: any, minLength: number): string {\n  return leftPad(isNumber(i) ? round(i) : \"0\", minLength, \"0\")\n}\n\nexport function pad2(s: any): string {\n  return padNumeric(s, 2)\n}\n\nexport function pad3(s: any): string {\n  return padNumeric(s, 3)\n}\n\nexport function pad4(s: any): string {\n  return padNumeric(s, 4)\n}\n","import { blank } from \"./Blank\"\n\nconst irregular = new Map([\n  [\"child\", \"children\"],\n  [\"photo\", \"photos\"],\n  [\"video\", \"videos\"]\n])\nconst es = /(s|ss|sh|ch|x|z)$/\nconst consonant_y = /[^aeiou]y$/\nconst vowel_y = /[aeiou]y$/\nconst is = /is$/\n\nexport function pluralize(singular: string) {\n  if (blank(singular)) return singular\n\n  const irr = irregular.get(singular)\n  if (irr != null) return irr\n\n  // https://www.grammarly.com/blog/plural-nouns/\n  if (singular.match(es) != null) {\n    return singular + \"es\"\n  }\n  if (singular.match(consonant_y) != null) {\n    return singular.replace(/y$/i, \"ies\")\n  }\n  if (singular.match(vowel_y) != null) {\n    return singular + \"s\"\n  }\n  if (singular.endsWith(\"o\")) {\n    return singular + \"es\"\n  }\n  if (singular.match(is) != null) {\n    return singular.replace(is, \"es\")\n  }\n\n  return singular + \"s\"\n}\n","import { isEmpty } from \"./Array\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { toS } from \"./toS\"\n\nexport type Primitive = number | string | boolean\nconst primitiveTypes = [\"number\", \"string\", \"boolean\"]\n\nexport interface PrimitiveValued {\n  [key: string]: Primitive\n}\n\nexport interface Primitivable {\n  valueOf(): Primitive\n}\n\nexport interface Primitivables {\n  valueOf(): Primitive[]\n}\n\n// HEY FUTURE ME, looking for something like DeepComparable? See the `Json` type in src/fe/JSON.ts\n\nexport type Comparable = Primitive | Date | Comparable[]\n\nexport function isPrimitive(obj: any): obj is Primitive {\n  return primitiveTypes.indexOf(typeof obj) !== -1\n}\n\nexport function mapPrimitive<T>(a: any, f: (t: Primitive) => T): Maybe<T> {\n  return isPrimitive(a) ? f(a) : undefined\n}\n\nexport function mapPrimitiveOr<T>(\n  a: any,\n  f: (t: Primitive) => T,\n  defaultValue: () => T\n): Maybe<T> {\n  return isPrimitive(a) ? f(a) : defaultValue()\n}\n\nexport function isPrimitiveArray(obj: any): obj is Primitive[] {\n  return Array.isArray(obj) && (obj as any[]).every(isPrimitive)\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\nconst TypeLevel = [\n  \"boolean\",\n  \"number\",\n  \"bigint\",\n  \"symbol\",\n  \"string\",\n  \"object\",\n  \"function\"\n] // typeof array is \"object\"\n\n/**\n * (null || undefined) < false < true < numbers < strings < arrays\n * @return 1 if a > b, -1 if a < b, 0 if a == b.\n */\nexport function cmp<T extends Maybe<Comparable> | Maybe<Comparable>[]>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): number {\n  // undefined == undefined:\n  if (a == null && b == null) return 0\n\n  // undefined should be < defined. We can't use typeof here because typeof null\n  // is \"object\" and typeof undefined = \"undefined\".\n  if (a == null) return -1\n  if (b == null) return 1\n\n  const aType = typeof a\n  const bType = typeof b\n\n  if (\n    (aType === \"string\" || aType === \"symbol\") &&\n    (bType === \"string\" || bType === \"symbol\")\n  ) {\n    // in German, ä sorts before z, in Swedish, ä sorts after z\n    return toS(a).localeCompare(toS(b))\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return cmpArr(a, b)\n  }\n  if (aType !== bType) {\n    return TypeLevel.indexOf(aType) - TypeLevel.indexOf(bType)\n  } else {\n    return a > b ? 1 : a < b ? -1 : 0\n  }\n}\n\nexport function lt<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) < 0\n}\n\nexport function lte<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) <= 0\n}\n\nexport function gte<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) >= 0\n}\n\nexport function gt<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) > 0\n}\n\n/**\n * @return 1 if a > b, -1 if a < b, 0 if a == b.\n */\nexport function cmpArr<T extends Comparable | Comparable[]>(\n  a: T[],\n  b: T[],\n  shorterArrayIsLessThan = true\n): number {\n  if (isEmpty(a) && isEmpty(b)) return 0\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    const c = cmp(a[i], b[i])\n    if (c !== 0) {\n      return c\n    }\n  }\n  return cmp(a.length, b.length) * (shorterArrayIsLessThan ? 1 : -1)\n}\n","import { Defined } from \"./Maybe\"\nimport { Maybe } from \"./MaybeTypes\"\nimport {\n  MaybeNullSyncOrAsync,\n  MaybeSyncOrAsync,\n  SyncOrAsync\n} from \"./SyncOrAsync\"\nimport { toA } from \"./toA\"\n\n// Looking for UnwrapPromiseLike? See fe/UnwrapPromiseLike.ts\n\n/**\n * Safe calls for Optional promises:\n */\nexport async function thenMap<T1, T2>(\n  objP: MaybeNullSyncOrAsync<T1>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>\n): Promise<Maybe<T2>> {\n  const obj = await objP\n  return obj == null ? undefined : f(obj)\n}\n\n/**\n * Serialized promise gathering and compaction\n * @see ../core/async/Promise#tuples\n */\nexport async function thenCollect<T1, T2>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T1>[]>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>\n): Promise<Defined<T2>[]> {\n  const result: Defined<T2>[] = []\n  for (const eaP of toA(await arr)) {\n    if (eaP != null) {\n      const ea = await eaP\n      if (ea != null) {\n        const r = await f(ea)\n        if (r != null) result.push(r as any)\n      }\n    }\n  }\n  return result\n}\n\nexport async function thenTap<T>(\n  p: SyncOrAsync<T>,\n  f: (t: T) => any = console.dir.bind(console)\n): Promise<T> {\n  const result = await p\n  // We await f so if it raises errors, thenTap will propagate the error:\n  await f(result)\n  return result\n}\n\nexport function isPromiseLike(o: any): o is PromiseLike<any> {\n  return o != null && typeof o === \"object\" && typeof o[\"then\"] === \"function\"\n}\n\nexport function isPromise(o: any): o is Promise<any> {\n  return (\n    isPromiseLike(o) &&\n    typeof (o as any)[\"catch\"] === \"function\" &&\n    typeof (o as any)[\"finally\"] === \"function\"\n  )\n}\n\n/**\n * Only run `ifTrue` if `predicate` is true after `p` finishes.\n */\nexport async function thenIf<T, U>({\n  p,\n  predicate,\n  ifTrue\n}: {\n  p: Promise<T>\n  predicate: (t: T) => boolean\n  ifTrue: (t: T) => SyncOrAsync<U>\n}): Promise<Maybe<U>> {\n  const t = await p\n  return predicate(t) ? ifTrue(t) : undefined\n}\n","import { strEnum, StrEnumKeys } from \"./StrEnum\"\n\n/**\n * \"settled\" means either resolved or rejected.\n *\n * \"fulfilled\" is an alias for \"resolved.\" We use \"resolved\" as that matches\n * the Promise API terminology.\n *\n * @see\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n */\nexport const PromiseStates = strEnum(\"pending\", \"resolved\", \"rejected\")\nexport type PromiseState = StrEnumKeys<typeof PromiseStates>\n","import { isEmpty, sum } from \"./Array\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { gt0 } from \"./Number\"\n\nfunction rndInt(min: number, max: number): number {\n  // CAUTION: using Math.round() will give you a non-uniform distribution!\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\n  return Math.floor(Math.random() * (max - min)) + min\n}\n\n/**\n * @param min (inclusive)\n * @param max (exclusive)\n * @return a random integer between min (included) and max (excluded),\n * excluding the values in `excluded`.\n */\nexport function randomInt(\n  min: number,\n  max: number,\n  excluded?: number[]\n): number {\n  return randomInts(min, max, 1, excluded)[0]\n}\n\n/**\n * @param min (inclusive)\n * @param max (exclusive)\n * @return a set of `size` random integers between min (included) and max\n * (excluded), excluding the values in `excluded`.\n */\nexport function randomInts(\n  min: number,\n  max: number,\n  size: number,\n  excluded?: number[]\n): number[] {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n\n  if (max < min) {\n    throw new Error(`randomInts(): invalid range: ${min} > ${max}`)\n  }\n  const range = max - min\n  const excludeSet = new Set(excluded ?? [])\n\n  if (max === min && range === 0 && excludeSet.size === 0 && size === 1) {\n    return [min]\n  }\n\n  const slotsRemaining = range - excludeSet.size\n\n  if (size > slotsRemaining) {\n    throw new Error(\n      `randomInts(): cannot satisfy request: ${JSON.stringify({\n        max,\n        min,\n        range,\n        size,\n        slotsRemaining\n      })}`\n    )\n  }\n  // const luckThreshold = 0.6 // found with minSearch()\n  // if ((slotsRemaining - size) / range < luckThreshold) {\n\n  // HEY FUTURE ME: turns out that either implementation is fine, even for\n  // large ranges and large excluded sets, but the retained implementation\n  // uses less memory allocation, so it wins.\n\n  // const result = []\n  // const eligible = []\n  // for (let i = min; i < max; i++) {\n  //   if (!excludeSet.has(i)) {\n  //     eligible.push(i)\n  //   }\n  // }\n  // for (let i = 0; i < size; i++) {\n  //   const idx = rndInt(0, eligible.length)\n  //   result.push(eligible.splice(idx, 1)[0])\n  // }\n  // return result\n  // } else {\n  const result = new Set<number>()\n  while (result.size < size) {\n    const candidate = rndInt(min, max)\n    if (!excludeSet.has(candidate)) {\n      result.add(candidate)\n    }\n  }\n  return [...result]\n  // }\n}\n\nexport function randomBoolean(trueRatio = 0.5): boolean {\n  return Math.random() <= trueRatio\n}\n\n/**\n * @return a random float between `min` and `max`\n */\nexport function randomFloat(min: number, max: number) {\n  return Math.random() * (max - min) + min\n}\n\nexport const NumericChars = \"0123456789\"\nexport const LowercaseChars = \"abcdefghijkmnopqrstuvwxyz\"\n// No upper case to support case-insensitive filesystems. Exported for tests.\n// We could have used GeoRadix.numerals, but that's a possible circular dep.\nexport const RandomChars = NumericChars + LowercaseChars\n\n/**\n * @return a random string matching /[a-z0-9]{count}/\n */\nexport function randomChars(\n  count: number,\n  chars: string = RandomChars\n): string {\n  let result = \"\"\n  for (let i = 0; i < count; i++) {\n    result += randomChar(chars)\n  }\n  return result\n}\n\nexport function randomChar(chars: string = RandomChars): string {\n  return chars[randomInt(0, chars.length)]\n}\n\nexport function pickRandom<T>(arr: T[]): Maybe<T> {\n  return arr[randomInt(0, arr.length)]\n}\n\n/**\n * Fisher-yates shuffle on shallow clone of `arr`\n */\nexport function shuffle<T>(arr: T[]): T[] {\n  const r = [...arr]\n  for (let i = r.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1))\n    if (i !== j) [r[i], r[j]] = [r[j], r[i]]\n  }\n  return r\n}\n\nexport function sample<T>(arr: T[], size: number): T[] {\n  const result: T[] = []\n  for (const idx of randomInts(0, arr.length, size)) {\n    result.push(arr[idx])\n  }\n  return result\n}\n\nexport function pickWeightedRandom<T extends { priority?: number }>(\n  arr: T[]\n): Maybe<T> {\n  if (isEmpty(arr)) return\n  const nonZeroes = arr.filter(ea => gt0(ea.priority))\n  const totalPriority = sum(nonZeroes, ea => ea.priority!)\n  let rand = randomFloat(0, totalPriority)\n  return nonZeroes.find(ea => {\n    rand -= ea.priority!\n    return rand <= 0\n  })\n}\n","import { strEnum, StrEnumKeys } from \"./StrEnum\"\n\nexport const ServiceNames = strEnum(\n  \"main\",\n  \"desktop\",\n  \"web\",\n  \"sync\",\n  \"info\",\n  \"test\",\n  \"logcat\",\n  \"logtail\",\n  \"list\",\n  \"billing\",\n  \"worker\",\n  \"test-worker\"\n)\n\nexport type ServiceName = StrEnumKeys<typeof ServiceNames>\n","export function splitFirst(\n  s: string,\n  pattern: string\n): [string, string] | [string] {\n  const indexOf = s.indexOf(pattern)\n  return indexOf === -1\n    ? [s]\n    : [s.slice(0, indexOf), s.slice(indexOf + pattern.length)]\n}\n","import { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { fromEntries } from \"./Object\"\nimport { ThunkOrT, tot } from \"./Thunk\"\n\n// See https://basarat.gitbooks.io/typescript/content/docs/types/literal-types.html\n\nexport type StrEnumType<T extends string> = {\n  [K in T]: K\n}\n\nexport type StrEnumHelpers<T extends string> = {\n  values: T[]\n  length: number\n  /** synonym for includes */\n  has(s: MaybeNull<string>): s is T\n  includes(s: MaybeNull<string>): s is T\n  getCI(s: MaybeNull<string>): Maybe<T>\n  omit<O extends T>(...t: O[]): Exclude<T, O>[]\n  indexOf(s: MaybeNull<string>): Maybe<number>\n  ordinal(s: MaybeNull<string>): number\n  validOrElse<R>(s: MaybeNull<string>, defaultValue: ThunkOrT<R>): T | R\n  mapValid<R>(s: MaybeNull<string>, f: (t: T) => R): Maybe<R>\n  cmp(a: MaybeNull<string>, b: MaybeNull<string>): Maybe<number>\n}\n\nexport type StrEnum<T extends string> = StrEnumType<T> & StrEnumHelpers<T>\n\nexport type StrEnumKeys<Type> = Type extends StrEnum<infer X> ? X : never\n\nexport function strEnum<T extends string>(...o: T[]): StrEnum<T> {\n  const values = Object.freeze(o) as T[]\n  const valueToIndex = fromEntries(values.map((ea, idx) => [ea, idx]))\n\n  const dict: StrEnumType<T> = {} as any\n  for (const ea of values) {\n    dict[ea] = ea\n  }\n\n  // toLowerCase() is safe because we know all strEnum values are latin ASCII:\n  const getCI = (s: MaybeNull<string>) => {\n    if (s == null) return // < remember that some strEnum values are \"\"\n    s = s.toLowerCase()\n    return values.find(ea => ea.toLowerCase() === s)\n  }\n\n  const indexOf = (s: MaybeNull<string>) =>\n    s != null ? valueToIndex[s] : undefined\n\n  const ordinal = (s: MaybeNull<string>) => indexOf(s) ?? values.length\n\n  const includes = (s: MaybeNull<string>): s is T => indexOf(s) != null\n\n  const omit = (...t: T[]) => values.filter(ea => !t.includes(ea)) as any\n\n  const validOrElse = <R>(s: MaybeNull<string>, defaultValue: ThunkOrT<R>) =>\n    includes(s) ? s : tot(defaultValue)\n\n  const mapValid = <R>(s: MaybeNull<string>, f: (t: T) => R) =>\n    includes(s) ? f(s as T) : undefined\n\n  const cmp = (a: MaybeNull<string>, b: MaybeNull<string>) => {\n    const a_ = indexOf(a)\n    const b_ = indexOf(b)\n    return a_ == null || b_ == null ? undefined : a_ > b_ ? 1 : a_ < b_ ? -1 : 0\n  }\n\n  return {\n    ...dict,\n    values,\n    length: values.length,\n    has: includes, // alias for includes\n    includes,\n    getCI,\n    omit,\n    indexOf,\n    ordinal,\n    validOrElse,\n    mapValid,\n    cmp\n  }\n}\n\n/* \n\nExample usage:\n\nexport const Directions = strEnum(\"North\", \"South\", \"East\", \"West\")\nexport type Direction = StrEnumKeys<typeof Directions>\n\n*/\n","import { at } from \"./At\"\nimport { flatten } from \"./Flatten\"\nimport { countIterable, sliceIterable } from \"./Iterable\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { clamp, round } from \"./Number\"\nimport { Segmenter } from \"./Segmenter\"\nimport { toA } from \"./toA\"\nimport { toS } from \"./toS\"\n\nexport function isString(obj: any): obj is string {\n  return typeof obj === \"string\"\n}\n\n// safe for frontend (which doesn't have a Buffer)\nexport function isBuffer(obj: any): obj is Buffer {\n  return obj?.constructor?.name === \"Buffer\"\n}\n\n/**\n * @return true iff `s` only uses characters in the basic multilingual plane\n * @see https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane\n */\nexport function isBMP(s: string): boolean {\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s.charCodeAt(i) !== s.codePointAt(i)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function charAt(s: string, i: number): Maybe<string> {\n  if (isBMP(s)) {\n    i = Math.trunc(i) || 0\n    if (i < 0) i += s.length\n    if (i < 0 || i >= s.length) return undefined\n    return s[i]\n  } else {\n    return at([...toS(s)], i)\n  }\n}\n\nexport function strlen(s: string) {\n  const g = graphemeSegmenter()\n  if (g != null) return countIterable(g.segment(s))\n\n  // Crap, we have to do it the hard (buggy) way\n  if (isBMP(s)) return s.length\n  return [...s].length\n}\n\n// can't use lazy here--circular dependency.\nlet _graphemeSegmenter: Segmenter | null | undefined\n\nfunction graphemeSegmenter(): Segmenter | null {\n  // only try once:\n  if (_graphemeSegmenter === undefined) {\n    try {\n      _graphemeSegmenter = new (Intl as any).Segmenter(undefined, {\n        granularity: \"grapheme\"\n      })\n    } catch {\n      // dang, no grapheme support in this environment\n      _graphemeSegmenter = null\n    }\n  }\n  return _graphemeSegmenter ?? null // < SITS, TS should have figured it out\n}\n\n/**\n * Returns a substring of the given string. Emoji and astral symbol friendly.\n *\n * @param from The starting position of the desired substring. The index of the\n * first character in the string is zero.\n * @param end The end index of the specified portion of the string. This is\n * exclusive of the element at the index 'end'. Negative values count from the\n * end index (like Array#slice). If end is undefined, then the returned value\n * extends to the end of the string.\n * @see https://mathiasbynens.be/notes/javascript-unicode\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length\n * @see https://blog.jonnew.com/posts/poo-dot-length-equals-two\n */\nexport function strslice(s: string, from: number, end?: number) {\n  if (isBMP(s)) {\n    // allow negative indexing from the end\n    if (from < 0) from += s.length\n    return s.slice(from, end)\n  } else {\n    const g = graphemeSegmenter()\n    if (g != null) {\n      const arr = sliceIterable(g.segment(s), from, end)\n      return arr.map((ea: any) => ea.segment).join(\"\")\n    }\n    // Sadness, no grapheme support. This doesn't work for compound emoji!\n    return [...toS(s)].slice(from, end).join(\"\")\n  }\n}\n\n/**\n * Gets a substring beginning at the specified location and having the specified length.\n * @param from The starting position of the desired substring. The index of the first character in the string is zero.\n * @param length The number of characters to include in the returned substring.\n */\nexport function substr(str: string, from: number, length?: number): string {\n  return isBMP(str)\n    ? str.slice(from, length == null ? undefined : from + length)\n    : strslice(str, from, length == null ? undefined : from + length)\n}\n\nexport function charArr(s: string): string[] {\n  const g = graphemeSegmenter()\n  return g == null\n    ? // unicode-friendly way of splitting a string into chars (ish):\n      [...toS(s)]\n    : [...g.segment(s)].map((ea: any) => ea.segment)\n}\n\nexport function trimRight(s: string): string {\n  return toS(s).replace(/\\s+$/, \"\")\n}\n\nexport function stripPrefix(s: string, prefix: string): string {\n  const str = toS(s)\n  const pfx = toS(prefix)\n  return pfx.length > 0 && str.startsWith(pfx) ? str.slice(pfx.length) : str\n}\n\nexport function stripPrefixes(s: string, prefixes: string[]): string {\n  if (s == null) return \"\"\n  const str = toS(s)\n  for (const pfx of prefixes) {\n    if (pfx != null && pfx.length > 0 && str.startsWith(pfx))\n      return stripPrefixes(str.slice(pfx.length), prefixes)\n  }\n  return str\n}\n\nexport function stripSuffix(s: string, suffix: string): string {\n  if (suffix == null) return s\n  const str = toS(s)\n  const sfx = toS(suffix)\n  return sfx.length > 0 && str.endsWith(sfx) ? str.slice(0, -sfx.length) : str\n}\n\nexport function stripPrefixSuffix(\n  s: string,\n  { prefix, suffix }: { prefix: string; suffix: string }\n): string {\n  return stripSuffix(stripPrefix(s, prefix), suffix)\n}\n\nexport function ensurePrefix(s: string, prefix: string): string {\n  if (prefix == null || prefix === \"\") return s\n  s = toS(s)\n  prefix = toS(prefix)\n  return s.startsWith(prefix) ? s : prefix + s\n}\n\nexport function ensureSuffix(s: string, suffix: string): string {\n  if (suffix == null || suffix === \"\") return s\n  s = toS(s)\n  suffix = toS(suffix)\n  return s.endsWith(suffix) ? s : s + suffix\n}\n\nexport function ensurePrefixSuffix(\n  s: string,\n  { prefix, suffix }: { prefix: string; suffix: string }\n): string {\n  return ensureSuffix(ensurePrefix(s, prefix), suffix)\n}\n\nexport function ellipsize(a: any, maxLen = 80, trailingChars = 0): string {\n  if (a == null) {\n    return \"\"\n  }\n  maxLen = Math.max(1, round(maxLen))\n  trailingChars = clamp(0, maxLen - 1, round(trailingChars))\n  const arr = charArr(a)\n  // ensure valid trailingChars\n  return arr.length <= maxLen\n    ? arr.join(\"\")\n    : arr.slice(0, maxLen - 1 - trailingChars).join(\"\") +\n        \"…\" +\n        (trailingChars > 0 ? arr.slice(-trailingChars).join(\"\") : \"\")\n}\n\nexport function newlineRe() {\n  return /\\r?\\n/gm // this can't be a const as it has state\n}\n\nexport function trimLastNewline(s: string): string {\n  return toS(s).replace(/\\r?\\n$/, \"\")\n}\n\n/**\n * Returns the nearest occurrence of a substring to the left of a given position in the string.\n * @param haystack The string to search against.\n * @param needle The substring to search for.\n * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.\n */\nexport function leftIndexOf(\n  haystack: string,\n  needle: string,\n  position?: number\n) {\n  if (position == null) position = haystack.length\n  for (let i = position; i >= 0; i--) {\n    if (strslice(haystack, i).startsWith(needle)) return i\n  }\n  return -1\n}\n\nexport function wrap(\n  s: string | string[],\n  opts?: { maxLineLen?: number; prefix?: string }\n): string[] {\n  const maxLineLen = opts?.maxLineLen ?? 80\n  const prefix = opts?.prefix ?? \"\"\n\n  if (Array.isArray(s) || s.includes(\"\\n\")) {\n    const lines = flatten(toA(s).map(ea => toS(ea).split(newlineRe())))\n    return flatten(lines.map(ea => wrap(ea, opts)))\n  }\n  s = ensurePrefix(toS(s), prefix).trim()\n  if (s.length <= maxLineLen) {\n    return [s]\n  }\n  const leftSliceAt = leftIndexOf(s, \" \", maxLineLen)\n\n  if (leftSliceAt > prefix.length) {\n    return [\n      strslice(s, 0, leftSliceAt),\n      ...wrap(strslice(s, leftSliceAt + 1), opts)\n    ]\n  } else {\n    const rightSliceAt = s.indexOf(\" \", prefix.length + 1)\n    if (rightSliceAt > 0 && rightSliceAt < s.length - 1) {\n      return [\n        strslice(s, 0, rightSliceAt),\n        ...wrap(strslice(s, rightSliceAt + 1), opts)\n      ]\n    } else {\n      return [s]\n    }\n  }\n}\n\nexport function eqlStrings(a: string, b: string): boolean {\n  return a == null || b == null\n    ? false\n    : a === b || a.normalize() === b.normalize()\n}\n\nexport function replaceAll(\n  s: string,\n  searchValue: string | RegExp,\n  replaceValue: string\n): string {\n  if (searchValue === \"\") return s\n  return s.split(searchValue).join(replaceValue)\n}\n\nexport function compressWhitespace(...s: string[]): string {\n  return s.join(\" \").replace(/\\s+/g, \" \").trim()\n}\n\n/**\n * @return s.split(sep).at(-1)\n */\nexport function splitLast(s: string, sep: string): string {\n  s = toS(s)\n  const idx = s.lastIndexOf(sep)\n  return idx === -1 ? s : s.slice(idx + sep.length)\n}\n","import { fmtHMS } from \"./Date\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { maybeCall } from \"./Object\"\nimport { SyncOrAsync } from \"./SyncOrAsync\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { TimeoutError } from \"./TimeoutError\"\n\nexport const Timeout = Symbol(\"timeout\")\n\nexport function toNotTimeout<T>(p: T | typeof Timeout): Maybe<T> {\n  return p === Timeout ? undefined : p\n}\n\nexport async function thenOrTimeout<T>(\n  p: SyncOrAsync<T>,\n  timeoutMs: number,\n  unref = true\n): Promise<T | typeof Timeout> {\n  timeoutMs = Math.round(timeoutMs ?? 0)\n  return timeoutMs <= 0\n    ? p\n    : new Promise<T | typeof Timeout>(async (resolve, reject) => {\n        let pending = true\n        const t = setTimeout(() => {\n          if (pending) {\n            pending = false\n            resolve(Timeout)\n          }\n        }, timeoutMs)\n        try {\n          if (unref) maybeCall(t, \"unref\") // timeouts don't have an unref method on fe.\n          const result = await p\n          if (pending) {\n            pending = false\n            resolve(result)\n          }\n        } catch (err) {\n          if (pending) {\n            pending = false\n            reject(err)\n          }\n        } finally {\n          clearTimeout(t)\n        }\n      })\n}\n\nexport async function thenOrTimeoutAt<T>(\n  p: SyncOrAsync<T>,\n  timeoutAtTs: number,\n  unref = true\n): Promise<T | typeof Timeout> {\n  const timeoutMs = timeoutAtTs - Date.now()\n  return timeoutMs <= 0 ? Timeout : thenOrTimeout(p, timeoutMs, unref)\n}\n\nexport async function thenOrOnTimeout<T, U>(\n  p: SyncOrAsync<T>,\n  timeoutMs: number,\n  onTimeout: () => SyncOrAsync<U>\n): Promise<T | U> {\n  return new Promise<T | U>(async (resolve, reject) => {\n    let pending = true\n    try {\n      const t = setTimeout(async () => {\n        if (pending) {\n          pending = false\n          try {\n            resolve(await onTimeout())\n          } catch (err) {\n            reject(err)\n          }\n        }\n      }, timeoutMs)\n      maybeCall(t, \"unref\") // timeouts don't have an unref method on fe.\n      const result = await p\n      if (pending) {\n        pending = false\n        clearTimeout(t)\n        resolve(result)\n      }\n    } catch (err) {\n      if (pending) {\n        pending = false\n        reject(err)\n      }\n    }\n  })\n}\n\n/**\n * @param timeoutMs disable timeouts if <= 0\n */\nexport async function thenOrTimeoutError<T>(\n  p: SyncOrAsync<T>,\n  timeoutMs: number,\n  unref = true\n): Promise<T> {\n  const result = await thenOrTimeout(p, timeoutMs, unref)\n  if (result === Timeout) {\n    throw new TimeoutError(\"timeout (\" + fmtHMS(timeoutMs) + \")\")\n  } else {\n    return result as T\n  }\n}\n\nexport async function thenOrTimeoutAtError<T>(\n  p: SyncOrAsync<T>,\n  timeoutAtTs: number,\n  unref = true\n): Promise<T> {\n  const timeoutMs = timeoutAtTs - Date.now()\n  if (timeoutMs <= 0) {\n    throw new TimeoutError(\"timeout (\" + fmtHMS(timeoutMs) + \")\")\n  }\n  return thenOrTimeoutError(p, timeoutMs, unref)\n}\n\nexport async function thenOrTimeoutAs<T>({\n  f,\n  timeoutMs,\n  as,\n  unref = true\n}: {\n  f: SyncOrAsync<T>\n  timeoutMs: number\n  as: ThunkOrT<T>\n  unref?: boolean\n}): Promise<T> {\n  const result = await thenOrTimeout(f, timeoutMs, unref)\n  return result === Timeout ? tot(as) : result\n}\n","import { isFunction } from \"./isFunction\"\n\nexport interface Thunk<T> {\n  (): T\n}\n\nexport interface ThunkOrLater<T> {\n  (): T | Promise<T>\n}\n\nexport type ThunkOrT<T> = T | Thunk<T>\n\n/**\n * Convert a ThunkOrT into a T.\n *\n * Caution: Don't have T be a function type!\n */\nexport function tot<T>(t: ThunkOrT<T>): T {\n  return isFunction(t) ? t() : t\n}\n\n/**\n * Thunk Or Later\n */\nexport async function tol<T>(t: T | ThunkOrLater<T>): Promise<T> {\n  return isFunction(t) ? t() : t\n}\n\nexport interface ThunkMaybe<T> {\n  (): T | undefined\n}\n\nexport function firstDefinedThunk<T>(\n  iter: Iterable<ThunkMaybe<T>>\n): T | undefined {\n  for (const f of iter) {\n    const result = f()\n    if (result != null) return result\n  }\n  return\n}\n\nexport function firstDefinedSuccess<T>(\n  iter: Iterable<ThunkMaybe<T>>\n): T | undefined {\n  for (const f of iter) {\n    try {\n      const result = f()\n      if (result != null) return result\n    } catch {\n      //\n    }\n  }\n  return\n}\n\nexport const NoOp = () => undefined\n","export class TimeoutError extends Error {}\n","import { blank, mapNotBlank } from \"./Blank\"\nimport { lazy } from \"./Lazy\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { isNumber, round, sigFigs, toInt } from \"./Number\"\nimport { pluralize } from \"./Pluralize\"\nimport { StrEnumKeys, strEnum } from \"./StrEnum\"\nimport { replaceAll } from \"./String\"\n\n// these instances are expensive to create, and can be reused for a given\n// locale.\nconst numberFormat = lazy(() => new Intl.NumberFormat())\n\nexport const thousandsSep = lazy(() =>\n  replaceAll(numberFormat().format(1111), \"1\", \"\").charAt(0)\n)\n\nexport const decimalSep = lazy(() =>\n  replaceAll(numberFormat().format(1.1), \"1\", \"\").charAt(0)\n)\n\nexport function bytesToMB(...bytes: Maybe<number>[]) {\n  let sum = 0\n  for (const ea of bytes) {\n    if (isNumber(ea)) sum += ea / MB\n  }\n  return round(sum)\n}\n\nexport function fmt(i: number): string {\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat\n  return numberFormat().format(i)\n}\n\n/**\n * Like `Number.toInt`, but accepts `fmt`ed strings by stripping thousands\n * separators before parsing.\n */\nexport function fmtToInt(s: Maybe<string>): Maybe<number> {\n  return mapNotBlank(s, ea => toInt(replaceAll(ea, thousandsSep(), \"\")))\n}\n\n// See https://en.wikipedia.org/wiki/Mebibyte\nexport const KB = 1000\nexport const MB = KB * 1000\nexport const GB = MB * 1000\nexport const TB = GB * 1000\n\nexport const KiB = 1024\nexport const MiB = KiB * 1024\nexport const GiB = MiB * 1024\nexport const TiB = GiB * 1024\n\nconst byteUnits = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"]\nconst mebiUnits = [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"]\n\nexport function fmtMB(megabytes: number, sigfigs = 3): string {\n  return fmtBytes(megabytes * MB, sigfigs)\n}\n\nexport function fmtBytes(bytes: number, sigfigs = 3): string {\n  if (bytes === 0) return \"0\"\n  if (!isNumber(bytes)) return \"-\"\n  const l = Math.floor(Math.log10(bytes))\n  const mag = Math.floor(l / 3)\n  const val = Math.pow(10, mag * 3)\n  const name = byteUnits[mag]\n  return sigFigs(bytes / val, sigfigs) + \" \" + name\n}\n\nexport function fmtMebi(bytes: number, sigfigs = 3): string {\n  if (bytes === 0) return \"0\"\n  const l = Math.floor(Math.log2(bytes))\n  const mag = Math.floor(l / 10)\n  const val = Math.pow(2, mag * 10)\n  const name = mebiUnits[mag]\n  return sigFigs(bytes / val, sigfigs) + \" \" + name\n}\n\nexport const MP = 1e6\n\nexport function megapixels(pixels: number): number {\n  return sigFigs(pixels / MP, 2)\n}\n\nexport const SizeDescriptions = strEnum(\n  \"tiny\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"original\"\n)\nexport type SizeDescription = StrEnumKeys<typeof SizeDescriptions>\n\nexport function pixels2size(pixels: number): SizeDescription {\n  return pixels < 320 * 240 // qvga\n    ? \"tiny\"\n    : pixels < 720 * 480 // wvga\n    ? \"small\"\n    : pixels < 1920 * 1080 // fhd\n    ? \"medium\"\n    : \"large\"\n}\n\nexport function plur(\n  i: Maybe<number>,\n  singular: Maybe<string>,\n  plural?: string\n) {\n  if (i == null) return \"\"\n  if (blank(singular)) return fmt(i)\n  return (\n    fmt(i) + \" \" + (i === 1 ? singular : (plural ?? pluralize(singular)).trim())\n  )\n}\n\nexport interface Metric {\n  count: string\n  desc: string\n}\n\nexport function plurMetric(i: number, singular: string, plural?: string) {\n  plural ??= pluralize(singular)\n  return { count: fmt(i), desc: i === 1 ? singular : plural }\n}\n","import { maybeCall } from \"./Object\"\n\nexport function setUnrefTimeout(callback: (args: void) => void, ms?: number) {\n  const t = setTimeout(callback, ms)\n  return maybeCall(t, \"unref\") ?? t\n}\n","export function isError(obj: any): obj is Error {\n  return obj != null && obj instanceof Error\n}\n","// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(obj: any): obj is Function {\n  return typeof obj === \"function\"\n}\n","import { isIterable } from \"./Iterable\"\nimport { isString } from \"./String\"\n\nexport type Arrayish<T> = ArrayLike<T> | Iterable<T> | Set<T>\n\nexport type OneOrMore<T> = T | Arrayish<T>\n\nexport function toA<T>(arr: undefined | null | Arrayish<T> | T): T[] {\n  return Array.isArray(arr) // < strings are not arrays\n    ? (arr as T[])\n    : arr == null\n    ? []\n    : isString(arr) // < don't rely on isIterable rejecting Strings\n    ? [arr as T]\n    : isIterable(arr)\n    ? Array.from(arr)\n    : [arr as T]\n}\n","import { compact } from \"./Array\"\nimport { isError } from \"./isError\"\nimport { toA } from \"./toA\"\nimport { toS } from \"./toS\"\n\nexport function toErr(obj: any): Error | undefined {\n  return obj == null ? undefined : isError(obj) ? obj : new Error(toS(obj))\n}\n\nexport function toErrs(...objs: any[]): Error[] {\n  return compact(toA(objs).map(toErr))\n}\n","import { stringify } from \"./JSON\"\n\n/**\n * Similar to `String(a)`, but `undefined` and `null` render as \"\", arrays are\n * comma-separated with no square bracket prefix/suffix\n */\nexport function toS(a?: any | any[]): string {\n  return toStr(a, \",\")\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst DefaultToString = {}.toString\n\n// types: \"undefined\" \"object\" \"boolean\" \"number\" \"bigint\" \"string\" \"symbol\" \"function\" \"object\"\nexport function toStr(a: any | any[], joinChar = \",\"): string {\n  if (a == null) {\n    return \"\"\n  } else {\n    switch (typeof a) {\n      case \"string\":\n        return a\n      case \"boolean\":\n      case \"number\":\n      case \"bigint\":\n      case \"symbol\":\n        return String(a)\n      default: // \"function\" or \"object\"\n        if (Array.isArray(a)) {\n          return a.map(ea => toStr(ea, joinChar)).join(joinChar)\n        } else if (a.toString !== DefaultToString) {\n          return a.toString()\n        } else {\n          return stringify(a)\n        }\n    }\n  }\n}\n","import { Command, program } from \"commander\"\nimport _fs from \"fs\"\nimport _path from \"path\"\nimport { argv } from \"process\"\nimport { version } from \"../core/Version\"\nimport { CliDesc, addFooter } from \"../core/cli/CliConstants\"\nimport { verifyUidGid } from \"../core/cli/VerifyUidGid\"\n\nprogram.version(version)\n\nprogram.description(\n  `Welcome to PhotoStructure, your new home for all your photos and videos.\\nSee https://photostructure.com/server/tools/ for details about these tools.`\n)\n\nfunction prefix(cmd: string) {\n  for (const dir of [\"bin\", __dirname]) {\n    const path = _path.join(dir, cmd)\n    if (_fs.existsSync(path)) return path\n  }\n  console.error(\"failed to find command \" + cmd)\n  return cmd\n}\n\nverifyUidGid()\n\naddFooter(program as Command)\n  .command(\"main\", CliDesc.main + \" (default)\", {\n    isDefault: true,\n    executableFile: prefix(\"main.js\")\n  })\n  .command(\"info\", CliDesc.info, {\n    executableFile: prefix(\"info.js\")\n  })\n  .command(\"list\", CliDesc.list, {\n    executableFile: prefix(\"list.js\")\n  })\n  .command(\"logcat\", CliDesc.logcat, {\n    executableFile: prefix(\"logcat.js\")\n  })\n  .command(\"logtail\", CliDesc.logtail, {\n    executableFile: prefix(\"logtail.js\")\n  })\n  .command(\"web\", CliDesc.web, {\n    executableFile: prefix(\"web.js\")\n  })\n  .command(\"sync\", CliDesc.sync, {\n    executableFile: prefix(\"sync.js\")\n  })\n  .parse(argv)\n","module.exports = require(\"@iarna/toml\");","module.exports = require(\"batch-cluster\");","module.exports = require(\"commander\");","module.exports = require(\"events\");","module.exports = require(\"fs-extra\");","module.exports = require(\"he\");","module.exports = require(\"luxon\");","module.exports = require(\"process\");","module.exports = require(\"type-detect\");","module.exports = require(\"util\");","module.exports = require(\"utimes\");","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"fs\");","module.exports = require(\"fs/promises\");","module.exports = require(\"node:os\");","module.exports = require(\"node:process\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"stream\");","module.exports = require(\"stream/promises\");","module.exports = require(\"timers\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(87978);\n"],"names":["SimpleAppName","SimpleShortAppName","SimpleAppNameLC","toLowerCase","AppName","lazy","isProd","nodeEnv","AppNameVersion","version","allDefined","arr","defined","every","intersection","a","b","valueOf","primitiveValueOfOrElse","s","Set","map","filter","ea","has","_uniqCount","sortedArr","length","t","lastElem","lastIndexOf","count","slice","zip","arrarr","len","Math","max","times","i","leastIndex","leastIndexBy","greatestIndex","greatestIndexBy","estIndex","lt","gt","leastBy","isEmpty","undefined","cmp","estIndexCtx","index","value","result","v","batches","batchsize","stepRange","round","async","everyAsync","f","Promise","all","diff","remove","minuend","subtrahend","some","eb","eql","objects","notBlank","toA","r","err","thunks","isNotEmpty","predicate","fromIndex","arrs","Array","isArray","elem","push","element","moved","sortBy","stringifySorted","x","y","idx","findIndex","splice","stringify","copyArrayTo","uniqBy","accept","reject","indexOf","sort","compact","Map","reduce","prev","curr","concat","min","n","Error","arr_length","results","j","ctx","batchSize","batchArr","lastPass","tap","prior","find","ea2","ea3","outer","resultArr","pred","maxDelta","before","after","mm","set","mapOr","get","entries","minLength","pad","unshift","BatchClusterObserver","EndableWrapper","constructor","name","rank","EndableRanks","service","super","this","end","commandTimeoutMs","ShortCommandTimeoutMs","bce","on","bp","pid","logger","info","renice","catch","onError","addPid","ppid","cmd","maxAgeMs","options","maxProcAgeMillis","minuteMs","Date","TimeoutError","error","lastStartError","task","errorToS","match","onTimeout","lastTaskError","command","FatalErrorFlag","lastInternalError","stdout","stderr","proc","streamFlushMillis","secondMs","warn","new","stout","toS","child_pid","cp","gt0","Pids","instance","onKill","reason","ended","ending","isIgnorableError","maxProcs","loggerName","maxIdleMsPerProcess","isWin","maxTasksPerProcess","Settings","valueOrDefault","spawnTimeoutMillis","minDelayBetweenSpawnMillis","minDelayBetweenSpawnMs","streamFlushMs","cleanupChildProcs","mkLogger","BoundedList","maxLength","_length","_firstIndex","store","mapIndex","trunc","at","last","l","clamp","clear","Symbol","iterator","self","iter","items","item","pop","reverse","shift","shiftOrFirst","callbackfn","forEach","initialValue","acc","floor","from","to","swap","start","ByteOrderMarks","bom","encoding","debom","bufferStartsWith","subarray","toString","prefix","Buffer","isBuffer","CaseInsensitiveMap","initialContents","normalizer","DefaultNormalizer","k","key","lookup","delete","size","values","keys","toStringTag","pick","obj","synonyms","m","MultiMap","vacuum","o","uniq","add","getFirst","lookupNearest","minDiceCoeff","exact","best","bestCoeff","coeff","diceCoeff","newBest","lc","colorEnabled","noColor","withAsciiEscape","off","msg","reset","bold","dim","italic","underline","overline","inverse","hidden","strikethrough","black","red","green","yellow","blue","magenta","cyan","lightGrey","darkGrey","redBright","greenBright","yellowBright","blueBright","magentaBright","cyanBright","white","bgBlack","bgRed","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgLightGrey","bgDarkGrey","bgRedBright","bgGreenBright","bgYellowBright","bgBlueBright","bgMagentaBright","bgCyanBright","bgWhite","incr","countSum","sum","keyAvg","avg","Average","isNumber","toJSON","toRecord","entriesByCountDesc","mapNumericOr","abs","top","topKeys","averageCounts","addAll","join","valuesToA","fill","DefaultSensitiveEnvRegexPattern","listener","ts","now","elapsed","log","elapsedMs","input","lowerCaseKeys","blank","line","splitCompactLines","re","exec","groups","val","str","replace","Function","bind","_self","Object","FifoCache","maxSize","clearEveryMs","setsSinceLastSpill","expireListeners","clearInterval","setUnrefInterval","spill","priorCache","currentCache","el","create","inspect","custom","visit","union","v2","visitor","deleteIf","orElse","getOrSet","valueThunk","_event","__uid","__start","FifoCacheAsync","opts","cacheHitsSync","cacheHitsAsync","cacheMisses","rejections","timeouts","readFsCache","writeFsCache","cache","fsCacheTtlMs","timeoutMs","mergeStats","stats","hasFsCacheSync","fsCachePath","isMtimeRecentSync","get_","Deferred","isRejected","isPending","promise","cacheDir","d","victim","filestamp","moveSync","rm","recursive","maxRetries","retryDelay","force","deleteFsCache","unlinkSync","getOrSetAsync","later","observe","setTimeout","then","fsCacheSlowMs","gte","sha","shortFsStringSha","parseJSON","bufferToString","readFileSync","meta","unlink","debug","outputFile","FifoSet","delegate","next","IndexedHeader","h","text","isString","greedyLeft","toEntry","row","substring","leftIdx","rightIdx","trim","headers","table","warnIfMissingHeaders","Fixed","skippedHeaders","rows","splitLines","headerRow","maxLen","max_","blankColumns","range","extractHeaders","fromEntries","firstBlankColumn","fromIdx","toIdx","RegExp","escapeRegExp","priorLastIndex","skippedOver","m_index","matched","lastIndex","left","indexOfNonSpace","right","lastIndexOfNonSpace","priorRightBoundary","leftmost","lastHeader","HashBits","thunk","ttlMs","LazyClass","ExtensibleFunction","watchers","_call","isStale","onSetResult","priorP","currentP","_prior","current","setUnrefTimeout","unset","lastSetTs","refresh","ttl","setTTL","watchLater","watcher","watch","lastSetAgoMs","hasPrior","ROLazy","_","DefaultLocale","extractLocale","e","env","LC_ALL","LC_MESSAGES","LANG","LANGUAGE","toLocale","locale","lastValue","envLocale","lazyAsync","desc","lc2locale","localeWin","isMac","localeMac","localePosix","regex","equalsIgnoreCase","g","lang","country","thenMap","PowerShell","executeJson","Name","stdout_","parseEnvTokens","rootLoggers","ConsoleLogger","consoleLogger","context","ContextualLogger","callCount","toBoolean","process","PS_LOG_COLOR","isTrue","NO_COLOR","includes","TERM","MaybeTestArgRe","_nodeEnv","NODE_ENV","isPacked","argv","isDev","isTest","SINGLE_SPEC_TESTS","mapGte0","mapInt","mapGt0","toInt","within","flatten","toFloat","defaultValue","mapNumeric","numstartRe","extractFloat","String","substr","extractInt","prepHammBigInts","leftPad","hammRatioBinaryString","matching","split","map2Numeric","columns","col","s1","s2","charAt","bitsPerValue","BigInt","bitsPerCell","total","sqrt","Try","toErr","primitiveEntries","isPrimitive","isDate","mapEntries","fieldNames","field","fieldName","first","errIfMissing","propertyIsEnumerable","defaults","sources","assign","dest","src","keysToRetain","maxKeys","keyCount","valpath","ciFieldPath","nextDot","fieldRemains","ciField","sortedKeys","sortIgnoreCase","deepDelete","keysToDelete","caseInsensitiveKeyName","isPreAlphaVersion","isAlphaVersion","isBetaVersion","isStableVersion","channel","baseVersion","versionMajor","versionMinor","versionPatch","versionMajorMinor","pids","pidExists","untilTrue","intervalMs","AllowableStartSlopMs","matchesPidfileInfo","entry","entryStartTime","getTime","fileStartTime","startTime","killPidWinTaskkill","args","execFile","killPid","rewritePidfileOnForce","execute","identity","killPidWin","kill","killPidWithNode","pidsDir","recentPids","vacuumOldWip","rateLimited","minCallDelayMs","minMtime","old","childFiles","isJsonExt","isHiddenBasename","base","mtimeMs","killOldProcs","everything","pidfiles","killed","endPromises","pidEntries","pidInfos","pidfile","json","readJson","pidEntry","timeoutAt","everythingBefore","toISOString","allSettled","opt","parseNativePath","getOrElse","writeJson_","children","ext","priorInfo","ago","configDir","dir","BaseFile","for","ProcCleaner","timers","predb","PriorityClasses","strEnum","PriorityClassToPosix","freeze","Normal","BelowNormal","Low","Idle","PriorityClassToNode","AboveNormal","constants","priority","PRIORITY_ABOVE_NORMAL","PRIORITY_NORMAL","PRIORITY_BELOW_NORMAL","PRIORITY_LOW","isFinite","isProcEntry","pe","existingPids","collectBatchedAsync","pidInfoWin","pidInfoPosix","win2pe","Id","pwshJsonDate","StartTime","ProcessName","procs","psWinWmic","executeJsonToA","PsWinCmd","PsWinSelectObj","psWin","psStdout2ProcEntry","stdoutOpts","psPosix","alive","pidToS","maxBuffer","ignoreExitCode","ignoreStderr","processIdClause","stdoutResult_","wmic","onlyReqValued","parseFixed","ProcessId","wmiDate","CreationDate","CommandLine","StartTs","title","PID","STARTED","COMMAND","nullOnBusy","priorResult","nextArgs","running","delayNextRunUntil","ceil","doneLatches","isRateLimited","afterRunDelay","delay","resolve","cause","WrappedError","postRun","run","donePromise","Latch","status","needToDelay","minNextDelayMs","setMinCallDelayMs","ms","RegExpEscaped","source","global","flags","ignoreCase","multiline","RegExpOptional","concatRegexp","ee","reniced","niceableCmds","basename","ffmpegPath","vlcPath","ensureSuffix","compactBlanks","nodeReniceWorks","TTLSet","priorityClass","priorityPosixToClass","processPriority","setPriority","permissionDenied","errno","code","pc","reniceWin","nice","renicePosix","isMainService","MainServices","serviceName","isWebService","ServiceNames","web","isWorkerService","worker","isSyncService","sync","isTestService","test","isTestNotWorker","isStatsDbService","processName","main","desktop","DbServices","list","billing","StatsDbServices","isDbJanitorService","asSet","onAdd","impl","toKey","shim","emit","setShim","c","useFsCache","hasShim","cacheDelete","findValueIndex","low","high","mid","midV","found","shiftLte","deleteCount","retainLastN","streamEnded","stdoutWrite","ready","writeTTY","stream","write","FailStr","isFatalError","isHealthCheckError","ReadyStr","JSON","stdoutEnded","addToEnv","migrationFile","migration","StdoutWrite","shutdownSync","restartSync","forceRestartSync","rebuildLibrary","shutdown","splitFirst","ellipsize","ensurePrefix","stripPrefix","stripSuffix","wrap","he","padChar","padding","strslice","haystack","needle","fromPosition","countChars","maxSplits","sliceTimes","matchedIndex","captured","uncaptured","unmatched","startsWithIgnoreCase","suffix","sfx","maxPre","maxPost","charsOmitted","toLocaleLowerCase","toLocaleUpperCase","CapRE","compareIgnoreCase","localeCompare","sensitivity","normalize","as","bs","uniqBy2","nn","hn","nl","hl","patterns","greatestBy","startsWith","Smart2Dumb","dumbquote","smart","dumb","quoted","splitKeep","splitUp","flatZip","nonSeparators","separators","NonRetriableErrorFlag","pos","sortNaturalBy","escape","cb","lines","rev","parseInt","fromCharCode","CommentRE","sep","replacement","dedupeRe","trimRe","delim","snake2camel","toUpperCase","stringShaToBuffer","msbits","createHash","update","digest","shortStringSha","radix","Radix58","encodeBuffer","GeoRadix","lcs","Array2D","z","ret","hamming","_hamming","an","bn","A","B","firstThunk","aGrams","bigrams","bGrams","nonUniqIntersection","uniqIntersections","diffWithoutCommonPrefix","cpc","commonPrefixLength","longestNumericString","digits","lnsDiff","a1","b1","notAlphaNumRe","radixDiff","stripDiacritics","RadixAlphaNum","decode","positionalDiff","aChar","charCodeAt","bChar","pref","ham","dice","lns","minLen","scheduleExpirationTimers","addIfMissing","onMissing","ctime","expired","username","gte0","userid","userids","geteuid","getuid","userInfo","uid","groupids","getegid","getgid","gid","groupid","usernameFromEnv","getEnv","usernameFromUserInfo","toNotBlank","userNameFromWhoami","userNameFromWindowsAccessToken","isRootUser","versionPrerelease","release","gitSha","gitDate","wmi","year","mon","day","hour","sec","micros","offset","UTC","WinDateRe","flatMap","dayMs","AbortError","toAsyncIterable","race","startedAt","PromiseStates","pending","id","payload","serialId","toLogJSON","_ctor","state","omit","settledAt","observeQuietly","p","isPromise","resolution","maybeResolve","maybeReject","unref","clearTimeout","stateStr","isResolved","isSettled","resolved","rejected","settledMs","asError","finally","onfulfilled","onrejected","firstback","endablesByRank","vacuumEndables","DefaultTimeoutMs","endable","validOrElse","_ending","endTimeoutMs","getDevEnvFlag","firstGt0","trace","thenOrTimeoutError","filterInPlace","entriesArray","endEndables","isSingleSpecTests","onEnd","onEnds","awaitSettled","addEndable","awaitEnd","exit","LogLevels","toWrappedError","message","fatal","stderrWrite","onFatalHandlers","exitOnStdStream","streamName","eventName","settledCount","setResult","priorD","resultD","resultIdAtStart","onChange","thenCompact","thenCollectSerial","thenCollectParallel","maxConcurrent","promises","array","maxCpus","PermissivePromises","Promises","func","enqueueAll","tol","batchInput","objP","withinMs","isFalse","DefaultTryAllTimeoutMs","console","thenOrTimeout","err_","finally_","caught","isFunction","defaultIfNull","objP1","objP2","o1","o2","ifUndefined","predicatePromise","promiseThunks","unsorted","normalizeName","PromiseTimer","errors","CountingSet","time","post","expectedTime","p98","slowTimer","tot","entriesBySumDesc","namePrefix","merged","agg","merge","mkElapsed","Elapsed","weightedAvg","weightedSampleAvg","errorCounts","callCounts","weightedAvgs","compactValues","mapFinite","report","sumSec","sigFigs","pushTime","pt","mapCompactObj","mapNotEmpty","maxConcurrency","EventEmitter","lastWorkTs","settleMsAvg","lastPushedNames","awaitAll","lastPushMsAgo","freeSlots","unsettledCount","runningNames","pendingNames","totalWorkCount","enqueue","laterPop","laters","serial","promiseOrLater","setImmediate","maybePopPendingWork","maxJobsToStart","isIdle","jobsToStart","runningSerialIds","blockedBySerialId","isTaskRunning","taskName","maybeRun","runningCount","hasPending","isFull","deferreds","pendingWithName","payloadsWithName","pendingPromises","awaitAllByName","_name","timeoutHandler","_soft","soft","callback","setInterval","until","acceptable","timeoutResult","sentSoftTimeout","delayCount","delayMs","SettingsKeys","sensitiveEnvRE","sensitiveEnvRegExp","sanitizedEnv","allSettings","RequiredPosixEnv","RequiredWindowsEnv","requiredEnv","caseInsensitiveEnv","isPosix","pathWithDefaults","childProcEnvSettings","forWorker","PS_IS_CHILD_PROCESS","isDocker","PS_IS_DOCKER","isElectron","ELECTRON_RUN_AS_NODE","persistedSettings","hasValue","addToEnvMaybe","maybeOpts","childEnv","overrides","forceCLocale","detached","shell","childEnvLogged","childProcLocale","transientSettings","deleteFromEnv","isLogged","ps","nonPs","partition","getSettingByNameOrKey","cp2log","endProcess","closeStreams","killResult","childGotSigterm","waitForPidExit","newProc","niceable","ReniceAfterMs","AddPidAfterMs","spawnOptions","quiet","disconnect","stdoutChunks","stderrChonks","exitCode","endStream","stdin","data","stderrEnded","isIgnorableFunc","causes","spawn","level","trimLastNewline","CliDesc","logcat","logtail","joinLines","cliWrap","DescriptionFooter","maxLineLen","getFullYear","whyMismatched","envKey","actual","toGt0","whyUidGidMismatched","verifyUidGid","why","closeTo","maxMsDelta","isObject","aTime","bTime","timeMs","deltaMs","Duration","fromMillis","toFormat","hourMs","iso","dt","DateTime","fromISO","zone","isValid","toMillis","dou","fromObject","invalidExplanation","DefaultDateTimeFormats","decCache","decodeDuration","parseDuration","encCache","fmtFullDuration","isDigits","captures","units","type","yearMs","weekMs","parseUnit","lt0","Units","unit","pad2","getMonth","getDate","getHours","getMinutes","getSeconds","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","AutoVacuumModes","CheckpointTypes","RepairModes","SynchronousModes","uidSuffix","tmpCacheDirs","preexistingDir","dirs","tmpDir","cacheDirs","XDG_CACHE_HOME","DefaultDockerLibraryDir","homeDir","cacheSubDir","isLinux","filterDirs","defaultCacheDir","firstDir","addSettingsListener","setSettingsDefaults","resetCacheDir","refreshEnvValue","broadcastChange","cacheDir_","nativePath","mkdirpSync_","mkNoMedia_","path","envConfigDir","dockerConfigDirs","desktopConfigDir","desktopConfigDirs","isReadWriteableDirectorySync","XDG_DATA_HOME","XDG_CONFIG_HOME","fromEnv","mkdirpSync","paths","isDirectorySync","homedir","defaultLogDirs","defaultLogDir_","logDir","readTomlFileSync","systemSettingsFile","ld","picturesDirWindows","picturesDir","defaultPicturesDir","XDG_PICTURES_DIR","PS_ENV_KEYS","delimiter","SensitiveEnvRE","file","tokens","DevEnvFlags","DevEnvKeys","IgnorableEnvKeys","EnvKeys","onEnvChange","SensitiveEnvRegexPattern","camel2snake","firstNotBlank","PS_SENSITIVE_ENV_REGEX_PATTERN","sensitiveEnvRegexPattern","CaseInsensitiveValued","splitErrorMessage","errs","messages","getErrorDescriptions","isError","errorName","errorCode","stripAnsiEsc","ErrorDelimiter","uniqSubstrings","normalizeErrorMessages","IgnoredErrorNames","joinErrorMessages","trimmed","trailingChars","sortErrorFlags","extractErrorFlags","stripErrorFlags","errorRate","Rate","fatalErrorRate","internalErrorRate","lastInternalErrors","MissingError","maxMsgLen","maxStackLines","shortStack","stack","ErrorCodes","description","errorErrno","err2desc","UNKNOWN","OK","EOF","EADDRINFO","EACCES","EAGAIN","EADDRINUSE","EADDRNOTAVAIL","EAFNOSUPPORT","EALREADY","EBADF","EBUSY","ECONNABORTED","ECONNREFUSED","ECONNRESET","EDESTADDRREQ","EFAULT","EHOSTUNREACH","EINTR","EINVAL","EISCONN","EMFILE","EMSGSIZE","ENETDOWN","ENETUNREACH","ENFILE","ENOBUFS","ENOMEM","ENOTDIR","EISDIR","ENONET","ENOTCONN","ENOTSOCK","ENOTSUP","ENOENT","ENOSYS","EPIPE","EPROTO","EPROTONOSUPPORT","EPROTOTYPE","ETIMEDOUT","ECHARSET","EAIFAMNOSUPPORT","EAISERVICE","EAISOCKTYPE","ESHUTDOWN","EEXIST","ESRCH","ENAMETOOLONG","EPERM","ELOOP","EXDEV","ENOTEMPTY","ENOSPC","EIO","EROFS","ENODEV","ESPIPE","ECANCELED","ErrorFlags","IgnorableErrorFlag","PleaseSendErrorFlag","HealthCheckErrorFlag","DoNotSendErrorFlag","RetriableErrorFlag","HealthCheckWarningFlag","InternalErrorFlag","NoLibraryErrorFlag","DbSetupErrorFlag","NonFatalErrorFlag","ErrorFlagsRE","FatalErrorPatterns","FatalErrorRe","InternalErrorRe","isPleaseSendError","notIgnorablePatterns","ignorablePatterns","ignorable","BusyErrorRe","isSqliteBusyError","isSqliteDisconnectedError","isSqliteConstraintError","isNonRetriableError","retriable","doNotSendPatterns","doNotSend","internalError","isEmptyObj","isInternalError","onEvent","event","isFatalErrorAllowed","postProbation","probationMs","lowErrorRate","eventsPerMinute","fatalErrorRatePerMinute","acceptsFatalErrors","isServiceThatAcceptsFatalErrors","fatalErrorRatePerMin","errorRatePerMin","fatalErrorRatePerMinuteSetting","mkMessage","mkCtx","toErrs","codes","splitUniq","syscall","maybeAnd","isRetriableError","isDoNotSendError","dedupeNeedle","captureStackTrace","fromJSON","target","eventsToRetain","omniListeners","priorEvents","once","addOmniListener","watchEvent","removeOmniListener","emitDebounced","listeners","removeAllListeners","mkEE","setMaxListeners","CapturingEventEmitter","getUid","getGids","getgroups","access","stat","w","processUid","processGid","gids","isRoot","isUser","isGroup","mode","actualPath_","actualPathCache","FileCache","pathIsRoot","actualDir","readdir_","ancestors","dirname","childrenSync","readdirSync","hasChildren","childNames","object","isSimpleFile","dirent","bflog","directoryEntry","de","parsed","posixPath","native2posix","withFastestAccess","files","msArr","shaMs","forPosix","posixPathOrFile","forDirectoryEntry","nativePathOrFile","fromPath","forChildDirent","DirectoryEntry","fromSimpleDirent","forSiblingDirent","clearThisAndParent","pathnames","that","thatNativePath","toNativePath_","isUNC","baseWithParent","parent","ellipsizePath","baseWithParentNoExt","baseWithGrandparent","posixPathFrom","StatDirent","directoryEntrySync","statSync","childDirectoryEntries","dirents","_directoryEntryChild","resolve_","children_","filterInPlaceAsync","isFile","childDirectories","isDirectory","trapSync","childFilesSync","withFileTypes","actualChildNames","includesAll","hasNoChildren","visitDescendants","child","descendants","someDescendant","depth","descendantsSync","thisDe","visitDescendantsSync","ancestorWithChildren","siblings","siblingDirectoryEntries","selfAndSiblings","firstExistingSelfOrAncestor","exists","splitNativePath","pathsForDateParsing","pathnamesWithoutDrive","bname","pathDepth","root","isAncestorOf","maybeDescendant","containedByNativePath","ancestor","descendant","isDescendantOf","maybeAncestor","isSelfOrDescendantOf","parentsAndSelf","parents","selfAndParents","findAncestor","actualPath","sibling","withPrefix","withNameSuffix","withSuffix","siblingOf","possibleSibling","isAbsolute","joinYMD","map3","month","pathElements","trap","methodName","errLogLevel","trapOr","timeSync","stat_","statMaybe","thenDefined","existsSync","notExists","thenNot","isDeleted","maxDepth","parentIsDeleted","mtime","mtimeSec","unixtime","lastModifiedUtc","toUTCString","statTimes","maxStatMs","maxStatDate","minStatMs","minStatDate","size_","isExecutable","isReadable","isNotReadable","isReadWritable","isNotReadWritable","isReadWriteExecutable","isStatRWX","isReadWriteExecutableSync","isReadWriteExecutable_","isReadWriteDirectory","assertReadWriteExecutable","userDesc","maybeReadWriteDirectory","bytesConsideredEmpty","isNonEmpty","minSizeBytes","isEmptyFile","isNonEmptyFile","modifiedGTE","thisMtime","modifiedCloseTo","thisMtimeMs","isRecent","agoMs","modifiedGT","thenMapOr","isNotDirectory","nearestDir","isFileSync","isDefined","rmdir","_fse","rmdirSync","mkdirp_","mkdirp","sha_","fileSha_","fileShaMeta_","autoInvalidate","readJson_","readFile","readJsonSync","readFileSync_","readFile_","readTextFile_","readTextFile","zReadFile_","zCopyToBuffer_","zcat","readLines","writeText_","txt","writeTextSync_","writeFile_","writeJson","writeFile","replacer","spaces","matchesContent","touch","touch_","ensureFile","utimes","unlink_","logLevel","rmrf","rmrf_","retryOnReject","errorIsRetriable","gunzip","createGunzip","gzip","createGzip","compressBrotli","createBrotliCompress","ensureFile_","ensureFileSync_","ensureFileSync","ensureNewNativePath","ensureNewNativePath_","ensureNew_","ensureNewSync_","ensureNewNativePathSync_","chmod_","chmod","chmodSync","zreadline","createReadStream","pipe","LineReader","siblingWithSameContents","childWithSameContents","targetSize","withSameName","sameSize","isNameHidden","targetSha","firstMatchingLine","close","onDataChunked","newlineRe","contemporary","maxDiffMs","thenMap2Or","arr1","arr2","watchUntil","persistent","_useFsWatch","filename","denull","interval","sibs","closest","transform","pipeline","autoClose","createWriteStream","attrTTL","projectRoot","ProjectPath","Root","execPath","Newline","DefaultMacOSPaths","DefaultPosixPaths","DefaultDockerPaths","DefaultWinPaths","mapNotBlankOr","SYSTEMROOT","DefaultPaths","isSimpleDirent","Stats","for_","fse","parentAndBase","parentBasename","parse","readdir","visitDescendantFiles","filterDescendantFiles","rmdir_","DefaultEnsureNewOptions","emptyIsNew","maxVersions","requireNumber","startIndex","arg","isEmptyFileSync","isCacheableFile","InstanceCacheMaxSize","ShortExtRe","normalizeExt","Dirent","JpegExts","isExt","exts","SidecarFiletypes","SidecarExts","extAliases","regexCache","CopiesRe","Copies2Re","stripCopySuffixFromName","aggressive","_stripCopySuffixFromName","initialName","ymdIsoRE","parsePosixPath","strippedName","strip","stripped","burstRe","coverRe","dscPrefixRe","fileStats_","shimmedFileSha_","uncachedFileSha_","streamSha_","transforms","hashAlgorithm","hash","shim1","randomBytes","DevMounts","MacSystemVolumes","MacPrivate","MacOsInstall","MacNotDmg","isPhotoStructureDmg","mountpoint","whyIgnorableMountpoint","isExcludedMountpoint","Transform","objectMode","autoDestroy","_transform","chunk","_encoding","done","_flush","writeTextfile_","toPathnames","driveRe","drive","upcaseDriveLetters","posix2native","fileish","pathlike1","pathlike2","CompressedExtRE","spliceCapture","splitLast","acceptSelf","joinNativePath","filePaths","np","lhs","rhs","basename_","isReadableDirectory","srcNativePath","destNativePath","move","overwrite","mountpoints","MinBinarySize","KiB","isBinaryFile","fallbackPathDirectories","systemRoot","tool","PATH","pathDirectories","isStatRX","fsutil","nslookupWin","pingWin","arpWin","hostname","posix","pathTo","execDir","projectDirs","cwd","__dirname","uniqInPlace","npx","throw","Bin","Data","ICC","Migrations","Public","Tools","Views","isInDMG","projectPathRoot","fs","ReadableBuffer","Readable","buffer","ReadDirCacheName","readdirCacheDir","clearReaddirCaches","path2cache","readdirCacheMs","clearCachedReaddir","statTimeoutMs","readdirUncached_","quickResult","Timeout","readdirSizeCacheThresh","slowDirs","toNotTimeout","thenOrTimeoutAt","_readdir_","isBoolean","winDriveRE","someSelfOrAncestor","sf","firstSelfOrAncestor","statToType","statFieldToComparable","whyStatNotEql","aType","bType","aVal","bVal","delta","isEmptyStats","minFileSize","staleMs","isRecentMs","birthtimeMs","throwIfNoEntry","nativePathExistsSync","minSize","onData","Chunker","read","filterBlanks","incompleteChunk","onChunk","writable","destroyed","writableEnded","writableFinished","PassthroughStream","Duplex","_write","maybeCall","closable","NoOp","destroy","remoteFamily","remoteAddress","remotePort","ByteCounter","onProgress","bytes","toMs","rStat","reference","atimeMs","btimeMs","retainFileBirthtimes","atime","btime","WritableToBuffer","Writable","deferred","_buf","writeFileSync_","writeFileSync","crlf","zcat_","zpipe_","outputStream","endsWith","createBrotliDecompress","readJsonGz_","outputJsonGz_","HealthCheckIds","CropStrategies","SharpFailOns","enabled","pushLogEntries","logFilter","flush","loggers","addContext","addParameterContext","param","throwIfAborted","signal","aborted","msTolevel","tapThunk","tapAsync","errorLevel","errorMsg","DefaultLogFormatter","PlaintextLogFormatter","DefaultLogFlushMs","sortByInPlace","SimpleLogFilter","minLogLevel","silent","defaultLevelIndex","levelIndex","highlight","LogLevelRe","defaultLogLevel","TraceLevelIndex","LogLevel2SyslogLevel","errorMs","_logTailEnabled","logEntries","SortedSet","logEntrySorter","formatLogEntry","inspectOptions","colors","customInspect","paddedLogLevels","rightPad","le","format","vec","pushAll","maxSamples","clone","samples","_n","_min","_max","_m","_s","_samples","_weightedTotalAvg","with","priorM","sigfigs","empty","mean","sd","stdDev","p16","p29","p38","p84","p99","variance","sampleMode","sampleModes","sampleVariance","sampleStdDev","sampleAvg","sampleSlope","slope","weightedTotalAvg","sigmasFromMean","mapGte0f","mu","sigma","splitBits","pow","map2","ea1","absdiff","dims","clampValue","randomValue","randomInt","zipMin","bitDepth","zipMax","clamped","bit","dimIndex","unzip","dIdx","isBitSet","BitShiftMax","disableBitshifting","bitsSetBig","setBits","lerp","v0","v1","nearest2","p0","p1","dx","zero","encodeDigits","Radix","numerals","decodePreparser","digitsToNumerals","encode","num","negate","encodeBigInt","bi","Number","buf","decodeBigInt","MAX_SAFE_INTEGER","ch","randomChars","log2","randomUid","chars","splitEveryN","sepChar","splitEvery","tokenEql","normalizeToken","Hex","Base64","TokenRadix","AlphaRadix","NumericRadix","eventCount","eventsPerSecond","msSinceLastEvent","modes","topN","cs","sumf","Mean","l2norm","dot","strength","normMin","normMax","xMin","xRange","normRange","x_mean","y_mean","denom","carryForward","vectors","finiteOrElse","__filename","_platform","platform","inspectFlag","NODE_INSPECT","isCI","isWinPortable","PORTABLE_EXECUTABLE_DIR","isLinux_x64","arch","isArm","isLinux_arm","isLinuxAppImage","APPIMAGE","APPDIR","isLinuxSnap","SNAP_USER_DATA","isMainElectron","versions","platformName","containsRpiModel","cpuinfoPath","isRaspberryPi","procDeviceModel","Done","ConvertToCompressedJson","pwshQuote","clearMockResults","ensureInstance","bco","postdb","mockResults","BatchCluster","processFactory","powerShellArgs","versionCommand","powerShellCulture","pass","fail","exitCommand","powerShellProcs","taskTimeoutMillis","setMaxProcs","pwsh","versionPojo","Major","Minor","Build","spawnedProcCount","pushMockJsonResult","pushMockResult","parser","passed","thenElapsed","enqueueTask","Task","fixed","which","Source","AggregateTypes","AssetFileSortCriteria","BooleanSetting","Setting","toEnv","notBlankToS","BoundedFloatSetting","parseFloat","addToJSON","BoundedIntegerSetting","ColorDistanceFunctions","DominantColorKmeansRunsDefault","DominantColorPixelsDefault","DurationSetting","encodeDuration","userValue","humanValue","fileValue","OptionalDurationSetting","FloatSetting","IntegerSetting","OptionalFileSetting","OptionalStringSetting","OptionalFloatSetting","OptionalIntegerSetting","SettingCategories","LibraryCategories","Auth","Color","Db","Deduping","Events","Filters","HealthChecks","Parsing","Previews","Reporting","Sidecars","Subscriptions","Sync","Tagging","Video","Volumes","Web","SystemCategories","_envValue","readFromEnv","optsOverrides","getState","user","_userValue","envValue","_fileValue","tmp","_tmpValue","dump","isUnset","setState","normalizeValue","shallowClone","maybeBroadcastChange","tmpValue","valueOrThrow","civ","names","setFromEnv","environment","setValueIfDefined","unWatch","mutateFunc","_names","_setName","aliases","_key","envFromName","_keys","envAliases","altKeys","category","categoryType","transient","advanced","envValueOrDefault","tmpValueIfUnset","resetDefaultValue","exampleValue","overrideValue","toEnvValue","cie","toCommentedLines","deprecated","WrapComments","maybeAddList","pluralize","orList","toEnvLine","toTomlLines","wrapTomlToLines","prepend","exposeNetworkWithoutAuth","DefaultMaxEmbeddedBuffer","Paths","libraryDir","copyAssetsToLibrary","previewsDir","StringSetting","originalsDir","scanAllDrives","scanMyPictures","scanPaths","StringArraySetting","argvScanPaths","pidFile","Cache","imageCacheMs","Logging","logCompression","logWebRequests","logWebDir","logStdout","tailLogs","logColor","logContextLimit","logSql","logServer","logServerLevel","useFsWatch","Filesystem","allowFilesystemSleep","watchDebounceMs","excludedFilesystemTypes","DefaultExcludedFilesystemTypes","excludedRootDirectories","DefaultExcludedLinuxRoots","excludedMountpointPaths","DefaultExcludedLinuxMountpointPaths","excludedMountpointBasenames","validateMountpoints","mountpointsTtlMs","remoteFilesystemTypes","volumeUuidFilePaths","readVolumeUuidFiles","writeVolumeUuidFiles","writeVolumeUuidMountpointBlocklist","volumeMetadataTtlMs","Networking","localhost","httpPort","trustProxy","Security","cspReportOnly","upgradeInsecureRequests","cspDirective","disabledHelmetMiddleware","StringEnumsSetting","HelmetPlugins","shortProcessNames","Processes","BatchClusterOptions","minDelayBetweenRetriesMs","exiftoolProcsPerChild","syncExitTimeoutMs","minTimeBetweenServiceRestartsMs","minDiskFreeGb","cpuLoadPercent","timeoutThrottleCoeff","maxConcurrentImports","maxConcurrentImportsWhenRemote","sharpThreadsPerProcess","StringEnumSetting","maxMemoryMb","enableArchive","enableDelete","enableEmptyTrash","enableRemove","enableRemoveAssets","argon2TimeCost","argon2MemoryCostMB","argon2Parallelism","forceLocalDbReplica","dbRetries","dbBackupRetentionCount","dbAutoVacuumMode","INCREMENTAL","dbWalCheckpointType","TRUNCATE","dbWalAutoCheckpoint","dbInvalidFKThreshold","dbSynchronousMode","NORMAL","dbRepairMode","maxBusyDbMs","dbBusyTimeoutMs","dbBackupIntervalMs","dbBackupIntervalMinutes","dbPageSizeBytes","dbCacheSizeMb","dbBatchSelectSize","dbBatchUpsertSize","dbForceRecover","dbBackupRemoteOnSuspend","trySoftDeletes","skipHealthCheckIds","ffmpegHwaccel","ffmpegThreads","ffmpegAvcTranscodeArgs","transcodeMaxResolution","transcodeVideos","transcodeBitrateQVGA","transcodeBitrateUHD","doNotTranscodeMimeTypes","doNotTranscodeVideoCodecs","doNotTranscodeAudioCodecs","enableSIMD","enableVipsCache","showFileInFolderUsesThunar","showFileInFolderUsesFileUri","showFileInFolderCommand","dcraw_emuPath","heifConvertPath","toolPaths","updateChannel","Desktops","UpgradeChannels","updateOnLaunch","updateCheckMinutes","autoHideMenuBar","hideOnLaunch","pauseSyncOnBattery","email","reportErrors","maxErrorsPerDay","minStreamCorrPct","lazyLoadExtraVh","hiddenHomeTags","placeholderThumbs","fastForwardEmptyTags","syncReportsDir","syncReportMaxRows","quickSyncMode","taskTimeoutMs","scanLibraryFirst","scanLibraryLast","progressRetentionDays","progressStaleDays","copyToLibraryMimeTypes","onlyNativeFileCopy","verifyFileCopies","assetPathnameFormat","writeSourceTagToLibraryCopies","assetSubdirectoryDatestampFormat","startPaused","syncIntervalHours","syncNewIntervalMs","syncChangedIntervalMs","retryEnqueued","forceRebuildLibrary","dropWorkQueues","forceSync","forceRebuildPreviews","noModelUpdates","exitWhenDone","overwriteOriginal","maxDuplicatePathElements","noAssetFileUpdates","noAssetUpdates","resyncAssetOnVisit","cpuCount","excludeNoMediaAssetsOnRebuild","matchSidecarsCaseInsensitively","matchSidecarsFuzzily","defaultSidecarType","writeMetadataToSidecarsIfImage","sidecarTagBlocklist","writeMetadataToSidecarsIfVideo","writeMetadataToSidecarsIfSidecarExists","strictDeduping","assetAggregation","useImageHashes","allowFuzzyDateImageHashMatches","minMatchesWithoutImageHashes","maxContemporaryAdoptionAssets","datesBeforeAreEstimated","minExposureSettingsCoeffPct","minImageCoeffPct","imageHashFuzzyDateDelta","imageHashDifferentMimetypesDelta","imageHashGreyscaleDelta","minColorCoeffPct","greyscaleColorThreshold","gpsErrorMeters","minCapturedAtPrecisionDifferentMimetypes","fuzzyDatePrecisionCoeff","dominantColorPixels","dominantColorDeltaE","ciede2000","dominantColorKmeansRuns","dominantColorMergeThreshold","dominantColorGreyThreshold","sharedStateDir","sharedStatePollMs","sharedStateTaskTimeoutMs","previewQuality","previewProgressive","previewMinimized","dcrawEmuArgs","iccProfileMappings","squareThumbStrategy","attention","videoFrameAtSec","previewSharpen","previewResolutions","FitSizes","embeddedPreviews","embeddedThumbnails","maxEmbeddedBuffer","fmtBytes","skipPreviews","variantSortCriteria","variantSortCriteriaPower","includePreviewTags","includedPreviewTags","DefaultIncludedPreviewTags","disableAllFilters","excludeGlobsAdd","excludeGlobsOmit","globsCaseInsensitive","respectFileExtensions","disableIgnorableFilters","requireMakeModel","rejectRatingsLessThan","keywordBlocklist","minImageDimension","minVideoDimension","minVideoDurationSec","maxVideoDurationSec","minAssetFileSizeBytes","KB","maxAssetFileSizeBytes","GB","validateJpegImages","imageFailOn","truncated","validateRawImages","validateVideos","validationErrorBlocklist","validationErrorAllowlist","capturedAtTags","DefaultCapturedAtTagsConst","capturedAtTagsFallback","ProblematicCapturedAtTags","badDates","defaultVideosToUTC","defaultCopyright","likeRating","lensMakes","DefaultLensMakes","extraDateTimeFormats","fuzzyDateParsing","fuzzyYearParsing","twoDigitCutoffYear","minValidYear","useStatToInferDates","usePathsToInferDates","useLibraryDirsToInferDates","enableSiblingInference","siblingInference","TagInferenceSettingValues","auto","siblingInferenceBasenameCoeff","writeInferredTagsToLibraryCopies","recountAllTags","tagCamera","tagLens","tagFullLensModel","tagYMD","DateTagFormats","ym","tagDateFromStat","tagKeywordsFromPath","tagKeywordsFromMetadata","keywordTags","keywordReparenting","KeywordReparentingStrategies","rootTagAlbumsAliases","rootTagKeywordsAliases","rootTagWhoAliases","keywordDelimiters","keywordPathSeparators","tagFileType","tagJsonFaces","tagFaceRegions","whoTags","tagNamesFormatter","NameTagFormats","tagNamesDefaultFamily","tagNamesCapitalizedAsFamily","tagNamesOrder","NameTagOrders","tagNamesSurnamePrefixes","tagNamesSurnames","tagNamesGiven","tagNamesFamilySurrounds","tagNamesGivenSurrounds","tagNamesLexical","excludedRootTags","tagDisplayNameFS","tagDisplayNameFSRoot","tagDisplayNameFSRootWithHostname","tagDisplayNameFSLabels","tagAlbumFilenames","tagAlbumTitle","tagAlbumTitleHierarchies","tagAlbumDescription","tagAlbumDate","tagAlbumsExcluded","omitAncestorTags","subscriptionTimeoutMs","pickPlanOnWelcome","coupon","autoRefreshLicense","license","sensitive","withDefaultPaths","settingsSorter","SuggestedDirsEnvKey","persistedSystemSettings","persistedLibrarySettings","SettingsByNameOrKey","settings","ciSettings","DefaultSharedStateDir","isEnvTrue","defaultLibraryDir","defaultOriginalsDir","SettingsToml","_join","splitStringArray","compactBlankish","_split","toValidValue","toValidValues","getCI","dv","parseStringEnum","parseTomlBuffer","mapNotBlank","stringifyToml","kvToToml","stripCounts","trimLeftPadding","stripDSC","IgnoredCapturedAtTags","DefaultExcludedLinuxMountpointNames","filesystem","LinuxDevMapperRE","LinuxVarSnapRE","LinuxRunUserGVFSRE","LinuxDockerRE","whyExcludedMountpoint","memoize","MinIoRate","MiB","cpuInfo","cpus","quota","intFromFileSync","period","shares","estimatedFreeMem","freemem","totalmem","mem","clearMaxWorkCaches","timeoutRate","maxProcsForMem","worstCaseMemPerProc","MB","estFreeMemMb","worstCaseMemPerProcMb","timeoutPenalization","timeoutsPerMinute","targetCpuLoadPct","cpuPortion","timeoutsPerSecond","penalization","resultBeforePenalization","resultAfterPenalization","cpuLoadPct","lerp2d","refreshEveryMinute","rateStats","toPrimitive","isPrimitiveArray","eqlArray","keepIfTrue","toIndex","step","needles","vArr","cmp_","notBlankish","strings","equals","expense","allowedDelta","newPos","currentExpense","newExpense","finalJoin","destination","sortUniqBy","deepSortBy","isIterable","onRetryWaitUntil","retry","retryCount","ifBlank","BlankishRE","blankish","monthMs","shortDateTimeFormat","Intl","DateTimeFormat","minute","second","shortDateFormat","toDate","fmtDateShort","hms","includeMs","millis","pad3","localToDate","local","pop2","millisecond","nextMidnightTs","setHours","fmtElapsedMs","plur","dateParts","timeParts","toFixedStr","type_detect","memoizeCompare","leftHandOperand","rightHandOperand","memoizeMap","memoizeSet","leftHandMap","WeakMap","_deepEqual","comparator","extensiveDeepEqual","simpleResult","simpleEqual","memoizeResultLeft","memoizeResultRight","comparatorResult","leftHandType","keysEqual","iterableEqual","regexpEqual","getGeneratorEntries","generatorEqual","Uint8Array","leftHandItems","rightHandItems","entriesEqual","objectEqual","extensiveDeepEqualByType","getIteratorEntries","hasIteratorFunction","iteratorError","generator","generatorResult","accumulator","getEnumerableKeys","getEnumerableSymbols","allKeys","getOwnPropertySymbols","getOwnPropertyDescriptor","enumerable","leftHandKeys","rightHandKeys","mapSymbols","leftHandEntries","rightHandEntries","isNode","date","isBrowser","dateComparator","functionComparator","deepEql","objComparators","fieldComparators","FramesToIgnoreRE","errorToArr","maxLines","assignFields","fmtList","joinWord","FitSizeValues","SqSizes","SqWidths","iterable","space","decycle","Revivers","addJsonRevivers","parseJSON_","retrocycle","reviver","JSON_","derez","nu","_value","$ref","prototype","hasOwnProperty","call","$","px","rez","apply","eval","_state","_resolve","_reject","onfinally","Lazy","t1","t2","t3","valueCount","addUniq","pushUniq","_k","flatValues","tuples","changed","findKeyByTuple","filterKeysByTuple","groupBy","globalThis","window","document","node","isNaN","numeralRE","nonNumericRE","isBigInt","mapPredicate","lte","isToNumber","toNumber","nton","MIN_SAFE_INTEGER","ston","toPrecision","decimalPlaces","numerator","denominator","minCoeff","expected","mustBeGreaterThan","orElseF","decimals","fractionDigits","toFixed","exp","log10","rnd","_factorials","factorial","Infinity","notEmptyObj","pairs","mapFields","isReqValued","block","omitKeys","assignNullish","srcKeys","compactValuesDeep","keyNames","pickDeep","flat","deepKeysByLocalField","keysToOmit","methods","Reflect","getPrototypeOf","ownKeys","method","lckey","flattenObject","NoneImpl","noop","zip1","zip2","zip3","None","Some","isOpt","ec","ed","pads","char","padNumeric","irregular","es","consonant_y","vowel_y","is","singular","irr","primitiveTypes","TypeLevel","cmpArr","shorterArrayIsLessThan","isPromiseLike","eaP","ifTrue","rndInt","random","excluded","randomInts","excludeSet","slotsRemaining","candidate","randomFloat","randomChar","RandomChars","trueRatio","NumericChars","LowercaseChars","nonZeroes","rand","pattern","valueToIndex","dict","ordinal","mapValid","a_","b_","isBMP","codePointAt","_graphemeSegmenter","graphemeSegmenter","Segmenter","granularity","sliceIterable","segment","charArr","pfx","leftIndexOf","position","countIterable","stripPrefixes","prefixes","leftSliceAt","rightSliceAt","searchValue","replaceValue","fmtHMS","timeoutAtTs","numberFormat","NumberFormat","fmt","thousandsSep","replaceAll","decimalSep","TB","GiB","TiB","byteUnits","mebiUnits","mag","megabytes","MP","pixels","SizeDescriptions","plural","objs","toStr","DefaultToString","joinChar","program","addFooter","isDefault","executableFile","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","__webpack_exports__"],"sourceRoot":""}