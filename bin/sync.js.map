{"version":3,"file":"sync.js","mappings":"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SACA,MACA,OACA,OACA,QACA,MACA,MACA,MACA,OAGFD,EAAoB,MAAOC,EAAS,cACpCD,EAAoB,cAAeC,EAAS,UAC5CD,EAAoB,QAASC,EAAS,cAGtCD,EACE,UACA,CACE,OACA,aACA,UACA,QACA,OACA,YACA,OACA,gBACA,YACA,uBACA,cACA,WACA,QAEF,4BAGFA,EACE,MACA,CAAC,WAAY,UAAW,UAAW,OAAQ,oBAC3C,wBAEFA,EAAoB,MAAO,CAAC,SAAU,SAAUC,GAAU,eAG1DD,EAAoB,MAAO,CAAC,aAAc,WAAY,kBAGtD,MAAME,EAAU,CACd,QACA,QACA,QACA,MACA,QACA,OACA,MACA,OACA,OACA,MACA,OACA,QACA,OA8VF,OA5VAF,EAAoB,MAAOE,EAAS,cACpCF,EAAoB,MAAOE,EAAS,cAGpCF,EACE,MACA,CACE,QACA,MACA,MACA,OACA,MACA,OACA,MACA,KACA,YACA,QACA,WACA,SACA,SACA,MACA,MACA,MACA,MACA,YACA,MACA,QAEF,qBAGFA,EACE,OACA,CACE,OACA,SACA,MACA,SACA,KACA,OACA,MACA,MACA,OACA,OACA,MACA,UACA,cACA,OAEF,sBAIFA,EACE,UACA,CACE,iBACA,uBACA,WACA,wBACA,QACA,qBACA,sBACA,aACA,SACA,WACA,uBACA,YACA,QACA,MACA,gBACA,UACA,cACA,SACA,UACA,YACA,eACA,SACA,YACA,aACA,eACA,wBACA,wBACA,kBACA,gBACA,YACA,cACA,eACA,iBACA,yBACA,mBACA,YACA,eACA,sBACA,oBACA,UACA,WACA,wBACA,gBACA,mBACA,OACA,wBACA,aACA,MACA,eACA,cACA,UACA,QACA,aACA,aACA,WACA,aACA,mBACA,gBACA,gBACA,qBACA,mBACA,oBACA,MACA,SACA,OACA,kBACA,oBACA,UACA,mBACA,WACA,YACA,aACA,eACA,gBACA,WACA,iBACA,kBACA,eACA,OACA,qBACA,WACA,gBACA,gBACA,gBACA,oBACA,sBACA,oBACA,gBACA,UACA,cACA,qBACA,0BACA,eACA,OACA,oBACA,kBACA,cACA,yBACA,WACA,oBACA,wBACA,SACA,YACA,YACA,WACA,UACA,OACA,eACA,UACA,eACA,gBACA,wBACA,qBACA,UACA,WACA,WACA,SACA,SACA,aACA,YACA,yBACA,mBACA,eACA,eACA,sBACA,mBACA,kBACA,iBACA,MACA,YACA,gBACA,YACA,QACA,UACA,mBACA,oBACA,gBACA,gBACA,QACA,kBACA,YACA,UACA,OAEF,iBAIFA,EAAoB,WAAY,CAAC,QAAS,UAAW,iBAGrDA,EACE,SACA,CACE,MACA,KACA,OACA,UACA,MACA,UACA,OACA,WACA,MACA,WACA,QACA,QAEF,QAGFA,EACE,OACA,CAAC,QAAS,UAAW,UAAW,YAAa,OAC7C,QAEFA,EACE,MACA,CACE,aACA,MACA,MACA,MACA,SACA,MACA,UACA,KACA,OACA,YAEF,QAGFA,EACE,MACA,CACE,OACA,OACA,WACA,WACA,UACA,OACA,UACA,OACA,SAEF,QAIFA,EACE,KACA,CAAC,MAAO,OAAQ,MAAO,MAAO,MAAO,OAAQ,MAAO,MAAO,OAAQ,MACnE,QAIFA,EACE,YACA,CAAC,MAAO,KAAM,MAAO,OAAQ,MAAO,QACpC,QAEFA,EACE,UACA,CAAC,OAAQ,UAAW,UAAW,UAAW,UAAW,QAAS,OAC9D,QAGFA,EACE,QACA,CAAC,MAAO,UAAW,MAAO,QAAS,WAAY,QAAS,OACxD,QAGFA,EACE,QACA,CAAC,SAAU,MAAO,MAAO,SAAU,MAAO,QAAS,OACnD,QAIFA,EACE,MACA,CACE,cACA,WACA,SACA,UACA,YACA,iBACA,UACA,SAEF,QAGFA,EAAoB,OAAQ,CAAC,YAAa,QAC1CA,EAAoB,OAAQ,CAAC,OAAQ,kBAErCA,EACE,SACA,CACE,eACA,YACA,YACA,UACA,cAGF,gBAGFA,EACE,WACA,CAAC,aAAc,UAAW,YAAa,iBACvC,qBAGFA,EAAoB,KAAM,CAAC,SAAU,QAGrCA,EACE,UACA,CAAC,QAAS,WAAY,WACtB,2BAGFA,EACE,KACA,CAAC,QAAS,SAAU,OAAQ,OAC5B,mCAGKnlG,EAAO0P,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","sources":["webpack://@photostructure/library/../core/node_modules/paseto/lib/errors.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/general/decode.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/general/index.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/apply_options.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/assert_payload.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/base64url.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/check_assertion.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/check_footer.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/check_payload.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/compress_pk.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/consume.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/crypto_worker.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/is_key_object.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/is_object.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/le64.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/ms.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/pack.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/pae.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/parse_paseto_payload.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/sign.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/symmetric_key_check.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/timing_safe_equal.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/help/verify.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/index.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v1/decrypt.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v1/encrypt.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v1/index.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v1/key.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v1/sign.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v1/verify.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v2/index.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v2/key.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v2/sign.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v2/verify.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v3/decrypt.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v3/encrypt.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v3/index.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v3/key.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v3/sign.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v3/verify.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v4/index.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v4/key.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v4/sign.js","webpack://@photostructure/library/../core/node_modules/paseto/lib/v4/verify.js","webpack://@photostructure/library/../core/AppName.ts","webpack://@photostructure/library/../core/Array.ts","webpack://@photostructure/library/../core/BatchClusterObserver.ts","webpack://@photostructure/library/../core/BoundedGreatestSet.ts","webpack://@photostructure/library/../core/BoundedList.ts","webpack://@photostructure/library/../core/Buffers.ts","webpack://@photostructure/library/../core/CaseInsensitiveMap.ts","webpack://@photostructure/library/../core/CaseInsensitiveValued.ts","webpack://@photostructure/library/../core/Chalk.ts","webpack://@photostructure/library/../core/CountingSet.ts","webpack://@photostructure/library/../core/DefaultSensitiveEnvRegexPattern.ts","webpack://@photostructure/library/../core/EditionName.ts","webpack://@photostructure/library/../core/Elapsed.ts","webpack://@photostructure/library/../core/Eql.ts","webpack://@photostructure/library/../core/ExamplesDir.ts","webpack://@photostructure/library/../core/ExamplesNativePath.ts","webpack://@photostructure/library/../core/ExtensibleFunction.ts","webpack://@photostructure/library/../core/FifoCache.ts","webpack://@photostructure/library/../core/FifoCacheAsync.ts","webpack://@photostructure/library/../core/FifoSet.ts","webpack://@photostructure/library/../core/Fixed.ts","webpack://@photostructure/library/../core/GeoHash.ts","webpack://@photostructure/library/../core/Halt.ts","webpack://@photostructure/library/../core/HashBits.ts","webpack://@photostructure/library/../core/IsSuspended.ts","webpack://@photostructure/library/../core/JSON.ts","webpack://@photostructure/library/../core/JsonSetup.ts","webpack://@photostructure/library/../core/Lazy.ts","webpack://@photostructure/library/../core/Locale.ts","webpack://@photostructure/library/../core/LogStartup.ts","webpack://@photostructure/library/../core/Logger.ts","webpack://@photostructure/library/../core/Map.ts","webpack://@photostructure/library/../core/MemoizedFunc.ts","webpack://@photostructure/library/../core/Memory.ts","webpack://@photostructure/library/../core/NoColor.ts","webpack://@photostructure/library/../core/NodeEnv.ts","webpack://@photostructure/library/../core/NodeVersion.ts","webpack://@photostructure/library/../core/Number.ts","webpack://@photostructure/library/../core/Object.ts","webpack://@photostructure/library/../core/OperatingSystem.ts","webpack://@photostructure/library/../core/PhotoStructureVersions.ts","webpack://@photostructure/library/../core/Pid.ts","webpack://@photostructure/library/../core/Pids.ts","webpack://@photostructure/library/../core/PriorityClass.ts","webpack://@photostructure/library/../core/ProcessTitle.ts","webpack://@photostructure/library/../core/Ps.ts","webpack://@photostructure/library/../core/Random.ts","webpack://@photostructure/library/../core/RateLimited.ts","webpack://@photostructure/library/../core/RegExp.ts","webpack://@photostructure/library/../core/Renice.ts","webpack://@photostructure/library/../core/ServiceNames.ts","webpack://@photostructure/library/../core/Set.ts","webpack://@photostructure/library/../core/SetServiceName.ts","webpack://@photostructure/library/../core/Shim0.ts","webpack://@photostructure/library/../core/Shim1.ts","webpack://@photostructure/library/../core/ShortCommandTimeoutMs.ts","webpack://@photostructure/library/../core/SortedSet.ts","webpack://@photostructure/library/../core/StartTs.ts","webpack://@photostructure/library/../core/Stdout.ts","webpack://@photostructure/library/../core/StdoutEnded.ts","webpack://@photostructure/library/../core/StdoutWrite.ts","webpack://@photostructure/library/../core/String.ts","webpack://@photostructure/library/../core/StringCase.ts","webpack://@photostructure/library/../core/StringHash.ts","webpack://@photostructure/library/../core/StringNormalizer.ts","webpack://@photostructure/library/../core/StringSimilarity.ts","webpack://@photostructure/library/../core/StringifySorted.ts","webpack://@photostructure/library/../core/TTLArray.ts","webpack://@photostructure/library/../core/TTLMap.ts","webpack://@photostructure/library/../core/TTLSet.ts","webpack://@photostructure/library/../core/TestLibraryDirPrefix.ts","webpack://@photostructure/library/../core/UID.ts","webpack://@photostructure/library/../core/UserInfo.ts","webpack://@photostructure/library/../core/Version.ts","webpack://@photostructure/library/../core/WeakCache.ts","webpack://@photostructure/library/../core/WinDate.ts","webpack://@photostructure/library/../core/asset-file/AssetFileAggregator.ts","webpack://@photostructure/library/../core/asset-file/AssetFileComparator.ts","webpack://@photostructure/library/../core/asset-file/AssetFileFactory.ts","webpack://@photostructure/library/../core/asset-file/AssetFileSorter.ts","webpack://@photostructure/library/../core/asset-file/IAssetFile.ts","webpack://@photostructure/library/../core/async/AbortError.ts","webpack://@photostructure/library/../core/async/Debounce.ts","webpack://@photostructure/library/../core/async/Deferred.ts","webpack://@photostructure/library/../core/async/Done.ts","webpack://@photostructure/library/../core/async/Endable.ts","webpack://@photostructure/library/../core/async/EndableInterval.ts","webpack://@photostructure/library/../core/async/EndableWrapper.ts","webpack://@photostructure/library/../core/async/Exit.ts","webpack://@photostructure/library/../core/async/LastOneInWins.ts","webpack://@photostructure/library/../core/async/Later.ts","webpack://@photostructure/library/../core/async/LazyAsync.ts","webpack://@photostructure/library/../core/async/MemoizedAsyncFunc.ts","webpack://@photostructure/library/../core/async/OneAtATime.ts","webpack://@photostructure/library/../core/async/Postrun.ts","webpack://@photostructure/library/../core/async/Promise.ts","webpack://@photostructure/library/../core/async/PromiseTimer.ts","webpack://@photostructure/library/../core/async/Promises.ts","webpack://@photostructure/library/../core/async/SerialLaterQueue.ts","webpack://@photostructure/library/../core/async/ThenOrTimeout.ts","webpack://@photostructure/library/../core/async/TimeoutHandler.ts","webpack://@photostructure/library/../core/async/Timers.ts","webpack://@photostructure/library/../core/async/until.ts","webpack://@photostructure/library/../core/child/ChildEnv.ts","webpack://@photostructure/library/../core/child/ChildProcess.ts","webpack://@photostructure/library/../core/child/ChildService.ts","webpack://@photostructure/library/../core/child/ChildServiceExitCommand.ts","webpack://@photostructure/library/../core/child/ServiceExitTimeoutMs.ts","webpack://@photostructure/library/../core/child/WatchedChild.ts","webpack://@photostructure/library/../core/ciSafePath.ts","webpack://@photostructure/library/../core/cli/CLI.ts","webpack://@photostructure/library/../core/cli/CliConstants.ts","webpack://@photostructure/library/../core/cli/CliWrap.ts","webpack://@photostructure/library/../core/cli/ColorArgs.ts","webpack://@photostructure/library/../core/cli/DescriptionFooter.ts","webpack://@photostructure/library/../core/cli/IsDaemon.ts","webpack://@photostructure/library/../core/cli/VerifyUidGid.ts","webpack://@photostructure/library/../core/cli/WriteSettingsArg.ts","webpack://@photostructure/library/../core/color/ColorNames.ts","webpack://@photostructure/library/../core/color/Colorspace.ts","webpack://@photostructure/library/../core/color/CrayonColors.ts","webpack://@photostructure/library/../core/color/DarkWikipediaColors.ts","webpack://@photostructure/library/../core/color/DeltaE.ts","webpack://@photostructure/library/../core/color/DominantColor.ts","webpack://@photostructure/library/../core/color/DominantColorCorrelation.ts","webpack://@photostructure/library/../core/color/DominantColors.ts","webpack://@photostructure/library/../core/color/Greys.ts","webpack://@photostructure/library/../core/color/Lab.ts","webpack://@photostructure/library/../core/color/LightWikipediaColors.ts","webpack://@photostructure/library/../core/color/ModeBits.ts","webpack://@photostructure/library/../core/color/ModeCount.ts","webpack://@photostructure/library/../core/color/ModeData.ts","webpack://@photostructure/library/../core/color/RGB.ts","webpack://@photostructure/library/../core/date/Date.ts","webpack://@photostructure/library/../core/date/DateInterval.ts","webpack://@photostructure/library/../core/date/Dated.ts","webpack://@photostructure/library/../core/date/DatedToMillis.ts","webpack://@photostructure/library/../core/date/DefaultDateTimeFormats.ts","webpack://@photostructure/library/../core/date/DurationCodec.ts","webpack://@photostructure/library/../core/date/DurationFormat.ts","webpack://@photostructure/library/../core/date/ExifDateTime.ts","webpack://@photostructure/library/../core/date/ExtendedDate.ts","webpack://@photostructure/library/../core/date/Filestamp.ts","webpack://@photostructure/library/../core/date/FuzzyDate.ts","webpack://@photostructure/library/../core/date/FuzzyDateParser.ts","webpack://@photostructure/library/../core/date/GetDateField.ts","webpack://@photostructure/library/../core/date/HasTime.ts","webpack://@photostructure/library/../core/date/IsDateTime.ts","webpack://@photostructure/library/../core/date/Localtime.ts","webpack://@photostructure/library/../core/date/Month.ts","webpack://@photostructure/library/../core/date/SetupLuxon.ts","webpack://@photostructure/library/../core/date/Timezone.ts","webpack://@photostructure/library/../core/date/ValidDate.ts","webpack://@photostructure/library/../core/date/getZoneName.ts","webpack://@photostructure/library/../core/db/AutoVacuumModes.ts","webpack://@photostructure/library/../core/db/CacheDbDir.ts","webpack://@photostructure/library/../core/db/CheckLocalDbReplica.ts","webpack://@photostructure/library/../core/db/CheckpointTypes.ts","webpack://@photostructure/library/../core/db/DbBackupCold.ts","webpack://@photostructure/library/../core/db/DbRetries.ts","webpack://@photostructure/library/../core/db/MkDb.ts","webpack://@photostructure/library/../core/db/RepairModes.ts","webpack://@photostructure/library/../core/db/SQLiteFiles.ts","webpack://@photostructure/library/../core/db/SQLiteReadWrite.ts","webpack://@photostructure/library/../core/db/SQLiteSuffixes.ts","webpack://@photostructure/library/../core/db/SQLiteVersion.ts","webpack://@photostructure/library/../core/db/Schemas.ts","webpack://@photostructure/library/../core/db/SynchronousModes.ts","webpack://@photostructure/library/../core/dir/CacheDir.ts","webpack://@photostructure/library/../core/dir/ConfigDir.ts","webpack://@photostructure/library/../core/dir/DefaultApplePhotosLibrary.ts","webpack://@photostructure/library/../core/dir/DefaultDockerLibraryDir.ts","webpack://@photostructure/library/../core/dir/DefaultLibraryDir.ts","webpack://@photostructure/library/../core/dir/DesktopConfigDir.ts","webpack://@photostructure/library/../core/dir/EnvConfigDir.ts","webpack://@photostructure/library/../core/dir/FirstDir.ts","webpack://@photostructure/library/../core/dir/HomeDir.ts","webpack://@photostructure/library/../core/dir/InHiddenPhotoStructureDir.ts","webpack://@photostructure/library/../core/dir/LibraryDir.ts","webpack://@photostructure/library/../core/dir/LibraryDirs.ts","webpack://@photostructure/library/../core/dir/LogDir.ts","webpack://@photostructure/library/../core/dir/PicturesDir.ts","webpack://@photostructure/library/../core/env/DevEnvFlags.ts","webpack://@photostructure/library/../core/env/Env.ts","webpack://@photostructure/library/../core/env/EnvKeys.ts","webpack://@photostructure/library/../core/env/EnvName.ts","webpack://@photostructure/library/../core/env/EnvTokens.ts","webpack://@photostructure/library/../core/env/GetEnv.ts","webpack://@photostructure/library/../core/error/Error.ts","webpack://@photostructure/library/../core/error/ErrorCodes.ts","webpack://@photostructure/library/../core/error/ErrorFlags.ts","webpack://@photostructure/library/../core/error/ErrorStore.ts","webpack://@photostructure/library/../core/error/ErrorTypes.ts","webpack://@photostructure/library/../core/error/InternalError.ts","webpack://@photostructure/library/../core/error/OnError.ts","webpack://@photostructure/library/../core/error/WrappedError.ts","webpack://@photostructure/library/../core/error/stack.ts","webpack://@photostructure/library/../core/event/BroadcastEvent.ts","webpack://@photostructure/library/../core/event/CapturingEventEmitter.ts","webpack://@photostructure/library/../core/event/DefaultSharedStateDir.ts","webpack://@photostructure/library/../core/event/EventEmitter.ts","webpack://@photostructure/library/../core/event/IsSyncing.ts","webpack://@photostructure/library/../core/event/PhotoStructureEvents.ts","webpack://@photostructure/library/../core/event/SharedState.ts","webpack://@photostructure/library/../core/event/TaskProcessor.ts","webpack://@photostructure/library/../core/event/UpdateReadyToInstall.ts","webpack://@photostructure/library/../core/fs/Access.ts","webpack://@photostructure/library/../core/fs/ActualPath.ts","webpack://@photostructure/library/../core/fs/Ancestors.ts","webpack://@photostructure/library/../core/fs/BaseFile.ts","webpack://@photostructure/library/../core/fs/BaseFilePredicates.ts","webpack://@photostructure/library/../core/fs/CRLF.ts","webpack://@photostructure/library/../core/fs/CachedirTag.ts","webpack://@photostructure/library/../core/fs/DefaultPaths.ts","webpack://@photostructure/library/../core/fs/DirWatcher.ts","webpack://@photostructure/library/../core/fs/DirectoryEntry.ts","webpack://@photostructure/library/../core/fs/DirectoryIterator.ts","webpack://@photostructure/library/../core/fs/DirectoryWalker.ts","webpack://@photostructure/library/../core/fs/EnsureNew.ts","webpack://@photostructure/library/../core/fs/Excluded.ts","webpack://@photostructure/library/../core/fs/FileCache.ts","webpack://@photostructure/library/../core/fs/FileCleanup.ts","webpack://@photostructure/library/../core/fs/FileExt.ts","webpack://@photostructure/library/../core/fs/FileStats.ts","webpack://@photostructure/library/../core/fs/FileType.ts","webpack://@photostructure/library/../core/fs/FsAdvisoryLocks.ts","webpack://@photostructure/library/../core/fs/FsLock.ts","webpack://@photostructure/library/../core/fs/FsLockDir.ts","webpack://@photostructure/library/../core/fs/FsWatcher.ts","webpack://@photostructure/library/../core/fs/FuzzyNames.ts","webpack://@photostructure/library/../core/fs/GrepReader.ts","webpack://@photostructure/library/../core/fs/Gzip.ts","webpack://@photostructure/library/../core/fs/Hash.ts","webpack://@photostructure/library/../core/fs/Hidden.ts","webpack://@photostructure/library/../core/fs/IgnorableMountpoint.ts","webpack://@photostructure/library/../core/fs/JpegExts.ts","webpack://@photostructure/library/../core/fs/JsonFileStore.ts","webpack://@photostructure/library/../core/fs/LineReader.ts","webpack://@photostructure/library/../core/fs/MkNoMedia.ts","webpack://@photostructure/library/../core/fs/NativePathsEql.ts","webpack://@photostructure/library/../core/fs/NoMedia.ts","webpack://@photostructure/library/../core/fs/Path.ts","webpack://@photostructure/library/../core/fs/PathTo.ts","webpack://@photostructure/library/../core/fs/PosixFile.ts","webpack://@photostructure/library/../core/fs/PosixFileFilters.ts","webpack://@photostructure/library/../core/fs/PosixNative.ts","webpack://@photostructure/library/../core/fs/ProjectPath.ts","webpack://@photostructure/library/../core/fs/ReadFile.ts","webpack://@photostructure/library/../core/fs/ReadFilePart.ts","webpack://@photostructure/library/../core/fs/ReadLines.ts","webpack://@photostructure/library/../core/fs/ReadableBuffer.ts","webpack://@photostructure/library/../core/fs/Readdir.ts","webpack://@photostructure/library/../core/fs/SeemsLikeSymlinkLoop.ts","webpack://@photostructure/library/../core/fs/SimpleDirent.ts","webpack://@photostructure/library/../core/fs/SimpleFile.ts","webpack://@photostructure/library/../core/fs/Stat.ts","webpack://@photostructure/library/../core/fs/StatSync.ts","webpack://@photostructure/library/../core/fs/StatTimeout.ts","webpack://@photostructure/library/../core/fs/StreamChunker.ts","webpack://@photostructure/library/../core/fs/StreamEnded.ts","webpack://@photostructure/library/../core/fs/Streams.ts","webpack://@photostructure/library/../core/fs/SyncReport.ts","webpack://@photostructure/library/../core/fs/SyncReportReader.ts","webpack://@photostructure/library/../core/fs/Tools.ts","webpack://@photostructure/library/../core/fs/Touch.ts","webpack://@photostructure/library/../core/fs/UIDStore.ts","webpack://@photostructure/library/../core/fs/Unlink.ts","webpack://@photostructure/library/../core/fs/WIP.ts","webpack://@photostructure/library/../core/fs/WritableToBuffer.ts","webpack://@photostructure/library/../core/fs/WriteFile.ts","webpack://@photostructure/library/../core/fs/zcat.ts","webpack://@photostructure/library/../core/health/ExiftoolHealthCheck.ts","webpack://@photostructure/library/../core/health/ExternalDirsHealthCheck.ts","webpack://@photostructure/library/../core/health/HealthCheck.ts","webpack://@photostructure/library/../core/health/HealthCheckIds.ts","webpack://@photostructure/library/../core/health/HealthCheckSetup.ts","webpack://@photostructure/library/../core/health/HeifHealthCheck.ts","webpack://@photostructure/library/../core/health/LibraryAdminLinks.ts","webpack://@photostructure/library/../core/health/LibraryDirectoriesCheck.ts","webpack://@photostructure/library/../core/health/LibraryFreeSpaceCheck.ts","webpack://@photostructure/library/../core/health/MemoryHealthCheck.ts","webpack://@photostructure/library/../core/health/NodeHealthCheck.ts","webpack://@photostructure/library/../core/health/NotInDMGHealthCheck.ts","webpack://@photostructure/library/../core/health/OSHealthCheck.ts","webpack://@photostructure/library/../core/health/PowerShellHealthCheck.ts","webpack://@photostructure/library/../core/health/SQLiteVersionHealthCheck.ts","webpack://@photostructure/library/../core/health/SecurityHealthCheck.ts","webpack://@photostructure/library/../core/health/SettingsEnvHealthCheck.ts","webpack://@photostructure/library/../core/health/SettingsLibraryHealthCheck.ts","webpack://@photostructure/library/../core/health/SettingsSystemHealthCheck.ts","webpack://@photostructure/library/../core/health/SystemLoadHealthCheck.ts","webpack://@photostructure/library/../core/health/VersionHealthCheck.ts","webpack://@photostructure/library/../core/health/VideoHealthCheck.ts","webpack://@photostructure/library/../core/health/VolumeHealthCheck.ts","webpack://@photostructure/library/../core/img/AssetPreviewBuilder.ts","webpack://@photostructure/library/../core/img/AssetPreviewInfo.ts","webpack://@photostructure/library/../core/img/AssetPreviews.ts","webpack://@photostructure/library/../core/img/CropStrategies.ts","webpack://@photostructure/library/../core/img/DCTHash.ts","webpack://@photostructure/library/../core/img/Dimensions.ts","webpack://@photostructure/library/../core/img/FileDimensions.ts","webpack://@photostructure/library/../core/img/FitSizes.ts","webpack://@photostructure/library/../core/img/Heif.ts","webpack://@photostructure/library/../core/img/HeifConvert.ts","webpack://@photostructure/library/../core/img/HeifFilter.ts","webpack://@photostructure/library/../core/img/ImageCache.ts","webpack://@photostructure/library/../core/img/ImageHash.ts","webpack://@photostructure/library/../core/img/ImageHashComparison.ts","webpack://@photostructure/library/../core/img/ImageSize.ts","webpack://@photostructure/library/../core/img/IncludePreviewTags.ts","webpack://@photostructure/library/../core/img/MeanDiffHash.ts","webpack://@photostructure/library/../core/img/PrepFileForBrowser.ts","webpack://@photostructure/library/../core/img/Previews.ts","webpack://@photostructure/library/../core/img/Ratio.ts","webpack://@photostructure/library/../core/img/RawInfo.ts","webpack://@photostructure/library/../core/img/Reducers.ts","webpack://@photostructure/library/../core/img/Sharp.ts","webpack://@photostructure/library/../core/img/SharpFailOn.ts","webpack://@photostructure/library/../core/img/SharpReadable.ts","webpack://@photostructure/library/../core/img/SyncFileTimeout.ts","webpack://@photostructure/library/../core/img/ValidFile.ts","webpack://@photostructure/library/../core/img/ValidationErrors.ts","webpack://@photostructure/library/../core/img/Video.ts","webpack://@photostructure/library/../core/img/ffmpeg.ts","webpack://@photostructure/library/../core/img/ffmpegThreads.ts","webpack://@photostructure/library/../core/img/jpegtran.ts","webpack://@photostructure/library/../core/img/libraw.ts","webpack://@photostructure/library/../core/img/sips.ts","webpack://@photostructure/library/../core/licensing/AutoRefreshLicense.ts","webpack://@photostructure/library/../core/licensing/BrotliDecode.ts","webpack://@photostructure/library/../core/licensing/Email.ts","webpack://@photostructure/library/../core/licensing/L.ts","webpack://@photostructure/library/../core/licensing/Licensing.ts","webpack://@photostructure/library/../core/licensing/Paseto.ts","webpack://@photostructure/library/../core/licensing/SystemIdSchemes.ts","webpack://@photostructure/library/../core/licensing/SystemIds.ts","webpack://@photostructure/library/../core/licensing/UserTimeoutMs.ts","webpack://@photostructure/library/../core/licensing/WriteLicense.ts","webpack://@photostructure/library/../core/log/AllRecentLogEntries.ts","webpack://@photostructure/library/../core/log/ColoredLogFormatter.ts","webpack://@photostructure/library/../core/log/ConsoleLogger.ts","webpack://@photostructure/library/../core/log/ContextualLogger.ts","webpack://@photostructure/library/../core/log/CurrentFileLogger.ts","webpack://@photostructure/library/../core/log/DefaultLogFormatter.ts","webpack://@photostructure/library/../core/log/GelfLogFormatter.ts","webpack://@photostructure/library/../core/log/LogBroadcaster.ts","webpack://@photostructure/library/../core/log/LogCommon.ts","webpack://@photostructure/library/../core/log/LogDir.ts","webpack://@photostructure/library/../core/log/LogDirCleanup.ts","webpack://@photostructure/library/../core/log/LogEntry.ts","webpack://@photostructure/library/../core/log/LogFilter.ts","webpack://@photostructure/library/../core/log/LogFilterImpl.ts","webpack://@photostructure/library/../core/log/LogLevel.ts","webpack://@photostructure/library/../core/log/LogMeta.ts","webpack://@photostructure/library/../core/log/LogReader.ts","webpack://@photostructure/library/../core/log/LogTail.ts","webpack://@photostructure/library/../core/log/LogTailEntries.ts","webpack://@photostructure/library/../core/log/LogWriter.ts","webpack://@photostructure/library/../core/log/PlaintextLogFormatter.ts","webpack://@photostructure/library/../core/log/ReadLogEntries.ts","webpack://@photostructure/library/../core/log/RecentLogs.ts","webpack://@photostructure/library/../core/log/SetupLogger.ts","webpack://@photostructure/library/../core/log/WriteRecentLogEntries.ts","webpack://@photostructure/library/../core/math/Average.ts","webpack://@photostructure/library/../core/math/Bits.ts","webpack://@photostructure/library/../core/math/ETA.ts","webpack://@photostructure/library/../core/math/Kmeans.ts","webpack://@photostructure/library/../core/math/Lerp.ts","webpack://@photostructure/library/../core/math/Matrix.ts","webpack://@photostructure/library/../core/math/PRNG.ts","webpack://@photostructure/library/../core/math/Radix.ts","webpack://@photostructure/library/../core/math/Rate.ts","webpack://@photostructure/library/../core/math/RomanNumerals.ts","webpack://@photostructure/library/../core/math/SquareMatrix.ts","webpack://@photostructure/library/../core/math/UUID.ts","webpack://@photostructure/library/../core/math/Vector.ts","webpack://@photostructure/library/../core/math/b64.ts","webpack://@photostructure/library/../core/net/Hostname.ts","webpack://@photostructure/library/../core/net/Request.ts","webpack://@photostructure/library/../core/net/ip.ts","webpack://@photostructure/library/../core/net/nslookup.ts","webpack://@photostructure/library/../core/net/ping.ts","webpack://@photostructure/library/../core/platform/Apt.ts","webpack://@photostructure/library/../core/platform/IsPacked.ts","webpack://@photostructure/library/../core/platform/Platform.ts","webpack://@photostructure/library/../core/platform/isDocker.ts","webpack://@photostructure/library/../core/platform/isRaspberryPi.ts","webpack://@photostructure/library/../core/predicates/PredicateNames.ts","webpack://@photostructure/library/../core/predicates/Predicates.ts","webpack://@photostructure/library/../core/predicates/SyncPredicates.ts","webpack://@photostructure/library/../core/progress/ProgressEvt.ts","webpack://@photostructure/library/../core/progress/ProgressObserver.ts","webpack://@photostructure/library/../core/progress/PullProgressObserver.ts","webpack://@photostructure/library/../core/progress/PushProgressObserver.ts","webpack://@photostructure/library/../core/pwsh/PowerShell.ts","webpack://@photostructure/library/../core/settings/AggregateTypes.ts","webpack://@photostructure/library/../core/settings/AssetFileSortCriteria.ts","webpack://@photostructure/library/../core/settings/BooleanSetting.ts","webpack://@photostructure/library/../core/settings/BoundedFloatSetting.ts","webpack://@photostructure/library/../core/settings/BoundedIntegerSetting.ts","webpack://@photostructure/library/../core/settings/ColorDistanceFunctions.ts","webpack://@photostructure/library/../core/settings/DominantColorKmeansRunsDefault.ts","webpack://@photostructure/library/../core/settings/DominantColorPixelsDefault.ts","webpack://@photostructure/library/../core/settings/DurationSetting.ts","webpack://@photostructure/library/../core/settings/FloatSetting.ts","webpack://@photostructure/library/../core/settings/ForceContext.ts","webpack://@photostructure/library/../core/settings/IntegerSetting.ts","webpack://@photostructure/library/../core/settings/MergeConfigDirs.ts","webpack://@photostructure/library/../core/settings/MetaSettings.ts","webpack://@photostructure/library/../core/settings/MinValidYear.ts","webpack://@photostructure/library/../core/settings/OptionalFileSetting.ts","webpack://@photostructure/library/../core/settings/OptionalFloatSetting.ts","webpack://@photostructure/library/../core/settings/OptionalIntegerSetting.ts","webpack://@photostructure/library/../core/settings/OptionalStringSetting.ts","webpack://@photostructure/library/../core/settings/PathToLibraryAsset.ts","webpack://@photostructure/library/../core/settings/PsEnvNames.ts","webpack://@photostructure/library/../core/settings/Setting.ts","webpack://@photostructure/library/../core/settings/SettingCategory.ts","webpack://@photostructure/library/../core/settings/Settings.ts","webpack://@photostructure/library/../core/settings/SettingsDefaults.ts","webpack://@photostructure/library/../core/settings/SettingsIO.ts","webpack://@photostructure/library/../core/settings/SettingsToml.ts","webpack://@photostructure/library/../core/settings/StringArraySetting.ts","webpack://@photostructure/library/../core/settings/StringEnumSetting.ts","webpack://@photostructure/library/../core/settings/StringEnumsSetting.ts","webpack://@photostructure/library/../core/settings/StringSetting.ts","webpack://@photostructure/library/../core/settings/SystemSettings.ts","webpack://@photostructure/library/../core/settings/TagInferenceSettingValues.ts","webpack://@photostructure/library/../core/settings/Toml.ts","webpack://@photostructure/library/../core/settings/TomlStringify.ts","webpack://@photostructure/library/../core/settings/ValueToS.ts","webpack://@photostructure/library/../core/settings/VerifyPsEnvSettings.ts","webpack://@photostructure/library/../core/settings/WrapComments.ts","webpack://@photostructure/library/../core/settings/ffmpegScaleType.ts","webpack://@photostructure/library/../core/tags/Bitrate.ts","webpack://@photostructure/library/../core/tags/Bname.ts","webpack://@photostructure/library/../core/tags/CapturedAt.ts","webpack://@photostructure/library/../core/tags/DateTagFormats.ts","webpack://@photostructure/library/../core/tags/DefaultCapturedAtTags.ts","webpack://@photostructure/library/../core/tags/DefaultIncludedPreviewTags.ts","webpack://@photostructure/library/../core/tags/DefaultLensMakes.ts","webpack://@photostructure/library/../core/tags/Duration.ts","webpack://@photostructure/library/../core/tags/ExifTool.ts","webpack://@photostructure/library/../core/tags/ExifUid.ts","webpack://@photostructure/library/../core/tags/ExifUnset.ts","webpack://@photostructure/library/../core/tags/ExposureSettings.ts","webpack://@photostructure/library/../core/tags/ExtType.ts","webpack://@photostructure/library/../core/tags/FileTypes.ts","webpack://@photostructure/library/../core/tags/History.ts","webpack://@photostructure/library/../core/tags/InferTimezone.ts","webpack://@photostructure/library/../core/tags/JsonSidecar.ts","webpack://@photostructure/library/../core/tags/KeywordReparentingStrategies.ts","webpack://@photostructure/library/../core/tags/KeywordTags.ts","webpack://@photostructure/library/../core/tags/LensMakeModel.ts","webpack://@photostructure/library/../core/tags/MakeModel.ts","webpack://@photostructure/library/../core/tags/MergedTags.ts","webpack://@photostructure/library/../core/tags/MimeTypes.ts","webpack://@photostructure/library/../core/tags/NameTagFormats.ts","webpack://@photostructure/library/../core/tags/NameTagOrders.ts","webpack://@photostructure/library/../core/tags/Names.ts","webpack://@photostructure/library/../core/tags/Orientation.ts","webpack://@photostructure/library/../core/tags/Rating.ts","webpack://@photostructure/library/../core/tags/ReadMimeType.ts","webpack://@photostructure/library/../core/tags/Sidecars.ts","webpack://@photostructure/library/../core/tags/SizeInfo.ts","webpack://@photostructure/library/../core/tags/TagInference.ts","webpack://@photostructure/library/../core/tags/TagPaths.ts","webpack://@photostructure/library/../core/tags/TitleDescription.ts","webpack://@photostructure/library/../core/uri/FileURI.ts","webpack://@photostructure/library/../core/uri/URI.ts","webpack://@photostructure/library/../core/uri/UriNormalization.ts","webpack://@photostructure/library/../core/uri/psfile.ts","webpack://@photostructure/library/../core/uri/pslib.ts","webpack://@photostructure/library/../core/uri/psnet.ts","webpack://@photostructure/library/../core/uri/volsha.ts","webpack://@photostructure/library/../core/version/ChannelVersionsCache.ts","webpack://@photostructure/library/../core/version/PhotoStructureVersion.ts","webpack://@photostructure/library/../core/version/SemVer.ts","webpack://@photostructure/library/../core/version/UpdateChannelVersion.ts","webpack://@photostructure/library/../core/version/UpdateChannels.ts","webpack://@photostructure/library/../core/version/Ver.ts","webpack://@photostructure/library/../core/version/VersionCheck.ts","webpack://@photostructure/library/../core/volumes/AssetMountpoint.ts","webpack://@photostructure/library/../core/volumes/CurrentVolumes.ts","webpack://@photostructure/library/../core/volumes/DefaultExcludedLinuxRoots.ts","webpack://@photostructure/library/../core/volumes/DefaultIgnorableFilesystemTypes.ts","webpack://@photostructure/library/../core/volumes/DfPosix.ts","webpack://@photostructure/library/../core/volumes/DfPosixRaw.ts","webpack://@photostructure/library/../core/volumes/DfWin.ts","webpack://@photostructure/library/../core/volumes/Gio.ts","webpack://@photostructure/library/../core/volumes/LazyFsAsync.ts","webpack://@photostructure/library/../core/volumes/LocalVolumesLinux.ts","webpack://@photostructure/library/../core/volumes/LocalVolumesMac.ts","webpack://@photostructure/library/../core/volumes/Mountpoints.ts","webpack://@photostructure/library/../core/volumes/MountpointsPosix.ts","webpack://@photostructure/library/../core/volumes/MountpointsWin.ts","webpack://@photostructure/library/../core/volumes/PosixVolumes.ts","webpack://@photostructure/library/../core/volumes/RemoteVolumesPosix.ts","webpack://@photostructure/library/../core/volumes/RemoteVolumesWin.ts","webpack://@photostructure/library/../core/volumes/VolumeTtls.ts","webpack://@photostructure/library/../core/volumes/VolumeUUID.ts","webpack://@photostructure/library/../core/volumes/Volumes.ts","webpack://@photostructure/library/../core/volumes/WriteVolumeUuid.ts","webpack://@photostructure/library/../core/web/HelmetPlugins.ts","webpack://@photostructure/library/../core/web/HttpGet.ts","webpack://@photostructure/library/../core/web/HttpStatus.ts","webpack://@photostructure/library/../core/web/UriToTagPath.ts","webpack://@photostructure/library/../core/web/WebUrls.ts","webpack://@photostructure/library/../core/words/Cuss.ts","webpack://@photostructure/library/../core/words/Leet.ts","webpack://@photostructure/library/../core/work/CpuInfo.ts","webpack://@photostructure/library/../core/work/CpuUsage.ts","webpack://@photostructure/library/../core/work/DoNotRun.ts","webpack://@photostructure/library/../core/work/FreeMem.ts","webpack://@photostructure/library/../core/work/IsPaused.ts","webpack://@photostructure/library/../core/work/MaxCpus.ts","webpack://@photostructure/library/../core/work/WorkTimeout.ts","webpack://@photostructure/library/../core/worker/RequestTask.ts","webpack://@photostructure/library/../core/worker/ShimDelegation.ts","webpack://@photostructure/library/../core/worker/WorkRequests.ts","webpack://@photostructure/library/../core/worker/WorkerCluster.ts","webpack://@photostructure/library/../core/worker/WorkerEnv.ts","webpack://@photostructure/library/../core/worker/ping.ts","webpack://@photostructure/library/../fe/Array.ts","webpack://@photostructure/library/../fe/ArrayCopy.ts","webpack://@photostructure/library/../fe/ArraySort.ts","webpack://@photostructure/library/../fe/AsPromise.ts","webpack://@photostructure/library/../fe/AssetUrls.ts","webpack://@photostructure/library/../fe/AsyncRetry.ts","webpack://@photostructure/library/../fe/At.ts","webpack://@photostructure/library/../fe/BabyMarkdown.ts","webpack://@photostructure/library/../fe/Blank.ts","webpack://@photostructure/library/../fe/Boolean.ts","webpack://@photostructure/library/../fe/Clone.ts","webpack://@photostructure/library/../fe/Date.ts","webpack://@photostructure/library/../fe/DateToJson.ts","webpack://@photostructure/library/../fe/DeepEql.ts","webpack://@photostructure/library/../fe/Defer.ts","webpack://@photostructure/library/../fe/Delay.ts","webpack://@photostructure/library/../fe/Dimensions.ts","webpack://@photostructure/library/../fe/Eql.ts","webpack://@photostructure/library/../fe/Error.ts","webpack://@photostructure/library/../fe/Fit.ts","webpack://@photostructure/library/../fe/Flatten.ts","webpack://@photostructure/library/../fe/FmtDuration.ts","webpack://@photostructure/library/../fe/FmtList.ts","webpack://@photostructure/library/../fe/HealthChecks.ts","webpack://@photostructure/library/../fe/ImageReducers.ts","webpack://@photostructure/library/../fe/ImageSizes.ts","webpack://@photostructure/library/../fe/Iterable.ts","webpack://@photostructure/library/../fe/JSON.ts","webpack://@photostructure/library/../fe/Latch.ts","webpack://@photostructure/library/../fe/Lazy.ts","webpack://@photostructure/library/../fe/Map.ts","webpack://@photostructure/library/../fe/Maybe.ts","webpack://@photostructure/library/../fe/MultiMap.ts","webpack://@photostructure/library/../fe/NodeOrBrowser.ts","webpack://@photostructure/library/../fe/Number.ts","webpack://@photostructure/library/../fe/Object.ts","webpack://@photostructure/library/../fe/Opt.ts","webpack://@photostructure/library/../fe/PRNG.ts","webpack://@photostructure/library/../fe/Pad.ts","webpack://@photostructure/library/../fe/ParseMaybe.ts","webpack://@photostructure/library/../fe/Pluralize.ts","webpack://@photostructure/library/../fe/Primitive.ts","webpack://@photostructure/library/../fe/Promise.ts","webpack://@photostructure/library/../fe/PromiseState.ts","webpack://@photostructure/library/../fe/Random.ts","webpack://@photostructure/library/../fe/RegExp.ts","webpack://@photostructure/library/../fe/Rotation.ts","webpack://@photostructure/library/../fe/RunStateEnum.ts","webpack://@photostructure/library/../fe/ServiceNames.ts","webpack://@photostructure/library/../fe/SplitFirst.ts","webpack://@photostructure/library/../fe/StrEnum.ts","webpack://@photostructure/library/../fe/String.ts","webpack://@photostructure/library/../fe/ThenOrTimeout.ts","webpack://@photostructure/library/../fe/Throttle.ts","webpack://@photostructure/library/../fe/Thunk.ts","webpack://@photostructure/library/../fe/TimeoutError.ts","webpack://@photostructure/library/../fe/URI.ts","webpack://@photostructure/library/../fe/URLSearchParams.ts","webpack://@photostructure/library/../fe/Units.ts","webpack://@photostructure/library/../fe/UnreachableCaseError.ts","webpack://@photostructure/library/../fe/UnrefTimeout.ts","webpack://@photostructure/library/../fe/UserAgent.ts","webpack://@photostructure/library/../fe/UserAgents.ts","webpack://@photostructure/library/../fe/api/ID.ts","webpack://@photostructure/library/../fe/api/ProgressState.ts","webpack://@photostructure/library/../fe/api/Subscriptions.ts","webpack://@photostructure/library/../fe/api/Tag.ts","webpack://@photostructure/library/../fe/app/FullPaths.ts","webpack://@photostructure/library/../fe/isError.ts","webpack://@photostructure/library/../fe/isFunction.ts","webpack://@photostructure/library/../fe/toA.ts","webpack://@photostructure/library/../fe/toErr.ts","webpack://@photostructure/library/../fe/toS.ts","webpack://@photostructure/library/./Cleanup.ts","webpack://@photostructure/library/./ForceRebuildLibrary.ts","webpack://@photostructure/library/./Library.ts","webpack://@photostructure/library/./LibraryFileFilters.ts","webpack://@photostructure/library/./SentryEnabled.ts","webpack://@photostructure/library/./SentrySetup.ts","webpack://@photostructure/library/./Service.ts","webpack://@photostructure/library/./SetVolumesTTL.ts","webpack://@photostructure/library/./StatsDbDir.ts","webpack://@photostructure/library/./WorkQueue.ts","webpack://@photostructure/library/./cli/DropWorkQueuesArgs.ts","webpack://@photostructure/library/./cli/ExitWhenDone.ts","webpack://@photostructure/library/./cli/ExitWhenDoneArg.ts","webpack://@photostructure/library/./cli/ForceArg.ts","webpack://@photostructure/library/./cli/LogArgs.ts","webpack://@photostructure/library/./cli/NoFilterArg.ts","webpack://@photostructure/library/./cli/RebuildArg.ts","webpack://@photostructure/library/./cli/SkipUpdateArg.ts","webpack://@photostructure/library/./curators/AlbumTagger.ts","webpack://@photostructure/library/./curators/AssetTagger.ts","webpack://@photostructure/library/./curators/CameraTagger.ts","webpack://@photostructure/library/./curators/DateTagger.ts","webpack://@photostructure/library/./curators/FilePathTagger.ts","webpack://@photostructure/library/./curators/KeywordTagger.ts","webpack://@photostructure/library/./curators/LensTagger.ts","webpack://@photostructure/library/./curators/Taggers.ts","webpack://@photostructure/library/./curators/TypeTagger.ts","webpack://@photostructure/library/./curators/WhoTagger.ts","webpack://@photostructure/library/./db/Db.ts","webpack://@photostructure/library/./db/DbModelJanitor.ts","webpack://@photostructure/library/./db/DbModelSetup.ts","webpack://@photostructure/library/./db/DbRequest.ts","webpack://@photostructure/library/./db/DbSchemaValid.ts","webpack://@photostructure/library/./db/DbSetupErrors.ts","webpack://@photostructure/library/./db/DbValued.ts","webpack://@photostructure/library/./db/DedupeTags.ts","webpack://@photostructure/library/./db/Knex.ts","webpack://@photostructure/library/./db/Migration.ts","webpack://@photostructure/library/./db/Migrations.ts","webpack://@photostructure/library/./db/SQLite.ts","webpack://@photostructure/library/./db/SqlQuery.ts","webpack://@photostructure/library/./db/TableInfo.ts","webpack://@photostructure/library/./db/WithDb.ts","webpack://@photostructure/library/./health/DbModelHealthCheck.ts","webpack://@photostructure/library/./health/LibraryHealthChecks.ts","webpack://@photostructure/library/./health/SyncHealthCheck.ts","webpack://@photostructure/library/./health/VolumeUuidHealthCheck.ts","webpack://@photostructure/library/./model/Asset.ts","webpack://@photostructure/library/./model/AssetFile.ts","webpack://@photostructure/library/./model/AssetId.ts","webpack://@photostructure/library/./model/AssetRevision.ts","webpack://@photostructure/library/./model/AssetTag.ts","webpack://@photostructure/library/./model/ChangedTag.ts","webpack://@photostructure/library/./model/DateTagNormalizer.ts","webpack://@photostructure/library/./model/Heartbeat.ts","webpack://@photostructure/library/./model/MaintenanceTasks.ts","webpack://@photostructure/library/./model/Model.ts","webpack://@photostructure/library/./model/ModelDb.ts","webpack://@photostructure/library/./model/ModelJson.ts","webpack://@photostructure/library/./model/ModelOps.ts","webpack://@photostructure/library/./model/Operation.ts","webpack://@photostructure/library/./model/Progress.ts","webpack://@photostructure/library/./model/ProgressMeta.ts","webpack://@photostructure/library/./model/ShaBlocklist.ts","webpack://@photostructure/library/./model/Tag.ts","webpack://@photostructure/library/./model/TagFts.ts","webpack://@photostructure/library/./model/TaggedAssetStream.ts","webpack://@photostructure/library/./model/TimestampedModel.ts","webpack://@photostructure/library/./operations/ApplyRemovable.ts","webpack://@photostructure/library/./operations/CheckPendingOperations.ts","webpack://@photostructure/library/./stats/Queue.ts","webpack://@photostructure/library/./stats/QueueItem.ts","webpack://@photostructure/library/./stats/StatsDb.ts","webpack://@photostructure/library/./stats/StatsDbJanitor.ts","webpack://@photostructure/library/./stats/StatsModel.ts","webpack://@photostructure/library/./sync-file/AssetFileFinder.ts","webpack://@photostructure/library/./sync-file/AssetFileImporter.ts","webpack://@photostructure/library/./sync-file/AssetFileRepository.ts","webpack://@photostructure/library/./sync-file/AssetPostUpsertTasks.ts","webpack://@photostructure/library/./sync-file/ImportResult.ts","webpack://@photostructure/library/./sync-file/UpdateAsset.ts","webpack://@photostructure/library/./sync-file/UpdateAssetFile.ts","webpack://@photostructure/library/./sync-file/UpdateAssetPreviews.ts","webpack://@photostructure/library/./sync-file/UpdateResult.ts","webpack://@photostructure/library/./sync-file/UpdateTask.ts","webpack://@photostructure/library/./sync.ts","webpack://@photostructure/library/./sync/AssetFileQueue.ts","webpack://@photostructure/library/./sync/AssetPostUpsertQueue.ts","webpack://@photostructure/library/./sync/AssetUpdateQueue.ts","webpack://@photostructure/library/./sync/DirectorySync.ts","webpack://@photostructure/library/./sync/DirectoryTaggerOperation.ts","webpack://@photostructure/library/./sync/FileSync.ts","webpack://@photostructure/library/./sync/ModelDbUpdater.ts","webpack://@photostructure/library/./sync/PathsToSync.ts","webpack://@photostructure/library/./sync/PrecheckFiles.ts","webpack://@photostructure/library/./sync/ProgressUpdater.ts","webpack://@photostructure/library/./sync/SyncCompleted.ts","webpack://@photostructure/library/./sync/SyncPaths.ts","webpack://@photostructure/library/./sync/SyncRunner.ts","webpack://@photostructure/library/./sync/SyncService.ts","webpack://@photostructure/library/./sync/Syncs.ts","webpack://@photostructure/library/./sync/UpdateQueue.ts","webpack://@photostructure/library/./sync/UriPath.ts","webpack://@photostructure/library/./tag/TagFtsFns.ts","webpack://@photostructure/library/./tag/TagSql.ts","webpack://@photostructure/library/external commonjs \"@iarna/toml\"","webpack://@photostructure/library/external commonjs \"@parcel/watcher\"","webpack://@photostructure/library/external commonjs \"@photostructure/tz-lookup\"","webpack://@photostructure/library/external commonjs \"@sentry/node\"","webpack://@photostructure/library/external commonjs \"assert\"","webpack://@photostructure/library/external commonjs \"axios\"","webpack://@photostructure/library/external commonjs \"batch-cluster\"","webpack://@photostructure/library/external commonjs \"better-sqlite3\"","webpack://@photostructure/library/external commonjs \"commander\"","webpack://@photostructure/library/external commonjs \"events\"","webpack://@photostructure/library/external commonjs \"exiftool-vendored\"","webpack://@photostructure/library/external commonjs \"fast-xml-parser\"","webpack://@photostructure/library/external commonjs \"file-type\"","webpack://@photostructure/library/external commonjs \"fs-extra\"","webpack://@photostructure/library/external commonjs \"he\"","webpack://@photostructure/library/external commonjs \"knex\"","webpack://@photostructure/library/external commonjs \"luxon\"","webpack://@photostructure/library/external commonjs \"ml-kmeans\"","webpack://@photostructure/library/external commonjs \"papaparse\"","webpack://@photostructure/library/external commonjs \"picomatch\"","webpack://@photostructure/library/external commonjs \"platform-folders\"","webpack://@photostructure/library/external commonjs \"plist\"","webpack://@photostructure/library/external commonjs \"process\"","webpack://@photostructure/library/external commonjs \"punycode\"","webpack://@photostructure/library/external commonjs \"semver\"","webpack://@photostructure/library/external commonjs \"sharp\"","webpack://@photostructure/library/external commonjs \"source-map-support\"","webpack://@photostructure/library/external commonjs \"trash\"","webpack://@photostructure/library/external commonjs \"type-detect\"","webpack://@photostructure/library/external commonjs \"util\"","webpack://@photostructure/library/external commonjs \"util/types\"","webpack://@photostructure/library/external commonjs \"utimes\"","webpack://@photostructure/library/external node-commonjs \"child_process\"","webpack://@photostructure/library/external node-commonjs \"cluster\"","webpack://@photostructure/library/external node-commonjs \"crypto\"","webpack://@photostructure/library/external node-commonjs \"dns\"","webpack://@photostructure/library/external node-commonjs \"fs\"","webpack://@photostructure/library/external node-commonjs \"fs/promises\"","webpack://@photostructure/library/external node-commonjs \"https\"","webpack://@photostructure/library/external node-commonjs \"net\"","webpack://@photostructure/library/external node-commonjs \"node:fs/promises\"","webpack://@photostructure/library/external node-commonjs \"node:os\"","webpack://@photostructure/library/external node-commonjs \"node:path/posix\"","webpack://@photostructure/library/external node-commonjs \"node:process\"","webpack://@photostructure/library/external node-commonjs \"os\"","webpack://@photostructure/library/external node-commonjs \"path\"","webpack://@photostructure/library/external node-commonjs \"stream\"","webpack://@photostructure/library/external node-commonjs \"stream/promises\"","webpack://@photostructure/library/external node-commonjs \"timers\"","webpack://@photostructure/library/external node-commonjs \"zlib\"","webpack://@photostructure/library/webpack/bootstrap","webpack://@photostructure/library/webpack/runtime/node module decorator","webpack://@photostructure/library/webpack/startup"],"sourcesContent":["const CODES = {\n  PasetoNotSupported: 'ERR_PASETO_NOT_SUPPORTED',\n  PasetoDecryptionFailed: 'ERR_PASETO_DECRYPTION_FAILED',\n  PasetoInvalid: 'ERR_PASETO_INVALID',\n  PasetoVerificationFailed: 'ERR_PASETO_VERIFICATION_FAILED',\n  PasetoClaimInvalid: 'ERR_PASETO_CLAIM_INVALID',\n}\n\nclass PasetoError extends Error {\n  constructor(message) {\n    super(message)\n    this.name = this.constructor.name\n    this.code = CODES[this.constructor.name]\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\nmodule.exports.PasetoError = PasetoError\n\nmodule.exports.PasetoNotSupported = class PasetoNotSupported extends PasetoError {}\nmodule.exports.PasetoDecryptionFailed = class PasetoDecryptionFailed extends PasetoError {}\nmodule.exports.PasetoInvalid = class PasetoInvalid extends PasetoError {}\nmodule.exports.PasetoVerificationFailed = class PasetoVerificationFailed extends PasetoError {}\nmodule.exports.PasetoClaimInvalid = class PasetoClaimInvalid extends PasetoError {}\n","const { PasetoInvalid, PasetoNotSupported } = require('../errors')\nconst { decode } = require('../help/base64url')\nconst parsePayload = require('../help/parse_paseto_payload')\n\nmodule.exports = (token, /* second arg is private API */ { parse = true } = {}) => {\n  if (typeof token !== 'string') {\n    throw new TypeError('token must be a string')\n  }\n\n  const { 0: version, 1: purpose, 2: payload, 3: footer, length } = token.split('.')\n\n  if (length !== 3 && length !== 4) {\n    throw new PasetoInvalid('token is not a PASETO formatted value')\n  }\n\n  if (version !== 'v1' && version !== 'v2' && version !== 'v3' && version !== 'v4') {\n    throw new PasetoNotSupported('unsupported PASETO version')\n  }\n\n  if (purpose !== 'local' && purpose !== 'public') {\n    throw new PasetoNotSupported('unsupported PASETO purpose')\n  }\n\n  const result = {\n    footer: footer ? decode(footer) : undefined,\n    payload: undefined,\n    version,\n    purpose,\n  }\n\n  if (purpose === 'local') {\n    return result\n  }\n\n  const sigLength = version === 'v1' ? 256 : version === 'v3' ? 96 : 64\n\n  let raw\n  try {\n    raw = decode(payload).subarray(0, -sigLength)\n  } catch {\n    throw new PasetoInvalid('token is not a PASETO formatted value')\n  }\n\n  if (!parse) {\n    result.payload = raw\n  } else {\n    result.payload = parsePayload(raw)\n  }\n\n  return result\n}\n","const decode = require('./decode')\n\nmodule.exports = { decode }\n","const ms = require('../help/ms')\n\nmodule.exports = (\n  { audience, expiresIn, iat = true, issuer, jti, kid, notBefore, now = new Date(), subject },\n  payload,\n) => {\n  if (!(now instanceof Date) || !now.getTime()) {\n    throw new TypeError('options.now must be a valid Date object')\n  }\n\n  const unix = now.getTime()\n\n  if (iat !== undefined) {\n    if (typeof iat !== 'boolean') {\n      throw new TypeError('options.iat must be a boolean')\n    }\n\n    if (iat) {\n      payload.iat = new Date(unix)\n    }\n  }\n\n  if (expiresIn !== undefined) {\n    if (typeof expiresIn !== 'string') {\n      throw new TypeError('options.expiresIn must be a string')\n    }\n\n    payload.exp = new Date(unix + ms(expiresIn))\n  }\n\n  if (notBefore !== undefined) {\n    if (typeof notBefore !== 'string') {\n      throw new TypeError('options.notBefore must be a string')\n    }\n\n    payload.nbf = new Date(unix + ms(notBefore))\n  }\n\n  if (audience !== undefined) {\n    if (typeof audience !== 'string') {\n      throw new TypeError('options.audience must be a string')\n    }\n\n    payload.aud = audience\n  }\n\n  if (issuer !== undefined) {\n    if (typeof issuer !== 'string') {\n      throw new TypeError('options.issuer must be a string')\n    }\n\n    payload.iss = issuer\n  }\n\n  if (subject !== undefined) {\n    if (typeof subject !== 'string') {\n      throw new TypeError('options.subject must be a string')\n    }\n\n    payload.sub = subject\n  }\n\n  if (kid !== undefined) {\n    if (typeof kid !== 'string') {\n      throw new TypeError('options.kid must be a string')\n    }\n\n    payload.kid = kid\n  }\n\n  if (jti !== undefined) {\n    if (typeof jti !== 'string') {\n      throw new TypeError('options.jti must be a string')\n    }\n\n    payload.jti = jti\n  }\n\n  return payload\n}\n","const { PasetoClaimInvalid } = require('../errors')\nconst ms = require('./ms')\n\nmodule.exports = (\n  {\n    ignoreExp,\n    ignoreNbf,\n    ignoreIat,\n    maxTokenAge,\n    subject,\n    issuer,\n    clockTolerance,\n    audience,\n    now = new Date(),\n  },\n  payload,\n) => {\n  if (!(now instanceof Date) || !now.getTime()) {\n    throw new TypeError('options.now must be a valid Date object')\n  }\n\n  const unix = now.getTime()\n\n  // iss\n  if ('iss' in payload && typeof payload.iss !== 'string') {\n    throw new PasetoClaimInvalid('payload.iss must be a string')\n  }\n\n  if (issuer !== undefined) {\n    if (typeof issuer !== 'string') {\n      throw new TypeError('options.issuer must be a string')\n    }\n\n    if (payload.iss !== issuer) {\n      throw new PasetoClaimInvalid('issuer mismatch')\n    }\n  }\n\n  // sub\n  if ('sub' in payload && typeof payload.sub !== 'string') {\n    throw new PasetoClaimInvalid('payload.sub must be a string')\n  }\n\n  if (subject !== undefined) {\n    if (typeof subject !== 'string') {\n      throw new TypeError('options.subject must be a string')\n    }\n\n    if (payload.sub !== subject) {\n      throw new PasetoClaimInvalid('subject mismatch')\n    }\n  }\n\n  // aud\n  if ('aud' in payload && typeof payload.aud !== 'string') {\n    throw new PasetoClaimInvalid('payload.aud must be a string')\n  }\n\n  if (audience !== undefined) {\n    if (typeof audience !== 'string') {\n      throw new TypeError('options.audience must be a string')\n    }\n\n    if (payload.aud !== audience) {\n      throw new PasetoClaimInvalid('audience mismatch')\n    }\n  }\n\n  if (clockTolerance !== undefined && typeof clockTolerance !== 'string') {\n    throw new TypeError('options.clockTolerance must be a string')\n  }\n\n  const tolerance = clockTolerance ? ms(clockTolerance) : 0\n\n  // iat\n  let iat\n  if ('iat' in payload) {\n    if (typeof payload.iat !== 'string') {\n      throw new PasetoClaimInvalid('payload.iat must be a string')\n    }\n    iat = new Date(payload.iat).getTime()\n    if (!iat) {\n      throw new PasetoClaimInvalid('payload.iat must be a valid ISO8601 string')\n    }\n    if (!ignoreIat) {\n      if (iat > unix + tolerance) {\n        throw new PasetoClaimInvalid('token issued in the future')\n      }\n    }\n  }\n\n  // nbf\n  if ('nbf' in payload) {\n    if (typeof payload.nbf !== 'string') {\n      throw new PasetoClaimInvalid('payload.nbf must be a string')\n    }\n    const nbf = new Date(payload.nbf).getTime()\n    if (!nbf) {\n      throw new PasetoClaimInvalid('payload.nbf must be a valid ISO8601 string')\n    }\n    if (!ignoreNbf) {\n      if (nbf > unix + tolerance) {\n        throw new PasetoClaimInvalid('token is not active yet')\n      }\n    }\n  }\n\n  // exp\n  if ('exp' in payload) {\n    if (typeof payload.exp !== 'string') {\n      throw new PasetoClaimInvalid('payload.exp must be a string')\n    }\n    const exp = new Date(payload.exp).getTime()\n    if (!exp) {\n      throw new PasetoClaimInvalid('payload.exp must be a valid ISO8601 string')\n    }\n    if (!ignoreExp) {\n      if (exp <= unix - tolerance) {\n        throw new PasetoClaimInvalid('token is expired')\n      }\n    }\n  }\n\n  // maxTokenAge\n  if (maxTokenAge !== undefined) {\n    if (typeof maxTokenAge !== 'string') {\n      throw new TypeError('options.maxTokenAge must be a string')\n    }\n\n    if (!('iat' in payload)) {\n      throw new PasetoClaimInvalid('missing iat claim')\n    }\n\n    if (iat + ms(maxTokenAge) < unix + tolerance) {\n      throw new PasetoClaimInvalid('maxTokenAge exceeded')\n    }\n  }\n}\n","module.exports.encode = (input) => input.toString('base64url')\nmodule.exports.decode = (input) => Buffer.from(input, 'base64')\n","module.exports = function checkAssertion(assertion) {\n  if (typeof assertion === 'undefined') {\n    return Buffer.from('')\n  }\n\n  if (Buffer.isBuffer(assertion)) {\n    return assertion\n  }\n\n  if (typeof assertion !== 'string') {\n    throw new TypeError('options.assertion must be a string, or a Buffer')\n  }\n\n  return Buffer.from(assertion, 'utf8')\n}\n","const isObject = require('./is_object')\n\nmodule.exports = function checkFooter(footer) {\n  if (typeof footer === 'undefined') {\n    return Buffer.from('')\n  }\n\n  if (Buffer.isBuffer(footer)) {\n    return footer\n  }\n\n  if (isObject(footer)) {\n    return Buffer.from(JSON.stringify(footer), 'utf8')\n  }\n\n  if (typeof footer !== 'string') {\n    throw new TypeError('options.footer must be a string, Buffer, or a plain object')\n  }\n\n  return Buffer.from(footer, 'utf8')\n}\n","const applyOptions = require('./apply_options')\nconst isObject = require('./is_object')\nconst deepClone = (payload) => JSON.parse(JSON.stringify(payload))\n\nmodule.exports = (payload, options) => {\n  if (Buffer.isBuffer(payload)) {\n    if (Object.keys(options).length !== 0) {\n      throw new TypeError('options cannot contain claims when payload is a Buffer')\n    }\n\n    return payload\n  }\n  if (!isObject(payload)) {\n    throw new TypeError('payload must be a Buffer or a plain object')\n  }\n\n  payload = deepClone(payload)\n  payload = applyOptions(options, payload)\n  return Buffer.from(JSON.stringify(payload), 'utf-8')\n}\n","module.exports = (key) => {\n  const { x, y } = key.export({ format: 'jwk' })\n  const yB = Buffer.from(y, 'base64')\n  const sign = 0x02 + (yB[yB.length - 1] & 1)\n  return Buffer.concat([Buffer.alloc(1, sign), Buffer.from(x, 'base64')])\n}\n","const assert = require('assert')\n\nconst { PasetoInvalid } = require('../errors')\nconst assertPayload = require('./assert_payload')\nconst { decode } = require('./base64url')\nconst parse = require('./parse_paseto_payload')\n\nfunction pre(h, token) {\n  if (typeof token !== 'string') {\n    throw new TypeError(`token must be a string, got: ${typeof token}`)\n  }\n\n  if (token.slice(0, h.length) !== h) {\n    throw new PasetoInvalid(`token is not a ${h.slice(0, h.length - 1)} PASETO`)\n  }\n\n  let { 0: raw, 1: f = '', length } = token.slice(h.length).split('.')\n\n  try {\n    assert(length <= 2)\n    raw = decode(raw)\n    f = decode(f)\n  } catch {\n    throw new PasetoInvalid('token is not a PASETO formatted value')\n  }\n\n  return { raw, f }\n}\n\nfunction post(version, buffer, options, complete, m, f, purpose) {\n  if (buffer) {\n    if (Object.keys(options).length !== 0) {\n      throw new TypeError('options cannot contain claims when options.buffer is true')\n    }\n    if (complete) {\n      return { payload: m, footer: f?.length ? f : undefined, version, purpose }\n    }\n\n    return m\n  }\n\n  const payload = parse(m)\n\n  assertPayload(options, payload)\n\n  if (complete) {\n    return { payload, footer: f?.length ? f : undefined, version, purpose }\n  }\n\n  return payload\n}\n\nmodule.exports = {\n  post,\n  pre,\n}\n","const crypto = require('crypto')\nconst util = require('util')\n\nconst pae = require('./pae')\nconst pack = require('./pack')\nconst { PasetoDecryptionFailed } = require('../errors')\nconst timingSafeEqual = require('./timing_safe_equal')\n\nconst {\n  webcrypto: { subtle },\n} = crypto\nconst hkdf = util.promisify(crypto.hkdf)\n\nconst EK_INFO = Buffer.from('paseto-encryption-key')\nconst AK_INFO = Buffer.from('paseto-auth-key-for-aead')\nconst EMPTY = Buffer.alloc(0)\n\nasync function v1encrypt(m, f, k) {\n  const h = 'v1.local.'\n  const n = hmac(m, crypto.randomBytes(32)).subarray(0, 32)\n  const salt = n.subarray(0, 16)\n  const [ek, ak] = await Promise.all([\n    hkdf('sha384', k, salt, EK_INFO, 32).then(Buffer.from),\n    hkdf('sha384', k, salt, AK_INFO, 32).then(Buffer.from),\n  ])\n\n  const c = await encrypt(m, ek, n.subarray(16))\n  const preAuth = pae(h, n, c, f)\n  const t = hmac(preAuth, ak)\n\n  return pack(h, f, n, c, t)\n}\n\nasync function v1decrypt(raw, f, k) {\n  const h = 'v1.local.'\n  const n = raw.subarray(0, 32)\n  const t = raw.subarray(-48)\n  const c = raw.subarray(32, -48)\n\n  const salt = n.subarray(0, 16)\n  const [ek, ak] = await Promise.all([\n    hkdf('sha384', k, salt, EK_INFO, 32).then(Buffer.from),\n    hkdf('sha384', k, salt, AK_INFO, 32).then(Buffer.from),\n  ])\n\n  const preAuth = pae(h, n, c, f)\n\n  const t2 = hmac(preAuth, ak)\n  if (!timingSafeEqual(t, t2)) throw new PasetoDecryptionFailed('decryption failed')\n  const payload = await decrypt(c, ek, n.subarray(16))\n  if (!payload) throw new PasetoDecryptionFailed('decryption failed')\n\n  return payload\n}\n\nasync function v3encrypt(m, f, k, i) {\n  const h = 'v3.local.'\n  const n = crypto.randomBytes(32)\n  const [tmp, ak] = await Promise.all([\n    hkdf('sha384', k, EMPTY, Buffer.concat([EK_INFO, n]), 48).then(Buffer.from),\n    hkdf('sha384', k, EMPTY, Buffer.concat([AK_INFO, n]), 48).then(Buffer.from),\n  ])\n  const ek = tmp.subarray(0, 32)\n  const n2 = tmp.subarray(32)\n\n  const c = await encrypt(m, ek, n2)\n  const preAuth = pae(h, n, c, f, i)\n  const t = hmac(preAuth, ak)\n\n  return pack(h, f, n, c, t)\n}\n\nasync function v3decrypt(raw, f, k, i) {\n  const h = 'v3.local.'\n  const n = raw.subarray(0, 32)\n  const t = raw.subarray(-48)\n  const c = raw.subarray(32, -48)\n\n  const [tmp, ak] = await Promise.all([\n    hkdf('sha384', k, EMPTY, Buffer.concat([EK_INFO, n]), 48).then(Buffer.from),\n    hkdf('sha384', k, EMPTY, Buffer.concat([AK_INFO, n]), 48).then(Buffer.from),\n  ])\n\n  const ek = tmp.subarray(0, 32)\n  const n2 = tmp.subarray(32)\n  const preAuth = pae(h, n, c, f, i)\n  const t2 = hmac(preAuth, ak)\n\n  if (!timingSafeEqual(t, t2)) throw new PasetoDecryptionFailed('decryption failed')\n  const payload = await decrypt(c, ek, n2)\n  if (!payload) throw new PasetoDecryptionFailed('decryption failed')\n\n  return payload\n}\n\nconst hmac = (data, key) => crypto.createHmac('sha384', key).update(data).digest()\n\nconst ctr = async (op, data, key, iv) =>\n  subtle[op](\n    { name: 'AES-CTR', counter: iv, length: 16 },\n    await subtle.importKey('raw', key, 'AES-CTR', false, [op]),\n    data,\n  ).then(Buffer.from)\nconst encrypt = ctr.bind(undefined, 'encrypt')\nconst decrypt = ctr.bind(undefined, 'decrypt')\n\nmodule.exports = {\n  sign: util.promisify(crypto.sign),\n  verify: util.promisify(crypto.verify),\n  'v1.local-encrypt': v1encrypt,\n  'v1.local-decrypt': v1decrypt,\n  'v3.local-encrypt': v3encrypt,\n  'v3.local-decrypt': v3decrypt,\n}\n","const { KeyObject } = require('crypto')\nlet { isKeyObject } = require('util/types')\n\nif (!isKeyObject) {\n  isKeyObject = (obj) => obj != null && obj instanceof KeyObject\n}\n\nmodule.exports = isKeyObject\n","module.exports = (input) => !!input && input.constructor === Object\n","const { PasetoNotSupported } = require('../errors')\n\nmodule.exports = (n) => {\n  if (!Number.isSafeInteger(n)) {\n    throw new PasetoNotSupported('message is too long for Node.js to safely process')\n  }\n\n  const up = ~~(n / 0xffffffff)\n  const dn = (n % 0xffffffff) - up\n\n  const buf = Buffer.allocUnsafe(8)\n\n  buf.writeUInt32LE(up, 4)\n  buf.writeUInt32LE(dn, 0)\n\n  return buf\n}\n","const second = 1000\nconst minute = second * 60\nconst hour = minute * 60\nconst day = hour * 24\nconst week = day * 7\nconst year = day * 365.25\n\nconst REGEX =\n  /^(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i\n\nmodule.exports = (str) => {\n  const matched = REGEX.exec(str)\n\n  if (!matched) {\n    throw new TypeError(`invalid time period format (\"${str}\")`)\n  }\n\n  const value = parseFloat(matched[1])\n  const unit = matched[2].toLowerCase()\n\n  switch (unit) {\n    case 'sec':\n    case 'secs':\n    case 'second':\n    case 'seconds':\n    case 's':\n      return Math.round(value * second)\n    case 'minute':\n    case 'minutes':\n    case 'min':\n    case 'mins':\n    case 'm':\n      return Math.round(value * minute)\n    case 'hour':\n    case 'hours':\n    case 'hr':\n    case 'hrs':\n    case 'h':\n      return Math.round(value * hour)\n    case 'day':\n    case 'days':\n    case 'd':\n      return Math.round(value * day)\n    case 'week':\n    case 'weeks':\n    case 'w':\n      return Math.round(value * week)\n    case 'year':\n    case 'years':\n    case 'yr':\n    case 'yrs':\n    case 'y':\n      return Math.round(value * year)\n  }\n}\n","const { encode } = require('./base64url')\n\nmodule.exports = function pack(header, footer, ...payload) {\n  let token = `${header}${encode(Buffer.concat(payload))}`\n  if (footer.byteLength) {\n    token += `.${encode(footer)}`\n  }\n  return token\n}\n","const le64 = require('./le64')\n\nmodule.exports = (...pieces) => {\n  pieces = pieces.filter(Boolean)\n  let accumulator = le64(pieces.length)\n  for (let piece of pieces) {\n    piece = Buffer.from(piece, 'utf8')\n    const len = le64(Buffer.byteLength(piece))\n    accumulator = Buffer.concat([accumulator, len, piece])\n  }\n  return accumulator\n}\n","const { PasetoInvalid } = require('../errors')\n\nconst { strict: assert } = require('assert')\nconst isObject = require('./is_object')\n\nmodule.exports = (payload) => {\n  try {\n    const parsed = JSON.parse(payload)\n    assert(isObject(parsed))\n    return parsed\n  } catch {\n    throw new PasetoInvalid('All PASETO payloads MUST be a JSON object')\n  }\n}\n","const { sign } = require('./crypto_worker')\n\nconst pae = require('./pae')\nconst pack = require('./pack')\n\nmodule.exports = async function signPaseto(h, m, f, alg, key, i, eo) {\n  const m2 = pae(eo, h, m, f, i)\n  const sig = await sign(alg, m2, key)\n  return pack(h, f, m, sig)\n}\n","const { createSecretKey } = require('crypto')\n\nconst isKeyObject = require('./is_key_object')\n\nmodule.exports = function checkKey(header, key) {\n  if (typeof key === 'string' && key.startsWith(`k${header.slice(1)}`)) {\n    key = Buffer.from(key.slice(header.length), 'base64url')\n  }\n\n  if (!isKeyObject(key)) {\n    try {\n      key = createSecretKey(key)\n    } catch {}\n  }\n\n  if (!isKeyObject(key)) {\n    throw new TypeError('invalid key provided')\n  }\n\n  if (key.type !== 'secret' || key.symmetricKeySize !== 32) {\n    throw new TypeError(`${header} secret key must be 32 bytes long symmetric key`)\n  }\n\n  return key\n}\n","const { timingSafeEqual: TSE } = require('crypto')\n\nconst paddedBuffer = (input, length) => {\n  if (input.length === length) {\n    return input\n  }\n\n  const buffer = Buffer.alloc(length)\n  input.copy(buffer)\n  return buffer\n}\n\nconst timingSafeEqual = (a, b) => {\n  const length = Math.max(a.length, b.length)\n  return TSE(paddedBuffer(a, length), paddedBuffer(b, length))\n}\n\nmodule.exports = timingSafeEqual\n","const { PasetoVerificationFailed } = require('../errors')\n\nconst { verify } = require('./crypto_worker')\nconst pae = require('./pae')\nconst { pre } = require('./consume')\n\nmodule.exports = async function verifyPaseto(h, token, alg, sigLength, key, i, eo) {\n  const { raw, f } = pre(h, token)\n\n  const m = raw.subarray(0, -sigLength)\n  const s = raw.subarray(-sigLength)\n  const m2 = pae(eo, h, m, f, i)\n\n  if (!(await verify(alg, m2, key, s))) {\n    throw new PasetoVerificationFailed('invalid signature')\n  }\n\n  return {\n    m,\n    footer: f.length ? f : undefined,\n  }\n}\n","const errors = require('./errors')\nconst V1 = require('./v1')\nconst V2 = require('./v2')\nconst V3 = require('./v3')\nconst V4 = require('./v4')\n\nconst { decode } = require('./general')\n\nmodule.exports = { decode, V1, V2, V3, V4, errors }\n","const { 'v1.local-decrypt': decrypt } = require('../help/crypto_worker')\nconst checkKey = require('../help/symmetric_key_check').bind(undefined, 'v1.local')\nconst { pre, post } = require('../help/consume')\n\nconst h = 'v1.local.'\n\nmodule.exports = async function v1Decrypt(\n  token,\n  key,\n  { complete = false, buffer = false, ...options } = {},\n) {\n  const { raw, f } = pre(h, token)\n  key = checkKey(key)\n  const k = key.export()\n  const m = await decrypt(raw, f, k)\n  return post('v1', buffer, options, complete, m, f, 'local')\n}\n","const checkFooter = require('../help/check_footer')\nconst checkKey = require('../help/symmetric_key_check').bind(undefined, 'v1.local')\nconst checkPayload = require('../help/check_payload')\nconst { 'v1.local-encrypt': encrypt } = require('../help/crypto_worker')\n\nmodule.exports = async function v1Encrypt(payload, key, { footer, ...options } = {}) {\n  const m = checkPayload(payload, options)\n  key = checkKey(key)\n  const f = checkFooter(footer)\n  const k = key.export()\n  return encrypt(m, f, k)\n}\n","const sign = require('./sign')\nconst verify = require('./verify')\nconst encrypt = require('./encrypt')\nconst decrypt = require('./decrypt')\nconst generateKey = require('./key')\n\nmodule.exports = { sign, verify, encrypt, decrypt, generateKey }\n","const crypto = require('crypto')\nconst { promisify } = require('util')\n\nconst { PasetoNotSupported } = require('../errors')\n\nconst generateKeyPair = promisify(crypto.generateKeyPair)\nconst generateSecretKey = promisify(crypto.generateKey)\n\nasync function generateKey(purpose, { format = 'keyobject' } = {}) {\n  if (format !== 'keyobject' && format !== 'paserk') throw new TypeError('invalid format')\n  switch (purpose) {\n    case 'local': {\n      const keyobject = await generateSecretKey('aes', { length: 256 })\n      if (format === 'paserk') {\n        return `k1.local.${keyobject.export().toString('base64url')}`\n      }\n      return keyobject\n    }\n    case 'public': {\n      const { privateKey, publicKey } = await generateKeyPair('rsa', { modulusLength: 2048 })\n      if (format === 'paserk') {\n        return {\n          secretKey: `k1.secret.${privateKey\n            .export({ format: 'der', type: 'pkcs1' })\n            .toString('base64url')}`,\n          publicKey: `k1.public.${publicKey\n            .export({ format: 'der', type: 'pkcs1' })\n            .toString('base64url')}`,\n        }\n      }\n      return privateKey\n    }\n    default:\n      throw new PasetoNotSupported('unsupported v1 purpose')\n  }\n}\n\nmodule.exports = generateKey\n","const {\n  constants: { RSA_PKCS1_PSS_PADDING: padding, RSA_PSS_SALTLEN_DIGEST: saltLength },\n  createPrivateKey,\n} = require('crypto')\n\nconst checkFooter = require('../help/check_footer')\nconst checkPayload = require('../help/check_payload')\nconst sign = require('../help/sign')\nconst isKeyObject = require('../help/is_key_object')\n\nfunction checkKey(key) {\n  if (typeof key === 'string' && key.startsWith('k1.secret.')) {\n    try {\n      const der = Buffer.from(key.slice(10), 'base64url')\n      key = { key: der, format: 'der', type: 'pkcs1' }\n    } catch {}\n  }\n\n  if (!isKeyObject(key)) {\n    try {\n      key = createPrivateKey(key)\n    } catch {}\n  }\n\n  if (!isKeyObject(key)) {\n    throw new TypeError('invalid key provided')\n  }\n\n  if (\n    key.type !== 'private' ||\n    key.asymmetricKeyType !== 'rsa' ||\n    key.asymmetricKeyDetails.modulusLength !== 2048\n  ) {\n    throw new TypeError(\n      'v1.public signing key must be a private RSA key with 2048 bit modulus length',\n    )\n  }\n\n  return key\n}\n\nmodule.exports = async function v1Sign(payload, key, { footer, ...options } = {}) {\n  const m = checkPayload(payload, options)\n  const f = checkFooter(footer)\n  key = checkKey(key)\n  return sign('v1.public.', m, f, 'sha384', { key, padding, saltLength })\n}\n","const {\n  constants: { RSA_PKCS1_PSS_PADDING: padding, RSA_PSS_SALTLEN_DIGEST: saltLength },\n  createPublicKey,\n} = require('crypto')\n\nconst verify = require('../help/verify')\nconst isKeyObject = require('../help/is_key_object')\nconst { post } = require('../help/consume')\n\nfunction checkKey(key) {\n  if (typeof key === 'string' && key.startsWith('k1.public.')) {\n    try {\n      const der = Buffer.from(key.slice(10), 'base64url')\n      key = { key: der, format: 'der', type: 'pkcs1' }\n    } catch {}\n  }\n\n  if (!isKeyObject(key) || key.type === 'private') {\n    try {\n      key = createPublicKey(key)\n    } catch {}\n  }\n\n  if (!isKeyObject(key)) {\n    throw new TypeError('invalid key provided')\n  }\n\n  if (\n    key.type !== 'public' ||\n    key.asymmetricKeyType !== 'rsa' ||\n    key.asymmetricKeyDetails.modulusLength !== 2048\n  ) {\n    throw new TypeError(\n      'v1.public verify key must be a public RSA key with 2048 bit modulus length',\n    )\n  }\n\n  return key\n}\n\nmodule.exports = async function v1Verify(\n  token,\n  key,\n  { complete = false, buffer = false, ...options } = {},\n) {\n  key = checkKey(key)\n\n  const { m, footer } = await verify('v1.public.', token, 'sha384', 256, {\n    key,\n    padding,\n    saltLength,\n  })\n\n  return post('v1', buffer, options, complete, m, footer, 'public')\n}\n","const sign = require('./sign')\nconst verify = require('./verify')\nconst { generateKey, bytesToKeyObject, keyObjectToBytes } = require('./key')\n\nmodule.exports = { sign, verify, generateKey, bytesToKeyObject, keyObjectToBytes }\n","const assert = require('assert')\nconst crypto = require('crypto')\nconst { promisify } = require('util')\n\nconst { PasetoNotSupported } = require('../errors')\nconst isKeyObject = require('../help/is_key_object')\n\nconst generateKeyPair = promisify(crypto.generateKeyPair)\n\nfunction _checkPrivateKey(v, key) {\n  if (typeof key === 'string' && key.startsWith(`k${v.slice(1)}.secret.`)) {\n    try {\n      key = Buffer.from(key.slice(10), 'base64url')\n      assert.strictEqual(key.byteLength, 64)\n    } catch {}\n  }\n\n  if (Buffer.isBuffer(key)) {\n    try {\n      key = bytesToKeyObject(key)\n    } catch {}\n  }\n\n  if (!isKeyObject(key)) {\n    try {\n      key = crypto.createPrivateKey(key)\n    } catch {}\n  }\n\n  if (!isKeyObject(key)) {\n    throw new TypeError('invalid key provided')\n  }\n\n  if (key.type !== 'private' || key.asymmetricKeyType !== 'ed25519') {\n    throw new TypeError(`${v}.public signing key must be a private ed25519 key`)\n  }\n\n  return key\n}\n\nfunction _checkPublicKey(v, key) {\n  if (typeof key === 'string' && key.startsWith(`k${v.slice(1)}.public.`)) {\n    try {\n      key = Buffer.from(key.slice(10), 'base64url')\n      assert.strictEqual(key.byteLength, 32)\n    } catch {}\n  }\n\n  if (Buffer.isBuffer(key)) {\n    try {\n      key = bytesToKeyObject(key)\n    } catch {}\n  }\n\n  if (!isKeyObject(key) || key.type === 'private') {\n    try {\n      key = crypto.createPublicKey(key)\n    } catch {}\n  }\n\n  if (!isKeyObject(key)) {\n    throw new TypeError('invalid key provided')\n  }\n\n  if (key.type !== 'public' || key.asymmetricKeyType !== 'ed25519') {\n    throw new TypeError(`${v}.public verify key must be a public ed25519 key`)\n  }\n\n  return key\n}\n\nasync function _generateKey(v, purpose, { format = 'keyobject' } = {}) {\n  if (format !== 'keyobject' && format !== 'paserk') throw new TypeError('invalid format')\n  switch (purpose) {\n    case 'public': {\n      const { privateKey, publicKey } = await generateKeyPair('ed25519')\n      if (format === 'paserk') {\n        return {\n          secretKey: `k${v.slice(1)}.secret.${keyObjectToBytes(privateKey).toString('base64url')}`,\n          publicKey: `k${v.slice(1)}.public.${keyObjectToBytes(publicKey).toString('base64url')}`,\n        }\n      }\n      return privateKey\n    }\n    default:\n      throw new PasetoNotSupported(`unsupported ${v} purpose`)\n  }\n}\n\nfunction bytesToKeyObject(bytes) {\n  if (!Buffer.isBuffer(bytes)) {\n    throw new TypeError('bytes must be a Buffer')\n  }\n\n  switch (bytes.byteLength) {\n    case 64: {\n      const keyObject = crypto.createPrivateKey({\n        key: Buffer.concat([\n          Buffer.from('302e020100300506032b657004220420', 'hex'),\n          bytes.subarray(0, 32),\n        ]),\n        format: 'der',\n        type: 'pkcs8',\n      })\n\n      if (\n        !bytes.subarray(32).equals(Buffer.from(keyObject.export({ format: 'jwk' }).x, 'base64'))\n      ) {\n        throw new TypeError('invalid byte sequence')\n      }\n\n      return keyObject\n    }\n    case 32:\n      return crypto.createPublicKey({\n        key: Buffer.concat([Buffer.from('302a300506032b6570032100', 'hex'), bytes]),\n        format: 'der',\n        type: 'spki',\n      })\n    default:\n      throw new TypeError('bytes must be 64 bytes (private key), or 32 bytes (public key)')\n  }\n}\n\nfunction _keyObjectToBytes(v, keyObject) {\n  if (!isKeyObject(keyObject)) {\n    throw new TypeError('keyObject must be a KeyObject instance')\n  }\n  if (keyObject.type === 'secret' || keyObject.asymmetricKeyType !== 'ed25519') {\n    throw new TypeError(`${v}.public key must be an Ed25519 key`)\n  }\n  switch (keyObject.type) {\n    case 'public':\n      return Buffer.from(keyObject.export({ format: 'jwk' }).x, 'base64')\n    case 'private': {\n      const { d, x } = keyObject.export({ format: 'jwk' })\n      return Buffer.concat([Buffer.from(d, 'base64'), Buffer.from(x, 'base64')])\n    }\n  }\n}\n\nasync function generateKey(...args) {\n  return _generateKey('v2', ...args)\n}\n\nfunction keyObjectToBytes(...args) {\n  return _keyObjectToBytes('v2', ...args)\n}\n\nmodule.exports = {\n  _checkPrivateKey,\n  _checkPublicKey,\n  _generateKey,\n  _keyObjectToBytes,\n  bytesToKeyObject,\n  generateKey,\n  keyObjectToBytes,\n}\n","const checkFooter = require('../help/check_footer')\nconst checkPayload = require('../help/check_payload')\nconst sign = require('../help/sign')\nconst { _checkPrivateKey } = require('./key')\n\nconst checkKey = _checkPrivateKey.bind(undefined, 'v2')\n\nmodule.exports = async function v2Sign(payload, key, { footer, ...options } = {}) {\n  const m = checkPayload(payload, options)\n  key = checkKey(key)\n  const f = checkFooter(footer)\n  return sign('v2.public.', m, f, undefined, key)\n}\n","const verify = require('../help/verify')\nconst { _checkPublicKey } = require('./key')\nconst { post } = require('../help/consume')\n\nconst checkKey = _checkPublicKey.bind(undefined, 'v2')\n\nmodule.exports = async function v2Verify(\n  token,\n  key,\n  { complete = false, buffer = false, ...options } = {},\n) {\n  key = checkKey(key)\n\n  const { m, footer } = await verify('v2.public.', token, undefined, 64, key)\n\n  return post('v2', buffer, options, complete, m, footer, 'public')\n}\n","const { 'v3.local-decrypt': decrypt } = require('../help/crypto_worker')\nconst checkKey = require('../help/symmetric_key_check').bind(undefined, 'v3.local')\nconst checkAssertion = require('../help/check_assertion')\nconst { pre, post } = require('../help/consume')\n\nconst h = 'v3.local.'\n\nmodule.exports = async function v3Decrypt(\n  token,\n  key,\n  { complete = false, buffer = false, assertion, ...options } = {},\n) {\n  const { raw, f } = pre(h, token)\n  key = checkKey(key)\n  const i = checkAssertion(assertion)\n  const k = key.export()\n  const m = await decrypt(raw, f, k, i)\n  return post('v3', buffer, options, complete, m, f, 'local')\n}\n","const checkFooter = require('../help/check_footer')\nconst checkKey = require('../help/symmetric_key_check').bind(undefined, 'v3.local')\nconst checkPayload = require('../help/check_payload')\nconst checkAssertion = require('../help/check_assertion')\nconst { 'v3.local-encrypt': encrypt } = require('../help/crypto_worker')\n\nmodule.exports = async function v3Encrypt(payload, key, { footer, assertion, ...options } = {}) {\n  const m = checkPayload(payload, options)\n  key = checkKey(key)\n  const f = checkFooter(footer)\n  const i = checkAssertion(assertion)\n  const k = key.export()\n  return encrypt(m, f, k, i)\n}\n","const sign = require('./sign')\nconst verify = require('./verify')\nconst encrypt = require('./encrypt')\nconst decrypt = require('./decrypt')\nconst { generateKey, bytesToKeyObject, keyObjectToBytes } = require('./key')\n\nmodule.exports = { sign, verify, encrypt, decrypt, generateKey, bytesToKeyObject, keyObjectToBytes }\n","const crypto = require('crypto')\nconst { promisify } = require('util')\n\nconst { PasetoNotSupported } = require('../errors')\nconst isKeyObject = require('../help/is_key_object')\nconst compressPk = require('../help/compress_pk')\n\nconst generateKeyPair = promisify(crypto.generateKeyPair)\nconst generateSecretKey = promisify(crypto.generateKey)\n\nasync function generateKey(purpose, { format = 'keyobject' } = {}) {\n  if (format !== 'keyobject' && format !== 'paserk') throw new TypeError('invalid format')\n  switch (purpose) {\n    case 'local': {\n      const keyobject = await generateSecretKey('aes', { length: 256 })\n      if (format === 'paserk') {\n        return `k3.local.${keyobject.export().toString('base64url')}`\n      }\n      return keyobject\n    }\n    case 'public': {\n      const { privateKey, publicKey } = await generateKeyPair('ec', { namedCurve: 'P-384' })\n      if (format === 'paserk') {\n        return {\n          secretKey: `k3.secret.${keyObjectToBytes(privateKey).toString('base64url')}`,\n          publicKey: `k3.public.${keyObjectToBytes(publicKey).toString('base64url')}`,\n        }\n      }\n      return privateKey\n    }\n    default:\n      throw new PasetoNotSupported('unsupported v3 purpose')\n  }\n}\n\nfunction bytesToKeyObject(bytes) {\n  if (!Buffer.isBuffer(bytes)) {\n    throw new TypeError('bytes must be a Buffer')\n  }\n\n  switch (bytes.byteLength) {\n    case 48:\n      return crypto.createPrivateKey({\n        key: Buffer.concat([\n          Buffer.from('303e0201010430', 'hex'),\n          bytes,\n          Buffer.from('a00706052b81040022', 'hex'),\n        ]),\n        format: 'der',\n        type: 'sec1',\n      })\n    case 49:\n      if (bytes[0] !== 0x02 && bytes[0] !== 0x03) {\n        throw new TypeError('invalid compressed public key')\n      }\n      return crypto.createPublicKey({\n        key: Buffer.concat([\n          Buffer.from('3046301006072a8648ce3d020106052b81040022033200', 'hex'),\n          bytes,\n        ]),\n        format: 'der',\n        type: 'spki',\n      })\n    case 97:\n      if (bytes[0] !== 0x04) {\n        throw new TypeError('invalid uncompressed public key')\n      }\n      return crypto.createPublicKey({\n        key: Buffer.concat([\n          Buffer.from('3076301006072a8648ce3d020106052b81040022036200', 'hex'),\n          bytes,\n        ]),\n        format: 'der',\n        type: 'spki',\n      })\n    default:\n      throw new TypeError(\n        'bytes must be 48 bytes (private key), 49 bytes (compressed public key), or 97 bytes (uncompressed public key)',\n      )\n  }\n}\n\nfunction keyObjectToBytes(keyObject) {\n  if (!isKeyObject(keyObject)) {\n    throw new TypeError('keyObject must be a KeyObject instance')\n  }\n  if (\n    keyObject.type === 'secret' ||\n    keyObject.asymmetricKeyType !== 'ec' ||\n    keyObject.asymmetricKeyDetails.namedCurve !== 'secp384r1'\n  ) {\n    throw new TypeError('v3.public key must be an EC P-384 key')\n  }\n  switch (keyObject.type) {\n    case 'public':\n      return compressPk(keyObject)\n    case 'private':\n      return Buffer.from(keyObject.export({ format: 'jwk' }).d, 'base64')\n  }\n}\n\nmodule.exports = {\n  generateKey,\n  bytesToKeyObject,\n  keyObjectToBytes,\n}\n","const { createPrivateKey } = require('crypto')\n\nconst checkFooter = require('../help/check_footer')\nconst checkPayload = require('../help/check_payload')\nconst checkAssertion = require('../help/check_assertion')\nconst sign = require('../help/sign')\nconst isKeyObject = require('../help/is_key_object')\nconst { bytesToKeyObject } = require('./key')\nconst compressPk = require('../help/compress_pk')\n\nfunction checkKey(key) {\n  if (typeof key === 'string' && key.startsWith('k3.secret.')) {\n    try {\n      key = Buffer.from(key.slice(10), 'base64url')\n      assert.strictEqual(key.byteLength, 48)\n    } catch {}\n  }\n\n  if (Buffer.isBuffer(key)) {\n    try {\n      key = bytesToKeyObject(key)\n    } catch {}\n  }\n\n  if (!isKeyObject(key)) {\n    try {\n      key = createPrivateKey(key)\n    } catch {}\n  }\n\n  if (!isKeyObject(key)) {\n    throw new TypeError('invalid key provided')\n  }\n\n  if (\n    key.type !== 'private' ||\n    key.asymmetricKeyType !== 'ec' ||\n    key.asymmetricKeyDetails.namedCurve !== 'secp384r1'\n  ) {\n    throw new TypeError('v3.public signing key must be a private EC P-384 key')\n  }\n\n  return key\n}\n\nmodule.exports = async function v3Sign(payload, key, { footer, assertion, ...options } = {}) {\n  const m = checkPayload(payload, options)\n  const f = checkFooter(footer)\n  const i = checkAssertion(assertion)\n  key = checkKey(key)\n  return sign('v3.public.', m, f, 'sha384', { key, dsaEncoding: 'ieee-p1363' }, i, compressPk(key))\n}\n","const { createPublicKey } = require('crypto')\n\nconst checkAssertion = require('../help/check_assertion')\nconst verify = require('../help/verify')\nconst isKeyObject = require('../help/is_key_object')\nconst { bytesToKeyObject } = require('./key')\nconst compressPk = require('../help/compress_pk')\nconst { post } = require('../help/consume')\n\nfunction checkKey(key) {\n  if (typeof key === 'string' && key.startsWith('k3.public.')) {\n    try {\n      key = Buffer.from(key.slice(10), 'base64url')\n      assert.strictEqual(key.byteLength, 49)\n    } catch {}\n  }\n\n  if (Buffer.isBuffer(key)) {\n    try {\n      key = bytesToKeyObject(key)\n    } catch {}\n  }\n\n  if (!isKeyObject(key) || key.type === 'private') {\n    try {\n      key = createPublicKey(key)\n    } catch {}\n  }\n\n  if (!isKeyObject(key)) {\n    throw new TypeError('invalid key provided')\n  }\n\n  if (\n    key.type !== 'public' ||\n    key.asymmetricKeyType !== 'ec' ||\n    key.asymmetricKeyDetails.namedCurve !== 'secp384r1'\n  ) {\n    throw new TypeError('v3.public verify key must be a public EC P-384 key')\n  }\n\n  return key\n}\n\nmodule.exports = async function v3Verify(\n  token,\n  key,\n  { complete = false, buffer = false, assertion, ...options } = {},\n) {\n  key = checkKey(key)\n  const i = checkAssertion(assertion)\n\n  const { m, footer } = await verify(\n    'v3.public.',\n    token,\n    'sha384',\n    96,\n    { key, dsaEncoding: 'ieee-p1363' },\n    i,\n    compressPk(key),\n  )\n\n  return post('v3', buffer, options, complete, m, footer, 'public')\n}\n","const sign = require('./sign')\nconst verify = require('./verify')\nconst { generateKey, bytesToKeyObject, keyObjectToBytes } = require('./key')\n\nmodule.exports = { sign, verify, generateKey, bytesToKeyObject, keyObjectToBytes }\n","const {\n  _checkPrivateKey,\n  _checkPublicKey,\n  _generateKey,\n  _keyObjectToBytes,\n  bytesToKeyObject,\n} = require('../v2/key')\n\nasync function generateKey(...args) {\n  return _generateKey('v4', ...args)\n}\n\nfunction keyObjectToBytes(...args) {\n  return _keyObjectToBytes('v4', ...args)\n}\n\nmodule.exports = {\n  _checkPrivateKey,\n  _checkPublicKey,\n  bytesToKeyObject,\n  generateKey,\n  keyObjectToBytes,\n}\n","const checkFooter = require('../help/check_footer')\nconst checkPayload = require('../help/check_payload')\nconst checkAssertion = require('../help/check_assertion')\nconst sign = require('../help/sign')\nconst { _checkPrivateKey } = require('./key')\n\nconst checkKey = _checkPrivateKey.bind(undefined, 'v4')\n\nmodule.exports = async function v4Sign(payload, key, { footer, assertion, ...options } = {}) {\n  const m = checkPayload(payload, options)\n  const i = checkAssertion(assertion)\n  key = checkKey(key)\n  const f = checkFooter(footer)\n  return sign('v4.public.', m, f, undefined, key, i)\n}\n","const checkAssertion = require('../help/check_assertion')\nconst verify = require('../help/verify')\nconst { _checkPublicKey } = require('./key')\nconst { post } = require('../help/consume')\n\nconst checkKey = _checkPublicKey.bind(undefined, 'v4')\n\nmodule.exports = async function v4Verify(\n  token,\n  key,\n  { complete = false, buffer = false, assertion, ...options } = {},\n) {\n  key = checkKey(key)\n  const i = checkAssertion(assertion)\n\n  const { m, footer } = await verify('v4.public.', token, undefined, 64, key, i)\n\n  return post('v4', buffer, options, complete, m, footer, 'public')\n}\n","import { lazy } from \"../core/Lazy\"\nimport { isProd, nodeEnv } from \"./NodeEnv\"\nimport { version } from \"./Version\"\n\nexport const SimpleAppName = \"PhotoStructure\"\nexport const SimpleShortAppName = \"phstr\" // < phstr.com redirects to photostructure.com\nexport const SimpleAppNameLC = SimpleAppName.toLowerCase()\n\nexport const AppName = lazy(() => SimpleAppName + (isProd ? \"\" : `-${nodeEnv}`))\nexport const AppNameVersion = lazy(() => AppName() + \" \" + version)\n","import {\n  compact,\n  isEmpty,\n  isNotEmpty,\n  primitiveValueOfOrElse,\n  remove,\n  stepRange,\n  uniqBy\n} from \"../fe/Array\"\nimport { copyArrayTo } from \"../fe/ArrayCopy\"\nimport { sortBy } from \"../fe/ArraySort\"\nimport { notBlank } from \"../fe/Blank\"\nimport { eql } from \"../fe/Eql\"\nimport { stringify } from \"../fe/JSON\"\nimport { Defined, defined, map, mapOr } from \"../fe/Maybe\"\nimport { Maybe, MaybeNull, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { times } from \"../fe/Number\"\nimport { tap } from \"../fe/Object\"\nimport { Comparable, Primitivable, Primitive, gt, lt } from \"../fe/Primitive\"\nimport { MaybeSyncOrAsync, SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { Thunk } from \"../fe/Thunk\"\nimport { toA } from \"../fe/toA\"\nimport { stringifySorted } from \"./StringifySorted\"\n\n// TODO: INLINE\nexport { diff, remove } from \"../fe/Array\"\n\n/**\n * `minuend - subtrahend`, using eql() to compare elements.\n *\n * @template T must have a .valueOf() implementation\n * @param {T[]} minuend (haystack)\n * @param {T[]} subtrahend (needles)\n * @returns {T[]} values in `minuend` that, according to `eql()`, are\n * not in `subtrahend`. Neither arg is mutated.\n */\nexport function diffEql<T>(minuend: T[], subtrahend: T[]): T[] {\n  return minuend.filter(ea => !subtrahend.some(eb => eql(ea, eb)))\n}\n\n// Extract the element type of an array:\nexport type ElementType<T extends readonly unknown[]> = T[number]\n// type T = ElementType<SomeArrayType[]>\n\n/**\n * @return true iff all `objects` are neither `undefined` nor `null`. Note\n * that `[]` returns true.\n */\nexport function allDefined<T>(\n  arr: MaybeNull<MaybeNull<T>[]>\n): arr is Defined<T>[] {\n  return defined(arr) && arr.every(defined)\n}\n\nexport function mapAllDefined<T, U>(\n  arr: MaybeNull<MaybeNull<T>[]>,\n  f: (t: T[]) => U\n): Maybe<U> {\n  return allDefined(arr) ? f(arr) : undefined\n}\n\nexport function mapAll<T, V>(\n  arr: MaybeNull<MaybeNull<T>[]>,\n  f: (ea: T[]) => V\n): Maybe<V> {\n  return allDefined(arr) ? f(arr) : undefined\n}\n\n/**\n * @return true iff all `objects` are `undefined` or `null`\n */\nexport function allNotDefined(objects: any[]): boolean {\n  return objects == null || objects.every(ea => ea == null)\n}\n\nexport function allNotBlank(...arr: MaybeNull<any>[]): boolean {\n  return arr != null && arr.every(notBlank)\n}\n\n/**\n * @return true iff any `objects` are `undefined` or `null`. Note that `[]`\n * returns false (as there aren't not-defined instances).\n */\nexport function anyNotDefined(objects: any[]): boolean {\n  return objects == null || objects.some(ea => ea == null)\n}\n\nexport function anyDefined(objects: any[]): boolean {\n  return objects != null && objects.some(ea => ea != null)\n}\n\nexport async function findAsync<T>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T) => MaybeSyncOrAsync<boolean>\n): PromiseMaybe<T> {\n  for (const ea of toA(arr)) {\n    if (ea != null && true === (await f(ea))) return ea\n  }\n  return\n}\n\nexport async function findLastAsync<T>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T) => MaybeSyncOrAsync<boolean>\n): PromiseMaybe<T> {\n  arr = toA(arr)\n  for (let i = arr.length - 1; i >= 0; i--) {\n    const ea = arr[i]\n    if (ea != null && true === (await f(ea))) return ea\n  }\n  return\n}\n\n/**\n * @return the first non-`null` result of `f`, or if `f` is omitted, the first\n * non-null value in `arr`.\n */\nexport function first<T, R>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T) => MaybeNull<R>\n): Maybe<R> {\n  // PERF: avoid compact() to avoid creating a new array\n  if (arr != null) {\n    for (const ea of toA(arr)) {\n      if (ea != null) {\n        const r = f(ea)\n        if (r != null) {\n          return r\n        }\n      }\n    }\n  }\n  return\n}\n\n/**\n * Return the first result from `f` that is defined.\n * @see Array#first\n * @see Later#firstDefinedLater\n */\nexport async function firstAsync<T, R>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T, index: number) => SyncOrAsync<MaybeNull<R>>\n): PromiseMaybe<R> {\n  if (arr != null) {\n    let index = -1\n    for (const t of arr) {\n      index++\n      try {\n        if (t != null) {\n          const r = await f(t, index)\n          if (r != null) {\n            return r\n          }\n        }\n      } catch (err) {\n        //\n      }\n    }\n  }\n  return undefined\n}\n\n/**\n * @see Later#firstDefinedLater\n */\nexport function firstNonEmptyThunk<T>(\n  ...thunks: Thunk<Maybe<T[]>>[]\n): Maybe<T[]> {\n  for (const t of thunks) {\n    const arr = t()\n    if (isNotEmpty(arr)) {\n      return arr\n    }\n  }\n  return\n}\n\n/**\n * @return the last value in the array that satisfies the predicate\n */\nexport function findFromIndex<T>(\n  arr: T[],\n  predicate: (t: T) => boolean,\n  fromIndex: number\n): Maybe<number> {\n  for (let i = fromIndex; i <= arr.length - 1; i++) {\n    if (predicate(arr[i])) return i\n  }\n  return\n}\n\n/**\n * @return the last value in the array that satisfies the predicate\n */\nexport function findLast<T>(arr: T[], predicate: (t: T) => boolean): Maybe<T> {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) return arr[i]\n  }\n  return\n}\n\n/**\n * @return the last index in the array that satisfies the predicate\n */\nexport function findLastIndex<T>(\n  arr: T[],\n  predicate: (t: T) => boolean\n): number {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) return i\n  }\n  return -1\n}\n\nexport function concat<T>(...arrs: (MaybeNull<T> | MaybeNull<T>[])[]): T[] {\n  const arr: T[] = []\n  for (const ea of arrs) {\n    if (Array.isArray(ea)) {\n      for (const elem of ea) {\n        if (elem != null) arr.push(elem)\n      }\n    } else if (ea != null) {\n      arr.push(ea)\n    }\n  }\n  return arr\n}\n\nexport function moveToEnd<T>(arr: T[], element: T): T[] {\n  remove(arr, element)\n  arr.push(element)\n  return arr\n}\n\nexport function moveIndexToEnd<T>(arr: T[], index: number): T[] {\n  const moved = arr[index]\n  if (moved == null) return arr\n  arr.push(moved)\n  for (let i = index; i < arr.length - 1; i++) {\n    arr[i] = arr[i + 1]\n  }\n  arr.length = arr.length - 1\n  return arr\n}\n\n/**\n * @template T must have a .valueOf() implementation\n * @return the values in both `a` and `b`\n */\nexport function intersection<T>(\n  a: T[],\n  b: T[],\n  valueOf: (t: T) => Primitive = primitiveValueOfOrElse\n): T[] {\n  const s = new Set(b.map(valueOf))\n  return a.filter(ea => s.has(valueOf(ea)))\n}\n\nexport function diceCoeff<T>(\n  a: T[],\n  b: T[],\n  valueOf: (t: T) => Primitive = primitiveValueOfOrElse\n): number {\n  if (isEmpty(a) && isEmpty(b)) return 1\n  return (intersection(a, b, valueOf).length * 2) / (a.length + b.length)\n}\n\n/**\n * @return true iff all elements in `a` are in `b` and all elements in `b` are\n * in `a`. Order is ignored. Elements must be sortable, however.\n */\nexport function eqlUnordered(a: Maybe<any[]>, b: Maybe<any[]>): boolean {\n  return a == null || b == null\n    ? false\n    : zip(sortBy(a, stringifySorted), sortBy(b, stringifySorted)).every(\n        ([x, y]) => eql(x, y)\n      )\n}\n\n/**\n * Remove the first item from `arr` where the `predicate` returns `true`.\n * @return the element removed from `arr`\n */\nexport function removeFirst<T>(\n  arr: T[],\n  predicate: (item: T, index: number, sourceArray: T[]) => boolean\n): Maybe<T> {\n  const idx = arr.findIndex(predicate)\n  return idx >= 0 ? arr.splice(idx, 1)[0] : undefined\n}\n\nexport function uniqInPlace<T>(\n  arr: T[],\n  f: (t: T) => Maybe<Primitive> = ea => stringify(ea)\n): void {\n  copyArrayTo(uniqBy(arr, f), arr)\n}\n\nexport function partition<T>(\n  arr: Iterable<T>,\n  filter: (t: T, index: number) => boolean\n): [T[], T[]] {\n  const accept: T[] = []\n  const reject: T[] = []\n  let i = 0\n  for (const ea of arr) {\n    ;(filter(ea, i++) ? accept : reject).push(ea)\n  }\n  return [accept, reject]\n}\n\nexport function isUniq<T extends Comparable>(t: T[]): boolean {\n  return t.every((ea, i) => t.indexOf(ea) === i)\n}\n\n/**\n * `Uniq -c`: return unique strings and their count\n */\nexport function uniqCount<T extends Primitive>(\n  arr: T[]\n): { t: T; count: number }[] {\n  return _uniqCount(arr.sort())\n}\n\nfunction _uniqCount<T extends Primitive>(\n  sortedArr: T[]\n): { t: T; count: number }[] {\n  if (sortedArr == null || sortedArr.length === 0) return []\n  const t = sortedArr[0]\n  const lastElem = sortedArr.lastIndexOf(t)\n  return [\n    { t, count: lastElem + 1 },\n    ..._uniqCount(sortedArr.slice(lastElem + 1))\n  ]\n}\n\nexport function mapCompact<T, R>(\n  arr: MaybeNull<T>[],\n  f: (t: T) => Maybe<R>\n): R[] {\n  return compact(compact(arr).map(f))\n}\n\nexport function toMapEntries<T, K, V>(\n  arr: T[],\n  f: (t: T) => MaybeNull<[K, V]>\n): Map<K, V> {\n  return new Map<K, V>(arr.map(f).filter(defined) as [K, V][])\n}\n\nexport function flatMap<T, U>(arr: T[], f: (t: T) => Maybe<Maybe<U>[]>): U[] {\n  return arr.reduce(\n    (prev: U[], curr: T) => prev.concat(...compact(f(curr))),\n    []\n  )\n}\n\nexport function retainLastN<T>(arr: T[], length: number): T[] {\n  if (arr.length > length) {\n    arr.splice(0, arr.length - length)\n  }\n  return arr\n}\n\nexport function retainFirstN<T>(arr: T[], length: number): T[] {\n  arr.length = Math.min(arr.length, length)\n  return arr\n}\n\nexport function zip<T1, T2>(arr1: T1[], arr2: T2[]): [T1, T2][]\nexport function zip<T1, T2, T3>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[]\n): [T1, T2, T3][]\nexport function zip<T1, T2, T3, T4>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[]\n): [T1, T2, T3, T4][]\nexport function zip<T1, T2, T3, T4, T5>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[]\n): [T1, T2, T3, T4, T5][]\nexport function zip<T1, T2, T3, T4, T5, T6>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[],\n  arr6: T6[]\n): [T1, T2, T3, T4, T5, T6][]\n// YAY TYPING IS FUN\nexport function zip<T1, T2, T3, T4, T5, T6, T7>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[],\n  arr6: T6[],\n  arr7: T7[]\n): [T1, T2, T3, T4, T5, T6, T7][]\nexport function zip<T1, T2, T3, T4, T5, T6, T7, T8>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[],\n  arr6: T6[],\n  arr7: T7[],\n  arr8: T8[]\n): [T1, T2, T3, T4, T5, T6, T7, T8][]\n\nexport function zip<T>(...arrarr: T[][]): Maybe<T>[][] {\n  const len = Math.max(...arrarr.map(ea => ea?.length ?? 0))\n  return times(len, i => arrarr.map(ea => ea?.[i]))\n}\n\nexport function flatZip<T>(...arrarr: T[][]): Maybe<T>[] {\n  const len = Math.max(...arrarr.map(ea => ea?.length ?? 0))\n  const r: T[] = []\n  times(len, i => arrarr.map(ea => r.push(ea?.[i])))\n  return r\n}\n\nexport function unFlatZip<T>(arr: T[] | Buffer, n: number): number[][] {\n  const len = arr.length / n\n  if (len !== Math.round(len))\n    throw new Error(\n      \"unFlatZip(): bad input array length \" +\n        stringify({ arr_length: arr.length, n })\n    )\n  const results = times(n, () => new Array(len))\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < n; j++) {\n      results[j][i] = arr[i * n + j]\n    }\n  }\n  return results\n}\n\n/**\n * Given [A,B,C], return [A], [A,B], [A,B,C]\n */\nexport function ancestry<T>(arr: T[]): T[][] {\n  return times(arr.length, i => arr.slice(0, i + 1))\n}\n\nexport function min<T extends Primitivable>(arr: MaybeNull<T>[]): Maybe<T> {\n  return arr[leastIndex(arr)] as Maybe<T>\n}\n\n/**\n * Return the first index into `arr` holding the least value (using `valueOf`\n * of T)\n */\nexport function leastIndex<T extends Primitivable>(\n  arr: MaybeNull<T>[]\n): number {\n  return leastIndexBy(arr, ea => ea.valueOf())\n}\n\nexport function max<T extends Primitivable>(arr: MaybeNull<T>[]): Maybe<T> {\n  return arr[greatestIndex(arr)] as Maybe<T>\n}\n\n/**\n * Return the first index into `arr` holding the largest value (using `valueOf`\n * of T)\n */\nexport function greatestIndex<T extends Primitivable>(\n  arr: MaybeNull<T>[]\n): number {\n  return greatestIndexBy(arr, ea => ea.valueOf())\n}\n\nexport function leastIndexBy<T>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<Comparable>\n): number {\n  return estIndex(arr, valueOf, (a, b) => lt(a, b))\n}\n\nexport function greatestIndexBy<T>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<Comparable>\n): number {\n  return estIndex(arr, valueOf, (a, b) => gt(a, b))\n}\n\nexport function leastBy<T>(\n  arr: Maybe<MaybeNull<T>[]>,\n  valueOf: (t: T) => Maybe<Comparable>\n): Maybe<T> {\n  return isEmpty(arr)\n    ? undefined\n    : (arr[leastIndexBy(arr, valueOf)] as Maybe<T>)\n}\n\nexport function least<T extends Comparable>(\n  arr: Maybe<MaybeNull<T>[]>\n): Maybe<T> {\n  return leastBy(arr, ea => ea)\n}\n\nexport function greatestBy<T>(\n  arr: Maybe<MaybeNull<T>[]>,\n  valueOf: (t: T) => Maybe<Comparable>\n): Maybe<T> {\n  return isEmpty(arr)\n    ? undefined\n    : (arr[greatestIndexBy(arr, valueOf)] as Maybe<T>)\n}\n\nfunction estIndex<T>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<Comparable>,\n  cmp: (a: Comparable, b: Comparable) => boolean\n): number {\n  return estIndexCtx(arr, valueOf, cmp).index\n}\n\nexport function leastByCtx<T, C extends Comparable>(\n  arr: Maybe<MaybeNull<T>[]>,\n  valueOf: (t: T) => Maybe<C>\n): Maybe<{ result: T; index: number; value: C }> {\n  const ctx = estIndexCtx(arr ?? [], valueOf, lt)\n  return arr == null || ctx == null || ctx.index < 0 || ctx.value == null\n    ? undefined\n    : { result: arr[ctx.index]!, index: ctx.index, value: ctx.value }\n}\n\nfunction estIndexCtx<T, C extends Comparable>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<C>,\n  cmp: (a: C, b: C) => boolean\n): { index: number; value: Maybe<C> } {\n  if (isEmpty(arr)) return { index: -1, value: undefined }\n\n  let result = -1\n  let value: Maybe<C>\n\n  for (let i = 0; i < arr.length; i++) {\n    const ea = arr[i]\n    if (ea != null) {\n      const v = valueOf(ea)\n      if (v != null) {\n        if (value == null || cmp(v, value) === true) {\n          result = i\n          value = v\n        }\n      }\n    }\n  }\n  return { index: result, value }\n}\n\nexport interface ArrayLike<T> {\n  length: number\n  [index: number]: Maybe<T>\n}\n\nexport function reverse<T extends ArrayLike<any>>(arr: T): T {\n  const r = []\n  for (let i = arr.length - 1; i >= 0; i--) {\n    r.push(arr[i])\n  }\n  return r as any\n}\n\nexport function* reverseG<T>(arr: ArrayLike<T>): Generator<T> {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    yield arr[i]!\n  }\n  return\n}\n\nexport function batches<T>(arr: T[], batchsize: number): T[][] {\n  if (batchsize < 1) batchsize = 1\n  return stepRange(0, arr.length, Math.round(batchsize), i =>\n    arr.slice(i, i + batchsize)\n  )\n}\n\nexport function collectBatched<T1, T2>(\n  arr: T1[],\n  batchSize: number,\n  f: (batch: T1[]) => Maybe<Maybe<T2>[]>\n): T2[] {\n  const result: T2[] = []\n  for (const batchArr of batches(compact(toA(arr)), batchSize)) {\n    result.push(...compact(f(batchArr)))\n  }\n  return result\n}\n\nexport async function collectBatchedAsync<T1, T2>(\n  arr: T1[],\n  batchSize: number,\n  f: (batch: T1[]) => PromiseMaybe<Maybe<T2>[]>\n): Promise<T2[]> {\n  const result: T2[] = []\n  for (const batchArr of batches(compact(toA(arr)), batchSize)) {\n    result.push(...compact(await f(batchArr)))\n  }\n  return result\n}\n\nexport function contextFilter<T>(\n  arr: T[],\n  predicate: (t: T, idx: number, lastPass: Maybe<T>) => boolean\n): T[] {\n  let lastPass: Maybe<T>\n  return arr.filter((ea, idx) =>\n    tap(predicate(ea, idx, lastPass), result => {\n      if (result) lastPass = ea\n    })\n  )\n}\n\nexport function clusterSome<T>(arr: T[], cmp: (a: T, b: T) => boolean): T[][] {\n  const result: T[][] = []\n  for (const ea of arr) {\n    const prior = result.find(ea2 => ea2.some(ea3 => cmp(ea, ea3)))\n    if (prior) prior.push(ea)\n    else result.push([ea])\n  }\n  return result\n}\n\nexport function clusterEvery<T>(arr: T[], cmp: (a: T, b: T) => boolean): T[][] {\n  const result: T[][] = []\n  for (const ea of arr) {\n    const prior = result.find(ea2 => ea2.every(ea3 => cmp(ea, ea3)))\n    if (prior) prior.push(ea)\n    else result.push([ea])\n  }\n  return result\n}\n\nexport async function clusterAsync<T>(\n  arr: T[],\n  cmp: (a: T, b: T) => SyncOrAsync<boolean>\n): Promise<NonNullable<T>[][]> {\n  const result: NonNullable<T>[][] = []\n  outer: for (const ea of arr) {\n    for (const resultArr of result) {\n      if (\n        ea != null &&\n        (await everyAsync(resultArr, prior => cmp(ea, prior)))\n      ) {\n        resultArr.push(ea)\n        continue outer\n      }\n    }\n    if (ea != null) result.push([ea])\n  }\n  return result\n}\n\n/**\n * Return if any `f` returns true.\n * @see Array#some\n */\nexport async function someAsync<T>(\n  arr: T[],\n  f: (t: T, index: number) => SyncOrAsync<boolean>\n): Promise<boolean> {\n  if (arr != null) {\n    for (let i = 0; i < arr.length; i++) {\n      if (await f(arr[i], i)) return true\n    }\n  }\n  return false\n}\n\n/**\n * Return if every `f` returns true.\n * @see Array#every\n */\nexport async function everyAsync<T>(\n  arr: T[],\n  f: (t: T, index: number) => SyncOrAsync<boolean>\n): Promise<boolean> {\n  return isEmpty(arr) || (await Promise.all(arr.map(f))).every(ea => ea)\n}\n\nexport function firstIndexNearest<T>({\n  arr,\n  fromIndex,\n  pred,\n  maxDelta\n}: {\n  arr: T[]\n  fromIndex: number\n  pred: (t: T, index: number) => boolean\n  maxDelta: number\n}): Maybe<number> {\n  for (let i = 1; i < Math.min(maxDelta + 1, arr.length); i++) {\n    {\n      const before = fromIndex - i\n      if (before >= 0 && true === map(arr[before], ea => pred(ea, before))) {\n        return before\n      }\n    }\n    {\n      const after = fromIndex + i\n      if (after < arr.length && pred(arr[after]!, after)) return after\n    }\n  }\n  return\n}\n\nexport function dupes<T extends Primitive>(arr: Maybe<T>[]) {\n  const mm = new Map<T, number>()\n  for (const ea of arr) {\n    if (ea != null)\n      mm.set(\n        ea,\n        mapOr(mm.get(ea), i => i + 1, 1)\n      )\n  }\n  return toA(mm.entries()).filter(([, v]) => v > 1)\n}\n\nexport function leftPadArray<T>(arr: T[], minLength: number, pad: T) {\n  if (arr.length < minLength) {\n    arr.unshift(...times(minLength - arr.length, () => pad))\n  }\n  return arr\n}\n","import {\n  BatchCluster,\n  BatchClusterEmitter,\n  BatchClusterOptions\n} from \"batch-cluster\"\nimport { ExifTool } from \"exiftool-vendored\"\nimport process from \"process\"\nimport { lazy } from \"../core/Lazy\"\nimport { minuteMs, secondMs } from \"../fe/Date\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { gt0 } from \"../fe/Number\"\nimport { TimeoutError } from \"../fe/TimeoutError\"\nimport { toS } from \"../fe/toS\"\nimport { mkLogger } from \"./Logger\"\nimport { Pids, addPid } from \"./Pids\"\nimport { renice } from \"./Renice\"\nimport { ShortCommandTimeoutMs } from \"./ShortCommandTimeoutMs\"\nimport { EndableRank, EndableRanks, ending } from \"./async/Endable\"\nimport { EndableWrapper } from \"./async/EndableWrapper\"\nimport { onTimeout } from \"./async/TimeoutHandler\"\nimport { errorToS } from \"./error/Error\"\nimport { FatalErrorFlag } from \"./error/ErrorFlags\"\nimport { isIgnorableError } from \"./error/ErrorTypes\"\nimport { onError } from \"./error/OnError\"\nimport { isWin } from \"./platform/Platform\"\nimport { Settings } from \"./settings/Settings\"\nimport { commandTimeoutMs } from \"./volumes/VolumeTtls\"\n\n// TODO: move to ./proc/? ./bc/?\n/**\n * Rather than extend ExifTool or BatchCluster, just facade it to be an\n * Endable\n */\nexport class BatchClusterObserver<\n  T extends ExifTool | BatchCluster\n> extends EndableWrapper {\n  lastStartError: Maybe<Error>\n  lastInternalError: Maybe<Error>\n  lastTaskError: Maybe<Error>\n\n  constructor(\n    name: string,\n    readonly t: T,\n    rank: EndableRank = EndableRanks.service\n  ) {\n    super(\n      `proc.BatchClusterObserver(${name})`,\n      () => this.t.end(),\n      rank,\n      name === \"worker\" ? commandTimeoutMs() : ShortCommandTimeoutMs\n    )\n    // TODO: TYPESCRIPT SITS: this cast shouldn't be necessary\n    const bce: Pick<BatchClusterEmitter, \"on\"> = t\n    bce.on(\"childStart\", async bp => {\n      if (bp.pid == null) {\n        this.onError(\"No PID returned for \" + name, new TimeoutError())\n        return\n      }\n      this.logger.info(\"Started child process\", { pid: bp.pid })\n      renice(bp.pid).catch(err => this.onError(\"renice failed\", err))\n      addPid(\n        {\n          pid: bp.pid,\n          ppid: process.pid,\n          cmd: name,\n          timeoutMs: t.options.maxProcAgeMillis + minuteMs\n        },\n        new Date()\n      )?.catch(err => this.onError(\"addPid failed for \" + name, err))\n    })\n    bce.on(\"startError\", error => {\n      this.lastStartError = error\n      this.onError(\"failed to start\", error)\n    })\n    bce.on(\"taskError\", (error, task) => {\n      if (errorToS(error).match(/timeout/) != null) onTimeout()\n      this.lastTaskError = error\n      this.onError(\"failed to run \" + map(task, ea => ea.command), error)\n    })\n    bce.on(\"fatalError\", error => {\n      this.onError(\"on(fatalError)\" + FatalErrorFlag, error)\n    })\n    bce.on(\"internalError\", error => {\n      this.lastInternalError = error\n      this.onError(\"internal error\", error)\n    })\n    bce.on(\"noTaskData\", (stdout, stderr, proc) => {\n      // This is probably due to streamFlushMillis being too aggressive.\n      const prior = t.options.streamFlushMillis\n      // Bump up the streamFlushMillis if it's not \"too big\" already, to try to\n      // avoid this in the future:\n      if (prior < secondMs) {\n        t.options.streamFlushMillis += 100\n        this.logger.warn(\"on(noTaskData): bumping up streamFlushMillis.\", {\n          prior,\n          new: t.options.streamFlushMillis,\n          stout: toS(stdout),\n          stderr: toS(stderr),\n          child_pid: proc?.pid\n        })\n      }\n    })\n    bce.on(\"endError\", err => {\n      this.logger.error(\"observeBatchCluster.endError()\", err)\n    })\n    bce.on(\"childEnd\", cp => {\n      if (gt0(cp?.pid)) {\n        this.logger.info(\"on(childExit)\", cp.pid)\n        void Pids.instance()?.onKill(cp.pid)\n      }\n    })\n  }\n\n  onError(reason: string, error: Error): void {\n    // Avoid stack overflow on end (where end error asks services to shut down,\n    // which causes an end error, which ...)\n    if (!this.t.ended && !ending() && isIgnorableError(error) === false) {\n      onError(this.name + \": \" + reason, error)\n    } else {\n      this.logger.warn(\"onError() (ending or ignorable): \" + reason, error)\n    }\n  }\n}\n\nexport function batchClusterOptions(\n  maxProcs: number,\n  loggerName: string\n): Partial<BatchClusterOptions> {\n  return {\n    maxProcs,\n    // Shut down idle procs after a minute or two (longer on Windows because\n    // forking is so expensive)\n    maxIdleMsPerProcess: (isWin ? 3 : 1) * minuteMs,\n    maxTasksPerProcess: Settings.maxTasksPerProcess.valueOrDefault,\n    // it shouldn't take longer than a second for node to spin up, but\n    // antivirus and slow external disks can cause huge latency:\n    spawnTimeoutMillis: commandTimeoutMs(),\n    // no fork-bombs\n    minDelayBetweenSpawnMillis: Settings.minDelayBetweenSpawnMs.valueOrDefault,\n    streamFlushMillis: Settings.streamFlushMs.valueOrDefault,\n    // We'll take care of it with the pid reaper:\n    cleanupChildProcs: false,\n    logger: lazy(() => mkLogger(loggerName))\n  }\n}\n","import { SortedSet } from \"./SortedSet\"\n\nexport class BoundedGreatestSet<T> {\n  readonly sortedArray: SortedSet<T>\n\n  constructor(\n    readonly maxLength: number,\n    readonly toValue: (t: T) => number\n  ) {\n    this.sortedArray = new SortedSet(toValue)\n  }\n\n  toArray() {\n    this.vacuum()\n    return this.sortedArray.store\n  }\n\n  vacuum() {\n    return this.sortedArray.retainLastN(this.maxLength)\n  }\n\n  add(...arr: T[]) {\n    this.sortedArray.addAll(...arr)\n    if (this.sortedArray.length >= 2 * this.maxLength) this.vacuum()\n  }\n}\n","import { List } from \"../fe/List\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { clamp, times } from \"../fe/Number\"\n\nexport class BoundedList<T> implements Iterable<T>, List<T> {\n  // round-robin implementation:\n  private readonly store: T[]\n  private _length = 0\n  private _firstIndex = 0\n  constructor(readonly maxLength: number) {\n    if (maxLength > 1000)\n      throw new Error(\"BoundedList.maxLength of \" + maxLength)\n    this.store = new Array<T>(...(times(maxLength, () => null) as any))\n  }\n\n  /**\n   * @param index follows https://github.com/tc39/proposal-item-method\n   */\n  private mapIndex<U>(index: number, f: (storeIndex: number) => U): Maybe<U> {\n    index = Math.trunc(index) ?? 0\n    if (index < 0) {\n      index += this._length\n    }\n    return index < 0 || index >= this._length\n      ? undefined\n      : f((index + this._firstIndex + this.maxLength) % this.maxLength)\n  }\n\n  // [i: number]: T {\n  //   return this.get(i) as any\n  // }\n\n  /**\n   * @see https://github.com/tc39/proposal-item-method\n   */\n  at(n: number): T {\n    return this.mapIndex(n, idx => this.store[idx]) as T\n  }\n\n  /**\n   * @return the last value in this list\n   */\n  get last(): Maybe<T> {\n    return this.at(-1)\n  }\n\n  set(n: number, value: T) {\n    return this.mapIndex(n, idx => (this.store[idx] = value))\n  }\n\n  get length(): number {\n    return this._length\n  }\n\n  set length(l: number) {\n    this._length = clamp(0, this._length, l)\n  }\n\n  clear() {\n    this.length = 0\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<T> {\n      for (let i = 0; i < self.length; i++) {\n        yield self.mapIndex(i, ea => self.store[ea])!\n      }\n    }\n    return iter()\n  }\n\n  push(...items: T[]): number {\n    // Don't bother pushing more than the last maxLength items:\n    for (const item of items.slice(-this.maxLength)) {\n      if (this._length < this.maxLength) {\n        this._length++\n      } else {\n        // push 1 entry off the head:\n        this._firstIndex++\n        this._firstIndex = this._firstIndex % this.maxLength\n      }\n      this.mapIndex(this._length - 1, idx => {\n        this.store[idx] = item\n      })\n    }\n    return this._length\n  }\n\n  pop(): T | undefined {\n    return this.mapIndex(this._length - 1, idx => {\n      this._length--\n      return this.store[idx]\n    })\n  }\n\n  unshift(...items: T[]): number {\n    for (const item of items.reverse()) {\n      if (this._length < this.maxLength) {\n        this._length++\n      }\n      // push 1 entry off the head:\n      this._firstIndex--\n      this.mapIndex(0, idx => {\n        this.store[idx] = item\n        this._firstIndex = idx\n      })\n    }\n    return this._length\n  }\n\n  shift(): T | undefined {\n    return this.mapIndex(0, idx => {\n      this._firstIndex++\n      this._length--\n      return this.store[idx]\n    })\n  }\n\n  shiftOrFirst() {\n    return this.length > 1 ? this.shift() : this.at(0)\n  }\n\n  every(callbackfn: (value: T, index: number) => boolean): boolean {\n    for (let i = 0; i < this._length; i++) {\n      if (!callbackfn(this.at(i), i)) return false\n    }\n    return true\n  }\n\n  some(callbackfn: (value: T, index: number) => boolean): boolean {\n    for (let i = 0; i < this._length; i++) {\n      if (callbackfn(this.at(i), i)) return true\n    }\n    return false\n  }\n\n  forEach(callbackfn: (value: T, index: number) => void): void {\n    for (let i = 0; i < this._length; i++) {\n      callbackfn(this.at(i), i)\n    }\n  }\n\n  map<U>(callbackfn: (value: T, index: number) => U): U[] {\n    const arr = []\n    for (let i = 0; i < this._length; i++) {\n      arr.push(callbackfn(this.at(i), i))\n    }\n    return arr\n  }\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue\n    for (let i = 0; i < this._length; i++) {\n      acc = callbackfn(acc, this.at(i), i)\n    }\n    return acc\n  }\n\n  reverse(): this {\n    for (let i = 0; i < Math.floor(this._length / 2); i++) {\n      this.mapIndex(i, from => {\n        this.mapIndex(this._length - 1 - i, to => {\n          const swap = this.store[to]\n          this.store[to] = this.store[from]\n          this.store[from] = swap\n        })\n      })\n    }\n    return this\n  }\n\n  toA(): T[] {\n    return [...this]\n  }\n\n  slice(start?: number | undefined, end?: number | undefined): T[] {\n    return [...this].slice(start, end)\n  }\n\n  // sort(compareFn?: ((a: T, b: T) => number) | undefined): this {\n  //   throw new Error(\"Method not implemented.\")\n  // }\n  // indexOf(searchElement: T, fromIndex?: number | undefined): number {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // lastIndexOf(searchElement: T, fromIndex?: number | undefined): number {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];\n  // filter(callbackfn: (value: T, index: number, array: T[]) => , thisArg?: any): T[];\n  // filter(callbackfn: any, thisArg?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n  // reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n  // reduce(callbackfn: any, initialValue?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n  // reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n  // reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n  // reduceRight(callbackfn: any, initialValue?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;\n  // find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined;\n  // find(predicate: any, thisArg?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // fill(value: T, start?: number | undefined, end?: number | undefined): this {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // copyWithin(target: number, start: number, end?: number | undefined): this {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // entries(): IterableIterator<[number, T]> {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // keys(): IterableIterator<number> {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // values(): IterableIterator<T> {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // [Symbol.unscopables](): { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; } {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // includes(searchElement: T, fromIndex?: number | undefined): boolean {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n}\n","import { toS } from \"../fe/toS\"\n\n// Windows has an issue compiling this file if it's called \"Buffer\" (!!)\n\nconst ByteOrderMarks: { bom: number[]; encoding: BufferEncoding }[] = [\n  { bom: [0xef, 0xbb, 0xbf], encoding: \"utf8\" },\n  { bom: [0xff, 0xfe], encoding: \"utf16le\" }\n]\n\n// tested by SettingsIO.spec.ts:\nexport function debom(b: Buffer): string {\n  for (const { bom, encoding } of ByteOrderMarks) {\n    if (bufferStartsWith(b, bom)) {\n      return b.subarray(bom.length).toString(encoding)\n    }\n  }\n  return b.toString()\n}\n\nexport function bufferToString(b: Buffer | string): string {\n  return Buffer.isBuffer(b) ? debom(b) : toS(b)\n}\n\nexport function bufferStartsWith(b: Buffer, prefix: number[]) {\n  return prefix.every((ea, idx) => b[idx] === ea)\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { DefaultNormalizer } from \"./StringNormalizer\"\n\nexport class CaseInsensitiveMap<V> implements Map<string, V> {\n  // the value contains the original-cased key\n  private readonly store = new Map<string, [string, V]>()\n\n  constructor(\n    initialContents: [string, V][] = [],\n    readonly normalizer = DefaultNormalizer\n  ) {\n    for (const [k, v] of initialContents) {\n      this.set(k, v)\n    }\n  }\n  get(key: string): Maybe<V> {\n    const k = this.normalizer(key)\n    return k == null ? undefined : this.store.get(k)?.[1]\n  }\n  lookup(key: Maybe<string>): Maybe<[string, V]> {\n    const k = this.normalizer(key)\n    return k == null ? undefined : this.store.get(k)\n  }\n  has(key: Maybe<string>): boolean {\n    const k = this.normalizer(key)\n    return k == null ? false : this.store.has(k)\n  }\n  set(key: Maybe<string>, value: V): this {\n    const k = this.normalizer(key)\n    if (key != null && k != null) this.store.set(k, [key, value])\n    return this\n  }\n  clear(): void {\n    this.store.clear()\n  }\n  delete(key: string): boolean {\n    const k = this.normalizer(key)\n    return k == null ? false : this.store.delete(k)\n  }\n  forEach(\n    callbackfn: (value: V, key: string, map: Map<string, V>) => void\n  ): void {\n    this.store.forEach(v => callbackfn(v[1], v[0], this))\n  }\n  get size(): number {\n    return this.store.size\n  }\n  entries(): IterableIterator<[string, V]> {\n    return this.store.values()\n  }\n  keys(): IterableIterator<string> {\n    return [...this.store.values()].map(ea => ea[0])[Symbol.iterator]()\n  }\n  values(): IterableIterator<V> {\n    return [...this.store.values()].map(ea => ea[1])[Symbol.iterator]()\n  }\n  [Symbol.iterator](): IterableIterator<[string, V]> {\n    return this.entries()\n  }\n  get [Symbol.toStringTag](): string {\n    return \"CaseInsensitiveMap\"\n  }\n\n  pick(...keys: string[]): Record<string, V> {\n    const result: Record<string, V> = {}\n    for (const key of keys) {\n      const l = this.lookup(key)\n      if (l != null) {\n        result[l[0]] = l[1]\n      }\n    }\n    return result\n  }\n}\n","import { uniq } from \"../fe/Array\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { MultiMap } from \"../fe/MultiMap\"\nimport * as o from \"../fe/Object\"\nimport { toA } from \"../fe/toA\"\nimport { diceCoeff } from \"./StringSimilarity\"\n\n/**\n * ONLY BASE-ASCII CASE-INSENSITIVE!\n */\nexport class CaseInsensitiveValued<V> {\n  private readonly m: MultiMap<string, string>\n  constructor(\n    readonly obj: o.Valued<V>,\n    readonly synonyms: (key: string, value: V) => Maybe<string[]> = () =>\n      undefined\n  ) {\n    this.m = new MultiMap()\n    this.vacuum()\n  }\n\n  vacuum() {\n    this.m.clear()\n    for (const [k, v] of o.entries(this.obj)) {\n      for (const key of uniq(\n        [k, ...toA(this.synonyms(k, v))].map(ea => ea.toLowerCase())\n      )) {\n        this.m.add(key, k)\n      }\n    }\n    this.m.vacuum()\n  }\n\n  lookup(key: string): Maybe<{ key: string; value: V }> {\n    if (key == null) return\n    const value = this.obj[key]\n    return value != null\n      ? { key, value }\n      : this.getFirst(this.m.get(key.toLowerCase()))\n  }\n\n  lookupNearest(key: string, minDiceCoeff = 0.4) {\n    const exact = this.lookup(key)\n    if (exact != null) return exact\n    let bestCoeff = -1\n    let best: Maybe<{ key: string; value: V }>\n    for (const [k, arr] of this.m.entries()) {\n      const coeff = diceCoeff(k, key)\n      if (coeff > minDiceCoeff && coeff > bestCoeff) {\n        const newBest = this.getFirst(arr)\n        if (newBest != null) {\n          best = newBest\n          bestCoeff = coeff\n        }\n      }\n    }\n\n    return best\n  }\n\n  get(key: string): Maybe<V> {\n    return this.lookup(key)?.value\n  }\n\n  getFirst(keys: Maybe<string[]>): Maybe<{ key: string; value: V }> {\n    if (keys == null) return\n    for (const k of keys) {\n      // return the first non-null value:\n      const value = this.obj[k]\n      if (value != null) return { key: k, value }\n    }\n    return\n  }\n\n  delete(key: string) {\n    const lc = key.toLowerCase()\n    const arr = this.m.get(lc)\n    if (arr != null) {\n      for (const k of arr) {\n        delete this.obj[k]\n      }\n      this.m.delete(lc)\n    }\n  }\n\n  pick(...keys: string[]): Record<string, V> {\n    const result: Record<string, V> = {}\n    for (const key of keys) {\n      const l = this.lookup(key)\n      if (l?.key != null) {\n        result[l.key] = l.value\n      }\n    }\n    return result\n  }\n}\n","import { noColor } from \"./NoColor\"\n\n// we're not referencing Setting.logColor here to break deploop:\nlet colorEnabled = !noColor()\n\nexport function setColorEnabled(on?: boolean) {\n  colorEnabled = on ?? !noColor()\n}\n\nfunction withAsciiEscape(on: number, off: number) {\n  return (msg: string) =>\n    colorEnabled ? `\\u001b[${on}m${msg}\\u001b[${off}m` : msg\n}\n\n// https://en.wikipedia.org/wiki/ANSI_escape_code#3/4_bit\n\nexport const reset = withAsciiEscape(0, 0)\nexport const bold = withAsciiEscape(1, 22)\nexport const dim = withAsciiEscape(2, 22)\nexport const italic = withAsciiEscape(3, 23)\nexport const underline = withAsciiEscape(4, 24)\nexport const overline = withAsciiEscape(53, 55)\nexport const inverse = withAsciiEscape(7, 27)\nexport const hidden = withAsciiEscape(8, 28)\nexport const strikethrough = withAsciiEscape(9, 29)\n\nexport const black = withAsciiEscape(30, 39)\nexport const red = withAsciiEscape(31, 39)\nexport const green = withAsciiEscape(32, 39)\nexport const yellow = withAsciiEscape(33, 39)\nexport const blue = withAsciiEscape(34, 39)\nexport const magenta = withAsciiEscape(35, 39)\nexport const cyan = withAsciiEscape(36, 39)\n\nexport const lightGrey = withAsciiEscape(37, 39)\nexport const darkGrey = withAsciiEscape(90, 39)\nexport const redBright = withAsciiEscape(91, 39)\nexport const greenBright = withAsciiEscape(92, 39)\nexport const yellowBright = withAsciiEscape(93, 39)\nexport const blueBright = withAsciiEscape(94, 39)\nexport const magentaBright = withAsciiEscape(95, 39)\nexport const cyanBright = withAsciiEscape(96, 39)\nexport const white = withAsciiEscape(97, 39)\n\nexport const bgBlack = withAsciiEscape(40, 49)\nexport const bgRed = withAsciiEscape(41, 49)\nexport const bgGreen = withAsciiEscape(42, 49)\nexport const bgYellow = withAsciiEscape(43, 49)\nexport const bgBlue = withAsciiEscape(44, 49)\nexport const bgMagenta = withAsciiEscape(45, 49)\nexport const bgCyan = withAsciiEscape(46, 49)\n\nexport const bgLightGrey = withAsciiEscape(47, 49)\nexport const bgDarkGrey = withAsciiEscape(100, 49)\nexport const bgRedBright = withAsciiEscape(101, 49)\nexport const bgGreenBright = withAsciiEscape(102, 49)\nexport const bgYellowBright = withAsciiEscape(103, 49)\nexport const bgBlueBright = withAsciiEscape(104, 49)\nexport const bgMagentaBright = withAsciiEscape(105, 49)\nexport const bgCyanBright = withAsciiEscape(106, 49)\nexport const bgWhite = withAsciiEscape(107, 49)\n\n// export function ansiColor(msg: string, rgb: Triplet) {\n//   const [r,g,b] = clampRGB(rgb)\n//   return `\\u001b[38;2;${r};${g};${b}m\"`\n// }\n","import { sort, sortBy } from \"../fe/ArraySort\"\nimport { isNumber, mapNumericOr } from \"../fe/Number\"\nimport { tap } from \"../fe/Object\"\nimport { toS } from \"../fe/toS\"\nimport { Average } from \"./math/Average\"\nimport { sum } from \"./math/Vector\"\n\nexport class CountingSet<K extends number | string> {\n  private readonly m = new Map<K, number>()\n\n  incr(key: K, count: number = 1): number {\n    const v = this.get(key) + count\n    if (v === 0) this.m.delete(key)\n    else this.m.set(key, v)\n    return v\n  }\n\n  get(key: K): number {\n    return this.m.get(key) ?? 0\n  }\n\n  /**\n   * If no keys are provided, return the max value\n   */\n  max(...arr: K[]): number {\n    return Math.max(\n      ...(arr.length === 0 ? this.m.values() : arr.map(ea => this.get(ea)))\n    )\n  }\n\n  has(key: K): boolean {\n    return this.m.has(key)\n  }\n\n  delete(key: K): boolean {\n    return this.m.delete(key)\n  }\n\n  /**\n   * Return the number of unique non-zero `incr`emented keys\n   */\n  get size(): number {\n    return this.m.size\n  }\n\n  /**\n   * Return the sum of all counts\n   */\n  get countSum(): number {\n    return sum(this.m.values())\n  }\n\n  keys(): IterableIterator<K> {\n    return this.m.keys()\n  }\n\n  /**\n   * @return if all keys are numeric, the average value of keys, otherwise, `undefined`.\n   */\n  keyAvg() {\n    const avg = new Average(0)\n    for (const k of this.keys()) {\n      if (isNumber(k)) {\n        avg.push(k)\n      } else {\n        return\n      }\n    }\n    return avg.avg\n  }\n\n  entries(): IterableIterator<[K, number]> {\n    return this.m.entries()\n  }\n\n  toJSON() {\n    return this.toRecord()\n  }\n\n  toRecord(): Record<string, number> {\n    const obj: any = {}\n    for (const [k, v] of this.m.entries()) {\n      obj[toS(k)] = v\n    }\n    return obj\n  }\n\n  /** Multimodal ties are solved by proximity to mean */\n  entriesByCountDesc(): [K, number][] {\n    const keyAvg = this.keyAvg()\n    return sortBy([...this.entries()], ([k, v]) => [\n      -v,\n      mapNumericOr(keyAvg, ea => Math.abs((k as number) - ea), 0)\n    ])\n  }\n\n  top(n = 1): [K, number][] {\n    return this.entriesByCountDesc().slice(0, n)\n  }\n\n  topKeys(n = 1): K[] {\n    return this.top(n).map(ea => ea[0])\n  }\n\n  get averageCounts(): Average {\n    return tap(new Average(this.size), a =>\n      [...this.m.values()].forEach(ea => a.push(ea))\n    )\n  }\n\n  forEach(callbackfn: (count: number, key: K) => void): void {\n    this.m.forEach(callbackfn)\n  }\n\n  clear(): void {\n    this.m.clear()\n  }\n\n  sortedByKey(): CountingSet<K> {\n    const result = new CountingSet<K>()\n    for (const [k, count] of sortBy(this.m.entries(), ea => ea[0])) {\n      result.incr(k, count)\n    }\n    return result\n  }\n\n  addAll(s: this) {\n    for (const [k, i] of s.entries()) {\n      this.incr(k, i)\n    }\n    return this\n  }\n\n  get toS() {\n    return sort([...this.keys()])\n      .map(key => key + \" \" + this.get(key))\n      .join(\"\\n\")\n  }\n\n  valuesToA<T>(f: (k: K) => T): T[] {\n    const arr: T[] = []\n    // pre-allocate:\n    arr.length = sum(this.m.values())\n    let idx = 0\n    for (const [k, count] of this.m.entries()) {\n      const value = f(k)\n      arr.fill(value, idx, idx + count)\n      idx += count\n    }\n    return arr\n  }\n}\n","export const DefaultSensitiveEnvRegexPattern = [\n  \"key(?!word)\",\n  \"aws_\",\n  \"npm_\",\n  \"pass\",\n  \"private\",\n  \"secret\",\n  \"token\"\n].join(\"|\")\n","import { lazy } from \"../core/Lazy\"\nimport { SimpleAppName } from \"./AppName\"\nimport { isElectron } from \"./platform/Platform\"\nimport { isDocker } from \"./platform/isDocker\"\n\nexport const EditionType = lazy(() =>\n  isElectron ? \"Desktops\" : isDocker() ? \"Docker\" : \"Servers\"\n)\n\nexport const EditionName = lazy(() => SimpleAppName + \" for \" + EditionType())\n","import { map } from \"../fe/Maybe\"\nimport { SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { Thunk } from \"../fe/Thunk\"\nimport { Logger } from \"./Logger\"\n\nexport class Elapsed {\n  private ts = Date.now()\n  constructor(\n    readonly l: Logger,\n    readonly listener?: (name: string, elapsedMs: number) => any\n  ) {}\n\n  elapsed(msg: string) {\n    const now = Date.now()\n    const diff = now - this.ts\n    this.ts = now\n    map(this.listener, ea => ea(msg, diff))\n    if (diff > 2) {\n      this.l.log(diff > 500 ? \"warn\" : diff > 100 ? \"info\" : \"debug\", msg, {\n        elapsedMs: diff\n      })\n    }\n  }\n}\n\nexport function elapsed<T>(t: Thunk<T>): { elapsedMs: number; result: T } {\n  const start = Date.now()\n  const result = t()\n  return { elapsedMs: Date.now() - start, result }\n}\n\nexport async function thenElapsed<T>(\n  t: SyncOrAsync<T>\n): Promise<{ elapsedMs: number; result: T }> {\n  const start = Date.now()\n  const result = await t\n  return { elapsedMs: Date.now() - start, result }\n}\n","import { eql } from \"../fe/Eql\"\nimport { map2Or } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { pick } from \"../fe/Object\"\nimport { MaybeSyncOrAsync } from \"../fe/SyncOrAsync\"\n\n// TODO: INLINE\nexport { eql } from \"../fe/Eql\"\nexport function definedAndEql<T>(a: Maybe<T>, b: Maybe<T>): boolean {\n  return a == null || b == null ? false : eql(a, b)\n}\n\nexport function definedAndNotEql<T>(a: Maybe<T>, b: Maybe<T>): boolean {\n  return a != null && b != null && !eql(a, b)\n}\n\nexport async function eqlAsync<T>(\n  a: MaybeSyncOrAsync<T>,\n  b: MaybeSyncOrAsync<T>\n): Promise<boolean> {\n  return map2Or(await a, await b, eql, () => false)\n}\n\nexport function eqlPicked<T, K extends keyof T>(\n  a: Maybe<T>,\n  b: Maybe<T>,\n  ...keys: K[]\n): boolean {\n  return a == null || b == null\n    ? false\n    : eql(pick(a, ...keys), pick(b, ...keys))\n}\n\nexport async function eqlAsyncPicked<T, K extends keyof T>(\n  a: MaybeSyncOrAsync<T>,\n  b: MaybeSyncOrAsync<T>,\n  ...keys: K[]\n): Promise<boolean> {\n  return map2Or(\n    await a,\n    await b,\n    (a1, a2) => eql(pick(a1, ...keys), pick(a2, ...keys)),\n    () => false\n  )\n}\n","import { examplesNativePath_ } from \"./ExamplesNativePath\"\nimport { lazy } from \"./Lazy\"\nimport { PosixFile } from \"./fs/PosixFile\"\n\n// This can't be a PosixFile: it causes a dep loop.\nexport const examples = lazy(() => PosixFile.for(examplesNativePath_()))\n","import { lazy } from \"../core/Lazy\"\nimport { ancestorWithChildren } from \"./fs/Ancestors\"\nimport { joinNativePath } from \"./fs/Path\"\n\n// This was broken out of ExamplesDir so assertEqlPrior could avoid a deploop\nexport const examplesNativePath_ = lazy(() => {\n  const exampleParentDir = ancestorWithChildren(__dirname, [\"examples\"])\n  if (exampleParentDir == null) {\n    throw new Error(\"Couldn't find the examples directory\")\n  }\n  return joinNativePath([exampleParentDir, \"examples\"])\n})\n","export abstract class ExtensibleFunction<T> extends Function {\n  readonly _self: ExtensibleFunction<T>\n  constructor() {\n    super(\"...args\", \"return this._self._call(...args)\")\n    const self = this.bind(this)\n    this._self = self\n    return self\n  }\n  abstract _call(): T\n}\n","import { inspect } from \"util\"\nimport { isNotEmpty, uniq } from \"../fe/Array\"\nimport { GetOrSet } from \"../fe/GetOrSet\"\nimport { orElse } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { gt0, isNumber, round } from \"../fe/Number\"\nimport { toS } from \"../fe/toS\"\nimport { union } from \"./Set\"\nimport { setUnrefInterval } from \"./async/Timers\"\n\n// simple null-safe keys()\nfunction keys(o: any): string[] {\n  return o == null ? [] : Object.keys(o)\n}\n\n/**\n * First-in-first-out cache. Implementation inspired by\n * https://github.com/dominictarr/hashlru.\n *\n * https://en.wikipedia.org/wiki/Cache_replacement_policies\n */\nexport class FifoCache<V> implements GetOrSet<string, V> {\n  private currentCache!: Record<string, V>\n  private setsSinceLastSpill: number = 0\n  private priorCache!: Record<string, V>\n  private clearInterval?: NodeJS.Timeout\n\n  private readonly expireListeners: ((k: string, v: V) => void)[] = []\n\n  constructor(\n    readonly maxSize: number,\n    readonly clearEveryMs?: number\n  ) {\n    if (maxSize > 30_000) {\n      // 30 seconds\n      throw new Error(\"maxSize is too big\")\n    }\n    // Set up _size and caches:\n    this.clear()\n    if (gt0(clearEveryMs)) {\n      this.clearInterval = setUnrefInterval(\n        () => {\n          this.spill()\n        },\n        round(clearEveryMs / 2)\n      )\n    }\n  }\n\n  private spill() {\n    if (\n      this.priorCache != null &&\n      this.currentCache != null &&\n      isNotEmpty(this.expireListeners)\n    ) {\n      for (const k in this.priorCache) {\n        if (this.currentCache[k] == null) {\n          const v = this.priorCache[k]\n          if (v != null) {\n            for (const el of this.expireListeners) {\n              el(k, v)\n            }\n          }\n        }\n      }\n    }\n    this.priorCache = this.currentCache ?? Object.create(null)\n    this.currentCache = Object.create(null)\n    this.setsSinceLastSpill = 0\n  }\n\n  [inspect.custom]() {\n    return {\n      ...this.priorCache,\n      ...this.currentCache\n    }\n  }\n\n  end() {\n    if (this.clearInterval != null) clearInterval(this.clearInterval)\n  }\n\n  clear(): this {\n    this.visit((k, v) => {\n      for (const el of this.expireListeners) {\n        el(k, v)\n      }\n    })\n    this.currentCache = Object.create(null)\n    this.priorCache = Object.create(null)\n    this.setsSinceLastSpill = 0\n    return this\n  }\n\n  get size(): number {\n    if (this.currentCache == null || this.priorCache == null) return 0\n    let sum = 0\n    for (const k of union(keys(this.priorCache), keys(this.currentCache))) {\n      if (this.has(k)) sum++\n    }\n    return sum\n  }\n\n  has(key: string): boolean {\n    return (\n      this.currentCache[key] !== undefined || this.priorCache[key] !== undefined\n    )\n  }\n\n  keys(): string[] {\n    return uniq([...keys(this.priorCache), ...keys(this.currentCache)]).filter(\n      k => null != this.currentCache[k] ?? this.priorCache[k]\n    )\n  }\n\n  delete(key: string) {\n    // We don't decrement size here, because we don't use `delete\n    // this.currentCache[key]` (because delete is slow (!!))\n    const v = this.currentCache[key]\n    if (v !== undefined) {\n      this.currentCache[key] = undefined as any\n      for (const el of this.expireListeners) {\n        el(key, v)\n      }\n    }\n    const v2 = this.priorCache[key]\n    if (v2 !== undefined) {\n      this.priorCache[key] = undefined as any\n      if (v == null) {\n        for (const el of this.expireListeners) {\n          el(key, v2)\n        }\n      }\n    }\n  }\n\n  visit(visitor: (key: string, value: V) => any) {\n    for (const k of union(keys(this.priorCache), keys(this.currentCache))) {\n      const v = this.currentCache[k] ?? this.priorCache[k]\n      if (v != null) visitor(k, v)\n    }\n  }\n\n  deleteIf(predicate: (key: string, value: V) => boolean) {\n    for (const k of this.keys()) {\n      const v = orElse(this.currentCache[k], this.priorCache[k])\n      if (v != null) {\n        if (predicate(k, v)) {\n          this.delete(k)\n        }\n      }\n    }\n  }\n\n  get(key: string | number): Maybe<V> {\n    key = toS(key)\n    return this.currentCache[key] ?? this.priorCache[key]\n  }\n\n  set(key: string | number, value: V) {\n    if (this.maxSize <= 0) return\n    key = toS(key)\n    if (this.currentCache[key] == null) {\n      if (this.setsSinceLastSpill >= this.maxSize) this.spill()\n      this.setsSinceLastSpill++\n    }\n    this.currentCache[key] = value\n  }\n\n  getOrSet(key: string | number, valueThunk: () => V): V {\n    key = toS(key)\n    if (this.has(key)) {\n      return this.get(key)!\n    }\n    const v = valueThunk()\n    this.set(key, v)\n    return v\n  }\n\n  on(_event: \"expire\", listener: (k: string, v: V) => void) {\n    this.expireListeners.push(listener)\n  }\n}\n\nexport interface Placeholder {\n  __uid: number\n  __start: number\n}\n\nexport function isPlaceholder(s: any): s is Placeholder {\n  return s != null && isNumber(s.__uid) && isNumber(s.__start)\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { gt0 } from \"../fe/Number\"\nimport { MaybeSyncOrAsync, SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { TimeoutError } from \"../fe/TimeoutError\"\nimport { toS } from \"../fe/toS\"\nimport { FifoCache } from \"./FifoCache\"\nimport { Deferred } from \"./async/Deferred\"\n\n// NOTE: this is used statically by Shim, so BE CAREFUL WITH NEW CORE IMPORTS:\n// they will probably cause a dependency loop.\n\nexport type FifoCacheAsyncOpts = ConstructorParameters<typeof FifoCacheAsync>[0]\n\nexport class FifoCacheAsync<V = any> {\n  #cacheHitsSync = 0\n  #cacheHitsAsync = 0\n  #cacheMisses = 0\n  #rejections = 0\n  #timeouts = 0\n  readonly cache: FifoCache<Deferred<V> | V>\n  constructor(\n    readonly opts: {\n      name: string\n      maxSize: number\n      timeoutMs: number\n      clearEveryMs?: number\n    }\n  ) {\n    this.cache = new FifoCache(opts.maxSize, opts.clearEveryMs)\n  }\n\n  get name() {\n    return this.opts.name\n  }\n\n  get size() {\n    return this.cache.size\n  }\n\n  mergeStats(stats: ReturnType<FifoCacheAsync[\"stats\"]>) {\n    this.#cacheHitsSync += stats.cacheHitsSync\n    this.#cacheHitsAsync += stats.cacheHitsAsync\n    this.#cacheMisses += stats.cacheMisses\n    this.#rejections += stats.rejections\n    this.#timeouts += stats.timeouts\n  }\n\n  stats() {\n    return {\n      size: this.size,\n      cacheHitsSync: this.#cacheHitsSync,\n      cacheHitsAsync: this.#cacheHitsAsync,\n      cacheMisses: this.#cacheMisses,\n      rejections: this.#rejections,\n      timeouts: this.#timeouts\n    }\n  }\n\n  has(key: string) {\n    return this.cache.has(key)\n  }\n\n  /**\n   * If the prior getOrSetAsync() threw an error, this method will also.\n   */\n  get_(key: string): MaybeSyncOrAsync<V> {\n    if (!this.cache.has(key)) {\n      this.#cacheMisses++\n      return\n    }\n    const v = this.cache.get(key)\n    if (v instanceof Deferred) {\n      if (v.isRejected) {\n        throw v.error\n      } else if (v.isPending) {\n        this.#cacheHitsAsync++\n        return v.promise\n      } else {\n        this.#cacheHitsSync++\n        return v.value\n      }\n    } else if (v instanceof Error) {\n      throw v\n    } else {\n      this.#cacheHitsSync++\n      return v\n    }\n  }\n\n  /**\n   * @return a value if the key was in cache and the promise was resolved.\n   */\n  get(key: string): Maybe<V> {\n    const v = this.cache.get(key)\n    if (v == null || (v instanceof Deferred && v.isPending)) {\n      this.#cacheMisses++\n    } else {\n      this.#cacheHitsSync++\n    }\n    return v instanceof Deferred ? v.value : v\n  }\n\n  clear() {\n    this.cache.clear()\n    this.#cacheHitsSync = 0\n    this.#cacheHitsAsync = 0\n    this.#cacheMisses = 0\n    this.#rejections = 0\n    this.#timeouts = 0\n  }\n\n  delete(key: string) {\n    return this.cache.delete(key)\n  }\n\n  deleteIf(predicate: (key: string) => boolean) {\n    for (const k of this.cache.keys()) {\n      if (predicate(k)) {\n        this.delete(k)\n      }\n    }\n  }\n\n  set(key: string, value: V): V {\n    this.cache.set(key, value)\n    return value\n  }\n\n  getOrSet(key: string, valueThunk: () => V): V {\n    const prior = this.get(key)\n    if (prior != null) {\n      if (prior instanceof Error) {\n        throw prior\n      } else {\n        return prior\n      }\n    }\n    return this.set(key, valueThunk())\n  }\n\n  // THIS METHOD IS NOT ASYNC: it relies on stable internal state!\n  getOrSetAsync(key: number | string, later: () => Promise<V>): SyncOrAsync<V> {\n    const k = toS(key)\n    {\n      const prior = this.get_(k)\n      if (prior != null) {\n        return prior instanceof Deferred ? prior.promise : prior\n      }\n    }\n\n    const d = new Deferred<V>(this.opts.name).observe(later())\n    // Add the deferred to the cache ASAP:\n    this.cache.set(k, d)\n\n    if (gt0(this.opts.timeoutMs)) {\n      void d.setTimeout(this.opts.timeoutMs)\n    }\n\n    void d.promise.then(\n      result => {\n        // remove the Deferred and release the scoped memory:\n        this.set(k, result)\n      },\n      error => {\n        this.cache.set(k, error)\n        this.#rejections++\n        if (error instanceof TimeoutError) {\n          this.#timeouts++\n        }\n      }\n    )\n    return d.promise\n  }\n}\n","export class FifoSet<T> implements Set<T> {\n  readonly [Symbol.toStringTag] = \"FifoSet\"\n  readonly values = (): IterableIterator<T> => this.delegate.values()\n  readonly keys = this.values\n\n  private readonly delegate = new Set<T>()\n\n  constructor(readonly maxSize: number) {}\n\n  get size(): number {\n    return this.delegate.size\n  }\n\n  add(value: T): this {\n    this.delegate.add(value)\n    this.vacuum()\n    return this\n  }\n\n  clear(): this {\n    this.delegate.clear()\n    return this\n  }\n\n  delete(value: T): boolean {\n    return this.delegate.delete(value)\n  }\n\n  forEach(callbackfn: (value: T, index: T, set: Set<T>) => void): void {\n    this.delegate.forEach(callbackfn)\n  }\n\n  has(value: T): boolean {\n    return this.delegate.has(value)\n  }\n\n  entries(): IterableIterator<[T, T]> {\n    return this.delegate.entries()\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values()\n  }\n\n  /**\n   * remove all expired entries\n   */\n  private vacuum() {\n    if (this.size > this.maxSize) {\n      const iter = this.delegate.entries()\n      while (this.size > this.maxSize) {\n        this.delete(iter.next().value[0])\n      }\n    }\n  }\n}\n","import { lazy } from \"../core/Lazy\"\nimport { last, range } from \"../fe/Array\"\nimport { blank, notBlank } from \"../fe/Blank\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { max_ } from \"../fe/Number\"\nimport { fromEntries, values } from \"../fe/Object\"\nimport { mkLogger } from \"./Logger\"\nimport { escapeRegExp } from \"./RegExp\"\nimport { indexOfNonSpace, isString, lastIndexOfNonSpace } from \"./String\"\nimport { splitLines } from \"./fs/CRLF\"\n\nexport interface Header<T> {\n  text: string & keyof T\n  greedyLeft?: boolean\n  greedyRight?: boolean\n}\n\nclass IndexedHeader<T> {\n  readonly text: string\n  readonly greedyLeft: boolean\n  indexOf?: number\n  leftIdx?: number\n  rightIdx?: number\n  constructor(h: Header<T> | string) {\n    this.text = isString(h) ? h : h.text\n    this.greedyLeft = isString(h) ? false : h[\"greedyLeft\"] ?? false\n  }\n\n  toEntry(row: string): [string, string] {\n    return [this.text, row.substring(this.leftIdx!, this.rightIdx).trim()]\n  }\n}\n\nconst logger = lazy(() => mkLogger(\"Fixed\"))\n\nexport type Headers<T> = (Header<T> | string)[]\n\n/**\n * Parse fixed-width input into an array of objects\n */\nexport function parseFixed<T>(\n  headers: Headers<T>,\n  table: string,\n  warnIfMissingHeaders = true\n): T[] {\n  return new Fixed(headers, table, warnIfMissingHeaders).entries\n}\n\n/**\n * Support for parsing fixed-width tabular data\n */\nexport class Fixed<T> {\n  readonly headers: IndexedHeader<T>[]\n  readonly headerRow: string\n  readonly skippedHeaders: string[] = []\n  readonly rows: string[] // doesn't include the header row!\n  readonly entries: T[]\n  readonly blankColumns: Set<number>\n\n  constructor(\n    headers: Headers<T>,\n    table: string,\n    readonly warnIfMissingHeaders = true\n  ) {\n    this.rows = splitLines(table)\n    this.headerRow = this.rows.shift()!\n    const maxLen = max_(...this.rows.map(ea => ea.length))\n    this.blankColumns = new Set(\n      range(0, maxLen).filter(idx => this.rows.every(ea => blank(ea[idx])))\n    )\n\n    this.headers = this.extractHeaders(headers.map(ea => new IndexedHeader(ea)))\n    this.entries = this.rows\n      .map(row => this.headers.map(h => h.toEntry(row)))\n      .map(arr => fromEntries(arr))\n      // Remove rows that have all blank values:\n      .filter(row => values(row).some(notBlank))\n  }\n\n  /**\n   * @param fromIdx inclusive\n   * @param toIdx inclusive\n   */\n  private firstBlankColumn(fromIdx: number, toIdx: number): Maybe<number> {\n    for (let idx = fromIdx; idx !== toIdx; toIdx > fromIdx ? idx++ : idx--) {\n      if (this.blankColumns.has(idx)) return idx\n    }\n    if (this.blankColumns.has(toIdx)) return toIdx\n    if (fromIdx === 0 || toIdx === 0) {\n      return 0\n    }\n    return undefined\n  }\n\n  private extractHeaders(headers: IndexedHeader<T>[]): IndexedHeader<T>[] {\n    // For every column, determine which header it belongs to.\n\n    // First parse headers columns\n    const re = new RegExp(\n      headers\n        .map(\n          ea => (ea.greedyLeft ? \"\\\\s+\" : \"\\\\b\") + escapeRegExp(ea.text) + \"\\\\b\"\n        )\n        .join(\"|\"),\n      \"gi\"\n    )\n    const result: IndexedHeader<T>[] = []\n\n    // basically String.splitKeep\n    // we're looking for tokens at or right of pos\n    let m: RegExpExecArray | null\n\n    // this is the \"re.lastIndex\" from the prior match\n    let priorLastIndex = 0\n\n    while ((m = re.exec(this.headerRow)) != null) {\n      const skippedOver = this.headerRow.substring(priorLastIndex, m.index)\n      if (!blank(skippedOver)) {\n        logger().debug(\"extractHeaders: skipping over unknown header\", {\n          skippedOver,\n          m_index: m.index\n        })\n        this.skippedHeaders.push(skippedOver.trim())\n      }\n\n      const matched = this.headerRow.substring(m.index, re.lastIndex)\n      // this is the leftmost non-whitespace index of the current header\n      const left = m.index + (indexOfNonSpace(matched) ?? 0)\n      // this is the rightmost non-whitespace index of the current header\n      const right = m.index + (lastIndexOfNonSpace(matched) ?? matched.length)\n      const text = matched.trim()\n      const h = headers.find(ea => ea.text === text)\n      if (h == null || left == null || right == null) {\n        this.skippedHeaders.push(text)\n        logger().debug(\"extractHeaders: internal error\", {\n          matched,\n          match: m,\n          left,\n          right\n        })\n      } else {\n        const prior = last(result)\n        result.push(h)\n\n        if (prior != null) {\n          const priorRightBoundary =\n            prior.rightIdx! +\n            (indexOfNonSpace(skippedOver) ?? skippedOver.length) +\n            1\n          prior.rightIdx = h.greedyLeft\n            ? this.firstBlankColumn(prior.rightIdx!, priorRightBoundary)\n            : this.firstBlankColumn(priorRightBoundary, prior.rightIdx!)\n        }\n        const leftmost = max_(\n          prior?.rightIdx,\n          m.index - (lastIndexOfNonSpace(skippedOver) ?? skippedOver.length)\n        )\n        h.leftIdx = h.greedyLeft\n          ? this.firstBlankColumn(leftmost, left)\n          : this.firstBlankColumn(left, leftmost)\n        h.rightIdx = right // < temporary!\n      }\n      priorLastIndex = re.lastIndex\n    }\n    // expand the right header... but how much?\n    const lastHeader = last(result)\n    if (lastHeader != null) {\n      if (!blank(this.headerRow.slice(priorLastIndex))) {\n        lastHeader.rightIdx = priorLastIndex\n      } else {\n        // If the remainder of the header is whitespace, just expand to the end:\n        lastHeader.rightIdx = max_(...this.rows.map(ea => ea.length))\n      }\n    }\n    return result\n  }\n}\n","import { map } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { BitZip } from \"./math/Bits\"\nimport { GeoRadix } from \"./math/Radix\"\nimport { within } from \"./Number\"\n\n// See https://en.wikipedia.org/wiki/Geographic_coordinate_system\n// and https://en.wikipedia.org/wiki/Decimal_degrees\n// https://www.movable-type.co.uk/scripts/geohash.html\n\nexport interface GeoLocation {\n  lat: number\n  lon: number\n}\n\nconst DefaultBitDepth = 30\n\nfunction toNearestBitDepth(bitDepth: number) {\n  return Math.floor(bitDepth / 5) * 5\n}\n\nexport function validLat(latitude: Maybe<number>): latitude is number {\n  return within(-90, 90, latitude) && latitude !== 0\n}\n\nexport function validLon(longitude: Maybe<number>): longitude is number {\n  return within(-180, 180, longitude) && longitude !== 0\n}\n\nexport function validLatLon(\n  latitude: Maybe<number>,\n  longitude: Maybe<number>\n): latitude is number {\n  return validLat(latitude) && validLon(longitude)\n}\n\nexport function locationToGeohash(\n  loc?: Maybe<Partial<GeoLocation>>,\n  bitDepth = DefaultBitDepth\n): Maybe<string> {\n  return geohash(loc?.lat, loc?.lon, bitDepth)\n}\n\nexport function geohash(\n  latitude?: number,\n  longitude?: number,\n  bitDepth = DefaultBitDepth\n): Maybe<string> {\n  return map(\n    geohashNumeric(latitude, longitude, toNearestBitDepth(bitDepth)),\n    i => GeoRadix.encode(i)\n  )\n}\n\nexport function geohashNumericShort(latitude?: number, longitude?: number) {\n  return geohashNumeric(latitude, longitude, 30)\n}\n\nconst GeoHashBitZip = new BitZip([\n  {\n    min: -180,\n    max: 180\n  },\n  {\n    min: -90,\n    max: 90\n  }\n])\n\nexport function geohashNumeric(\n  latitude?: number,\n  longitude?: number,\n  bitDepth = DefaultBitDepth\n): Maybe<number> {\n  return !validLatLon(latitude, longitude)\n    ? undefined\n    : // The geohash spec does bitmixing oddly, requiring this to be lon, lat :(\n      GeoHashBitZip.zip([longitude!, latitude!], toNearestBitDepth(bitDepth))\n}\n\nexport function ungeohash(\n  geohashString: string,\n  bitDepth: number = DefaultBitDepth\n): Maybe<[number, number]> {\n  return map(GeoRadix.decode(geohashString), ea => ungeohash_num(ea, bitDepth))\n}\n\n/**\n * @return [latitude, longitude]\n */\nexport function ungeohash_num(\n  geohashNum: number,\n  bitDepth: number = DefaultBitDepth\n): [number, number] {\n  return GeoHashBitZip.unzip(\n    geohashNum,\n    toNearestBitDepth(bitDepth)\n  )?.reverse() as [number, number]\n}\n\nexport function geoHashToLocation(\n  geohashNum: number,\n  bitDepth: number = DefaultBitDepth\n): GeoLocation {\n  const [lat, lon] = ungeohash_num(geohashNum, bitDepth)\n  return { lat, lon }\n}\n\nconst EarthDiaMeters = 12742000\n\nexport function geohashDistanceMeters(\n  geohash1: Maybe<number>,\n  geohash2: Maybe<number>\n): Maybe<number> {\n  if (geohash1 == null || geohash2 == null) return\n  if (geohash1 === geohash2) return 0\n  return distanceMeters(\n    geoHashToLocation(geohash1),\n    geoHashToLocation(geohash2)\n  )\n}\n\n// http://www.movable-type.co.uk/scripts/latlong.html\nexport function distanceMeters(a: GeoLocation, b: GeoLocation) {\n  const phi1 = (a.lat * Math.PI) / 180 // φ, λ in radians\n  const phi2 = (b.lat * Math.PI) / 180\n  const deltaPhi = ((b.lat - a.lat) * Math.PI) / 180\n  const deltaLambda = ((b.lon - a.lon) * Math.PI) / 180\n  const c =\n    Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +\n    Math.cos(phi1) *\n      Math.cos(phi2) *\n      Math.sin(deltaLambda / 2) *\n      Math.sin(deltaLambda / 2)\n  const d = Math.atan2(Math.sqrt(c), Math.sqrt(1 - c))\n  return EarthDiaMeters * d\n}\n","/**\n * Used to signal Promises to halt processing and return asap\n */\nexport class Halt {\n  #halt = false\n  get halted() {\n    return this.#halt\n  }\n  halt() {\n    this.#halt = true\n  }\n}\n","// Secure hash research:\n\n// SHA1 has known collisions. It should be expected for a nerd to have sample\n// images that have colliding SHA1 hashes on their laptop.\n\n// I don't see why these SHA values would need to be externally consumed, so\n// people shouldn't care if the SHA in the db isn't a FIPS standard. I don't\n// want to pull in another native library dependency if I can help it.\n\n// ALSO: I don't need that many bits to ensure uniqueness! 160 was enough for\n// SHA1, 192 should be plenty, and only takes 32 base64 characters (and doesn't\n// waste chars on padding).\n\n// HOWEVER: versions pre-v0.3.5 used the most significant 224 bits, so when we\n// build SHAs of strings (like for volume UIDs), we maintain backward\n// compatibility by slicing MSB 224 bits. If we slice 192 bits and we use a\n// non-8-bit-divisible radix, the values change.\n\n// See https://news.ycombinator.com/item?id=10011472\n// https://en.wikipedia.org/wiki/Secure_Hash_Algorithms\n\n// `shasum -a 512224` implements SHA-512/224.\n// `shasum -a 512256` implements SHA-512/256.\n\nexport const HashBits = 192\n","import { lazy } from \"../core/Lazy\"\n\n// On server builds, always returns false. Overridden by Desktop to match system\n// state.\nexport const isSuspended = lazy(() => false)\n","import { parseJSON } from \"../fe/JSON\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { Obj } from \"../fe/Object\"\n\n// TODO: inline\nexport { parseJSON } from \"../fe/JSON\"\n\nexport function mapParsed<T>(s: string, f: (o: Obj) => T): Maybe<T> {\n  const j = parseJSON(s)\n  return j == null ? undefined : f(j)\n}\n","import {\n  BinaryField,\n  ExifDate,\n  ExifDateTime,\n  ExifTime\n} from \"exiftool-vendored\"\nimport { DateTime } from \"luxon\"\nimport { lazy } from \"../core/Lazy\"\nimport { defer } from \"../fe/Defer\"\nimport { JsonReviver, addJsonRevivers } from \"../fe/JSON\"\nimport { compactValues } from \"../fe/Object\"\nimport { DateInterval } from \"./date/DateInterval\"\nimport { FuzzyDate } from \"./date/FuzzyDate\"\nimport { WrappedError } from \"./error/WrappedError\"\nimport { CapturedAt } from \"./tags/CapturedAt\"\n\nconst FixDateTimeToJSON = defer(() => {\n  ;(DateTime as any).prototype[\"toJSON\"] = function toJSON() {\n    return compactValues({\n      _ctor: DateTime.name,\n      ts: this.toMillis(),\n      zone: this.zone?.type === \"system\" ? undefined : this.zoneName\n    })\n  }\n})\n\nconst DateTimeReviver: JsonReviver = {\n  name: DateTime.name,\n  fromJSON(ea: any) {\n    // DateTime requires the zone to be thrown in as a second options hash (!!!)\n    return DateTime.fromMillis(ea.ts, compactValues({ zone: ea.zone }))\n  }\n}\n\nexport const addDefaultJsonRevivers = lazy(() => {\n  FixDateTimeToJSON()\n  // FixBinaryFieldToJSON()\n  addJsonRevivers(\n    ExifDateTime,\n    ExifDate,\n    ExifTime,\n    DateTimeReviver,\n    CapturedAt,\n    DateInterval,\n    FuzzyDate,\n    BinaryField,\n    // no need to revive binary field\n    WrappedError\n  )\n})\n","import { inspect } from \"util\"\nimport { isEmpty } from \"../fe/Array\"\nimport { ChangeListener } from \"../fe/ChangeListener\"\nimport { eql } from \"../fe/Eql\"\nimport { MemoizedLazy, MemoizedThunk } from \"../fe/Lazy\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { gt0 } from \"../fe/Number\"\nimport { setUnrefTimeout } from \"../fe/UnrefTimeout\"\nimport { ExtensibleFunction } from \"./ExtensibleFunction\"\n\n// USED BY LOG: DON'T DEPEND ON ANYTHING (much)\n\n// TODO: INLINE\nexport { MemoizedLazy, MemoizedThunk, UnwrapLazy } from \"../fe/Lazy\"\n\nexport function lazy<T>(f: () => T, ttlMs?: number): MemoizedThunk<T> {\n  return new LazyClass(f, ttlMs) as any\n}\n\nclass LazyClass<T> extends ExtensibleFunction<T> implements MemoizedLazy<T> {\n  private lastSetTs?: number\n  private result?: T\n  readonly watchers: ChangeListener<T>[] = []\n\n  constructor(\n    private readonly thunk: () => T,\n    private ttlMs?: number\n  ) {\n    super()\n  }\n\n  override _call() {\n    if (this.isStale()) {\n      // NO PROMISE AWAITING HERE. Otherwise N calls would go through while we\n      // wait for the promise to resolve.\n      this.#setResult(this.thunk())\n    }\n    return this.result!\n  }\n\n  private async onSetResult(priorP: Maybe<T>, currentP: T) {\n    if (isEmpty(this.watchers)) return\n    // prior and current could be a promise!\n\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const _prior = await priorP\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const current = await currentP\n    if (!eql(_prior, current)) {\n      for (const ea of this.watchers) ea(current)\n    }\n    // We're interpreting undefined as unset, and `null` as a valid set value.\n    if (this.ttlMs != null && this.ttlMs > 0 && current !== undefined) {\n      // help the garbage collector:\n      setUnrefTimeout(() => this.vacuum(), this.ttlMs)\n    }\n  }\n\n  vacuum() {\n    if (this.isStale()) this.unset()\n  }\n\n  #setResult(t: T) {\n    this.lastSetTs = Date.now()\n    void this.onSetResult(this.result, t)\n    return (this.result = t)\n  }\n\n  isStale() {\n    return (\n      this.lastSetTs == null ||\n      (gt0(this.ttlMs) && this.lastSetTs + this.ttlMs < Date.now())\n    )\n  }\n\n  set(t: T) {\n    this.#setResult(t)\n  }\n\n  unset() {\n    this.#setResult(undefined as any)\n    this.lastSetTs = undefined\n  }\n\n  clear() {\n    const _prior = this.result\n    this.unset()\n    return _prior\n  }\n\n  prior() {\n    this.vacuum()\n    return this.result\n  }\n\n  refresh() {\n    return this.#setResult(this.thunk())\n  }\n\n  ttl() {\n    return this.ttlMs\n  }\n\n  setTTL(ttl: number | undefined) {\n    this.ttlMs = gt0(ttl) ? ttl : undefined\n  }\n\n  watchLater(watcher: ChangeListener<T>) {\n    this.watchers.push(watcher)\n  }\n\n  watch(watcher: ChangeListener<T>) {\n    watcher(this())\n    this.watchLater(watcher)\n  }\n\n  toString() {\n    return \"[Lazy]\"\n  }\n\n  // If you move this back to fe, you'll need to switch this with something\n  // like `const inspect_custom = isNode ? require(\"util\").inspect.custom :\n  // Symbol.for(\"inspect.custom\")`\n  [inspect.custom]() {\n    return \"[Lazy]\"\n  }\n\n  lastSetAgoMs() {\n    return this.lastSetTs == null ? undefined : Date.now() - this.lastSetTs\n  }\n\n  hasPrior() {\n    return this.lastSetTs != null\n  }\n}\n\nclass ROLazy<T> extends LazyClass<T> {\n  override set(_: T) {}\n}\n\nexport function rolazy<T>(thunk: () => T, ttlMs?: number): MemoizedThunk<T> {\n  return new ROLazy(thunk, ttlMs) as any\n}\n","import { lazy } from \"../core/Lazy\"\nimport { compact } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { secondMs } from \"../fe/Date\"\nimport { Maybe, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { Obj } from \"../fe/Object\"\nimport { mkLogger } from \"./Logger\"\nimport { equalsIgnoreCase } from \"./String\"\nimport { lazyAsync } from \"./async/LazyAsync\"\nimport { thenMap } from \"./async/Promise\"\nimport { StdoutOpts, stdout_ } from \"./child/ChildProcess\"\nimport { env } from \"./env/Env\"\nimport { parseEnvTokens } from \"./env/EnvTokens\"\nimport { isMac, isWin } from \"./platform/Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\nimport { commandTimeoutMs } from \"./volumes/VolumeTtls\"\n\nexport const DefaultLocale = \"en\"\n\nconst logger = lazy(() => mkLogger(\"Locale\"))\n\nexport function localeSync() {\n  return locale.lastValue() ?? envLocale() ?? DefaultLocale\n}\n\n/**\n * @see https://en.wikipedia.org/wiki/ISO_639\n */\nexport const locale = lazyAsync<string>({\n  desc: \"locale\",\n  later: async () =>\n    lc2locale(\n      extractLocale() ??\n        (await (isWin\n          ? localeWin()\n          : isMac\n          ? localeMac()\n          : localePosix()\n        ).catch(error => {\n          logger().warn(\"Failed to get locale\", { error })\n          return DefaultLocale\n        }))\n    ),\n  timeoutMs: commandTimeoutMs()\n})\n\nexport const envLocale = lazy(extractLocale)\n\n// See https://wiki.archlinux.org/index.php/Locale\nfunction extractLocale(e: Obj = env()) {\n  for (const ea of [e.LC_ALL, e.LC_MESSAGES, e.LANG, e.LANGUAGE]) {\n    const lc = toLocale(ea)\n    if (lc != null) return lc\n  }\n  return\n}\n\n// Like \"en_US.UTF-8\"\nconst regex = /^(?<lang>[a-z]{2,3})(?:[_-](?<country>[a-z]{2,3}))?\\b/i\n\nfunction toLocale(str: Maybe<string>) {\n  if (blank(str)) return\n  // Some people set their locale to \"C\":\n  if (\n    str === DefaultLocale ||\n    equalsIgnoreCase(\"c\", str) ||\n    equalsIgnoreCase(\"posix\", str)\n  ) {\n    return DefaultLocale\n  }\n  const g = regex.exec(str.trim())?.groups\n  return g == null ? undefined : compact([g.lang, g.country]).join(\"-\")\n}\n\nexport function lc2locale(lc: Maybe<string>): string {\n  return toLocale(lc) ?? DefaultLocale\n}\n\nexport function localeWin(): PromiseMaybe<string> {\n  return thenMap(\n    PowerShell.instance().executeJson(\n      \"Get-WinSystemLocale | Select-Object -Property Name\"\n    ),\n    ea => ea.Name as string\n  )\n}\n\nconst opts: StdoutOpts = {\n  timeoutMs: 10 * secondMs\n}\n\nexport async function localeMac(): PromiseMaybe<string> {\n  return toLocale(\n    await stdout_(\"defaults\", [\"read\", \"-globalDomain\", \"AppleLocale\"], opts)\n  )\n}\n\nexport async function localePosix() {\n  return lc2locale(\n    extractLocale(\n      parseEnvTokens({\n        lowerCaseKeys: false,\n        input: await stdout_(\"locale\", [], opts)\n      })\n    )\n  )\n}\n\nexport function childProcLocale() {\n  return {\n    LANG: \"C\",\n    LC_ALL: \"C\"\n  }\n}\n","import { arch, platform } from \"os\"\nimport { argv, versions } from \"process\"\nimport { lazy } from \"../core/Lazy\"\nimport { pick } from \"../fe/Object\"\nimport { mkLogger } from \"./Logger\"\nimport { osFullName } from \"./OperatingSystem\"\nimport { serviceName } from \"./ServiceNames\"\nimport { StartTs } from \"./StartTs\"\nimport { version } from \"./Version\"\nimport { psenv } from \"./child/ChildEnv\"\nimport { isPacked } from \"./platform/IsPacked\"\nimport { isElectron } from \"./platform/Platform\"\nimport { Settings } from \"./settings/Settings\"\n\nexport const logStartup = lazy(() => {\n  mkLogger(\"LogStartup\").info(\"setup(): starting \" + serviceName(), {\n    version,\n    StartTs,\n    argv,\n    arch: arch(),\n    platform: platform(),\n    os: osFullName(),\n    isPacked: isPacked(),\n    isElectron,\n    versions: pick(versions, \"electron\", \"node\"),\n    settings: {\n      logLevel: Settings.logLevel.valueOrDefault,\n      httpPort: Settings.httpPort.valueOrDefault,\n      libraryDir: Settings.libraryDir.valueOrDefault\n    },\n    ...psenv()\n  })\n})\n","import { lazy } from \"../core/Lazy\"\nimport { ConsoleLogger } from \"./log/ConsoleLogger\"\nimport { ContextualLogger } from \"./log/ContextualLogger\"\nimport { SimpleLogger } from \"./log/Logger\"\n\nexport const rootLoggers = lazy<SimpleLogger[]>(() => [\n  ConsoleLogger.instance()\n])\n\nconst consoleLogger = lazy(() => [ConsoleLogger.instance()])\n\nexport type Logger = ContextualLogger // TODO: inline?\n\nexport function mkLogger(context: string): ContextualLogger {\n  return new ContextualLogger(context, rootLoggers)\n}\n\nexport function mkConsoleLogger(context: string): ContextualLogger {\n  return new ContextualLogger(context, consoleLogger)\n}\n","import { compact } from \"../fe/Array\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe, MaybePromiseMaybe } from \"../fe/MaybeTypes\"\nimport { toA } from \"../fe/toA\"\nimport { concat } from \"./Array\"\n\nexport function hasAll<K>(m: Map<K, any> | Set<K>, arr: K[]): boolean {\n  return arr.every(ea => m.has(ea))\n}\n\nexport function flatMap<T, K, V>(iter: T[], f: (t: T) => [K, V][]): Map<K, V> {\n  return new Map<K, V>(concat(...iter.map(ea => f(ea))))\n}\n\nexport function compactMap<K, V>(\n  m: Iterable<Maybe<[Maybe<K>, Maybe<V>]>>\n): Map<K, V> {\n  const arr = compact(m).filter(([k, v]) => k != null && v != null) as [K, V][]\n  return new Map<K, V>(arr)\n}\n\nexport function toMap<T, K, V>(\n  i: Maybe<Iterable<Maybe<T>>>,\n  f: (entry: T) => Maybe<[Maybe<K>, Maybe<V>]>\n): Map<K, V> {\n  return compactMap(compact(i).map(f))\n}\n\nexport async function toMapAsync<T, K, V>(\n  iterable: Maybe<Iterable<Maybe<T>>>,\n  f: (entry: T) => MaybePromiseMaybe<[Maybe<K>, Maybe<V>]>\n): Promise<Map<K, V>> {\n  if (iterable == null) return new Map()\n  const entries = await Promise.all(compact(toA(iterable)).map(ea => f(ea)))\n  return compactMap(entries)\n}\n\nexport function toObj<T>(m: Map<string, T>): { [key: string]: T } {\n  const obj: any = {}\n  for (const [k, v] of m) {\n    obj[k] = v\n  }\n  return obj\n}\n\nexport function filter<K, V>(\n  m: Map<K, V>,\n  f: (key: K, value: V) => boolean\n): Map<K, V> {\n  return new Map<K, V>([...m.entries()].filter(([k, v]) => f(k, v)))\n}\n\n/**\n * Only retain the entries in m where f() returns true.\n */\nexport function filterInPlace<K, V>(\n  m: Map<K, V>,\n  retainIfTrue: (key: K, value: V) => boolean\n): void {\n  ;[...m.entries()].forEach(([k, v]) => retainIfTrue(k, v) || m.delete(k))\n}\n\nexport function pickKeys<K, V>(m: Map<K, V>, keys: K[]): Map<K, V> {\n  return filter(m, k => keys.indexOf(k) >= 0)\n}\n\n/**\n * Return the first value associated to the key that matches the given predicate\n */\nexport function getLike<K, V>(\n  m: Map<K, V>,\n  predicate: (k: K) => boolean\n): Maybe<V> {\n  return map(\n    [...m.entries()].find(([k]) => predicate(k)),\n    ([, v]) => v\n  )\n}\n\nexport function inverse<K, V>(m: Map<K, V>): Map<V, K> {\n  return new Map([...m.entries()].map(([k, v]) => [v, k] as [V, K]))\n}\n","import { stringify } from \"../fe/JSON\"\nimport { FifoCache } from \"./FifoCache\"\n\nexport interface MemoizedFunc<A, R> {\n  (a: A): R\n  clear(a?: A): void\n  size(): number\n  callCount(): number\n}\n\nexport function memoize<A, R>(\n  f: (a: A) => R,\n  opts: { maxSize: number; ttlMs?: number }\n): MemoizedFunc<A, R> {\n  let callCount = 0\n  const store = new FifoCache<R>(opts.maxSize, opts.ttlMs)\n  const r: any = (a: A) => {\n    if (a == null) return\n    callCount++\n    return store.getOrSet(stringify(a), () => f(a))\n  }\n  r.clear = (a?: A) => (a == null ? store.clear() : store.delete(stringify(a)))\n  r.size = () => store.size\n  r.callCount = () => callCount\n  return r\n}\n","import { memoryUsage } from \"process\"\nimport { sigFigs } from \"../fe/Number\"\nimport { MB } from \"../fe/Units\"\nimport { sum } from \"./math/Vector\"\n\nexport function memoryUsageBytes() {\n  const mem = memoryUsage()\n  // These are sometimes not defined. We don't want to return NaN.\n  return sum([mem.external, mem.heapUsed, mem.arrayBuffers])\n}\n\nexport function memoryUsageMb() {\n  return sigFigs(memoryUsageBytes() / MB, 2)\n}\n\nexport function memoryUsageRssBytes() {\n  return memoryUsage().rss\n}\n\nexport function memoryUsageRssMb() {\n  return sigFigs(memoryUsageRssBytes() / MB, 2)\n}\n","import { isTrue, toBoolean } from \"../fe/Boolean\"\n\n/**\n * @see https://no-color.org/\n */\nexport function noColor(): boolean {\n  // force color if PS_LOG_COLOR is true\n  return (\n    toBoolean(process.env.PS_LOG_COLOR) ??\n    (isTrue(process.env.NO_COLOR) ||\n      [\"dumb\", \"unknown\"].includes(process.env.TERM as string))\n  )\n}\n","import process from \"process\"\nimport { isTrue } from \"../fe/Boolean\"\nimport { toS } from \"../fe/toS\"\nimport { isPacked } from \"./platform/IsPacked\"\n\n// new mocha 10 uses \"mocha.js\"\nconst MaybeTestArgRe = /mocha\\.js$|\\.spec\\.js$/\n\nexport function _nodeEnv() {\n  switch (toS(process.env.NODE_ENV).toLowerCase()) {\n    case \"test\":\n    case \"testing\":\n      return \"test\"\n    case \"dev\":\n    case \"development\":\n      return \"development\"\n    case \"prod\":\n    case \"production\":\n      return \"production\"\n    default:\n      if (\n        !isPacked() &&\n        process.argv.some(ea => MaybeTestArgRe.exec(ea) != null)\n      ) {\n        return \"test\"\n      } else {\n        return \"production\"\n      }\n  }\n}\n\n// Make sure NODE_ENV gets the final value. If not, stuff like Pug stays in\n// dev mode: https://pugjs.org/api/express.html\nexport const nodeEnv = (process.env.NODE_ENV = _nodeEnv())\n\nexport const isDev = nodeEnv === \"development\"\nexport const isTest = nodeEnv === \"test\"\nexport const isProd = nodeEnv === \"production\"\n\nexport function isSingleSpecTests() {\n  return isTest && isTrue(process.env.SINGLE_SPEC_TESTS)\n}\n\nexport function setSingleSpecTests(b: boolean) {\n  process.env.SINGLE_SPEC_TESTS = b ? \"true\" : \"false\"\n}\n","import { satisfies } from \"semver\"\nimport { lazy } from \"./Lazy\"\nimport { isElectron } from \"./platform/Platform\"\n\nexport const isSupportedNode = lazy(_isSupportedNode)\n\nexport const requiredNodeRange = lazy(() =>\n  isElectron ? \"16||18||20\" : \"18||20\"\n)\nexport function _isSupportedNode(nodeVersion = process.versions.node) {\n  return satisfies(nodeVersion, requiredNodeRange())\n}\n","import { count, isEmpty } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { flatten } from \"../fe/Flatten\"\nimport { map, orElse } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport {\n  clamp,\n  gt0,\n  isNumber,\n  map2Numeric,\n  mapInt,\n  mapNumeric,\n  toFloat,\n  toInt\n} from \"../fe/Number\"\nimport { leftPad } from \"../fe/Pad\"\nimport { toS } from \"../fe/toS\"\nimport { pop } from \"./math/Bits\"\n\n// TODO: INLINE\nexport { within } from \"../fe/Number\"\n\nexport function firstGt0(...objects: any[]): Maybe<number> {\n  return objects.find(gt0)\n}\n\n/**\n * @return the first element in `objects` that can be parsed into a number and is\n * greater than zero.\n */\nexport function firstNonZero(...objects: any[]): Maybe<number> {\n  for (const ea of flatten(objects)) {\n    const f = toFloat(ea)\n    if (f != null && f !== 0) return f\n  }\n  return undefined\n}\n\nexport function mapGte0<T>(n: any, f: (i: number) => T): Maybe<T> {\n  return mapInt(n, i => (i >= 0 ? f(i) : undefined))\n}\n\nexport function mapGte0Or<T>(\n  n: any,\n  f: (i: number) => T,\n  defaultValue: T | (() => T)\n): T {\n  return orElse(mapGte0(n, f), defaultValue)\n}\n\nexport function mapGte0f<T>(n: any, f: (i: number) => T): Maybe<T> {\n  return mapNumeric(n, i => (i >= 0 ? f(i) : undefined))\n}\n\nexport function mapGt0<T>(n: any, f: (i: number) => T): Maybe<T> {\n  const ea = toInt(n)\n  return ea != null && ea > 0 ? f(ea) : undefined\n}\n\nexport function map2Gt0<T>(\n  a: any,\n  b: any,\n  f: (i: number, j: number) => T\n): Maybe<T> {\n  const i = toInt(a)\n  const j = toInt(b)\n  return i != null && i > 0 && j != null && j > 0 ? f(i, j) : undefined\n}\n\nexport function mapGt0f<T>(n: any, f: (i: number) => T): Maybe<T> {\n  const ea = toFloat(n)\n  return ea != null && ea > 0 ? f(ea) : undefined\n}\n\nexport function mapGt0Or<T>(\n  n: any,\n  f: (i: number) => T,\n  defaultValue: T | (() => T)\n): T {\n  return orElse(mapGt0(n, f), defaultValue)\n}\n\n// WAT WAT WAAAAAT? (this is the simplest regex I could come up with that\n// supported both \"-123\", \"+123.\", \"-123.456\" and \"-.789\") \\\n\n// I could do this:\n// const validFloatRe = /((?:[+-]?[0-9]+(?:\\.[0-9]*)?)|(?:[+-]?[0-9]*(?:\\.[0-9]+)))/\n\n// but that sort of rigor isn't necessary. parseFloat is fine with parsing\n// \"-123.456GUACAMOLE\".\nconst numstartRe = /[+-]?[\\d,.]+/\n\n/**\n * Pull out the first float from `value`.\n *\n * This method ignores any non-numeric characters that prefix or suffix the\n * first number (as opposed to `toFloat`, which ignores only non-numeric\n * suffixes)\n */\nexport function extractFloat(value: any): Maybe<number> {\n  if (isNumber(value)) return value\n  if (blank(value)) return undefined\n  const s = String(value)\n  return map(numstartRe.exec(s), m => toFloat(s.substr(m.index)))\n}\n\n/**\n * Pull out the first integer from `value`.\n *\n * This method ignores any non-numeric characters that prefix or suffix the\n * first number (as opposed to `toInt`, which ignores only non-numeric suffixes)\n */\nexport function extractInt(value: any): Maybe<number> {\n  return toInt(extractFloat(value))\n}\n\nexport function extractFraction(value: any): Maybe<number> {\n  if (isNumber(value)) return value\n  const s = toS(value)\n  if (s.includes(\"/\")) {\n    const arr = s.split(\"/\", 2)\n    return map2Numeric(extractInt(arr[0]), extractInt(arr[1]), (i, j) => i / j)\n  } else {\n    return extractFloat(s)\n  }\n}\n\nexport function assertPositive(name: string, value?: number) {\n  if (value == null || value <= 0) {\n    throw new Error(name + \" must be positive\")\n  }\n}\n\nexport class Array2D {\n  private readonly store: number[] = []\n  constructor(readonly columns: number) {}\n  get(row: number, col: number): number {\n    return row < 0 || col < 0\n      ? 0\n      : orElse(this.store[row * this.columns + col], () => 0)\n  }\n  set(row: number, col: number, value: number) {\n    this.store[row * this.columns + col] = value\n  }\n}\n\nfunction prepHammBigInts(\n  a: number | bigint,\n  b: number | bigint\n): Maybe<[string, string]> {\n  if (a == null || b == null) return\n  const arr = [a, b].map(ea => ea.toString(2))\n  const maxLen = Math.max(...arr.map(ea => ea.length))\n  return arr.map(ea => leftPad(ea, maxLen, \"0\")) as [string, string]\n}\n\n/**\n * @return the number of bits not matching between a and b\n */\nexport function hammingDistanceBigInt(\n  a: number | bigint,\n  b: number | bigint\n): Maybe<number> {\n  return map(prepHammBigInts(a, b), ([s1, s2]) =>\n    count([...s1], (ea, idx) => ea !== s2.charAt(idx))\n  )\n}\n\n/**\n * @return `matching bits / total bits`. 1 == complete match.\n */\nexport function hammRatioBigInt(\n  a: Maybe<number | bigint>,\n  b: Maybe<number | bigint>\n): Maybe<number> {\n  if (a == null || b == null) return 0\n  return map(prepHammBigInts(a, b), ([i, j]) => hammRatioBinaryString(i, j))\n}\n\nexport function hammRatioBinaryString(a: string, b: string) {\n  if (a === b) return 1\n  if (a.length !== b.length)\n    throw new Error(`hammRatioBinaryString(${a}, ${b}): invalid lengths`)\n  let matching = 0\n  // console.log(\"hammRatioBinaryString a\")\n  // console.log(splitEvery(a, 24).join(\"\\n\"))\n  // console.log(\"hammRatioBinaryString b\")\n  // console.log(splitEvery(b, 24).join(\"\\n\"))\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === b[i]) matching++\n  }\n  // console.log(\"matching: \" + matching)\n  // 50% match is random. Scale that to 0.\n  return clamp(0, 1, (2 * matching) / a.length - 1)\n}\n\nexport function valuesToBigInt(arr: number[], bitsPerValue: number): bigint {\n  if (isEmpty(arr)) return BigInt(0)\n  return BigInt(\n    \"0b0\" +\n      arr.map(ea => leftPad(ea.toString(2), bitsPerValue - 1, \"0\")).join(\"\")\n  )\n}\n\nexport function hammRatioIntArrays(\n  a: number[],\n  b: number[],\n  bitsPerCell: number\n) {\n  if (a.length !== b.length)\n    throw new Error(\"hammRatioIntArrays(): inequal arrays\")\n  let diff = 0\n  const total = bitsPerCell * a.length\n  for (let i = 0; i < a.length; i++) {\n    diff += pop(a[i] ^ b[i])\n  }\n\n  // 50% match is random. Scale that to 0:\n  return clamp(0, 1, (2 * (total - diff)) / total - 1)\n}\n\n/**\n * \"safe\" square-root\n *\n * @return 0 if i is not a number or is negative\n */\nexport function sqrt(i: number): number {\n  return gt0(i) ? Math.sqrt(i) : 0\n}\n","import { compact, uniq } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { isDate } from \"../fe/Date\"\nimport { eql } from \"../fe/Eql\"\nimport { flatten } from \"../fe/Flatten\"\nimport { defined, map } from \"../fe/Maybe\"\nimport { Maybe, MaybeNull } from \"../fe/MaybeTypes\"\nimport { gt } from \"../fe/Number\"\nimport { Obj, entries, keys } from \"../fe/Object\"\nimport { Primitive, isPrimitive } from \"../fe/Primitive\"\nimport { Thunk } from \"../fe/Thunk\"\nimport { toErr } from \"../fe/toErr\"\nimport { first } from \"./Array\"\nimport { equalsIgnoreCase, sortIgnoreCase } from \"./String\"\n\n// \"{ new(): T }\"\n// is from https://www.typescriptlang.org/docs/handbook/generics.html#using-class-types-in-generics\nexport interface Constructor<M> {\n  new (...args: any[]): M\n}\n\nexport function definedThunks(...thunks: Thunk<any>[]): boolean {\n  return thunks.every(ea => defined(ea()))\n}\n\nexport function firstThunk<T>(...thunks: Thunk<Maybe<T>>[]): Maybe<T> {\n  for (const t of thunks) {\n    const r = t()\n    if (r != null) {\n      return r\n    }\n  }\n  return\n}\n\nexport function firstTrueThunk<T>(\n  thunks: Thunk<Maybe<T>>[],\n  predicate?: (t: T) => boolean\n): Maybe<T> {\n  for (const t of thunks) {\n    const r = t()\n    if (r != null && (predicate == null || predicate(r))) {\n      return r\n    }\n  }\n  return\n}\n\nexport function firstDefined<T>(...objects: MaybeNull<T>[]): Maybe<T> {\n  return objects.find(defined)\n}\n\nexport function firstDefinedField<T, K extends keyof T>(\n  obj: T,\n  ...fieldNames: K[]\n): Maybe<T[K]> {\n  return map(\n    fieldNames.find(field => null != obj[field]),\n    fieldName => obj[fieldName]\n  )\n}\n\nexport function firstFieldLike<T extends Obj, K extends keyof T>(\n  obj: T,\n  predicate: (key: K, value: T[K]) => boolean\n): Maybe<T[K]> {\n  return first(\n    keys(obj) as K[], // SITS: why is this cast needed?\n    key => (predicate(key, obj[key]) ? obj[key] : undefined)\n  )\n}\n\n// knex interprets undefined parameters as runtime mistakes, so use null:\nexport function ornull<T>(a?: T): T | null {\n  return a === undefined ? null : a\n}\n\nexport function mapAnd<T>(obj: MaybeNull<T>, f: (t: T) => boolean): boolean {\n  return obj != null ? f(obj) : false\n}\n\nexport function mapOrThrow<T, R>(\n  obj: MaybeNull<T>,\n  f: (t: T) => R,\n  errIfMissing: string\n): R {\n  if (obj != null) {\n    return f(obj)\n  } else {\n    throw new Error(errIfMissing)\n  }\n}\n\nexport function Try<T>(\n  f: () => T,\n  onError?: (error: Error) => Maybe<T>\n): Maybe<T> {\n  try {\n    return f()\n  } catch (err) {\n    return onError?.(toErr(err)!)\n  }\n}\n\nexport function tryEach<T>(iter: Iterable<T>, f: (t: T) => any): void {\n  ;[...iter].forEach(ea => Try(() => f(ea)))\n}\n\nexport function identity<T>(t: T) {\n  return t\n}\n\nexport function ctor(obj: any): Maybe<string> {\n  return map(obj.constructor, ea => ea.name)\n}\n\nexport function hasKeys(obj: any): boolean {\n  return Object.keys(obj).some(\n    k => typeof k === \"string\" && obj.propertyIsEnumerable(k)\n  )\n}\n\n/**\n * primitive and Dates\n */\nexport function primitiveEntries<T extends Obj>(o: T): [keyof T, Primitive][] {\n  return keys(o)\n    .filter(k => isPrimitive(o[k]) || isDate(o[k]))\n    .map(k => [k, o[k]] as [string, Primitive])\n}\n\nexport function spread<T extends Obj>(\n  defaults: T,\n  ...sources: MaybeNull<Partial<T>>[]\n): T {\n  return Object.assign({} as T, defaults, ...compact(sources))\n}\n\n/**\n * Assign fields from src that have Primitive value types\n */\nexport function assignMissingPrimitives<T>(dest: T, src: Maybe<Partial<T>>): T {\n  if (src == null) {\n    return dest\n  }\n  for (const [k, v] of primitiveEntries(src)) {\n    if (dest[k] == null) {\n      dest[k] = v as any\n    }\n  }\n  return dest\n}\n\n/**\n * Only assign fields that are missing or nullish\n */\nexport function assignNullishFields<T>(dest: T, src: Maybe<Partial<T>>): T {\n  if (src == null) {\n    return dest\n  }\n  for (const [k, v] of entries(src)) {\n    if (dest[k] == null) {\n      ;(dest[k] as any) = v\n    }\n  }\n  return dest\n}\n\nexport function pickMap<K extends string, V, U>(\n  obj: Record<K, V>,\n  keysToRetain: K[],\n  f: (key: K, value: V) => U\n): Record<K, U> {\n  const r = {} as Record<K, U>\n  for (const k of keysToRetain) {\n    r[k] = f(k, obj[k])\n  }\n  return r\n}\n\nexport function mapEntries<T extends Obj, U>(\n  obj: T,\n  f: (key: keyof T & string, value: T[keyof T]) => Maybe<U>\n): Record<keyof T, U> {\n  const r = {} as Record<keyof T, U>\n  for (const [k, v] of entries(obj)) {\n    // PERF: UNROLL\n    const val = f(k, v)\n    if (val != null) r[k] = val\n  }\n  return r\n}\n\nexport function mapNullEntries<T extends Obj, U>(\n  obj: T,\n  f: (key: keyof T & string, value: T[keyof T]) => MaybeNull<U>,\n  maxKeys?: number\n): Record<keyof T, U> {\n  const r = {} as Record<keyof T, U>\n  let keyCount = 0\n  for (const k of keys(obj)) {\n    r[k] = f(k, obj[k])!\n    keyCount++\n    if (gt(keyCount, maxKeys)) break\n  }\n  return r\n}\n\n/**\n * Do all fields in `a` match `b`?\n */\nexport function eqlSubset<T>(a: Maybe<Pick<T, any>>, b: T): boolean {\n  return a == null ? false : keys(a).every((ea: keyof T) => eql(a[ea], b[ea]))\n}\n\n/**\n * For a given field name, what's o[fieldpath]?\n *\n * If fieldpath includes \".\", those will be used to find sub-objects.\n */\nexport function valpath(o: any, ciFieldPath: string): any {\n  if (ciFieldPath == null || o == null || blank(ciFieldPath)) return o\n  if (Array.isArray(o)) return compact(o.map(ea => valpath(ea, ciFieldPath)))\n  const nextDot = ciFieldPath.indexOf(\".\")\n  const field = nextDot < 0 ? ciFieldPath : ciFieldPath.slice(0, nextDot)\n  const fieldRemains = nextDot < 0 ? undefined : ciFieldPath.slice(nextDot + 1)\n  const k = keys(o)\n  if (k.includes(field)) return valpath(o[field], fieldRemains!)\n  const ciField = k.find(ea => equalsIgnoreCase(ea, field))\n  if (ciField != null) {\n    return valpath(o[ciField], fieldRemains!)\n  }\n  return\n}\n\nexport function sortedKeys(o: any): any {\n  if (o == null || isPrimitive(o)) return o\n  if (Array.isArray(o)) {\n    return o.map(ea => sortedKeys(ea))\n  }\n  if (typeof o === \"object\") {\n    const a: any = {}\n    for (const k of sortIgnoreCase(keys(o))) {\n      a[k] = sortedKeys(o[k])\n    }\n    return a\n  }\n  return o\n}\n\nexport function deepDelete(o: any, ...keysToDelete: string[]): any {\n  if (o == null || typeof o !== \"object\") return o\n  if (Array.isArray(o)) return o.map(ea => deepDelete(ea, ...keysToDelete))\n  return mapEntries(o, (k, v) =>\n    keysToDelete.includes(k) ? undefined : deepDelete(v, ...keysToDelete)\n  )\n}\n\n/**\n * @return the value associated to `caseInsensitiveKeyName`\n */\nexport function pluckCaseInsensitive(\n  o: any,\n  caseInsensitiveKeyName: string\n): any {\n  if (typeof o !== \"object\") return\n  if (o[caseInsensitiveKeyName] !== undefined) return o[caseInsensitiveKeyName]\n  for (const ea of keys(o).filter(s =>\n    equalsIgnoreCase(s, caseInsensitiveKeyName)\n  )) {\n    if (o[ea] !== undefined) return o[ea]\n  }\n  return\n}\n\nexport function pairToObject(key: string, value: any) {\n  const o: any = {}\n  o[key] = value\n  return o\n}\n\nexport function mergeObjects(...arr: Maybe<object>[]) {\n  const o: any = {}\n  for (const obj of compact(arr)) {\n    for (const k of keys(obj)) {\n      o[k] = obj[k]\n    }\n  }\n  return o\n}\n\nexport function zipPojos(...arr: Maybe<Obj>[]): Obj {\n  const result: Obj = {}\n  for (const key of uniq(flatten(arr.map(keys)))) {\n    result[key] = arr.map(obj => obj?.[key])\n  }\n  return result\n}\n","import { execSync } from \"child_process\"\nimport { readFileSync } from \"fs\"\nimport { arch, platform, release } from \"os\"\nimport { satisfies } from \"semver\"\nimport { lazy } from \"../core/Lazy\"\nimport { mapNotBlankOr, notBlank } from \"../fe/Blank\"\nimport { minuteMs } from \"../fe/Date\"\nimport { map2Or } from \"../fe/Maybe\"\nimport { isString } from \"../fe/String\"\nimport { toS } from \"../fe/toS\"\nimport { uniqCount } from \"./Array\"\nimport { mkLogger } from \"./Logger\"\nimport { parseEnvTokens } from \"./env/EnvTokens\"\nimport { isLinux, isMac, isWin } from \"./platform/Platform\"\nimport { isDocker } from \"./platform/isDocker\"\nimport { debianVersionToSemver } from \"./version/SemVer\"\nimport { cpuInfo } from \"./work/CpuInfo\"\n\nconst logger = lazy(() => mkLogger(\"os\"))\n\nexport const osArch = lazy(() => `${osName()} on ${arch()}`)\nexport const osFullName = lazy(() => osArch() + (isDocker() ? \" (Docker)\" : \"\"))\n\nfunction osName() {\n  switch (platform()) {\n    case \"linux\":\n      return osNameLinux()\n    case \"darwin\":\n      return osNameMac()\n    case \"win32\": // doesn't mean 32 bit (BECAUSE WINDOWS)\n      return osNameWin()\n    default:\n      return osNameDefault()\n  }\n}\n\nfunction osNameDefault() {\n  return platform() + \" \" + release()\n}\n\n// Ubuntu:\n\n// NAME=\"Ubuntu\"\n// VERSION=\"20.04.1 LTS (Focal Fossa)\"\n// ID=ubuntu\n// ID_LIKE=debian\n// PRETTY_NAME=\"Ubuntu 20.04.1 LTS\"\n// VERSION_ID=\"20.04\"\n// HOME_URL=\"https://www.ubuntu.com/\"\n// SUPPORT_URL=\"https://help.ubuntu.com/\"\n// BUG_REPORT_URL=\"https://bugs.launchpad.net/ubuntu/\"\n// PRIVACY_POLICY_URL=\"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\"\n// VERSION_CODENAME=focal\n// UBUNTU_CODENAME=focal\n\n// Alpine:\n\n// NAME=\"Alpine Linux\"\n// ID=alpine\n// VERSION_ID=3.11.6\n// PRETTY_NAME=\"Alpine Linux v3.11\"\n// HOME_URL=\"https://alpinelinux.org/\"\n// BUG_REPORT_URL=\"https://bugs.alpinelinux.org/\"\n\n// Fedora:\n\n// NAME=\"Fedora Linux\"\n// VERSION=\"36 (Container Image)\"\n// ID=fedora\n// VERSION_ID=36\n// VERSION_CODENAME=\"\"\n// PLATFORM_ID=\"platform:f36\"\n// PRETTY_NAME=\"Fedora Linux 36 (Container Image)\"\n// ANSI_COLOR=\"0;38;2;60;110;180\"\n// LOGO=fedora-logo-icon\n// CPE_NAME=\"cpe:/o:fedoraproject:fedora:36\"\n// HOME_URL=\"https://fedoraproject.org/\"\n// DOCUMENTATION_URL=\"https://docs.fedoraproject.org/en-US/fedora/f36/system-administrators-guide/\"\n// SUPPORT_URL=\"https://ask.fedoraproject.org/\"\n// BUG_REPORT_URL=\"https://bugzilla.redhat.com/\"\n// REDHAT_BUGZILLA_PRODUCT=\"Fedora\"\n// REDHAT_BUGZILLA_PRODUCT_VERSION=36\n// REDHAT_SUPPORT_PRODUCT=\"Fedora\"\n// REDHAT_SUPPORT_PRODUCT_VERSION=36\n// PRIVACY_POLICY_URL=\"https://fedoraproject.org/wiki/Legal:PrivacyPolicy\"\n// VARIANT=\"Container Image\"\n// VARIANT_ID=container\n\n// `man os-release`:\nconst OsReleaseFiles = [\"/etc/os-release\", \"/usr/lib/os-release\"]\n\nexport const osReleaseTokens = lazy(() => {\n  if (!isLinux) return\n\n  for (const filename of OsReleaseFiles) {\n    try {\n      const input = readFileSync(filename).toString()\n      if (notBlank(input)) {\n        return parseEnvTokens({ input, lowerCaseKeys: true })\n      }\n    } catch (error) {\n      logger().warn(\"failed to read os-release file\", { filename, error })\n    }\n  }\n\n  return\n})\n\nexport const osNameLinux = lazy(() => {\n  const t = osReleaseTokens()\n  if (notBlank(t?.pretty_name)) return t?.pretty_name\n  return map2Or(\n    t?.name,\n    t?.version ?? t?.version_id,\n    (n, v) => n + \" \" + v,\n    osNameDefault\n  )\n})\n\nexport const osDistributionLinux = lazy(() =>\n  isLinux ? osReleaseTokens()?.id?.toLowerCase() : undefined\n)\n\nexport function isDebian() {\n  return osDistributionLinux() === \"debian\"\n}\nexport function isUbuntu() {\n  return osDistributionLinux() === \"ubuntu\"\n}\nexport function hasApt() {\n  return isDebian() || isUbuntu()\n}\nexport function isFedora() {\n  return osDistributionLinux() === \"fedora\"\n}\nexport function isAlpine() {\n  return osDistributionLinux() === \"alpine\"\n}\n\n// https://en.wikipedia.org/wiki/MacOS_version_history\n\nconst MacCodenames = {\n  \"10\": {\n    \"6\": \"Snow Leopard\",\n    \"7\": \"Lion\",\n    \"8\": \"Mountain Lion\",\n    \"9\": \"Mavericks\",\n    \"10\": \"Yosemite\",\n    \"11\": \"El Capitan\",\n    \"12\": \"Sierra\",\n    \"13\": \"High Sierra\",\n    \"14\": \"Mojave\",\n    \"15\": \"Catalina\"\n  },\n  \"11\": \"Big Sur\", // 11.1, 11.2, ...\n  \"12\": \"Monterey\", // 12.1, 12.2, ...\n  \"13\": \"Ventura\", // 13.1, 13.2, ...\n  \"14\": \"Sonoma\" // 14.1, 14.2, ...\n}\n\n// https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions\n\n// Windows 11:\n// require(\"os\").release() === '10.0.22000'\n\n// Windows 10:\n// require(\"os\").release() === '10.0.19044'\n\n// YAY\n\nconst WinReleaseToVersions = {\n  \"10\": \"10\", // or 11, see below\n  \"6\": { \"3\": \"8.1\", \"2\": \"8\", \"1\": \"7\", \"0\": \"Vista\" },\n  \"5\": { \"2\": \"Server 2003\", \"1\": \"XP\", \"0\": \"2000\" },\n  \"4\": { \"9\": \"ME\", \"1\": \"98\", \"0\": \"95\" }\n}\n\nfunction majorMinor(ver: string) {\n  return ver.split(\".\").slice(0, 2)\n}\n\nfunction versionToCodename(\n  ver: string,\n  codenames: typeof MacCodenames | typeof WinReleaseToVersions\n) {\n  const [major, minor] = majorMinor(ver)\n  const m = (codenames as any)[major]\n  return isString(m) ? m : m?.[minor]\n}\n\n/**\n * @return something like \"10.11.5\"\n */\nconst macProductVersion = lazy(() =>\n  execSync(\"sw_vers -productVersion\").toString().trim()\n)\n\nfunction macCodename(productVersion = macProductVersion()) {\n  return versionToCodename(productVersion, MacCodenames)\n}\n\nexport function osNameMac(productVersion = macProductVersion()) {\n  try {\n    return mapNotBlankOr(\n      macCodename(productVersion),\n      ea => `macOS ${ea} (${productVersion})`,\n      osNameDefault\n    )\n  } catch (err) {\n    logger().warn(\"osNameMac(): unknown release\", err)\n    return osNameDefault()\n  }\n}\n\nexport function osNameWin(r = release()) {\n  const codename = r.startsWith(\"10.0.22\")\n    ? \"11\"\n    : versionToCodename(r, WinReleaseToVersions)\n  if (codename != null) {\n    return `Windows ${codename} (${r})`\n  } else {\n    logger().warn(\"osNameWin(): unknown release: \" + r)\n    return `Windows (${r})`\n  }\n}\n\nexport const CPUs = lazy(\n  () =>\n    uniqCount(cpuInfo().map(c => c.model))\n      .map(ea => `${ea.count} × ${ea.t}`)\n      .join(\", \"),\n  minuteMs\n)\n\n// lazy for testing\nexport const whyOsNotSupported = lazy(() => {\n  if (isWin) {\n    return /^Windows (?:10|11) /i.test(osNameWin())\n      ? undefined\n      : \"Windows 10 and 11 is supported\"\n  }\n  if (isMac) {\n    const v = macProductVersion()\n    return satisfies(v, \">=12\", { loose: true })\n      ? undefined\n      : \"macOS 12 (Monterey) or later is supported\"\n  }\n  if (isLinux) {\n    const version = toS(debianVersionToSemver(osReleaseTokens()?.version_id))\n    if (isDebian()) {\n      return satisfies(version, \">=11\", { loose: true })\n        ? undefined\n        : \"Debian 11 or later is supported\"\n    }\n    if (isUbuntu())\n      return satisfies(version, \"20 || 22\", { loose: true })\n        ? undefined\n        : \"Ubuntu 20.x LTS or 22.x LTS is supported\"\n\n    if (isFedora()) {\n      return satisfies(version, \"37 || 38\", { loose: true })\n        ? undefined\n        : \"Fedora 37 or 38 is supported\"\n    }\n    if (isAlpine()) {\n      return satisfies(version, \">=3.15\", { loose: true })\n        ? undefined\n        : \"Alpine >= 3.15 is supported\"\n    }\n  }\n\n  return \"recent versions of Windows 10/11, macOS, Debian, Ubuntu, and Fedora are supported\"\n})\n","/**\n * Updated when Curators, AssetFile schema, or metadata changes warrant\n * re-updating all AssetFiles from files\n */\n// 8: v0.7.x\n// 9: v0.8.x: new image hashes, spread dominant colors\n// 10: v0.8.0: remove searchHash and rightHash\n// 11: v0.8.3: fix ImageId to prefix the tag. Support greyscale images.\n// 12: v2.1: new dominant color percentages\nexport const AssetFileVersion = 12\n\n// 2: v0.8.x: new taggers\n// 3: v1.0.0: new people, album, and taggers\nexport const AssetVersion = 3\n","import { pidExists } from \"batch-cluster\"\nimport { toA } from \"../fe/toA\"\nimport { untilTrue } from \"./async/until\"\n\nexport function existingPids(pids: number[]): number[] {\n  return toA(pids).filter(pidExists)\n}\n\nexport function waitForPidExit(\n  pid: number,\n  timeoutMs: number\n): Promise<boolean> {\n  return untilTrue(() => !pidExists(pid), { timeoutMs, intervalMs: 250 })\n}\n","import { pidExists } from \"batch-cluster\"\nimport child_process from \"child_process\"\nimport process from \"process\"\nimport { lazy } from \"../core/Lazy\"\nimport { compact, isEmpty } from \"../fe/Array\"\nimport { notBlank } from \"../fe/Blank\"\nimport { ago, minuteMs, secondMs } from \"../fe/Date\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe, MaybePromiseMaybe, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { gt, gt0, lt, toInt } from \"../fe/Number\"\nimport { opt } from \"../fe/Opt\"\nimport { MaybeSyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { toA } from \"../fe/toA\"\nimport { toS } from \"../fe/toS\"\nimport { FifoCache } from \"./FifoCache\"\nimport { mkLogger } from \"./Logger\"\nimport { Try, identity } from \"./Object\"\nimport { ProcEntry, pidInfos } from \"./Ps\"\nimport { rateLimited } from \"./RateLimited\"\nimport { Endable, EndableRanks, ending } from \"./async/Endable\"\nimport { EndableWrapper } from \"./async/EndableWrapper\"\nimport { thenMap } from \"./async/Promise\"\nimport { setUnrefInterval } from \"./async/Timers\"\nimport { configDir } from \"./dir/ConfigDir\"\nimport { onError } from \"./error/OnError\"\nimport { BaseFile } from \"./fs/BaseFile\"\nimport { isJsonExt } from \"./fs/FileExt\"\nimport { isHiddenBasename, parseNativePath } from \"./fs/Path\"\nimport { isWin } from \"./platform/Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\n\n// TODO: move to ./proc/Pids.ts\nconst logger = lazy(() => mkLogger(\"proc.Pids\"))\n\nexport interface PidfileInfo {\n  pid: number\n  cmd: string // < only for debugging\n  ppid: number // < if ppid is gone, reap.\n  /**\n   * If <= 0, the process can run indefinitely (like web or sync)\n   */\n  timeoutMs: number\n}\n\nexport interface PidfileJson extends PidfileInfo {\n  startTime: number\n  timeoutTime?: number\n}\n\n// yeah, it's a lot of slop, but addPid() is called after a timeout, so start\n// isn't really the start time.\nconst AllowableStartSlopMs = 10 * secondMs\n\nfunction matchesPidfileInfo(\n  info: Maybe<PidfileJson>,\n  entry: Maybe<ProcEntry>\n): boolean {\n  if (info == null || entry == null || info.pid !== entry.pid) return false\n\n  // The start times need to match, ish:\n  const entryStartTime = map(entry.start, ea => ea.getTime())\n  const fileStartTime = info.startTime\n  return (\n    gt0(entryStartTime) &&\n    gt0(fileStartTime) &&\n    Math.abs(entryStartTime - fileStartTime) < AllowableStartSlopMs\n  )\n\n  // Command names can change, so we just use the start time to match PIDs.\n}\n\nfunction killPidWinTaskkill(pid: number, force = false) {\n  const args = [\"/PID\", toS(toInt(pid)), \"/T\"]\n  if (force) {\n    args.push(\"/F\")\n  }\n  child_process.execFile(\"taskkill\", args)\n}\n\nasync function killPidWin(pid: number, force = false) {\n  if (ending() || PowerShell.instance().ended) {\n    killPidWinTaskkill(pid, force)\n  } else {\n    try {\n      // https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/stop-process?view=powershell-6\n      const cmd = compact([\n        \"Stop-Process\",\n        \"-Id\",\n        toInt(pid),\n        force ? \"-Force\" : undefined\n      ]).join(\" \")\n      await PowerShell.instance().execute(cmd, identity)\n    } catch (err) {\n      logger().warn(\"killWin(): pwsh error, using TASKKILL: \" + err)\n      killPidWinTaskkill(pid, force)\n    }\n  }\n}\n\nasync function killPidWithNode(pid: number, force = false) {\n  try {\n    process.kill(pid, force ? \"SIGKILL\" : \"SIGTERM\")\n  } catch (err) {\n    if (!String(err).includes(\"ESRCH\")) throw err\n  }\n}\n\n/**\n * Send a signal to the given process id.\n *\n * @param {number} pid the process id. Required.\n * @param {boolean} [force=false] if true, and the current user has\n * permissions to send the signal, the pid will be forced to shut down.\n */\nexport function killPid(\n  pid: number,\n  force = false,\n  rewritePidfileOnForce = true\n) {\n  logger().log(force ? \"warn\" : \"debug\", \"killPid\", { pid, force })\n  if (pid === process.pid || pid === process.ppid) {\n    throw new Error(\"cannot self-terminate\")\n  }\n  if (force && rewritePidfileOnForce) {\n    void Pids.instance()?.onKill(pid)\n  }\n  return isWin ? killPidWin(pid, force) : killPidWithNode(pid, force)\n}\n\nexport class Pids {\n  static readonly instance = lazy(() =>\n    map(configDir(), dir => new Pids(BaseFile.for(dir).join(\"pids\")))\n  )\n  private readonly recentPids = new FifoCache<Promise<BaseFile>>(10 * secondMs)\n  constructor(readonly pidsDir: BaseFile) {\n    //\n  }\n\n  async addPid(\n    info: PidfileInfo,\n    start: Date,\n    force = false\n  ): PromiseMaybe<BaseFile> {\n    if (info == null) {\n      throw new Error(\"undefined info\")\n    }\n    const pid = info.pid\n    if (!gt0(pid)) {\n      throw new Error(\"undefined pid\")\n    }\n    const key = info.ppid + \":\" + info.pid\n    if (!pidExists(pid)) {\n      this.recentPids.delete(key)\n      logger().debug(\"addPid(): no-op, pid already gone\", { info, start })\n      return\n    }\n\n    if (force) this.recentPids.delete(key)\n    return this.recentPids.getOrSet(key, async () => {\n      const f = this.pidsDir.join(info.pid + \".json\")\n      const cmd = opt(Try(() => parseNativePath(info.cmd).base))\n        .filter(notBlank)\n        .getOrElse(() => info.cmd)\n\n      const startTime = start.getTime()\n      const json: PidfileJson = {\n        ...info,\n        cmd,\n        startTime\n      }\n      // no need to fslock for pidfiles\n      await f.writeJson_(json)\n      logger().debug(\"addPid() wrote \" + f, json)\n      return f\n    })\n  }\n\n  pidfiles() {\n    return this.pidsDir.clear().children(ea => {\n      const pid = toInt(ea.name)\n      return ea.ext === \".json\" && pid != null && pid !== process.pid\n    })\n  }\n\n  async pids(pidfiles: MaybeSyncOrAsync<BaseFile[]> = this.pidfiles()) {\n    return compact(toA(await pidfiles).map(ea => toInt(ea.name)))\n  }\n\n  async onKill(pid: number): PromiseMaybe<BaseFile> {\n    const pidfile = this.pidsDir.join(pid + \".json\")\n    return thenMap(pidfile.clear().readJson<PidfileJson>(), priorInfo =>\n      this.addPid({ ...priorInfo, timeoutMs: 1 }, ago(minuteMs), true).catch(\n        err => {\n          logger().info(\"onKill(): failed to rewrite pidfile: \" + err, { pid })\n          return undefined\n        }\n      )\n    )\n  }\n\n  readonly vacuumOldWip = rateLimited({\n    name: \"Pids.vacuumOldWip()\",\n    minCallDelayMs: minuteMs,\n    f: async () => {\n      // look for and delete old WIPs\n      const minMtime = Date.now() - 2 * minuteMs\n      const old = await this.pidsDir.childFiles(\n        async ea =>\n          isJsonExt(ea) &&\n          isHiddenBasename(ea.base) &&\n          lt(await ea.mtimeMs(), minMtime)\n      )\n      for (const ea of toA(old)) {\n        logger().warn(\"killOldProcs(): deleting old pid WIP, \" + ea.base)\n        await ea.unlink(\"debug\")\n      }\n    }\n  })\n\n  /**\n   * @param everything if `true`, ignore pidfile maxAgeMs.\n   * @param force given to `kill`.\n   */\n  readonly killOldProcs = rateLimited({\n    name: \"Pids.killOldProcs()\",\n    minCallDelayMs: minuteMs,\n    f: async (\n      opts: {\n        everything?: boolean\n        force?: boolean\n        everythingBefore?: number\n      } = {}\n    ) => {\n      await this.vacuumOldWip()\n      const everything = opts.everything ?? false\n      const force = opts.force ?? isWin\n      const pidfiles = await this.pidfiles()\n      const pids = await this.pids(pidfiles ?? [])\n      if (isEmpty(pids)) {\n        logger().info(\"killOldProcs(): no pidfiles\")\n        return []\n      }\n      const killed: (PidfileJson & Partial<ProcEntry>)[] = []\n\n      const endPromises: Promise<void>[] = []\n\n      const pidEntries = await pidInfos(pids)\n      if (pidEntries == null) {\n        onError(\"Pids.killOldProcs(): failed to get process information\")\n        return\n      }\n\n      for (const pidfile of pidfiles!) {\n        const json = await pidfile.readJson<PidfileJson>()\n        if (json == null) {\n          logger().warn(\n            \"killOldProcs(): failed to read pidfile \" + pidfile.base\n          )\n          await pidfile.unlink(\"debug\")\n          continue\n        }\n\n        const pid = json.pid\n\n        if (!gt0(pid)) {\n          logger().warn(\n            \"killOldProcs(): invalid json.pid: unlinking pidfile \" +\n              pidfile.base,\n            { json, pid }\n          )\n          await pidfile.unlink(\"debug\")\n          continue\n        }\n\n        const pidEntry = pidEntries.find(ea => ea.pid === pid)\n        if (pidEntry == null || !matchesPidfileInfo(json, pidEntry)) {\n          logger().debug(\n            \"killOldProcs(): pid no longer present: unlinking \" + pidfile.base,\n            { json, pidEntry }\n          )\n          await pidfile.unlink(\"debug\")\n          killed.push(json)\n          continue\n        }\n\n        const timeoutAt = gt0(json.timeoutMs)\n          ? json.startTime + json.timeoutMs\n          : undefined\n\n        const reason = everything\n          ? \"all pids are being shut down\"\n          : gt(Date.now(), timeoutAt)\n          ? `timed out ${Date.now() - timeoutAt!} ms ago`\n          : lt(json.startTime, opts.everythingBefore)\n          ? \"cleanup everything before \" +\n            new Date(opts.everythingBefore!).toISOString()\n          : undefined\n\n        if (reason != null) {\n          logger().info(\"killOldProcs(): killing\", {\n            reason,\n            json\n          })\n          endPromises.push(killPid(pid, force, false))\n          killed.push({ ...json, ...pidEntry })\n          // ... we'll remove the pidfile once the process exits ...\n        }\n      }\n      if (endPromises.length > 0) {\n        await Promise.allSettled(endPromises)\n      }\n\n      return killed\n    }\n  })\n}\n\nexport function addPid(\n  info: PidfileInfo,\n  start: Date\n): MaybePromiseMaybe<BaseFile> {\n  return Pids.instance()?.addPid(info, start)\n}\n\n// Should only be invoked by MainService\nexport const ProcCleaner = lazy<Endable>(() => {\n  const timers = [\n    // TCBH: prime intervals so they don't collide unnecessarily:\n    { everything: false, force: false, intervalMs: 5 * minuteMs },\n    { everything: false, force: true, intervalMs: 17 * minuteMs }\n  ].map(ea =>\n    setUnrefInterval(() => Pids.instance()?.killOldProcs(ea), ea.intervalMs)\n  )\n  return new EndableWrapper(\n    \"ProcCleaner\",\n    () => {\n      timers.map(clearInterval)\n      return Pids.instance()?.killOldProcs()\n    },\n    EndableRanks.predb\n  )\n})\n","import os from \"os\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { strEnum, StrEnumKeys } from \"../fe/StrEnum\"\n\n// From https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.processpriorityclass?view=netframework-4.8\n\n// AboveNormal Specifies that the process has priority higher than Normal but\n// lower than High.\n\n// BelowNormal Specifies that the process has priority above Idle but below\n// Normal.\n\n// High Specifies that the process performs time-critical tasks that must be\n// executed immediately, such as the Task List dialog, which must respond\n// quickly when called by the user, regardless of the load on the operating\n// system. The threads of the process preempt the threads of normal or idle\n// priority class processes. Use extreme care when specifying High for the\n// process's priority class, because a high priority class application can use\n// nearly all available processor time.\n\n// Idle Specifies that the threads of this process run only when the system is\n// idle, such as a screen saver. The threads of the process are preempted by the\n// threads of any process running in a higher priority class. This priority\n// class is inherited by child processes.\n\n// Normal Specifies that the process has no special scheduling needs.\n\nexport const PriorityClasses = strEnum(\"Normal\", \"BelowNormal\", \"Idle\", \"Low\")\n\nexport type PriorityClass = StrEnumKeys<typeof PriorityClasses>\n\n// PRIORITY_LOW: 19,\n// PRIORITY_BELOW_NORMAL: 10,\n// PRIORITY_NORMAL: 0,\n// PRIORITY_ABOVE_NORMAL: -7,\n// PRIORITY_HIGH: -14,\n// PRIORITY_HIGHEST: -20\n\nexport const PriorityClassToPosix = Object.freeze({\n  Normal: 0,\n  BelowNormal: 10,\n  Low: 19,\n  Idle: 19\n}) satisfies Record<PriorityClass, number>\n\nexport const PriorityClassToNode = Object.freeze({\n  AboveNormal: os.constants.priority.PRIORITY_ABOVE_NORMAL,\n  Normal: os.constants.priority.PRIORITY_NORMAL,\n  BelowNormal: os.constants.priority.PRIORITY_BELOW_NORMAL,\n  Idle: os.constants.priority.PRIORITY_LOW,\n  Low: os.constants.priority.PRIORITY_LOW\n}) satisfies Record<PriorityClass, number>\n\nexport function priorityPosixToClass(\n  priority: Maybe<number>\n): Maybe<PriorityClass> {\n  if (priority == null || !isFinite(priority)) {\n    return\n  } else if (priority < PriorityClassToPosix.BelowNormal) {\n    return PriorityClasses.Normal\n  } else if (priority < PriorityClassToPosix.Idle) {\n    return PriorityClasses.BelowNormal\n  } else {\n    return PriorityClasses.Idle\n  }\n}\n","import { SimpleAppName, SimpleShortAppName } from \"./AppName\"\nimport { mkLogger } from \"./Logger\"\nimport { isMainService, serviceName } from \"./ServiceNames\"\nimport { isElectron } from \"./platform/Platform\"\n\n// break dep loop on Settings:\nlet shortProcessNames = !isElectron\nexport function setShortProcessNames(short: boolean) {\n  shortProcessNames = short\n}\n\nexport function setProcessTitle() {\n  try {\n    const result = [shortProcessNames ? SimpleShortAppName : SimpleAppName]\n    if (!(isMainService() && isElectron)) {\n      result.push(serviceName())\n    }\n    const title = result.join(isElectron ? \" \" : \"-\")\n    // SITS: using an import doesn't work\n    require(\"process\").title = title\n  } catch (error) {\n    mkLogger(\"ServiceNames\").warn(\"Failed to set friendly process name\", error)\n  }\n}\n","import process from \"process\"\nimport { lazy } from \"../core/Lazy\"\nimport { isEmpty, isNotEmpty, uniq } from \"../fe/Array\"\nimport { sortBy } from \"../fe/ArraySort\"\nimport { blank, notBlank } from \"../fe/Blank\"\nimport { secondMs } from \"../fe/Date\"\nimport { PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { gt0, toInt } from \"../fe/Number\"\nimport { onlyReqValued } from \"../fe/Object\"\nimport { toA } from \"../fe/toA\"\nimport { toS } from \"../fe/toS\"\nimport { collectBatchedAsync } from \"./Array\"\nimport { parseFixed } from \"./Fixed\"\nimport { mkLogger } from \"./Logger\"\nimport { existingPids } from \"./Pid\"\nimport { StartTs } from \"./StartTs\"\nimport { pwshJsonDate, wmiDate } from \"./WinDate\"\nimport { thenMap } from \"./async/Promise\"\nimport { StdoutOpts, stdoutResult_, stdout_ } from \"./child/ChildProcess\"\nimport { wmic } from \"./fs/PathTo\"\nimport { isWin } from \"./platform/Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\n\nexport interface ProcEntry {\n  pid: number\n  start: Date\n  cmd: string\n}\n\n// TODO: move to ./proc/Ps.ts\nconst logger = lazy(() => mkLogger(\"proc.ps\"))\n\nexport function isProcEntry(pe: any): pe is ProcEntry {\n  return pe != null && gt0(pe.pid) && pe.start != null && notBlank(pe.cmd)\n}\n\nexport async function ps(): Promise<ProcEntry[]> {\n  const procs = await (isWin ? psWin() : psPosix())\n  return sortBy(procs.filter(isProcEntry), ea => ea.pid) ?? []\n}\n\nexport async function pidInfo(pid: number): PromiseMaybe<ProcEntry> {\n  return thenMap(pidInfos([pid]), arr => toA(arr).find(ea => ea.pid === pid))\n}\n\nexport async function notExistingPids(pids: number[]): PromiseMaybe<number[]> {\n  if (isEmpty(pids)) return []\n  return thenMap(existingPids(pids), arr => {\n    const alive = [process.pid, ...arr]\n    return pids.filter(ea => !alive.includes(ea))\n  })\n}\n\nexport async function pidInfos(pids: number[]): PromiseMaybe<ProcEntry[]> {\n  const arr = existingPids(pids)\n\n  const arr2 = await collectBatchedAsync<number, ProcEntry>(\n    arr,\n    20,\n    isWin ? pidInfoWin : pidInfoPosix\n  )\n  const result = arr2.filter(ea => isProcEntry(ea) && arr.includes(ea.pid))\n  return logger().tap({ msg: \"pidInfos()\", result, meta: { pids } })\n}\n\nfunction win2pe(arr: any[]): ProcEntry[] {\n  return arr.map((entry: any) => ({\n    pid: entry.Id,\n    start: pwshJsonDate(entry.StartTime),\n    cmd: entry.ProcessName\n  })) as ProcEntry[]\n}\n\nconst PsWinCmd = \"Get-Process\"\nconst PsWinSelectObj = \"| Select-Object -Property Id,ProcessName,StartTime\"\n\nasync function psWin(): Promise<ProcEntry[]> {\n  if (PowerShell.instance().ended) return psWinWmic()\n  const result = await PowerShell.instance().executeJsonToA(\n    [PsWinCmd, PsWinSelectObj].join(\" \")\n  )\n  return result == null ? psWinWmic() : win2pe(result)\n}\n\nfunction pidToS(pids: number[]): string {\n  return uniq([...pids.filter(gt0), process.pid]).join(\",\")\n}\n\nasync function pidInfoWin(pids: number[]): PromiseMaybe<ProcEntry[]> {\n  if (PowerShell.instance().ended) return psWinWmic(pids)\n  const cmd = [\n    PsWinCmd,\n    \"-Id\",\n    // PowerShell wants the IDs joined by comma:\n    pidToS(pids),\n    \"-ErrorAction SilentlyContinue\", // I expect it not to find some pids\n    PsWinSelectObj\n  ].join(\" \")\n  return thenMap(PowerShell.instance().executeJsonToA(cmd), ea => win2pe(ea))\n}\n\nconst stdoutOpts: StdoutOpts = {\n  maxBuffer: 1024 * 1024, // windows process lists can be enormous\n  timeoutMs: 15 * secondMs, // ps sometimes takes a long time\n  ignoreExitCode: true,\n  ignoreStderr: true\n}\n\nconst headers: (\"CommandLine\" | \"CreationDate\" | \"ProcessId\")[] = [\n  \"CommandLine\",\n  \"CreationDate\",\n  \"ProcessId\"\n]\n\n// NOTE: only used if powershell is shut down\nexport async function psWinWmic(pids?: number[]): Promise<ProcEntry[]> {\n  const args = [\"process\"]\n  if (isNotEmpty(pids)) {\n    // wmic wants multiple PIDs as or clauses, like\n    // wmic process where \"ProcessId=11308 or ProcessId=9416\"\n    const processIdClause = uniq([...pids.filter(gt0), process.pid])\n      .map(ea => `ProcessId=${ea}`)\n      .join(\" or \")\n    args.push(\"where\", processIdClause)\n  }\n  args.push(\"get\", headers.join(\",\"))\n  const result = await stdoutResult_(wmic(), args, stdoutOpts)\n  const results = onlyReqValued(\n    parseFixed(headers, result.result).map((ea: any) => ({\n      pid: toInt(ea.ProcessId, { defaultValue: -1 })!,\n      start: wmiDate(ea.CreationDate),\n      cmd: toS(ea.CommandLine)\n    }))\n  )\n  if (!results.find(ea => ea.pid === process.pid)) {\n    results.push({\n      pid: process.pid,\n      start: new Date(StartTs),\n      cmd: \"node \" + process.title\n    })\n  }\n  return results\n}\n\nfunction psStdout2ProcEntry(result: string): ProcEntry[] {\n  if (blank(result)) return []\n  return parseFixed(\n    [\"PID\", { text: \"STARTED\", greedyLeft: true }, \"COMMAND\"],\n    result\n  ).map((ea: any) => ({\n    pid: toInt(ea.PID, { defaultValue: -1 })!,\n    start: new Date(ea.STARTED),\n    cmd: toS(ea.COMMAND)\n  }))\n}\n\nasync function psPosix(): Promise<ProcEntry[]> {\n  return psStdout2ProcEntry(\n    await stdout_(\"ps\", [\"-ewwwo\", \"pid,lstart,command\"], stdoutOpts)\n  )\n}\n\n/**\n * @param pid the pid to look for\n * @return an array of either just this process, or the process and the requested pid.\n */\nasync function pidInfoPosix(pids: number[]): Promise<ProcEntry[]> {\n  const r = await stdoutResult_(\n    \"ps\",\n    // we include the current pid to prevent either `ps` or the fixed parser\n    // from grumping at us:\n    [\"-p\", pidToS(pids), \"-wwwo\", \"pid,lstart,command\"],\n    {\n      ...stdoutOpts,\n      ignoreExitCode: true\n    }\n  )\n  return psStdout2ProcEntry(r.result)\n}\n","import { Radix, TokenRadix } from \"./math/Radix\"\nimport { decuss } from \"./words/Cuss\"\n\n// Extracted from Radix to break deploop between Radix > Cuss > ProjectPath\n\nexport function safeRandomChars({\n  radix = TokenRadix,\n  length\n}: {\n  radix: Radix\n  length: number\n}): string {\n  return decuss(() => radix.randomChars(length))\n}\n\nexport function safeRandomUid(args?: {\n  radix?: Radix\n  chars?: number\n  splitEveryN?: number\n  sepChar?: string\n}): string {\n  return decuss(() =>\n    (args?.radix ?? TokenRadix).randomUid(\n      args?.chars ?? 20,\n      args?.splitEveryN ?? 5,\n      args?.sepChar ?? \"-\"\n    )\n  )\n}\n","import { delay } from \"../fe/Delay\"\nimport { Latch } from \"../fe/Latch\"\nimport { Maybe, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { gt0, max_ } from \"../fe/Number\"\nimport { SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { Deferred } from \"./async/Deferred\"\nimport { setUnrefTimeout } from \"./async/Timers\"\nimport { WrappedError } from \"./error/WrappedError\"\n\nexport interface RateLimited<T> {\n  (...args: any[]): PromiseMaybe<T>\n  // unschedule any pending future calls\n  clear(): void\n  isRateLimited(): boolean\n  minCallDelayMs(): number\n  setMinCallDelayMs(millis: number): void\n  donePromise(): Promise<void>\n  force(...args: any[]): PromiseMaybe<T>\n  status(): {\n    running: boolean\n    needToDelay: boolean\n    delayNextRunUntil: number\n  }\n}\n\n/**\n * Ensures no concurrent invocations, and a delay between method calls to be at\n * least `minCallDelayMs`.\n *\n * As opposed to debounce, this implementation will only postpone a\n * call to f() at most every timeoutMs, rather than postponing forever.\n */\nexport function rateLimited<T>({\n  f,\n  minCallDelayMs,\n  timeoutMs = undefined,\n  nullOnBusy,\n  name\n}: {\n  f: (...args: any[]) => SyncOrAsync<T>\n  minCallDelayMs: number\n  timeoutMs?: number\n  nullOnBusy?: boolean\n  name: string\n}): RateLimited<T> {\n  let running = false\n  let delayNextRunUntil: number = 0\n  let priorResult: Maybe<Deferred<T>>\n  let nextArgs: Maybe<any[]>\n  minCallDelayMs = Math.ceil(minCallDelayMs)\n\n  const doneLatches: Latch[] = []\n\n  function isRateLimited() {\n    return running || delayNextRunUntil > Date.now()\n  }\n\n  function afterRunDelay() {\n    if (nextArgs != null) {\n      const arr = nextArgs\n      nextArgs = undefined\n      void r(...arr)\n    }\n  }\n\n  async function postRun() {\n    running = false\n    delayNextRunUntil = Date.now() + minCallDelayMs\n\n    setUnrefTimeout(afterRunDelay, minCallDelayMs + 1)\n\n    // only release latches _after_ we've marked ourselves as not running:\n    doneLatches.forEach(ea => ea.resolve())\n    doneLatches.length = 0\n  }\n\n  async function run(...args: any[]) {\n    running = true\n    delayNextRunUntil = Date.now() + max_(minCallDelayMs, timeoutMs)\n\n    // We get to run!\n    const d = (priorResult = new Deferred<T>(name))\n    if (gt0(timeoutMs)) void d.setTimeout(timeoutMs)\n    try {\n      void d.resolve(await f(...args))\n    } catch (cause) {\n      void d.reject(\n        new WrappedError(\"RateLimited(\" + name + \") failed\", { cause })\n      )\n    } finally {\n      void postRun()\n    }\n    return d.promise\n  }\n\n  const r: any = (...args: any[]) => {\n    if (isRateLimited()) {\n      if (nullOnBusy === true) {\n        return null\n      }\n      const result = priorResult?.promise\n      nextArgs = args\n      // the delay breaks hard loops:\n      return delay(1).then(() => result)\n    } else {\n      return run(...args)\n    }\n  }\n  r.clear = () => {\n    nextArgs = undefined\n  }\n\n  r.donePromise = () => {\n    if (!running) return Promise.resolve()\n    const l = new Latch()\n    doneLatches.push(l)\n    return l\n  }\n\n  r.force = async (...args: any[]) => {\n    // unschedule any other runs\n    nextArgs = undefined\n    // wait for the prior run:\n    if (running) await r.donePromise()\n    running = false\n    delayNextRunUntil = 0\n    return r(...args)\n  }\n\n  r.isRateLimited = () => isRateLimited()\n  r.status = () => {\n    return {\n      running,\n      needToDelay: delayNextRunUntil > Date.now(),\n      minNextDelayMs: Math.max(0, Date.now() - delayNextRunUntil)\n    }\n  }\n  r.minCallDelayMs = () => minCallDelayMs\n  r.setMinCallDelayMs = (ms: number) => {\n    minCallDelayMs = ms\n  }\n  return r\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { pick } from \"../fe/Object\"\nimport { toS } from \"../fe/toS\"\n\nexport type IndexedString = [string, number]\n\n/**\n * Given a RegExp and string, return all captured groups and their starting\n * index.\n */\nexport function captures(\n  regex: RegExp,\n  str: string\n): Pick<RegExpExecArray, \"index\" | \"groups\">[] {\n  const result = []\n  if (!regex.global) throw new Error(\"must provide global regex\")\n  let m: RegExpExecArray | null\n  while ((m = regex.exec(str)) != null) {\n    // This is necessary to avoid infinite loops with zero-width matches\n    if (m.index === regex.lastIndex) {\n      regex.lastIndex++\n    } else {\n      result.push(pick(m, \"index\", \"groups\"))\n    }\n  }\n  return result\n}\n\nexport function escapeRegExp(s: string | RegExpEscaped): string {\n  return s instanceof RegExpEscaped\n    ? s.source\n    : toS(s).replace(/[-.,\\\\^$*+?()|[\\]{}]/g, \"\\\\$&\")\n}\n\nexport function matchQuotes(s: string) {\n  return s.replace(/[‘’']/g, \"[‘’']\").replace(/[“”„«»〃\"]/g, `[“”„”«»〃\"]`)\n}\n\nexport function orRegExpPatterns(\n  arr: (string | RegExp)[],\n  flags?: string\n): RegExp {\n  const result = []\n  for (const ea of arr) {\n    try {\n      result.push(ea instanceof RegExp ? ea.source : new RegExp(ea).source)\n    } catch {\n      result.push(escapeRegExp(ea))\n    }\n  }\n  return new RegExp(result.map(ea => \"(?:\" + ea + \")\").join(\"|\"), flags)\n}\n\n/**\n * When provided to `concatRegexp()`, this `source` won't be further\n * escaped.\n *\n * This is only useful if a snippet of a regular expression is not valid by\n * itself (as it doesn't include balanced parenthesis or other grouping\n * constructs).\n */\nexport class RegExpEscaped {\n  constructor(\n    readonly source: string,\n    readonly flags?: string\n  ) {}\n\n  get global() {\n    return this.flags?.includes(\"g\") ?? false\n  }\n  get ignoreCase() {\n    return this.flags?.includes(\"m\") ?? false\n  }\n  get multiline() {\n    return this.flags?.includes(\"i\") ?? false\n  }\n}\n\nexport class RegExpOptional extends RegExpEscaped {\n  static from(...arr: Maybe<RegExp | string | RegExpEscaped>[]) {\n    const re = concatRegexp(arr)\n    return new RegExpOptional(\"(?:\" + re.source + \")?\", re.flags)\n  }\n}\n\nexport function concatRegexp(\n  arr: Maybe<RegExp | string | RegExpEscaped>[],\n  flags?: string\n): RegExp {\n  let re = \"\"\n  let global = flags?.includes(\"g\") ?? false\n  let ignoreCase = flags?.includes(\"i\") ?? false\n  let multiline = flags?.includes(\"m\") ?? false\n  for (const ea of arr) {\n    if (ea instanceof RegExpEscaped || ea instanceof RegExp) {\n      re += ea.source\n      global ||= ea.global\n      ignoreCase ||= ea.ignoreCase\n      multiline ||= ea.multiline\n    } else {\n      re += escapeRegExp(toS(ea))\n    }\n  }\n  return new RegExp(\n    re,\n    flags ??\n      (global ? \"g\" : \"\") + (ignoreCase ? \"i\" : \"\") + (multiline ? \"m\" : \"\")\n  )\n}\n","import os from \"os\"\nimport path from \"path\"\nimport { lazy } from \"../core/Lazy\"\nimport { compactBlanks } from \"../fe/Array\"\nimport { minuteMs, secondMs } from \"../fe/Date\"\nimport { later } from \"../fe/Delay\"\nimport { flatten } from \"../fe/Flatten\"\nimport { gt0 } from \"../fe/Number\"\nimport { ensureSuffix } from \"../fe/String\"\nimport { toS } from \"../fe/toS\"\nimport { mkLogger } from \"./Logger\"\nimport {\n  PriorityClass,\n  PriorityClassToNode,\n  PriorityClassToPosix,\n  PriorityClasses,\n  priorityPosixToClass\n} from \"./PriorityClass\"\nimport { TTLSet } from \"./TTLSet\"\nimport { stdoutResult_ } from \"./child/ChildProcess\"\nimport { ee } from \"./event/EventEmitter\"\nimport { isWin } from \"./platform/Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\nimport { Settings } from \"./settings/Settings\"\n\nconst logger = lazy(() => mkLogger(\"Renice\"))\n\n// HEY FUTURE ME: reniced.prior()?.clear() is NOT THE SAME as reniced.unset()\n// -- we want to keep the prior TTLSet to avoid creating more memory garbage.\nlater(() => ee().on(\"clearCache\", () => reniced.prior()?.clear()))\n\n// 20220215: changed to a include-list, because we really only care to nice\n// sync, worker, and ffmpeg.\n\n// Don't renice web, renice, ps, df, ...\n\nconst niceableCmds = lazy(() => [\n  \"sync.js\",\n  \"worker.js\",\n  ...flatten(\n    [\"dcraw_emu\", path.basename(Settings.ffmpegPath.valueOrDefault)].map(ea =>\n      isWin ? [ea, ensureSuffix(ea, \".exe\")] : ea\n    )\n  )\n])\n\nexport function niceable(\n  cmd: string,\n  args: string[] | readonly string[]\n): boolean {\n  return compactBlanks([\n    path.basename(cmd),\n    ...args.map(ea => path.basename(ea))\n  ]).some(ea => niceableCmds().includes(ea.toLowerCase()))\n}\n\nlet nodeReniceWorks = true\n\nconst reniced = lazy(() => new TTLSet<number>(minuteMs))\n\n// both the batch cluster observer and child services renice, which makes sync-file get\n// double-renice-d.\nexport async function renice(pid: number | undefined, priority?: number) {\n  if (!gt0(pid) || reniced().has(pid)) return\n  reniced().add(pid)\n\n  const priorityClass: PriorityClass =\n    priorityPosixToClass(priority) ??\n    (Settings.processPriority.valueOrDefault as PriorityClass)\n\n  priority ??= PriorityClassToNode[priorityClass]\n\n  if (nodeReniceWorks) {\n    try {\n      os.setPriority(pid, priority)\n      return priority\n    } catch (error: any) {\n      // if it's a permission issue, don't try other methods.\n      const permissionDenied =\n        error?.errno === -13 || error?.info?.code === \"EACCES\"\n\n      logger().warn(\"Failed to renice using node:os\", {\n        pid,\n        priority,\n        permissionDenied,\n        error\n      })\n\n      if (permissionDenied) {\n        // it's not node's fault!\n        return\n      }\n      nodeReniceWorks = false\n      // try os-specific methods below:\n    }\n  }\n\n  try {\n    await (isWin\n      ? reniceWin(pid, priorityClass)\n      : renicePosix(\n          pid,\n          PriorityClassToPosix[priorityClass] ??\n            PriorityClassToPosix.BelowNormal\n        ))\n    logger().info(\"Renice pid \" + pid + \" to \" + priorityClass)\n    return priority\n  } catch (err) {\n    // Probably because the process already ended:\n    logger().info(\"Failed to renice pid \" + pid, err)\n    return\n  }\n}\n\nasync function reniceWin(pid: number, pc: PriorityClass) {\n  if (gt0(pid) && PriorityClasses.includes(pc)) {\n    await PowerShell.instance()\n      .execute(`(Get-Process -Id ${pid}).PriorityClass = \"${pc}\"`, ea => ea)\n      .catch(error => logger().info(\"reniceWin() failed\", error))\n  }\n}\n\nasync function renicePosix(pid: number, nice = 19) {\n  await stdoutResult_(\"renice\", [nice, \"-p\", pid].map(toS), {\n    timeoutMs: 10 * secondMs,\n    isIgnorableError: () => true,\n    ignoreExitCode: true\n  }).catch(error => logger().info(\"renicePosix() failed\", error))\n}\n","import process from \"process\"\nimport { lazy } from \"../core/Lazy\"\nimport { compactBlanks } from \"../fe/Array\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { ServiceName, ServiceNames } from \"../fe/ServiceNames\"\nimport { toS } from \"../fe/toS\"\nimport { isTest } from \"./NodeEnv\"\nimport { isPacked } from \"./platform/IsPacked\"\n\nexport const serviceName = lazy<ServiceName>(() => {\n  if (isPacked()) {\n    throw Error(\"serviceName() is unset\")\n  } else {\n    return \"\" as any\n  }\n})\n\nexport const processName = lazy(() =>\n  compactBlanks([serviceName.prior(), toS(process.pid)]).join(\"-\")\n)\n\nserviceName.watchLater(() => {\n  processName.unset()\n})\n\nexport function serviceNameIndex(s: Maybe<ServiceName>): number {\n  return ServiceNames.indexOf(s) ?? ServiceNames.length + 1\n}\n\nexport const MainServices: ServiceName[] = [\n  ServiceNames.main,\n  ServiceNames.desktop\n]\n\n/**\n * If a database isn't available, these services can't run\n */\nexport const DbServices: ServiceName[] = [\n  ServiceNames.sync,\n  ServiceNames.info,\n  ServiceNames.web,\n  ServiceNames.list,\n  ServiceNames.test\n]\n\nexport function isDbService() {\n  return DbServices.includes(serviceName())\n}\n\nexport function isLibraryRequiredService() {\n  return [ServiceNames.sync, ServiceNames.list].includes(serviceName() as any)\n}\n\nexport function isServiceThatAcceptsFatalErrors() {\n  return !isMainService() && !isWebService()\n}\n\nexport function isMainService(name?: ServiceName) {\n  // \"main\" and \"desktop\" are both \"main services\". We only discriminate between\n  // them when the CLI is rendered.\n  return MainServices.includes(name ?? serviceName())\n}\n\nexport function isWebService(name?: ServiceName) {\n  return (name ?? serviceName()) === ServiceNames.web\n}\n\nexport function isBillingService(name?: ServiceName) {\n  return (name ?? serviceName()) === ServiceNames.billing\n}\n\nexport function isWorkerService(name?: ServiceName) {\n  return (name ?? serviceName()) === ServiceNames.worker\n}\n\nexport function isSyncService(name?: ServiceName) {\n  return (name ?? serviceName()) === ServiceNames.sync\n}\n\nexport function isInfoService() {\n  return serviceName() === ServiceNames.info\n}\n\nexport function isTestService() {\n  return serviceName() === ServiceNames.test\n}\n\nfunction isTestNotWorker() {\n  return (isTest || isTestService()) && !isWorkerService()\n}\n\nexport const StatsDbServices: ServiceName[] = [ServiceNames.sync]\n\nexport function isStatsDbService() {\n  return isSyncService()\n}\n\nexport function isStatsDbMigrator() {\n  return isStatsDbService() || isTestNotWorker()\n}\n\nexport function isModelDbMigrator() {\n  // Normally the web service is doing the migrations -- it's first to set up\n  // a library.\n  return isSyncService() || isWebService() || isTestNotWorker()\n}\n\n// Lazy so info can force --cleanup to run a backup:\nexport const isDbJanitorService = lazy(() => isSyncService() || isTestService())\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { Primitive } from \"../fe/Primitive\"\nimport { toA } from \"../fe/toA\"\n\nexport function asSet<T>(s: Maybe<Iterable<T>>): Set<T> {\n  return s instanceof Set ? s : new Set(toA(s))\n}\n\nexport function setEql<T>(a: Set<T>, b: Set<T>): boolean {\n  return (\n    toA(a.keys()).every(ea => b.has(ea)) && toA(b.keys()).every(ea => a.has(ea))\n  )\n}\n\nexport function getOrAdd<K, V>(s: Set<K>, k: K, onAdd: () => V): Maybe<V> {\n  if (k == null) throw new Error(\"null key\")\n  if (s.has(k)) {\n    return undefined\n  } else {\n    s.add(k)\n    return onAdd()\n  }\n}\n\n//\n// These only support primitives, as comparison is done with ==\n//\n\n/**\n * @return unique elements in a or b\n */\nexport function union<T extends Primitive>(\n  a: Iterable<T>,\n  b: Iterable<T>\n): Set<T> {\n  return new Set([...a, ...b])\n}\n\n/**\n * @return elements in a that are also in b\n */\nexport function intersection<T extends Primitive>(\n  a: Iterable<T>,\n  b: Iterable<T>\n): Set<T> {\n  const s = asSet(b)\n  return new Set([...a].filter(ea => s.has(ea)))\n}\n\n/**\n * @return elements in `a` that are not in `b`\n */\nexport function diff<T extends Primitive>(\n  a: Iterable<T>,\n  b: Iterable<T>\n): Set<T> {\n  const s = asSet(b)\n  return new Set([...a].filter(ea => !s.has(ea)))\n}\n","import { ServiceName, ServiceNames } from \"../fe/ServiceNames\"\nimport { setupLogger } from \"./log/SetupLogger\"\nimport { logStartup } from \"./LogStartup\"\nimport { isTest } from \"./NodeEnv\"\nimport { isMainService, serviceName } from \"./ServiceNames\"\n\nexport function setServiceName(s: ServiceName) {\n  // Normalize \"desktop\" to \"main\":\n  if (isMainService(s as any)) s = ServiceNames.main\n  const prior = serviceName.prior()\n  if (prior === s) return // already done\n\n  if (!isTest && prior != null && prior !== s) {\n    console.error(\"Don't set service name twice\", {\n      prior,\n      new: s\n    })\n  }\n  serviceName.set(s)\n  setupLogger()\n  logStartup()\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { time } from \"./async/PromiseTimer\"\n\n// TODO: add a cache to Shim0\n\nexport interface Shim0<R> {\n  (): Promise<R>\n  setShim(f: Maybe<() => Promise<R>>): void\n  hasShim(): boolean\n}\n\nexport function shim0<R>({\n  impl,\n  name\n}: {\n  impl: () => Promise<R>\n  name: string\n}): Shim0<R> {\n  let shim: undefined | (() => Promise<R>)\n\n  const f: Shim0<R> = () =>\n    time(\n      name + (shim == null ? \"(local)\" : \"(remote)\"),\n      shim != null ? shim() : impl()\n    )\n\n  f.setShim = (i: Maybe<() => Promise<R>>) => {\n    shim = i\n  }\n\n  f.hasShim = () => shim != null\n\n  return f\n}\n","import { stringify } from \"../fe/JSON\"\nimport { MemoizedThunk } from \"../fe/Lazy\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { isString } from \"../fe/String\"\nimport { SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { FifoCacheAsync } from \"./FifoCacheAsync\"\nimport { Shim0 } from \"./Shim0\"\nimport { ee } from \"./event/EventEmitter\"\n\n// NOTE: this is used statically, so BE CAREFUL WITH NEW CORE IMPORTS: they will\n// probably cause a dependency loop.\n\nexport interface Shim1<I, O> {\n  (input: I): Promise<O>\n  setShim(f: Maybe<(input: I) => SyncOrAsync<O>>): void\n  hasShim(): boolean\n  cache?: MemoizedThunk<FifoCacheAsync<O>>\n  cacheDelete(input: I): void\n}\n\nexport function shim1<I, R>({\n  name,\n  impl,\n  cache,\n  toKey = ea => (isString(ea) ? ea : stringify(ea))\n}: {\n  name: string\n  impl: (input: I) => SyncOrAsync<R>\n  cache?: MemoizedThunk<FifoCacheAsync<R>>\n  toKey?: (input: I) => string\n}): Shim1<I, R> {\n  let shim: Maybe<(input: I) => SyncOrAsync<R>>\n\n  const f = async (input: I) => {\n    const start = Date.now()\n    const result = await (shim != null ? shim(input) : impl(input))\n    ee().emit(\n      \"timing\",\n      name + (shim == null ? \"(local)\" : \"(remote)\"),\n      Date.now() - start\n    )\n    return result\n  }\n\n  const result: Shim1<I, R> = async (input: I) => {\n    if (cache == null) return f(input)\n    return cache().getOrSetAsync(toKey(input), async () => f(input))\n  }\n\n  result.setShim = (i: Maybe<(input: I) => Promise<R>>) => {\n    shim = i\n  }\n\n  result.hasShim = () => shim != null\n\n  result.cache = cache\n\n  result.cacheDelete = (input: I) => cache?.().delete(toKey(input))\n\n  return result\n}\n\nexport type ShimReturnType<\n  T extends Shim0<any> | Shim1<any, any> | ((...args: any) => any)\n> = T extends Shim0<infer R>\n  ? Promise<R>\n  : T extends Shim1<any, infer R>\n  ? Promise<R>\n  : T extends (...args: any) => infer R\n  ? R\n  : any\n","import { secondMs } from \"../fe/Date\"\n\n/**\n * For commands that don't need to wait for a disk to spin up, and only return\n * something like --version\n *\n * Note that this is considered the longest time a human can wait before\n * overwhelmed by WTF IS GOING ON.\n */\nexport const ShortCommandTimeoutMs = 7 * secondMs\n","import { at } from \"../fe/At\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { Comparable } from \"../fe/Primitive\"\n\nexport class SortedSet<T> {\n  readonly store: T[] = []\n\n  constructor(readonly valueOf: (t: T) => Maybe<Comparable>) {}\n\n  get length() {\n    return this.store.length\n  }\n\n  addAll(...t: Maybe<T>[]) {\n    return t.map(ea => this.add(ea))\n  }\n\n  findIndex(t: Maybe<T>) {\n    return this.findValueIndex(t == null ? undefined : this.valueOf(t))\n  }\n\n  findValueIndex(v: Maybe<Comparable>) {\n    if (v == null) return\n\n    let low = 0,\n      high = this.store.length - 1\n\n    while (low <= high) {\n      const mid = low + Math.floor((high - low) / 2)\n      const midV = this.valueOf(this.store[mid])!\n      if (v === midV) return { found: true, index: mid }\n      else if (v > midV) low = mid + 1\n      else high = mid - 1\n    }\n    return { found: false, index: low }\n  }\n\n  add(t: Maybe<T>) {\n    const idx = this.findIndex(t)\n    if (idx?.found === false) {\n      this.store.splice(idx.index, 0, t!)\n    }\n    return idx\n  }\n\n  /**\n   * @see https://github.com/tc39/proposal-relative-indexing-method#polyfill\n   */\n  at(idx: number) {\n    return at(this.store, idx)\n  }\n\n  toA() {\n    return [...this.store]\n  }\n\n  /**\n   * Remove all the entries less than the given entry\n   */\n  shiftLte(c: Comparable): T[] {\n    const idx = this.findValueIndex(c)\n    if (idx == null || (idx.index === 0 && !idx.found)) return []\n    if (idx.index === this.store.length - 1) {\n      const result = [...this.store]\n      this.store.length = 0\n      return result\n    } else {\n      return this.store.splice(0, idx.index + (idx.found ? 1 : 0))\n    }\n  }\n\n  /**\n   * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n   * @param start The zero-based location in the array from which to start removing elements.\n   * @param deleteCount The number of elements to remove.\n   */\n  splice(start: number, deleteCount?: number): T[] {\n    const result = this.store.splice(start, deleteCount)\n    return result\n  }\n\n  retainLastN(n: number) {\n    if (n < this.length) {\n      this.splice(0, this.store.length - n)\n    }\n    return this.store\n  }\n}\n","export const StartTs = Date.now()\n\nexport function runtimeMs() {\n  return Date.now() - StartTs\n}\n","import { stderr } from \"process\"\nimport { SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { stdoutEnded } from \"./StdoutEnded\"\nimport { crlf } from \"./fs/CRLF\"\nimport { streamEnded } from \"./fs/StreamEnded\"\nimport { Settings } from \"./settings/Settings\"\n\n/**\n * Emit `msg` to stdout unless `quiet` is true\n */\nexport function consoleLog(msg: string, ...optionalParams: any[]) {\n  if (!Settings.quiet.valueOrDefault && !stdoutEnded()) {\n    console.log(crlf(msg), ...optionalParams)\n  }\n}\n\nexport function consoleError(msg: string, ...optionalParams: any[]) {\n  if (!Settings.quiet.valueOrDefault && !streamEnded(stderr)) {\n    console.error(msg, ...optionalParams)\n  }\n}\n\nexport async function quietly<T>(f: () => SyncOrAsync<T>): Promise<T> {\n  const prior = Settings.quiet.envValue\n  try {\n    Settings.quiet.envValue = true\n    return await f()\n  } finally {\n    Settings.quiet.envValue = prior\n  }\n}\n","import { stdout } from \"process\"\nimport { streamEnded } from \"./fs/StreamEnded\"\n\nexport function stdoutEnded() {\n  return streamEnded(stdout)\n}\n","import process from \"process\"\nimport { WriteStream } from \"tty\"\nimport { notBlank } from \"../fe/Blank\"\nimport { stringify } from \"../fe/JSON\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { isWorkerService } from \"./ServiceNames\"\nimport { stdoutEnded } from \"./StdoutEnded\"\nimport { FailStr } from \"./error/ErrorFlags\"\nimport { isFatalError, isHealthCheckError } from \"./error/ErrorTypes\"\nimport { BaseFile } from \"./fs/BaseFile\"\nimport { streamEnded } from \"./fs/StreamEnded\"\nimport { Setting } from \"./settings/Setting\"\n\nexport const ReadyStr = JSON.stringify({ ready: true })\n\nexport function stdoutWriteReady(ready: boolean = true) {\n  if (!stdoutEnded()) {\n    process.stdout.write(JSON.stringify({ ready }) + \"\\n\")\n  }\n}\n\nexport function stdoutWrite(obj: any, ready?: boolean) {\n  return writeTTY({ obj, ready, stream: process.stdout })\n}\n\nexport function stderrWrite(obj: any) {\n  return writeTTY({ obj, stream: process.stdout })\n}\n\nexport function writeTTY({\n  obj,\n  ready,\n  stream\n}: {\n  obj: any\n  ready?: boolean\n  stream: Maybe<WriteStream>\n}) {\n  const ttyEnded = stream == null || streamEnded(stream)\n  // if (obj != null) {\n  //   try {\n  //     mkLogger(\"writeTTY\").debug(\"()\", { obj, ready, ttyEnded })\n  //   } catch {\n  //     // don't care if I can't log\n  //   }\n  // }\n\n  if (ttyEnded) return\n\n  const str = stringify(obj)\n  stream.write(str + \"\\n\")\n\n  // Only the worker service runs under batch-cluster\n  if (isWorkerService() && ready != null) {\n    if (str.includes(FailStr) || isFatalError(str) || isHealthCheckError(str)) {\n      stream.write(FailStr + \"\\n\")\n    } else {\n      stream.write(ReadyStr + \"\\n\")\n    }\n  }\n}\n\nexport function stdoutWriteSettings(...arr: Setting<any>[]) {\n  const o = {}\n  for (const ea of arr) {\n    ea.addToEnv(o)\n  }\n  stdoutWrite(o)\n}\n\nexport function stdoutWriteMigration(migrationFile: BaseFile) {\n  return stdoutWrite({ migration: migrationFile.name })\n}\n\nexport interface MigrationEvent {\n  migration: string\n}\n\nexport function isMigrationEvent(o: any): o is MigrationEvent {\n  return o != null && notBlank(o.migration)\n}\n\nexport const StdoutWrite = {\n  shutdownSync: () => stdoutWrite({ shutdownSync: true }),\n  restartSync: () => stdoutWrite({ restartSync: true }),\n  forceRestartSync: () => stdoutWrite({ forceRestartSync: true }),\n  rebuildLibrary: () => stdoutWrite({ rebuildLibrary: true }),\n  shutdown: () => stdoutWrite({ shutdown: true })\n}\n","import { compactBlanks, isEmpty, uniq, uniqBy2 } from \"../fe/Array\"\nimport { sortBy } from \"../fe/ArraySort\"\nimport { blank, notBlank } from \"../fe/Blank\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe, MaybeNull } from \"../fe/MaybeTypes\"\nimport { mapNumeric, times, toFloat } from \"../fe/Number\"\nimport { padding } from \"../fe/Pad\"\nimport { cmp } from \"../fe/Primitive\"\nimport { strslice } from \"../fe/String\"\nimport { toA } from \"../fe/toA\"\nimport { toS } from \"../fe/toS\"\nimport { flatZip, greatestBy } from \"./Array\"\nimport { escapeRegExp } from \"./RegExp\"\nimport { NonRetriableErrorFlag } from \"./error/ErrorFlags\"\n\n// TODO: inline\nexport { splitFirst } from \"../fe/SplitFirst\"\nexport {\n  ellipsize,\n  ensurePrefix,\n  ensureSuffix,\n  isString,\n  stripPrefix,\n  stripSuffix,\n  wrap\n} from \"../fe/String\"\n\nconst he = require(\"he\")\n\nexport function ensureSuffixIgnoreCase(s: string, suffix: string): string {\n  if (suffix == null || suffix === \"\") return s\n  s = toS(s)\n  suffix = toS(suffix)\n  return s.endsWith(suffix) || equalsIgnoreCase(s.slice(-suffix.length), suffix)\n    ? s\n    : s + suffix\n}\n\nexport function rightPad(s: any, minLength: number, padChar: string): string {\n  if (padChar.length === 0) throw new Error(\"rightPad() given empty pad\")\n  const str = String(s)\n  return str + padding(padChar, minLength - str.length)\n}\n\nexport function padReplace(\n  s: string,\n  fromIdx: number,\n  length: number,\n  padChar: string\n) {\n  return (\n    strslice(s, 0, fromIdx) +\n    padding(padChar, length) +\n    strslice(s, fromIdx + length)\n  )\n}\n\nexport function contains(\n  haystack: string,\n  needle: string,\n  fromPosition?: number\n): boolean {\n  return toS(haystack).indexOf(toS(needle), fromPosition) > -1\n}\n\nexport function countChars(\n  haystack: string,\n  needle: string,\n  fromPosition = 0\n): number {\n  if (needle == null || needle.length === 0) return 0\n  // NOTE: this assumes .indexOf is going to be quick native code, and\n  // recursion will be faster than a simple for loop over ths string\n  // characters.\n  const idx = haystack.indexOf(needle, fromPosition)\n  return idx === -1 ? 0 : 1 + countChars(haystack, needle, idx + needle.length)\n}\n\nexport function maybeToS(a?: any): Maybe<string> {\n  return a == null ? undefined : String(a)\n}\n\nexport function trim(arr: any[]): string[] {\n  return arr.map(toS).filter(ea => notBlank(ea))\n}\n\nexport function splitEvery(s: string, n: number, maxSplits?: number): string[] {\n  const sliceTimes =\n    Math.min(Math.ceil(s.length / n), maxSplits ?? s.length) - 1\n  if (sliceTimes <= 0) return [s]\n  return [\n    ...times(sliceTimes, i => s.slice(i * n, (i + 1) * n)),\n    s.slice(sliceTimes * n)\n  ]\n}\n\n/**\n * Removes the first capture group defined by `re` found in `s`.\n */\nexport function spliceCapture(\n  s: string,\n  re: RegExp\n): Maybe<{\n  captured: string\n  uncaptured: string\n  unmatched: string\n  matchedIndex: number\n}> {\n  const m = re.exec(s)\n  if (m == null || m[1] == null) return\n  const matchedIndex = m[0].indexOf(m[1]) + m.index\n  return {\n    captured: m[1],\n    uncaptured:\n      s.substring(0, matchedIndex) + s.substring(matchedIndex + m[1].length),\n    unmatched: s.substring(0, m.index) + s.substring(m.index + m[0].length),\n    matchedIndex\n  }\n}\n\nexport function stripPrefixIgnoreCase(s: string, prefix: string): string {\n  s = toS(s)\n  prefix = toS(prefix)\n  return startsWithIgnoreCase(s, prefix) ? s.slice(prefix.length) : s\n}\n\nexport function stripSuffixIgnoreCase(\n  s: string,\n  suffix: string,\n  opts: { normalize?: boolean } = {}\n): string {\n  if (suffix == null) return s\n  const str = toS(s)\n  const sfx = toS(suffix)\n\n  return sfx.length > 0 && equalsIgnoreCase(str.slice(-sfx.length), sfx, opts)\n    ? str.slice(0, -sfx.length)\n    : str\n}\n\nexport function gist(a: string, maxPre = 80, maxPost = 80): string {\n  const s = toS(a)\n  const charsOmitted = s.length - (maxPre + maxPost)\n  return charsOmitted <= 0\n    ? s\n    : s.slice(0, maxPre).trim() +\n        \" …(+\" +\n        charsOmitted +\n        \" chars)…\" +\n        s.slice(-maxPost).trim()\n}\n\nexport function isLowerCase(s: Maybe<string>): boolean {\n  return toS(s).toLocaleLowerCase() === s\n}\n\nexport function isUpperCase(s: Maybe<string>): boolean {\n  return toS(s).toLocaleUpperCase() === s\n}\nconst CapRE = /^[A-Z]/\n\n/**\n * Is the first character in `s` `[A-Z]`?\n */\nexport function isFirstCharAZ(s: Maybe<string>): boolean {\n  return CapRE.test(toS(s))\n}\n\nexport function capitalize(s: Maybe<string>): string {\n  s = toS(s)\n  return blank(s) ? s : strslice(s, 0, 1).toLocaleUpperCase() + strslice(s, 1)\n}\n\nexport function compareIgnoreCase(a: string, b: string) {\n  const result = a.localeCompare(b, undefined, { sensitivity: \"base\" })\n  return result === 0\n    ? // for determinism:\n      a.localeCompare(b)\n    : result\n}\n\nexport function equalsIgnoreCase(\n  a: MaybeNull<string | Buffer>,\n  b: MaybeNull<string | Buffer>,\n  { normalize = true }: { normalize?: boolean } = {}\n): boolean {\n  if (a == null || b == null) return false\n  const as = toS(a)\n  const bs = toS(b)\n  if (as.length !== bs.length) return false\n  if (as === bs) return true\n  // cheap, but false is sometimes wrong (like in Turkish):\n  if (as.toLowerCase() === bs.toLowerCase()) return true\n  return (\n    (normalize ? as.normalize() : as).localeCompare(\n      normalize ? bs.normalize() : bs,\n      undefined,\n      { sensitivity: \"base\" }\n    ) === 0\n  )\n}\n\nexport function uniqIgnoreCase(arr: string[]): string[] {\n  return uniqBy2(arr, equalsIgnoreCase)\n}\n\nexport function sortIgnoreCase(arr: Iterable<string>): string[] {\n  return toA(arr).sort(compareIgnoreCase)\n}\n\nexport function sortByCaseInsensitive<T>(\n  arr: Iterable<T> | T[],\n  f: (t: T, index: number) => Maybe<string>\n): T[] {\n  return toA(arr)\n    .filter(ea => ea != null)\n    .map((item, idx) => ({\n      item,\n      cmp: map(f(item, idx), ea => [ea, idx]) as [string, number]\n    }))\n    .filter(ea => ea.cmp != null)\n    .sort((a, b) => {\n      const ea = compareIgnoreCase(a.cmp[0], b.cmp[0])\n      return ea !== 0 ? ea : cmp(a.cmp[1], b.cmp[1])\n    })\n    .map(ea => ea.item)\n}\n\n/** TODO DELETE IF UNUSED\n * @return true iff `haystack` starts with `needle`\n */\nexport function startsWithIgnoreCase(\n  haystack: Maybe<string>,\n  needle: Maybe<string>\n): boolean {\n  return haystack == null ||\n    needle == null ||\n    needle.length === 0 ||\n    haystack.length === 0\n    ? false\n    : equalsIgnoreCase(haystack.substring(0, needle.length), needle)\n}\n\n/**\n * @return the first item in `haystack` that is a case-insensitive substring of\n * `needle`.\n */\nexport function firstSubstringIgnoreCase(\n  haystack: string[],\n  needle: string\n): Maybe<{ index: number; match: string }> {\n  if (isEmpty(haystack) || blank(needle)) return\n  for (const ea of haystack) {\n    if (equalsIgnoreCase(ea, needle)) return { index: 0, match: ea }\n  }\n  for (const ea of haystack) {\n    const index = needle.indexOf(ea)\n    if (index >= 0) return { index, match: ea }\n  }\n  const nn = needle.normalize()\n  for (const ea of haystack) {\n    {\n      const index = nn.indexOf(ea)\n      if (index >= 0) return { index, match: ea }\n    }\n    const hn = ea.normalize()\n    {\n      const index = nn.indexOf(hn)\n      if (index >= 0) return { index, match: hn }\n    }\n    {\n      const nl = nn.toLowerCase()\n      const hl = hn.toLowerCase()\n      const index = nl.indexOf(hl)\n      if (index >= 0) return { index, match: hl }\n    }\n  }\n  return\n}\n\n/**\n * Is any item in `haystack` included in `needle`?\n */\nexport function includesIgnoreCase(\n  haystack: string[],\n  needle: string\n): boolean {\n  return isEmpty(haystack) || blank(needle)\n    ? false\n    : haystack.some(ea => equalsIgnoreCase(needle, ea))\n}\n\nexport function reverse(s: string): string {\n  return s == null ? s : [...s].reverse().join(\"\")\n}\n\nexport type Stringable = { valueOf(): string }\n\n/**\n * Return the longest-matching prefix pattern from `patterns` that needle\n * startsWith.\n */\nexport function longestPrefix(\n  needle: string,\n  patterns: string[]\n): Maybe<string> {\n  return greatestBy(\n    patterns.filter(ea => needle.startsWith(ea)),\n    ea => ea.length\n  )\n}\n\n// \\u001b[90m\nexport function stripAnsiEsc(s: string): string {\n  // DON'T REPLACE WITH https://github.com/chalk/ansi-regex/blob/main/index.js :: that shite doesn't work.\n\n  // eslint-disable-next-line no-control-regex\n  return toS(s).replace(/\\u001B\\[[\\d;]+[a-z]/gi, \"\")\n}\n\nconst Smart2Dumb: [RegExp, string][] = [\n  [/[‘’]/g, `'`],\n  [/[“”„«»〃]/g, `\"`]\n]\n\nexport function dumbquote(s: string): string {\n  return Smart2Dumb.reduce(\n    (acc, [smart, dumb]) => acc.replace(smart, dumb),\n    s\n  ).normalize()\n}\n\nconst quoted = /^(['\"]).+\\1$/\n\nexport function stripQuotes(s: string): string {\n  if (blank(s)) return s\n  // Some Vivitar cameras have numeric models (!!) so we need to toS().\n  s = toS(s).trim()\n  if (quoted.exec(dumbquote(s)) != null) {\n    s = s.slice(1, -1).trim()\n  }\n  return s\n}\n\nconst SingleQuoteWrappedRE = /^['‘’].*['‘’]$/\nconst DoubleQuoteWrappedRE = /^[\"“”„«»〃].*[\"“”„«»〃]$/\n\n/**\n * If the string's first and last characters are single or double quotes, and\n * they match, they will be removed from the return value.\n */\nexport function trimQuotes(s: string): string {\n  s = toS(s).trim()\n  return SingleQuoteWrappedRE.test(s) || DoubleQuoteWrappedRE.test(s)\n    ? s.slice(1, -1).trim()\n    : s\n}\n\nexport function wbrPath(s: string): string {\n  return s\n    .split(/(?<=[\\\\/_,:=-])/)\n    .map(ea => he.escape(ea.normalize()) as string)\n    .join(\"<wbr>\")\n}\n\nexport function zipStrings(...arr: string[]): string {\n  let s = \"\"\n  const cb = compactBlanks(arr)\n  const maxLen = Math.max(...cb.map(ea => ea.length))\n  for (let j = 0; j < maxLen; j++) {\n    for (let i = 0; i < cb.length; i++) {\n      map(cb[i], str => map(str[j], ea => (s += ea)))\n    }\n  }\n  return s\n}\n\nexport function splitKeep(s: string, re: RegExp): string[] {\n  const result = splitUp(s, re)\n  return flatZip(result.nonSeparators, result.separators).filter(\n    ea => ea != null && ea.length > 0\n  ) as string[]\n}\n\n/**\n * @return (nonSeparator + separator)*\n */\nexport function splitUp(\n  s: string,\n  re: RegExp\n): { nonSeparators: string[]; separators: string[] } {\n  if (!re.global)\n    throw new Error(\"bad regex (missing global flag)\" + NonRetriableErrorFlag)\n  const nonSeparators: string[] = []\n  const separators: string[] = []\n  let pos = 0\n  let m: RegExpExecArray | null\n  while ((m = re.exec(s)) != null) {\n    // This is necessary to avoid infinite loops with zero-width matches\n    if (m.index === re.lastIndex) {\n      re.lastIndex++\n    } else {\n      re.lastIndex = m[0].length + m.index\n      nonSeparators.push(s.substring(pos, m.index))\n      separators.push(s.substring(m.index, re.lastIndex))\n      pos = re.lastIndex\n    }\n  }\n  if (pos < s.length) {\n    nonSeparators.push(s.substring(pos))\n  }\n  return { nonSeparators, separators }\n}\n\nexport function sortNaturalBy(line: string) {\n  return splitKeep(toS(line), /\\d+(?:\\.\\d+)?/g).map(\n    ea => toFloat(ea.trim()) ?? ea\n  )\n}\n\nexport function sortNatural(lines: string[]): string[] {\n  return sortBy(lines, line => sortNaturalBy(line))\n}\n\nexport function stripDiacritics(s: string): string {\n  // see https://stackoverflow.com/a/37511463/1268016\n  return toS(s)\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\")\n}\n\nexport function stripEmoji(s: string): string {\n  // see https://stackoverflow.com/a/38987183/1268016\n  return toS(s).replace(\n    /\\ud83c[\\udf00-\\udfff]|\\ud83d[\\udc00-\\ude4f]|\\ud83d[\\ude80-\\udeff]/g,\n    \"\"\n  )\n}\n\n/**\n * Remove strings that are prefixes to longer strings in `arr`, ignoring case\n * differences\n * @example ([\"abc\", \"bcd\", \"a\", \"ab\", \"b\"]) -> [\"abc\", \"bcd\"]\n */\nexport function uniqSubstr(arr: string[]): string[] {\n  const rev = sortIgnoreCase(compactBlanks(arr))\n  const result = rev.filter(\n    (ea, idx) => !startsWithIgnoreCase(rev[idx + 1], ea)\n  )\n  return sortBy(result, ea => arr.indexOf(ea))\n}\n\nexport function commonPrefix(a: Maybe<string>, b: Maybe<string>) {\n  if (blank(a) || blank(b)) return \"\"\n  const max = Math.min(a.length, b.length)\n  for (let i = 0; i < max; i++) {\n    if (a[i] !== b[i]) {\n      return a.slice(0, i)\n    }\n  }\n  return a.slice(0, max)\n}\n\nexport function commonPrefixIgnoreCase(\n  a: Maybe<string>,\n  b: Maybe<string>,\n  opts: { normalize?: boolean } = {}\n) {\n  if (blank(a) || blank(b)) return \"\"\n  const max = Math.min(a.length, b.length)\n  for (let i = 0; i < max; i++) {\n    if (!equalsIgnoreCase(a[i], b[i], opts)) {\n      return a.slice(0, i)\n    }\n  }\n  return a.slice(0, max)\n}\n\nexport function commonPrefixLengthIgnoreCase(\n  a: Maybe<string>,\n  b: Maybe<string>,\n  opts: { normalize?: boolean } = {}\n): number {\n  if (blank(a) || blank(b)) return 0\n  const max = Math.min(a.length, b.length)\n  for (let i = 0; i < max; i++) {\n    if (!equalsIgnoreCase(a[i], b[i], opts)) {\n      return i\n    }\n  }\n  return max\n}\n\nexport function indexOfNonSpace(s: string): Maybe<number> {\n  return s.match(/\\S/)?.index\n}\n\nexport function lastIndexOfNonSpace(s: string): Maybe<number> {\n  return s.match(/\\S\\s*$/)?.index\n}\n\nexport function trimLeftPadding(s: string): string {\n  return s.replace(/^[-0_\\s]+/, \"\")\n}\n\n/**\n * Convert \"hello\\040world\" to \"hello world\"\n */\nexport function unoctal(s: string): string {\n  const o = splitUp(s, /\\\\\\d\\d\\d/g)\n\n  return flatZip(\n    o.nonSeparators,\n    o.separators.map(ea =>\n      ea?.length === 4\n        ? mapNumeric(parseInt(ea.slice(1), 8), String.fromCharCode)\n        : undefined\n    )\n  )\n    .map(toS)\n    .join(\"\")\n}\n\nconst CommentRE = /#.*$/gm\n\nexport function stripComments(s: string): string {\n  return s.replace(CommentRE, \"\")\n}\n\nexport function uniqPath(s: MaybeNull<string>[], sep = \":\"): string {\n  // This impl may be easier to follow than 2 compactBlanks() and a uniq()\n  const set = new Set<string>()\n  for (const ea of toA(s)) {\n    if (ea != null && !blank(ea)) {\n      for (const ea2 of ea.split(sep)) {\n        if (!blank(ea2)) set.add(ea2)\n      }\n    }\n  }\n  return [...set].join(sep)\n}\n\n/**\n * First needle wins, all other needles are replaced with `replacement`. Used\n * to make error messages a bit shorter.\n */\nexport function dedupeNeedle(\n  arr: string[],\n  needle: string,\n  replacement: string\n) {\n  if (blank(needle)) return arr\n  const re = new RegExp(\n    // `(?<quot>['\"]?)` + escapeRegExp(needle) + `$<quot>`,\n    `(['\"]?)` + escapeRegExp(needle) + `\\\\1`,\n    \"gm\"\n  )\n  const idx = arr.findIndex(ea => re.test(ea))\n  const dedupeRe = new RegExp(\n    \"(\" + escapeRegExp(replacement) + \"[,:\\\\s]*){2,}\",\n    \"gim\"\n  )\n  if (idx < 0) return arr\n  for (let i = idx + 1; i < arr.length; i++) {\n    arr[i] = arr[i]\n      .replace(re, replacement)\n      .replace(/\\s{2,}/g, \" \")\n      // de-stutter:\n      .replace(dedupeRe, replacement)\n      .trim()\n  }\n  return arr\n}\n\nexport function splitUniq(arr: Maybe<string>[], delim: string): string[] {\n  return uniq(\n    compactBlanks(\n      arr\n        .join(delim)\n        .split(delim)\n        .map(ea => ea.trim())\n    )\n  )\n}\n","import { toS } from \"../fe/toS\"\n\nexport function camel2snake(s: string): string {\n  return toS(s)\n    .replace(/([A-Z])([a-z])/g, (_, a, b) => \"_\" + a.toLowerCase() + b)\n    .replace(/[A-Z]+|\\d+/g, ea => \"_\" + ea)\n    .replace(/^_/, \"\")\n    .replace(/_+/g, \"_\")\n}\n\nexport function camel2words(s: string): string {\n  return toS(s)\n    .replace(/([A-Z])([a-z])/g, (_, a, b) => \" \" + a.toLowerCase() + b)\n    .replace(/[A-Z]+|\\d+/g, ea => \" \" + ea)\n    .trim()\n}\n\nexport function snake2camel(s: string): string {\n  return toS(s).replace(/_([A-Z])/gi, (_, a) => a.toUpperCase())\n}\n\nexport function asObjectKey(s: string) {\n  return snake2camel(\n    s.replace(/^[A-Z]+/, ea => ea.toLowerCase()).replace(/[^a-z]+/gi, \"_\")\n  )\n}\n","import crypto from \"crypto\"\nimport { HashBits } from \"./HashBits\"\nimport { GeoRadix, Radix58 } from \"./math/Radix\"\n\nexport function stringShaToBuffer(input: string, msbits = HashBits): Buffer {\n  return crypto\n    .createHash(\"sha512\")\n    .update(input)\n    .digest()\n    .subarray(0, msbits / 8)\n}\n/**\n * Encoding of the SHA of `input`.\n */\n\nexport function shortStringSha(\n  input: string,\n  len = 9,\n  radix = Radix58,\n  msbits = 224 // < pre-v0.3.5 used 224 bits, so this keeps those SHAs stable\n): string {\n  return radix.encodeBuffer(stringShaToBuffer(input, msbits)).substring(0, len)\n}\n// filesystem-safe short shas\n\nexport function shortFsStringSha(\n  input: string,\n  len = 24,\n  radix = GeoRadix,\n  msbits = 224 // < pre-v0.3.5 used 224 bits, so this keeps those SHAs stable\n): string {\n  return shortStringSha(input, len, radix, msbits)\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { toS } from \"../fe/toS\"\n\nexport function DefaultNormalizer(ea: Maybe<string>): Maybe<string> {\n  return ea == null || ea === \"\" ? undefined : toS(ea).toLowerCase().normalize()\n}\n","import { commonPrefixLength, compactBlanks, count } from \"../fe/Array\"\nimport { sortBy } from \"../fe/ArraySort\"\nimport { blank } from \"../fe/Blank\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { clamp, mapNumericOr, times, toInt } from \"../fe/Number\"\nimport { leftPad } from \"../fe/Pad\"\nimport { Primitive } from \"../fe/Primitive\"\nimport { strslice, substr } from \"../fe/String\"\nimport { toS } from \"../fe/toS\"\nimport { RadixAlphaNum } from \"./math/Radix\"\nimport { Array2D } from \"./Number\"\nimport { firstThunk } from \"./Object\"\nimport { intersection } from \"./Set\"\nimport { stripDiacritics } from \"./String\"\n\n/**\n * @return [0,1], where 0 means no common string, and 1 is equality\n */\nexport function commonSubstringRatio(a: string, b: string): number {\n  return [a, b].some(blank)\n    ? 0\n    : lcs(a, b).length / Math.max(a.length, b.length)\n}\n\n/**\n * @see https://en.wikipedia.org/wiki/Longest_common_substring_problem\n */\nexport function lcs(a: string, b: string): string {\n  if (a == null) return b\n  if (b == null) return a\n  a = a.normalize()\n  b = b.normalize()\n  if (a === b || b.includes(a)) return a\n  if (a.includes(b)) return b\n  const m = new Array2D(a.length)\n  let z = 0\n  let ret = \"\"\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i] === b[j]) {\n        if (i === 0 || j === 0) {\n          m.set(i, j, 1)\n        } else {\n          m.set(i, j, m.get(i - 1, j - 1) + 1)\n        }\n        if (m.get(i, j) >= z) {\n          z = m.get(i, j)\n          ret = substr(a, i - z + 1, z)\n        }\n      }\n    }\n  }\n  return ret\n}\n\n/**\n * Hamming distance. Note that `a` and `b` (before or after normalization) must\n * be the same length, or `undefined` will be returned.\n *\n * Note that this is case-sensitive!\n *\n * @see https://en.wikipedia.org/wiki/Hamming_distance\n */\nexport function hamming(a: string, b: string): Maybe<number> {\n  if (a == null || b == null) return undefined\n  if (a === b) return 0\n  const r = _hamming(a, b)\n  if (r != null) return r\n  const an = a.normalize()\n  const bn = b.normalize()\n  return a !== an || b !== bn ? _hamming(an, bn) : undefined\n}\n\nfunction _hamming(a: string, b: string): Maybe<number> {\n  return a.length !== b.length\n    ? undefined\n    : [...a].reduce((acc, ea, idx) => (ea === b.charAt(idx) ? acc : acc + 1), 0)\n}\n\n/**\n * Return the Sørensen–Dice similarity index between two strings.\n * @see https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient\n * @return [0,1]. O for no match, 1 for full, case-insensitive match.\n */\nexport function diceCoeff(a: string, b: string): number {\n  const A = a.toUpperCase().normalize()\n  const B = b.toUpperCase().normalize()\n  return firstThunk<number>(\n    () => (A === B ? 1 : undefined),\n    () => (blank(a) !== blank(b) ? 0 : undefined),\n    () => (a.length === 1 && b.length === 1 ? 0 : undefined),\n    () => {\n      const aGrams = bigrams(A)\n      const bGrams = bigrams(B)\n      const intersections = nonUniqIntersection(aGrams, bGrams).length\n      return (2 * intersections) / (aGrams.length + bGrams.length)\n    }\n  )!\n}\n\n/**\n * Convert \"abcd\" to [\"ab\", \"bc\", \"cd\"]\n */\nexport function bigrams(s: string): string[] {\n  if (s == null || s.length === 0) return []\n  const arr = [...s]\n  return arr.slice(0, -1).map((ea, i) => ea + arr[i + 1])\n}\n\nexport function nonUniqIntersection<T extends Primitive>(a: T[], b: T[]): T[] {\n  const uniqIntersections = intersection(a, b)\n  const i: T[] = []\n  uniqIntersections.forEach(ea => {\n    const n = Math.min(\n      count(a, s => s === ea),\n      count(b, s => s === ea)\n    )\n    times(n, () => i.push(ea))\n  })\n  return i\n}\n\n/**\n * Tries to prevent numeric overflow:\n */\nfunction diffWithoutCommonPrefix(\n  a: string,\n  b: string,\n  f: (s: string) => number\n): number {\n  const cpc = commonPrefixLength(a, b)\n  return f(strslice(a, cpc)) - f(strslice(b, cpc))\n}\n\n/**\n * Return the value of the longest string of digits in `s`\n */\nfunction longestNumericString(s: string): Maybe<string> {\n  const digits = compactBlanks(toS(s).split(/\\D+/))\n  return sortBy(digits, ea => -ea.length)[0]\n}\n\nexport function lnsDiff(a: string, b: string): number {\n  const [a1, b1] = [a, b]\n    .map(longestNumericString)\n    .map(ea => (blank(ea) ? \"\" : ea))\n  return diffWithoutCommonPrefix(a1, b1, s => toInt(s, { defaultValue: 0 })!)\n}\n\nconst notAlphaNumRe = /[^\\da-z]+/gi\nexport function radixDiff(a: string, b: string): number {\n  const [a1, b1] = [a, b].map(s =>\n    stripDiacritics(s).replace(notAlphaNumRe, \"\").toLowerCase()\n  )\n  return diffWithoutCommonPrefix(a1, b1, s => RadixAlphaNum.decode(s)!)\n}\n\nexport function str(a: string, b: string) {\n  return {\n    pref: commonPrefixLength(a, b),\n    ham: hamming(a, b),\n    dice: diceCoeff(a, b),\n    lns: lnsDiff(a, b),\n    radixDiff: radixDiff(a, b)\n  }\n}\n\n/**\n * @return the number of non-lower-case characters in `s`\n */\nexport function lcdiff(s: string): number {\n  return count(\n    [...s.normalize()],\n    ea => ea.toLowerCase().localeCompare(ea) !== 0\n  )\n}\n\n/**\n * @return the weighted average of the character differences per character index\n */\nexport function positionalDiff(a: string, b: string) {\n  let result: Maybe<number>\n  for (let i = Math.max(a.length, b.length); i >= 0; i--) {\n    const aChar = mapNumericOr(a.charCodeAt(i), ea => ea, 256)\n    const bChar = mapNumericOr(b.charCodeAt(i), ea => ea, 256)\n    const diff = clamp(-256, 256, aChar - bChar)\n    if (result == null) result = diff\n    else result = (result + diff) / 2\n  }\n  return result\n}\n\nexport function paddedPositionalDiff(a: string, b: string, minLen = 8) {\n  return positionalDiff(leftPad(a, minLen, \" \"), leftPad(b, minLen, \" \"))\n}\n","import { stringify } from \"../fe/JSON\"\nimport { sortedKeys } from \"./Object\"\n\n/**\n * Returns JSON.stringify with keys in sorted order (if `o` is a Record)\n */\nexport function stringifySorted(o: any): string {\n  return stringify(sortedKeys(o))\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { times } from \"../fe/Number\"\n\nexport class TTLArray<T> implements Iterable<T> {\n  private readonly times: number[] = []\n  private readonly a: T[] = []\n  private readonly expirationListeners: (() => void)[] = []\n  constructor(\n    readonly ttlMs: number,\n    readonly maxLength?: number\n  ) {}\n\n  [Symbol.iterator](): Iterator<T, any, undefined> {\n    this.vacuum()\n    const arr = [...this.a]\n    function* iter(): IterableIterator<T> {\n      for (const k of arr) {\n        yield k\n      }\n    }\n    return iter()\n  }\n\n  push(...t: T[]) {\n    times(t.length, () => this.times.push(Date.now()))\n    this.a.push(...t)\n    if (this.maxLength != null) this.vacuum()\n  }\n\n  pushUniq(...t: T[]) {\n    t.forEach(ea => {\n      if (!this.includes(ea)) this.push(ea)\n    })\n  }\n\n  includes(t: T) {\n    this.vacuum()\n    return this.a.indexOf(t) >= 0\n  }\n\n  find(predicate: (value: T, index: number) => boolean): T | undefined {\n    this.vacuum()\n    return this.a.find(predicate)\n  }\n\n  some(predicate: (value: T, index: number) => boolean): boolean {\n    this.vacuum()\n    return this.a.some(predicate)\n  }\n\n  shift() {\n    this.vacuum()\n    this.times.shift()\n    return this.a.shift()\n  }\n\n  first() {\n    this.vacuum()\n    return this.a[0]\n  }\n\n  last() {\n    this.vacuum()\n    return this.a[this.a.length - 1]\n  }\n\n  shiftOrFirst() {\n    return this.length > 1 ? this.shift() : this.first()\n  }\n\n  pop() {\n    this.vacuum()\n    this.times.pop()\n    return this.a.pop()\n  }\n\n  onExpire(listener: () => any) {\n    this.expirationListeners.push(listener)\n  }\n\n  /**\n   * Returns a copy of a section of an array.\n   * For both start and end, a negative index can be used to indicate an offset from the end of the array.\n   * For example, -2 refers to the second to last element of the array.\n   * @param start The beginning index of the specified portion of the array.\n   * If start is undefined, then the slice begins at index 0.\n   * @param end The end index of the specified portion of the array. This is exclusive of the element at the index 'end'.\n   * If end is undefined, then the slice extends to the end of the array.\n   */\n  slice(start?: number, end?: number): T[] {\n    this.vacuum()\n    return this.a.slice(start, end)\n  }\n\n  get length(): number {\n    this.vacuum()\n    return this.a.length\n  }\n\n  clear(): this {\n    this.times.length = 0\n    this.a.length = 0\n    return this\n  }\n\n  get values(): T[] {\n    this.vacuum()\n    return [...this.a]\n  }\n\n  map<U>(callbackfn: (value: T, index: number, array: T[]) => U) {\n    this.vacuum()\n    return this.a.map(callbackfn)\n  }\n\n  oldestEntryAge(): Maybe<number> {\n    this.vacuum()\n    return this.times[0]\n  }\n\n  /**\n   * Remove all expired entries\n   */\n  private vacuum() {\n    if (this.a.length === 0) return\n    const priorLength = this.a.length\n    if (this.maxLength != null) {\n      const deleteCount = this.a.length - this.maxLength\n      this.times.splice(0, deleteCount)\n      this.a.splice(0, deleteCount)\n    }\n    const minTime = Date.now() - this.ttlMs\n    const firstGoodIndex = this.times.findIndex(ea => ea > minTime)\n    if (firstGoodIndex === -1) {\n      this.clear()\n    } else if (firstGoodIndex > 0) {\n      this.times.splice(0, firstGoodIndex)\n      this.a.splice(0, firstGoodIndex)\n    }\n    if (priorLength !== this.a.length) {\n      for (const ea of this.expirationListeners) {\n        ea()\n      }\n    }\n  }\n}\n","import { sortBy } from \"../fe/ArraySort\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { Primitive } from \"../fe/Primitive\"\nimport { setUnrefInterval } from \"./async/Timers\"\n\nexport class TTLMap<K extends Primitive, V> implements Map<K, V> {\n  readonly [Symbol.toStringTag] = \"TTLMap\"\n\n  readonly #expireListeners: ((k: K, v: V) => void)[] = []\n\n  // Maps entries to insertion time values. Entries should expire after ttlMs.\n  readonly #delegate = new Map<K, { ts: number; v: V }>()\n\n  #ttlMs!: number\n  #interval!: NodeJS.Timeout\n\n  constructor(ttlMs: number) {\n    this.ttlMs = ttlMs\n  }\n\n  get ttlMs() {\n    return this.#ttlMs\n  }\n\n  set ttlMs(ms: number) {\n    this.#ttlMs = ms\n    if (this.#interval != null) {\n      clearInterval(this.#interval)\n    }\n    this.#interval = setUnrefInterval(() => this.#vacuum(), ms)\n    this.#vacuum()\n  }\n\n  clear(): this {\n    this.#delegate.clear()\n    return this\n  }\n\n  delete(key: K): boolean {\n    return this.#delegate.delete(key)\n  }\n\n  deleteAll(keys: K[]) {\n    for (const ea of keys) {\n      this.delete(ea)\n    }\n  }\n\n  forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void): void {\n    for (const [k, v] of this.#delegate.entries()) {\n      if (this.#chkEntry(k, v)) {\n        callbackfn(v.v, k, this)\n      }\n    }\n  }\n\n  get(key: K): V | undefined {\n    const v = this.#delegate.get(key)\n    if (this.#chkEntry(key, v)) {\n      v.ts = Date.now()\n      return v.v\n    } else {\n      return\n    }\n  }\n\n  getOrMaybeSet(key: K, valueThunk: () => Maybe<V>): Maybe<V> {\n    const v = this.#delegate.get(key)\n    if (this.#chkEntry(key, v)) return v.v\n    const value = valueThunk()\n    if (value != null) this.set(key, value)\n    return value\n  }\n\n  /**\n   * Get the timestamp of the last set() or get() for the given key.\n   */\n  lastSetOrGetTs(key: K) {\n    // NOTE: don't use this.get() here: that'd update the timestamp to now!\n    return this.#delegate.get(key)?.ts\n  }\n\n  set(key: K, value: V): this {\n    this.#delegate.set(key, { ts: Date.now(), v: value })\n    return this\n  }\n\n  has(key: K): boolean {\n    return this.#chkEntry(key, this.#delegate.get(key))\n  }\n\n  get size() {\n    this.#vacuum()\n    return this.#delegate.size\n  }\n\n  keys(): IterableIterator<K> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<K> {\n      for (const [k, v] of self.#delegate.entries()) {\n        if (self.#chkEntry(k, v)) {\n          yield k\n        }\n      }\n    }\n    return iter()\n  }\n\n  values(): IterableIterator<V> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<V> {\n      for (const [k, v] of self.#delegate.entries()) {\n        if (self.#chkEntry(k, v)) {\n          yield v.v\n        }\n      }\n    }\n    return iter()\n  }\n\n  valuesByRecency() {\n    this.#vacuum()\n    return sortBy(this.#delegate.values(), ea => -ea.ts)\n  }\n\n  entries(): IterableIterator<[K, V]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<[K, V]> {\n      for (const [k, v] of self.#delegate.entries()) {\n        if (self.#chkEntry(k, v)) {\n          yield [k, v.v]\n        }\n      }\n    }\n    return iter()\n  }\n\n  [Symbol.iterator](): IterableIterator<[K, V]> {\n    return this.entries()\n  }\n\n  on(_event: \"expire\", listener: (k: K, v: V) => void) {\n    this.#expireListeners.push(listener)\n  }\n\n  #chkEntry(\n    key: K,\n    value: Maybe<{ v: V; ts: number }>\n  ): value is { v: V; ts: number } {\n    if (value == null) {\n      return false\n    } else if (value.ts + this.ttlMs > Date.now()) {\n      return true\n    } else {\n      this.#delegate.delete(key)\n      for (const ea of this.#expireListeners) {\n        ea(key, value.v)\n      }\n      return false\n    }\n  }\n\n  /**\n   * remove all expired entries\n   */\n  #vacuum() {\n    for (const [k, v] of this.#delegate.entries()) {\n      this.#chkEntry(k, v)\n    }\n  }\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { setUnrefTimeout } from \"./async/Timers\"\n\nexport class TTLSet<T> implements Set<T> {\n  readonly [Symbol.toStringTag] = \"TTLSet\"\n  private readonly expireListeners: ((k: T) => void)[] = []\n\n  // Maps entries to insertion time values. Entries should expire after value + this.ttlMs.\n  private readonly delegate = new Map<T, number>()\n\n  /**\n   * @param ttlMs if external consumers change this public value, we won't\n   * auto-re-vacuum existing values, but the new ttl will be correct for new\n   * values.\n   */\n  constructor(\n    public ttlMs: number,\n    readonly scheduleExpirationTimers = false\n  ) {}\n\n  get size(): number {\n    this.#vacuum()\n    return this.delegate.size\n  }\n\n  add(value: T): this {\n    this.delegate.set(value, Date.now())\n    if (this.scheduleExpirationTimers)\n      setUnrefTimeout(() => this.#vacuum(), this.ttlMs + 1)\n    return this\n  }\n\n  addAll(values: T[]) {\n    for (const ea of values) {\n      this.add(ea)\n    }\n    return\n  }\n\n  addIfMissing<R>(value: T, onMissing: () => R): Maybe<R> {\n    const prior = this.delegate.get(value)\n    if (prior == null || this.#isEntryExpired(value, prior)) {\n      this.add(value)\n      return onMissing()\n    } else {\n      return\n    }\n  }\n\n  clear(): this {\n    this.delegate.clear()\n    return this\n  }\n\n  delete(value: T): boolean {\n    return this.delegate.delete(value)\n  }\n\n  forEach(callbackfn: (value: T, index: T, set: Set<T>) => void): void {\n    for (const [value, ctime] of this.delegate) {\n      if (!this.#isEntryExpired(value, ctime)) {\n        callbackfn(value, value, this)\n      }\n    }\n  }\n\n  has(value: Maybe<T>): boolean {\n    return value != null && !this.#isEntryExpired(value)\n  }\n\n  values(): IterableIterator<T> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<T> {\n      for (const [k, v] of self.delegate) {\n        if (!self.#isEntryExpired(k, v)) {\n          yield k\n        }\n      }\n    }\n    return iter()\n  }\n\n  readonly keys = this.values.bind(this)\n\n  entries(): IterableIterator<[T, T]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<[T, T]> {\n      for (const [k, v] of self.delegate) {\n        if (!self.#isEntryExpired(k, v)) {\n          yield [k, k]\n        }\n      }\n    }\n    return iter()\n  }\n\n  toA(): T[] {\n    this.#vacuum()\n    return [...this.delegate.keys()]\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values()\n  }\n\n  on(_event: \"expire\", listener: (k: T) => void) {\n    this.expireListeners.push(listener)\n  }\n\n  /**\n   * @param ctime is the last-set time associated to the key.\n   */\n  #isEntryExpired(key: T, ctime?: number): boolean {\n    ctime ??= this.delegate.get(key)\n    if (ctime == null || !this.delegate.has(key)) return true\n\n    const expired = ctime <= Date.now() - this.ttlMs\n    if (expired) {\n      // delete the key before we tell the listerners\n      this.delegate.delete(key)\n      for (const ea of this.expireListeners) {\n        ea(key)\n      }\n    }\n    return expired\n  }\n\n  /**\n   * remove all expired entries\n   */\n  #vacuum() {\n    for (const [k, v] of this.delegate) {\n      this.#isEntryExpired(k, v)\n    }\n  }\n}\n","export const TestLibraryDirPrefix = \"test-ps-lib-\"\n","import { lazy } from \"../core/Lazy\"\nimport { sortBy } from \"../fe/ArraySort\"\nimport { blank } from \"../fe/Blank\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { toS } from \"../fe/toS\"\nimport { isTest } from \"./NodeEnv\"\nimport { GeoRadix } from \"./math/Radix\"\n\nlet lastTime = 0\n\nconst UidRadix = GeoRadix\n\n// only exposed for tests:\nexport const uidSuffix = lazy(() => \"-\" + UidRadix.randomChars(7))\n\n/**\n * Generate a unique ID with filesystem safe characters that sorts\n * chronologically. This is required by FsLock to ensure older locks are\n * acquired before newer locks.\n */\nexport function uid() {\n  // No need to pad the date:\n\n  // > GeoRadix.encode(new Date(\"2019-12-31\").getTime())\n  // '1exdn1300'\n  // > GeoRadix.encode(new Date(\"2064-12-31\").getTime()) <- MTBMF Mean Time Before Matt Failure\n  // '2r80m3600'\n\n  lastTime = Math.max(Date.now(), lastTime + 1)\n  return uidForTs(lastTime)\n}\n\nexport function uidForTs(ts: number): string {\n  return UidRadix.encode(ts) + uidSuffix()\n}\n\nconst uidRe = /^[\\da-z]{9}-[\\da-z]{7}$/i\n\nexport function isUID(s: Maybe<string>): boolean {\n  return uidRe.test(toS(s))\n}\n\nexport function tsFromUid(s: Maybe<string>): Maybe<number> {\n  const ts = toS(s).replace(/(?<=\\S)-.*/, \"\")\n  return blank(ts) ? undefined : UidRadix.decode(ts)\n}\n\nexport function sortByUid<T extends { uid: string }>(arr: T[]) {\n  return sortBy(arr, ea => tsFromUid(ea.uid))\n}\n\nexport function resetUid() {\n  if (isTest) {\n    uidSuffix.unset()\n    lastTime = 0\n  } else {\n    throw new Error(\"unsupported\")\n  }\n}\n","import os from \"node:os\"\nimport process from \"node:process\"\nimport { lazy } from \"../core/Lazy\"\nimport { uniq } from \"../fe/Array\"\nimport { blank, toNotBlank } from \"../fe/Blank\"\nimport { toBoolean } from \"../fe/Boolean\"\nimport { PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { gte0 } from \"../fe/Number\"\nimport { mkLogger } from \"./Logger\"\nimport { ShortCommandTimeoutMs } from \"./ShortCommandTimeoutMs\"\nimport { stdout_ } from \"./child/ChildProcess\"\nimport { getEnv } from \"./env/GetEnv\"\nimport { isWin } from \"./platform/Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\n\nconst logger = lazy(() => mkLogger(\"UserInfo\"))\n\nexport async function userDesc() {\n  let result = \"user \" + (await username())\n  if (gte0(userid())) {\n    result += \" (userid \" + userid() + \")\"\n  }\n  return result\n}\n\nexport const userids = lazy<number[]>(() =>\n  // we prefer the effective id, but use getgid and userInfo to backfill.\n  // uniq also compacts\n  uniq([process.geteuid?.(), process.getuid?.(), os.userInfo().uid])\n)\n\nexport const userid = lazy<number>(() => userids()[0])\n\nexport const groupids = lazy<number[]>(() =>\n  // we prefer the effective id, but use getgid and userInfo to backfill:\n  uniq([process.getegid?.(), process.getgid?.(), os.userInfo().gid])\n)\n\nexport const groupid = lazy<number>(() => groupids()[0])\n\nexport const usernameFromEnv = lazy(() => {\n  for (const ea of [\n    // https://github.com/sindresorhus/username/blob/f4a47485fcdf3bafee221cf5e6d6180344020d08/index.js#L9\n    \"SUDO_USER\",\n    \"C9_USER\", // Cloud9\n    \"LOGNAME\",\n    \"USER\",\n    \"LNAME\",\n    \"USERNAME\" // windows calls this UserName, so we're using getEnv() (which is case-insensitive)\n  ]) {\n    const v = getEnv(ea as any)\n    if (!blank(v)) return v\n  }\n  return\n})\n\nexport const usernameFromUserInfo = lazy(() =>\n  toNotBlank(os.userInfo()?.username)\n)\n\nexport const userNameFromWhoami = lazy(async () =>\n  stdout_(\"whoami\", [], {\n    ignoreExitCode: true,\n    timeoutMs: ShortCommandTimeoutMs,\n    isIgnorableError: () => true\n  })\n    .then(toNotBlank)\n    .catch(error => logger().warn(\"$(whoami) failed\", { error }))\n)\n\nexport const userNameFromWindowsAccessToken = lazy(async () =>\n  !isWin\n    ? undefined\n    : PowerShell.instance().execute(\n        // https://stackoverflow.com/a/29955210\n        \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\",\n        toNotBlank\n      )\n)\n\nexport const username = lazy<PromiseMaybe<string>>(\n  async () =>\n    usernameFromEnv() ??\n    usernameFromUserInfo() ??\n    (await userNameFromWhoami()) ??\n    (await userNameFromWindowsAccessToken())\n)\n\nfunction pwshIsAdmin() {\n  return isWin\n    ? PowerShell.instance().execute(\n        // https://serverfault.com/a/95464\n        \"(New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\",\n        toBoolean\n      )\n    : undefined\n}\n\nexport const isRootUser = lazy<PromiseMaybe<boolean>>(async () =>\n  isWin ? pwshIsAdmin() : userids().includes(0)\n)\n","export const version = \"2023.11.0-alpha.1\";\nexport const versionMajor = 2023;\nexport const versionMinor = 11;\nexport const versionPatch = 0;\nexport const versionPrerelease = [\"alpha\",1];\nexport const release = \"2023.11.0-alpha.1+20231107131203\";\nexport const gitSha = \"9b2c00b1e0ce2ea9685b10dde99ce4a0c430b719\";\nexport const gitDate = new Date(1699391523000);\nexport default {version,versionMajor,versionMinor,versionPatch,versionPrerelease,release,gitSha,gitDate};\n","import { Maybe } from \"../fe/MaybeTypes\"\nimport { Primitive } from \"../fe/Primitive\"\n\nexport class WeakCache<K extends Primitive, V extends object>\n  implements Map<K, V>\n{\n  readonly [Symbol.toStringTag] = \"WeakCache\"\n\n  // Maps entries to insertion time values. Entries should expire after ttlMs.\n  readonly #delegate = new Map<K, WeakRef<V>>()\n\n  clear(): this {\n    this.#delegate.clear()\n    return this\n  }\n\n  delete(key: K): boolean {\n    return this.#delegate.delete(key)\n  }\n\n  deleteAll(keys: K[]) {\n    for (const ea of keys) {\n      this.delete(ea)\n    }\n  }\n\n  forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void): void {\n    for (const [k, v] of this.entries()) {\n      callbackfn(v, k, this)\n    }\n  }\n\n  findEntry(\n    callbackfn: (value: V, key: K, map: Map<K, V>) => boolean\n  ): Maybe<V> {\n    for (const [k, v] of this.entries()) {\n      if (callbackfn(v, k, this)) {\n        return v\n      }\n    }\n    return\n  }\n\n  deleteValueIf(predicate: (value: V, key: K, map: Map<K, V>) => boolean) {\n    for (const [k, v] of this.entries()) {\n      if (predicate(v, k, this)) {\n        this.#delegate.delete(k)\n      }\n    }\n  }\n\n  get(key: K): V | undefined {\n    const w = this.#delegate.get(key)\n    const v = w?.deref()\n    if (v == null && w != null) {\n      this.#delegate.delete(key)\n    }\n    return v\n  }\n\n  getOrMaybeSet(key: K, valueThunk: () => Maybe<V>): Maybe<V> {\n    const v = this.#delegate.get(key)?.deref()\n    if (v != null) return v\n    const value = valueThunk()\n    if (value != null) this.set(key, value)\n    return value\n  }\n\n  set(key: K, value: V): this {\n    this.#delegate.set(key, new WeakRef(value))\n    return this\n  }\n\n  has(key: K): boolean {\n    return this.#delegate.get(key)?.deref() != null\n  }\n\n  get size() {\n    this.#vacuum()\n    return this.#delegate.size\n  }\n\n  keys(): IterableIterator<K> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<K> {\n      for (const [k, w] of self.#delegate.entries()) {\n        if (w.deref() == null) {\n          self.#delegate.delete(k)\n        } else {\n          yield k\n        }\n      }\n    }\n    return iter()\n  }\n\n  values(): IterableIterator<V> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<V> {\n      for (const [k, w] of self.#delegate.entries()) {\n        const v = w.deref()\n        if (v == null) {\n          self.#delegate.delete(k)\n        } else {\n          yield v\n        }\n      }\n    }\n    return iter()\n  }\n\n  entries(): IterableIterator<[K, V]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<[K, V]> {\n      for (const [k, w] of self.#delegate.entries()) {\n        const v = w.deref()\n        if (v == null) {\n          self.#delegate.delete(k)\n        } else {\n          yield [k, v]\n        }\n      }\n    }\n    return iter()\n  }\n\n  [Symbol.iterator](): IterableIterator<[K, V]> {\n    return this.entries()\n  }\n\n  /**\n   * remove all expired entries\n   */\n  #vacuum() {\n    for (const [k, v] of this.#delegate.entries()) {\n      if (v.deref() == null) this.#delegate.delete(k)\n    }\n  }\n}\n","import { dayMs, minuteMs } from \"../fe/Date\"\nimport { allDefined } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { toInt } from \"../fe/Number\"\nimport { opt } from \"../fe/Opt\"\nimport { within } from \"./Number\"\n\nconst wmi =\n  /((?:19|20)\\d\\d)([01]\\d)([0-3]\\d)([012]\\d)([0-5]\\d)([0-5]\\d)\\.(\\d{6})([+-]\\d{3})?/\n/**\n * yyyymmddHHMMSS.mmmmmmsUUU or 20190415124112.947119-420\n *\n * @see https://msdn.microsoft.com/en-us/library/aa387237(v=vs.85).aspx\n */\nexport function wmiDate(s: string): Maybe<Date> {\n  const m = wmi.exec(s)\n  if (m == null) return\n  const arr = m.slice(1, 8).map(ea => toInt(ea))\n  if (!allDefined(arr)) return undefined\n  const [year, mon, day, hour, min, sec, micros] = arr as number[]\n  const offset = toInt(m[8], { defaultValue: 0 })!\n\n  // console.dir({ s, m, year, mon, day, hour, min, sec, micros, offset })\n  return new Date(\n    Date.UTC(year, mon - 1, day, hour, min, sec, micros / 1000) -\n      offset * minuteMs\n  )\n}\n\nconst WinDateRe = /Date\\((\\d+)\\)/\n\n/**\n * PowerShell renders Dates in JSON structures as \"/Date(1552014999676)/\"\n */\nexport function pwshJsonDate(s: string): Maybe<Date> {\n  return opt(s)\n    .flatMap(ea => WinDateRe.exec(ea))\n    .flatMap(ea => ea[1])\n    .flatMap(toInt)\n    .filter(ea => within(0, Date.now() + dayMs, ea))\n    .map(ea => new Date(ea))\n    .get()\n}\n","import { toA } from \"../../fe/toA\"\nimport { clusterEvery, clusterSome } from \"../Array\"\nimport { AggregateTypes } from \"../settings/AggregateTypes\"\nimport { Settings } from \"../settings/Settings\"\nimport { isSimilarAssetFile } from \"./AssetFileComparator\"\nimport { sortAssetFiles } from \"./AssetFileSorter\"\nimport { IAssetFile } from \"./IAssetFile\"\n\nexport async function aggregateAssetFiles<T extends IAssetFile>(\n  arr: T[]\n): Promise<T[][]> {\n  // clustering may not be deterministic if we don't sort beforehand.\n  const sorted = toA(sortAssetFiles(arr) ?? arr)\n  const some = Settings.assetAggregation.valueOrDefault === AggregateTypes.union\n  return (some ? clusterSome : clusterEvery)(sorted, isSimilarAssetFile)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { compact, isNotEmpty } from \"../../fe/Array\"\nimport { blank, mapNotBlank } from \"../../fe/Blank\"\nimport { eql } from \"../../fe/Eql\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt, sigFigs } from \"../../fe/Number\"\nimport { allKeysDefined, keys, values } from \"../../fe/Object\"\nimport { fmt } from \"../../fe/Units\"\nimport { definedAndEql } from \"../Eql\"\nimport { geohashDistanceMeters } from \"../GeoHash\"\nimport { mkLogger } from \"../Logger\"\nimport { validRotations } from \"../img/Dimensions\"\nimport { toImageHash } from \"../img/ImageHash\"\nimport {\n  compareImageHashes,\n  isSimilarImageHash\n} from \"../img/ImageHashComparison\"\nimport { Settings } from \"../settings/Settings\"\nimport { CapturedAt } from \"../tags/CapturedAt\"\nimport {\n  findInequalFields,\n  whyExposureSettingsNotSimilar\n} from \"../tags/ExifUid\"\nimport { isVideoMimeType } from \"../tags/MimeTypes\"\nimport { IAssetFile } from \"./IAssetFile\"\n\nconst logger = lazy(() => mkLogger(\"sync-file.AssetFileComparator\"))\n\nfunction whyInequal(\n  af1: IAssetFile,\n  af2: IAssetFile,\n  field: keyof IAssetFile,\n  normalizer: (a: any, b: any) => [any, any] = (a, b) => [a, b]\n): Maybe<string> {\n  const a = af1[field]\n  const b = af2[field]\n  if (blank(a) || blank(b) || eql(a, b)) return\n  const [an, bn] = normalizer(a, b)\n  return eql(an, bn) || eql(a, bn) || eql(an, b)\n    ? undefined\n    : `Different ${String(field)}: ${a} ≠ ${b}`\n}\n\nfunction lc(s: any) {\n  return mapNotBlank(s, ea => ea.toLowerCase().trim().normalize())\n}\n\nfunction lc2(a: any, b: any) {\n  return [lc(a), lc(b)] as [any, any]\n}\n\nexport const VideoImageMismatchMsg = \"Videos ≠ images\"\n\nfunction whyExifUidNotEql(\n  af1: IAssetFile,\n  af2: IAssetFile,\n  field: \"cameraId\" | \"lensId\" | \"imageId\"\n) {\n  const ne = findInequalFields(af1[field], af2[field])\n  return ne == null\n    ? undefined\n    : `Different ${field} (${ne.aKey}:${ne.aValue} ≠ ${ne.aKey}:${ne.aValue})`\n}\n\nexport function whyNotSameAsset(\n  needle: Maybe<IAssetFile>,\n  haystack: Maybe<IAssetFile>,\n  siblings: IAssetFile[]\n) {\n  {\n    const why = whyNotSimilarAssetFile(needle, haystack)\n    if (why != null) return why\n  }\n  if (Settings.assetAggregation.valueOrDefault === \"intersection\") {\n    for (const sib of siblings) {\n      // don't test again:\n      if (sib.id !== haystack?.id) {\n        const why = whyNotSimilarAssetFile(needle, sib)\n        if (why != null) return why\n      }\n    }\n  }\n  return\n}\n\nexport function isSimilarAssetFile(\n  af1: Maybe<IAssetFile>,\n  af2: Maybe<IAssetFile>\n): boolean {\n  return whyNotSimilarAssetFile(af1, af2) == null\n}\n\n/**\n * Only compares these specific AssetFiles. You probably want whyNotSameAsset.\n */\nexport function whyNotSimilarAssetFile(\n  af1: Maybe<IAssetFile>,\n  af2: Maybe<IAssetFile>\n): Maybe<string> {\n  if (!allKeysDefined(af1, \"width\", \"height\", \"mimetype\", \"sha\")) {\n    return \"af1 was missing required fields\"\n  }\n  if (!allKeysDefined(af2, \"width\", \"height\", \"mimetype\", \"sha\")) {\n    return \"af2 was missing required fields\"\n  }\n\n  if (definedAndEql(af1.sha, af2.sha)) {\n    logger().debug(\"matching SHA\", { af1, af2 })\n    // Same SHA is always the same asset\n    return\n  }\n\n  // TODO: Live Photos support will need to revisit this!\n  const af1IsVideo = isVideoMimeType(af1.mimetype)\n  const af2IsVideo = isVideoMimeType(af2.mimetype)\n\n  if (af1IsVideo !== af2IsVideo) {\n    return logger().tap({\n      msg: \"whyNotIsSimilar\",\n      result: VideoImageMismatchMsg,\n      meta: {\n        af1: af1.uri,\n        af2: af2.uri,\n        af1IsVideo,\n        af2IsVideo\n      }\n    })\n  }\n\n  const af1ca = CapturedAt.fromAssetFile(af1)\n  const af2ca = CapturedAt.fromAssetFile(af2)\n  if (af1ca == null) return \"af1 missing capturedAt metadata\"\n  if (af2ca == null) return \"af2 missing capturedAt metadata\"\n\n  const capturedAtIsFuzzy = af1ca.isFuzzy || af2ca.isFuzzy\n\n  if (\n    capturedAtIsFuzzy &&\n    Settings.allowFuzzyDateImageHashMatches.valueOrDefault\n  ) {\n    const ih1 = toImageHash(af1 as any)\n    const ih2 = toImageHash(af2 as any)\n    if (\n      // allow image hashes to be _pretty_ close\n      isSimilarImageHash(ih1, ih2, {\n        rotationsToCheck: validRotations(af1, af2)\n      })\n    ) {\n      logger().info(\"allowFuzzyDateImageHashMatches mode: image hashes match\", {\n        af1,\n        af2\n      })\n      return\n    }\n  }\n\n  if (!af1ca.overlaps(af2ca)) {\n    return `captured-at ${af1ca.toISOStringWithPrecision()} != ${af2ca.toISOStringWithPrecision()}`\n  }\n\n  // If any of these *don't* match, we're definitely a different photo. Order\n  // doesn't really matter.\n  const fieldDiff =\n    whyInequal(af1, af2, \"make\", lc2) ?? whyInequal(af1, af2, \"model\", lc2)\n  // DON'T CHECK FOR GEOHASH HERE! it might be a bit different!\n\n  if (fieldDiff != null) return fieldDiff\n\n  const dist = map(geohashDistanceMeters(af1.geohash, af2.geohash), ea =>\n    sigFigs(ea, 2)\n  )\n  const fields = {\n    cameraId: whyExifUidNotEql(af1, af2, \"cameraId\") ?? null,\n    imageId: whyExifUidNotEql(af1, af2, \"imageId\") ?? null,\n    lensId: whyExifUidNotEql(af1, af2, \"lensId\") ?? null,\n    exposureSettings: whyExposureSettingsNotSimilar(af1, af2) ?? null,\n    closeGeoHash: gt(dist, Settings.gpsErrorMeters.valueOrDefault)\n      ? \"geohashes are \" + fmt(dist!) + \"m different: too far apart\"\n      : null\n  }\n\n  logger().debug(\"whyNotSimilar()\", { fields })\n\n  const mismatched = compact(values(fields))\n  if (isNotEmpty(mismatched)) {\n    return mismatched.join(\";\")\n  }\n\n  if (Settings.useImageHashes.valueOrDefault) {\n    const ih1 = toImageHash(af1 as any)\n    const ih2 = toImageHash(af2 as any)\n    if (ih1 != null && ih2 != null) {\n      const ihc = compareImageHashes(ih1, ih2, {\n        capturedAtIsFuzzy\n      })\n      return true === ihc?.isSimilar ? undefined : ihc?.whyNotSimilar\n    }\n  }\n\n  // If we aren't using image hashing, we have to lean (hard) on metadata:\n  const fieldMatches = keys(fields).filter(k => fields[k] == null)\n\n  return fieldMatches.length >=\n    Settings.minMatchesWithoutImageHashes.valueOrDefault\n    ? undefined\n    : \"Insufficient metadata correlation\"\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { map } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toFloat } from \"../../fe/Number\"\nimport { toA } from \"../../fe/toA\"\nimport { geohashNumericShort } from \"../GeoHash\"\nimport { mkLogger } from \"../Logger\"\nimport { shim1 } from \"../Shim1\"\nimport { SortableAssetFile } from \"../asset-file/AssetFileSorter\"\nimport { DominantColor } from \"../color/DominantColor\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFileOrString } from \"../fs/SimpleFile\"\nimport { ImageHash, imageHash_ } from \"../img/ImageHash\"\nimport { max } from \"../math/Vector\"\nimport { Settings } from \"../settings/Settings\"\nimport { readTags } from \"../tags/ExifTool\"\nimport {\n  AssetFileCapturedAtFields,\n  AssetFileImageHashFields,\n  AssetFileMetadata,\n  AssetFileStatFields,\n  AssetFileUriFields,\n  IAssetFile\n} from \"./IAssetFile\"\n\nconst logger = lazy(() => mkLogger(\"asset-file.AssetFileFactory\"))\n\nexport async function assetFileUriFields_(\n  f: PosixFile\n): Promise<AssetFileUriFields> {\n  try {\n    return {\n      nativePath: f.nativePath,\n      uri: await f.uri_(),\n      mountpoint: (await f.mountpoint())?.nativePath\n    }\n  } catch (error) {\n    return logger().throw(\"Failed to build URI for \" + f, { error })\n  }\n}\n\nexport async function assetFileStatFields_(\n  f: PosixFile\n): Promise<AssetFileStatFields> {\n  const stat = await f.stat_()\n  const arr = await f.sidecareStats()\n  const mtime = max([stat.mtimeMs, ...toA(arr).map(ea => ea.mtimeMs)])!\n  return {\n    mtime,\n    fileSize: stat.size\n  }\n}\n\nexport function imageHashToAssetFileImageHashFields(\n  ih: ImageHash\n): AssetFileImageHashFields & ImageHash {\n  return {\n    ...ih,\n    ...DominantColor.toModeData(ih.dominantColors)\n  }\n}\n\nexport async function assetFileImageHashFields_(\n  f: PosixFile\n): PromiseMaybe<AssetFileImageHashFields & ImageHash> {\n  if (!Settings.useImageHashes.valueOrDefault) {\n    return\n  }\n  const ih = await imageHash_(f.nativePath)\n\n  if (ih == null) {\n    return logger().throw(\"Failed to extract image hash for \" + f)\n  }\n\n  return imageHashToAssetFileImageHashFields(ih)\n}\n\nexport const assetFileMetadata_ = shim1({\n  name: \"asset-file.assetFileMetadata\",\n  impl: _assetFileMetadata_\n})\n\nasync function _assetFileMetadata_(\n  nativePath: SimpleFileOrString\n): Promise<AssetFileCapturedAtFields & AssetFileMetadata> {\n  const f = PosixFile.for(nativePath)\n  const t = await readTags(f)\n  if (t == null) {\n    return logger().throw(\"Failed to read tags for \" + f)\n  }\n\n  const caFields = t.capturedAt?.toAssetFileFields()\n  if (caFields == null) {\n    return logger().throw(\"Failed to extract captured-at for \" + f)\n  }\n\n  // image hash runs readTags, so we shouldn't do this in parallel.\n\n  return {\n    ...caFields,\n    ...t.exposureSettings,\n    ...t.dimensions,\n    mimetype: t.mimetype,\n    rotation: t.rotation,\n    make: t.Make,\n    model: t.Model,\n\n    // store the rating so if we lose access to the file we still have the metadata:\n    rating: t.rating,\n\n    cameraId: t.cameraId,\n    imageId: t.imageId,\n    lensId: t.lensId,\n    geohash: geohashNumericShort(t.GPSLatitude, t.GPSLongitude),\n\n    durationMs: map(t.duration, ea => Math.round(ea * 1000)),\n    fps: map(toFloat(t.VideoFrameRate), Math.round)\n  }\n}\n\nexport async function mkAssetFile_(f: PosixFile) {\n  const [saf, ih] = await Promise.all([\n    mkSortableAssetFile_(f),\n    assetFileImageHashFields_(f)\n  ])\n  const result = {\n    ...saf,\n    ...ih\n  } satisfies IAssetFile\n  return result\n}\n\nexport async function mkSortableAssetFile_(f: PosixFile) {\n  const [a, b, c, sha] = await Promise.all([\n    assetFileUriFields_(f),\n    assetFileStatFields_(f),\n    assetFileMetadata_(f),\n    f.sha_()\n  ])\n  const result = {\n    ...a,\n    ...b,\n    ...c,\n    sha\n  } satisfies SortableAssetFile\n  return result\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { compact, uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank } from \"../../fe/Blank\"\nimport { minuteMs, weekMs } from \"../../fe/Date\"\nimport { Dimensions } from \"../../fe/Dimensions\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { groupBy } from \"../../fe/MultiMap\"\nimport { gt0, map2Numeric } from \"../../fe/Number\"\nimport { toReqValued } from \"../../fe/Object\"\nimport { CmpReverseFlag, Comparable, Primitive } from \"../../fe/Primitive\"\nimport { strEnum } from \"../../fe/StrEnum\"\nimport {\n  PS_LIBRARY_SCHEME,\n  PS_LOCAL_FILE_SCHEME,\n  PS_NETWORK_FILESYSTEM_SCHEME\n} from \"../../fe/URI\"\nimport { mkLogger } from \"../Logger\"\nimport { includesIgnoreCase } from \"../String\"\nimport { IAssetFile } from \"../asset-file/IAssetFile\"\nimport { copySuffixCountFromName } from \"../fs/FuzzyNames\"\nimport { parentBasename, parsePosixPath } from \"../fs/Path\"\nimport { AssetFileSortCriterion } from \"../settings/AssetFileSortCriteria\"\nimport { Settings } from \"../settings/Settings\"\nimport { isSupportedByCurrentBrowserExt } from \"../tags/FileTypes\"\nimport { uriExists } from \"../uri/FileURI\"\nimport { URI } from \"../uri/URI\"\n\nconst logger = lazy(() => mkLogger(\"img.AssetFileSorter\"))\n\n// goodness ascending:\nconst UriSchemes = strEnum(\n  \"file\",\n  PS_NETWORK_FILESYSTEM_SCHEME,\n  PS_LOCAL_FILE_SCHEME,\n  PS_LIBRARY_SCHEME\n)\n\nexport type SortableAssetFile = Pick<\n  IAssetFile,\n  | \"uri\"\n  | \"mountpoint\"\n  | \"nativePath\"\n  | \"mtime\"\n  | \"fileSize\"\n  | \"mimetype\"\n  | \"sha\"\n  | \"width\"\n  | \"height\"\n  | \"capturedAtPrecisionMs\"\n  | \"make\"\n  | \"model\"\n  | \"rating\"\n  | \"cameraId\"\n  | \"imageId\"\n  | \"lensId\"\n  | \"geohash\"\n>\n\n/**\n * Rough comparable number such that substantively larger resolution files are\n * considered \"better\"\n */\nexport function dim2sort(d: Partial<Dimensions>): Maybe<number> {\n  return map2Numeric(d?.width, d?.height, (w, h) => sortScale(w * h))\n}\n\nexport function sortScale(i: Maybe<number>): Maybe<number> {\n  if (!gt0(i)) return\n  // 1/6 is the strongest fractional exponent such that ImageSize values are\n  // still distinct.\n  return Math.round(\n    Math.pow(i, Settings.variantSortCriteriaPower.valueOrDefault)\n  )\n}\n\nexport function mtime2sort(ms: number): number {\n  // ignore smaller than 5 minute differences\n  return Math.round(ms / (5 * minuteMs))\n}\n\nconst MetadataFields: (keyof SortableAssetFile)[] = [\n  \"make\",\n  \"model\",\n  \"rating\",\n  \"cameraId\",\n  \"imageId\",\n  \"lensId\",\n  \"geohash\"\n]\n\n/**\n * A pleasing melange of heuristics to pick the \"best\" file from a set of\n * files to show to the user.\n *\n * Sorted by best to worst (or \"goodness descending\").\n *\n * Files that are missing, less than a KB, or have no URI will be removed from\n * the returned array.\n */\nexport function sortAssetFiles<T extends SortableAssetFile>(files: T[]): T[] {\n  // For each uniq SHA, pretend everyone has the youngest (biggest!) mtime.\n  // This lets scheme win over mtime for the same SHA.\n  for (const sameSha of groupBy(files, ea => ea.sha).values()) {\n    if (sameSha.length > 1) {\n      const maxMtime = Math.max(...compact(sameSha.map(ea => ea.mtime)))\n      for (const ea of sameSha) {\n        ea.mtime = maxMtime\n      }\n    }\n  }\n  const goodnessAscending = sortBy(files, assetFileSortCriteria)\n  return goodnessAscending.reverse()\n}\n\nexport type AssetFileSortPojo = Record<AssetFileSortCriterion, Comparable>\n\n// the Obj is easier to log:\nexport function assetFileSortCriteriaPojo(\n  af: SortableAssetFile\n): Maybe<AssetFileSortPojo> {\n  const parsedURI = URI.parse(af.uri)\n\n  if (blank(parsedURI?.scheme) || blank(parsedURI?.path)) {\n    logger().warn(\"assetFileSortCriteriaPojo(): skipping (invalid URI)\", {\n      uri_scheme: parsedURI?.scheme,\n      uri_path: parsedURI?.path,\n      af,\n      parsedURI\n    })\n    return\n  }\n\n  const schemeIdx = UriSchemes.indexOf(parsedURI.scheme)\n\n  if (schemeIdx == null) {\n    logger().warn(\n      \"assetFileSortCriteriaPojo(): skipping (invalid URI scheme)\",\n      {\n        uri_scheme: parsedURI.scheme,\n        af,\n        parsedURI\n      }\n    )\n    return\n  }\n\n  const mtimeMs = af.mtime ?? 0\n  const parsedFile = parsePosixPath(parsedURI.path)\n\n  // 5-minute-resolution, plus the scheme index to resolve close ties\n\n  const metadataFields = []\n  for (const ea of MetadataFields) {\n    if (!blank(af[ea])) {\n      metadataFields.push(ea)\n    }\n  }\n  // assume later counts may be newer edits, and pick those:\n\n  // Note that we don't fetch tags here, as that is done for only the winning\n  // file by AssetPreviewBuilder.\n\n  // bigger values win:\n  const fields = {\n    resolution: dim2sort(af),\n    schemeIdx,\n\n    capturedAtPrecision: -(af.capturedAtPrecisionMs ?? weekMs), // < smaller is better, so negate\n    metadataCoverage: metadataFields.length, // < bigger is better\n    metadataFields: metadataFields.join(\",\"),\n\n    // booleans sort [false, true], and we want supported files to win:\n    isBrowserSupported: isSupportedByCurrentBrowserExt(parsedFile.ext),\n\n    mtime: mtime2sort(mtimeMs), // we want more recent to be better\n    fileSize: sortScale(af.fileSize), // bigger is better?\n\n    isCover: includesIgnoreCase([\"cover\"], parsedFile.base),\n\n    count: Math.abs(copySuffixCountFromName(parsedFile.name) ?? 0),\n\n    // uno reverse card these strings so A > B\n    basename: CmpReverseFlag + parsedFile.base,\n    parentBasename:\n      CmpReverseFlag + parentBasename(af.nativePath ?? parsedURI.path),\n    uri: CmpReverseFlag + af.uri\n  }\n\n  return logger().tap({\n    msg: \"assetFileSortCriteriaPojo()\",\n    result: toReqValued(fields)\n  })\n}\n\nexport function assetFileSortFields(): AssetFileSortCriterion[] {\n  return uniq<AssetFileSortCriterion>([\n    ...Settings.variantSortCriteria.values,\n    // Always include URI for determinism:\n    \"uri\"\n  ] as any)\n}\n\n/**\n * @return undefined if any assetFileSortCriteriaPojo fields are undefined\n */\nexport function assetFileSortCriteria(\n  af: SortableAssetFile\n): Maybe<Primitive[]> {\n  const obj = assetFileSortCriteriaPojo(af)\n  if (obj == null) return\n  const result = []\n  for (const field of assetFileSortFields()) {\n    result.push((obj as any)[field])\n  }\n  return result\n}\n\nexport async function bestExistingAssetFile<T extends SortableAssetFile>(\n  files: T[]\n): PromiseMaybe<T> {\n  for (const ea of sortAssetFiles(files)) {\n    if (await uriExists(ea.uri, ea.nativePath)) {\n      return logger().tap({\n        msg: \"bestExistingAssetFile()\",\n        result: ea,\n        meta: { files: files.map(af => af.uri) }\n      })\n    }\n  }\n  return logger().tap({\n    msg: \"bestExistingAssetFile(): no existing uris\",\n    result: undefined,\n    meta: { files: files.map(ea => ea.uri) }\n  })\n}\n","import { PartiallyNull } from \"../../fe/PartiallyNull\"\nimport { ExposureSettings } from \"../../fe/api/ExposureSettings\"\nimport { WithModeData } from \"../color/ModeData\"\nimport { ImageHash } from \"../img/ImageHash\"\nimport { uri2nativePath } from \"../uri/FileURI\"\n\n// TODO: do we _want_ isGreyscale here (or in the AssetFile model)?\n\nexport interface AssetFileUriFields {\n  nativePath: string\n  uri: string\n  mountpoint?: string\n}\n\nexport interface AssetFileStatFields {\n  mtime: number // in millis\n  fileSize: number // in bytes\n}\n\nexport interface AssetFileCapturedAtFields\n  extends Pick<AssetFileUriFields, \"nativePath\">,\n    Pick<AssetFileStatFields, \"mtime\"> {\n  capturedAtLocal: number\n  capturedAtOffset?: number\n  /**\n   * Valid values are [0, yearMs]. If null or -1, it means the precision is unknown.\n   */\n  capturedAtPrecisionMs?: number\n  capturedAtSrc: string\n}\n\n// image hashing is optional--but mimetype and dimensions are required, so we\n// only pull out the hashes here:\nexport type AssetFileImageHashFields = Pick<\n  ImageHash,\n  \"meanHash\" | \"dctHash\" | \"diffHash\"\n> &\n  PartiallyNull<WithModeData> // < not all images have N dominant colors\n\nexport interface AssetFileMetadata\n  extends Partial<ExposureSettings>,\n    AssetFileCapturedAtFields {\n  mimetype: string\n\n  width: number\n  height: number\n  rotation?: number\n\n  make?: string\n  model?: string\n\n  rating?: number\n\n  cameraId?: string\n  imageId?: string\n  lensId?: string\n  geohash?: number\n\n  // Optional, as it only applies to videos:\n  durationMs?: number\n  fps?: number\n}\n\nexport interface IAssetFile\n  extends Partial<AssetFileImageHashFields>, // < image hashing is optional!\n    AssetFileUriFields,\n    AssetFileStatFields,\n    AssetFileCapturedAtFields,\n    AssetFileMetadata {\n  id?: number\n  assetId?: number\n\n  // this is expensive all by itself\n  sha: string\n\n  /** truthy if this is the \"primary\" variation */\n  shown?: number | boolean\n}\n\nexport async function getAssetFileNativePath<T extends AssetFileUriFields>(\n  af: T\n): Promise<string> {\n  return (af.nativePath ??= (await uri2nativePath(af.uri, af.mountpoint))!)\n}\n","/**\n * @see AbortController\n * @see AbortSignal\n */\nexport class AbortError extends Error {}\n","import timers from \"timers\"\nimport { gt0 } from \"../../fe/Number\"\n\nexport interface Debounced {\n  (...args: any[]): any\n  reset(): void\n  force(): void\n  setTimeoutMs(timeoutMs: number): void\n  timeoutMs(): number\n}\n\nexport function debounce(\n  f: (...args: any[]) => any,\n  timeoutMs: number\n): Debounced {\n  let lastTimeout: any\n  let args: any[] = []\n\n  const r: any = gt0(timeoutMs)\n    ? (...a: any[]) => {\n        args = a\n        if (lastTimeout != null) timers.clearTimeout(lastTimeout)\n        lastTimeout = timers.setTimeout(() => {\n          f(...args)\n        }, timeoutMs)\n      }\n    : f\n  r.reset = () => {\n    if (lastTimeout != null) timers.clearTimeout(lastTimeout)\n    lastTimeout = undefined\n  }\n  r.force = () => {\n    r.reset()\n    f()\n  }\n  r.setTimeoutMs = (ea: number) => {\n    r.reset()\n    timeoutMs = ea\n  }\n  r.timeoutMs = () => timeoutMs\n  return r\n}\n","import timers from \"timers\"\nimport util from \"util\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { asError } from \"../../fe/Error\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { omit } from \"../../fe/Object\"\nimport { Comparable } from \"../../fe/Primitive\"\nimport { isPromise } from \"../../fe/Promise\"\nimport { PromiseState, PromiseStates } from \"../../fe/PromiseState\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { TimeoutError } from \"../../fe/TimeoutError\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { isIgnorableError } from \"../error/ErrorTypes\"\nimport { onTimeout } from \"./TimeoutHandler\"\n\n/**\n * Deferred resolution of a promise with synchronous state\n */\nexport class Deferred<T, P = any> implements Promise<T> {\n  static async *toAsyncIterable<I, O>(arr: Deferred<I, O>[]) {\n    while (!isEmpty(arr)) {\n      // Yield the first completed value:\n      const idx = arr.findIndex(ea => !ea.isPending)\n      if (idx >= 0) {\n        const result = arr[idx]\n        arr.splice(idx, 1)\n        yield result\n      } else {\n        try {\n          // Wait for the next one to complete, and run the loop again:\n          await Promise.race(arr)\n        } catch {\n          // if the next promise raises, we still want to return that Deferred\n          // (the caller can check on the rejected status)\n        }\n      }\n    }\n  }\n\n  static #id = 0\n\n  static resolve<I, O = any>(\n    t: I,\n    opts?: { payload?: O; serialId?: Comparable }\n  ): Deferred<I, O> {\n    const d = new Deferred<I>(\".resolved()\", opts)\n    return d.resolve(t)\n  }\n\n  readonly id: number\n  readonly payload?: P\n  /**\n   * If this is defined, Promises should prevent concurrent execution of other\n   * Deferred instances with the same serialId.\n   */\n  readonly serialId?: Comparable\n  readonly startedAt = Date.now()\n  #settledAt?: number\n  #state: PromiseState = PromiseStates.pending\n  #value?: T\n  readonly promise: Promise<T>\n  #resolve!: (value: T) => void\n  #reject!: (reason?: any) => void\n  #error: Maybe<Error>\n  #priorTimeout: Maybe<NodeJS.Timeout>\n  #logger: Maybe<Logger>\n\n  /**\n   * @param name can be either a string or a data payload to associate with the\n   * promise.\n   */\n  constructor(\n    readonly name: string,\n    opts?: { payload?: P; serialId?: Comparable }\n  ) {\n    this.id = Deferred.#id++\n    this.promise = new Promise<T>((resolve, reject) => {\n      this.#resolve = resolve\n      this.#reject = reject\n    })\n    this.payload = opts?.payload\n    this.serialId = opts?.serialId\n  }\n\n  private get logger() {\n    return this.#logger ?? mkLogger(\"async.Deferred(\" + this.name + \")\")\n  }\n\n  // Only true for the same instance\n  eql(d: Deferred<T>): boolean {\n    return d instanceof Deferred && d.id === this.id\n  }\n\n  // This is used by LogMeta for logging:\n  toLogJSON() {\n    return {\n      _ctor: \"Deferred\",\n      name: this.name,\n      state: this.#state,\n      value: this.value,\n      serialId: this.serialId,\n      payload: this.payload,\n      elapsedMs: this.elapsedMs\n    }\n  }\n\n  toJSON() {\n    return omit(this.toLogJSON(), \"value\", \"elapsedMs\")\n  }\n\n  get settledAt() {\n    return this.#settledAt\n  }\n\n  get elapsedMs() {\n    return (this.#settledAt ?? Date.now()) - this.startedAt\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"async.Deferred(\" + this.name + \")\"\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON()\n  }\n\n  observeQuietly(p: Promise<T>): Deferred<Maybe<T>> {\n    if (isPromise(p)) {\n      p.then(resolution => {\n        void this.maybeResolve(resolution)\n      }).catch(err => {\n        this.logger.warn(\"observeQuietly.reject()\", err)\n        void this.maybeResolve(undefined as any)\n      })\n    } else {\n      void this.maybeResolve(p)\n    }\n    return this as any\n  }\n\n  observe(p: SyncOrAsync<T>): this {\n    if (isPromise(p)) {\n      p.then(resolution => {\n        void this.maybeResolve(resolution)\n      }).catch(err => {\n        void this.maybeReject(err)\n      })\n    } else {\n      void this.maybeResolve(p)\n    }\n    return this\n  }\n\n  /**\n   * Reject the promise if it hasn't been resolved or rejected within\n   * `timeoutMs`\n   */\n  setTimeout(timeoutMs: number, unref: boolean = true): this {\n    if (this.#priorTimeout != null) {\n      timers.clearTimeout(this.#priorTimeout)\n      this.#priorTimeout = undefined\n    }\n\n    if (gt0(timeoutMs)) {\n      // unref so it doesn't prevent node from exiting:\n      this.#priorTimeout = timers.setTimeout(() => {\n        if (this.isPending) {\n          void this.reject(\n            new TimeoutError(\n              \"Timeout \" +\n                this.name +\n                \" after \" +\n                (Date.now() - this.startedAt) +\n                \"ms\"\n            )\n          )\n          onTimeout()\n        }\n      }, timeoutMs)\n      if (unref) {\n        this.#priorTimeout.unref()\n      }\n    }\n    return this\n  }\n\n  get stateStr(): PromiseState {\n    return this.isPending\n      ? \"pending\"\n      : this.isResolved\n      ? \"resolved\"\n      : \"rejected\"\n  }\n\n  get isPending() {\n    return this.#state === PromiseStates.pending\n  }\n\n  /**\n   * @return the resolved value for this Deferred, or `undefined` if this\n   * is either still pending or rejected.\n   */\n  get value(): Maybe<T> {\n    return this.isResolved ? this.#value : undefined\n  }\n\n  get error(): Maybe<Error> {\n    return this.#error\n  }\n\n  /**\n   * true iff either resolved or rejected.\n   */\n  get isSettled() {\n    return this.#state !== PromiseStates.pending\n  }\n\n  get isResolved() {\n    return this.#state === PromiseStates.resolved\n  }\n\n  get isRejected() {\n    return this.#state === PromiseStates.rejected\n  }\n\n  get settledMs(): number | undefined {\n    return this.#settledAt == null\n      ? undefined\n      : this.#settledAt - this.startedAt\n  }\n\n  /**\n   * Resolves the internal promise. Cannot be invoked more than once.\n   */\n  resolve(value: T): this {\n    return this.#settle(() => {\n      this.#state = PromiseStates.resolved\n      this.#value = value\n      this.#resolve(value)\n    })\n  }\n\n  maybeResolve(value: T): this {\n    return this.isPending ? this.resolve(value) : this\n  }\n\n  reject(reason?: any): this {\n    this.logger.log(\n      isIgnorableError(reason) === true ? \"info\" : \"warn\",\n      \".reject()\",\n      reason\n    )\n    const err = asError(reason)\n    return this.#settle(() => {\n      this.#error = err\n      this.#state = PromiseStates.rejected\n      this.#reject(err)\n    })\n  }\n\n  maybeReject(reason?: any): this {\n    return this.isPending ? this.reject(reason) : this\n  }\n\n  finally(f: () => any): this {\n    // don't create a new promise chain that may have an unhandled error!\n    void this.promise.finally(f).catch(() => undefined)\n    return this\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): Promise<TResult1 | TResult2> {\n    return this.promise.then(onfulfilled, onrejected)\n  }\n\n  catch<U>(onrejected: (reason: any) => U | PromiseLike<U>): Promise<T | U> {\n    return this.promise.catch(err => onrejected(err))\n  }\n\n  #settle(firstback: () => void): this {\n    if (this.#state === PromiseStates.pending) {\n      map(this.#priorTimeout, timers.clearTimeout)\n      firstback()\n      this.#settledAt = Date.now()\n      const ms = this.settledMs!\n      if (this.isResolved && ms > 5000) {\n        this.logger.info(\"Completed in \" + ms + \"ms\")\n      }\n    } else {\n      this.logger.warn(\n        \"settled multiple times (already \" + this.stateStr + \")\",\n        { value: this.#value }\n      )\n    }\n    return this\n  }\n}\n","import { Latch } from \"../../fe/Latch\"\nimport { Endable } from \"./Endable\"\nimport { EndableWrapper } from \"./EndableWrapper\"\n\nexport interface Done extends Endable {\n  isDone(): boolean\n  donePromise(): Promise<void>\n}\n\nexport class DoneWrapper extends EndableWrapper implements Done {\n  readonly doneLatch = new Latch()\n\n  isDone() {\n    return !this.doneLatch.isPending() || this.ended\n  }\n\n  donePromise() {\n    return this.doneLatch.promise\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { MultiMap } from \"../../fe/MultiMap\"\nimport { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\nimport { MaybeSyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { mkLogger } from \"../Logger\"\nimport { isSingleSpecTests, isTest } from \"../NodeEnv\"\nimport { firstGt0 } from \"../Number\"\nimport { getDevEnvFlag } from \"../env/DevEnvFlags\"\nimport { setUnrefInterval } from \"./Timers\"\n\nconst logger = lazy(() => mkLogger(\"async.Endable\"))\n\nexport interface Endable {\n  readonly name: string\n  readonly ended: boolean\n  readonly endTimeoutMs?: number\n  end(): Promise<any> | any\n}\n\nconst endablesByRank = new MultiMap<EndableRank, Endable>()\n\nsetUnrefInterval(() => vacuumEndables(), 1 * minuteMs)\n\nconst DefaultTimeoutMs = 5 * secondMs\n\nexport const EndableRanks = strEnum(\n  \"first\",\n  \"stats\",\n  \"service\",\n  \"predb\",\n  \"db\",\n  \"postdb\",\n  \"logger\",\n  \"logtail\"\n)\nexport type EndableRank = StrEnumKeys<typeof EndableRanks>\n\n/**\n * Add an endable with an arbitrary end rank\n */\nexport function addEndable<T extends Endable>(\n  rank: EndableRank,\n  endable: T\n): T {\n  EndableRanks.validOrElse(rank, () => {\n    throw new Error(\"internal error: invalid rank \" + rank)\n  })\n  endablesByRank.add(rank, endable)\n  return endable\n}\n\nlet _ending = false\n\nexport function ending(): boolean {\n  return _ending\n}\n\nexport function setEnding(value: boolean) {\n  if (isTest) {\n    _ending = value\n  } else {\n    throw new Error(\"cannot set ending\")\n  }\n}\n\nexport function endAll(...arr: Maybe<Endable>[]) {\n  return Promise.all(arr.map(ea => end(ea)))\n}\n\nexport async function end(e: MaybeSyncOrAsync<Endable>, endTimeoutMs?: number) {\n  const endable = await e\n  if (endable == null || true === endable?.ended) return\n  const timeoutMs =\n    isTest && getDevEnvFlag(\"PS_SINGLE_SPEC_TESTS\")\n      ? 100\n      : firstGt0(endTimeoutMs, endable.endTimeoutMs, DefaultTimeoutMs)!\n  logger().trace(endable.name + \" ending...\", { timeoutMs })\n  try {\n    await thenOrTimeoutError(endable.end(), timeoutMs, false)\n  } catch (err) {\n    try {\n      // the logger might throw errors at the very end:\n      logger().warn(endable.name + \".end() failed\", err)\n    } catch {\n      //\n    }\n  }\n}\n\nfunction vacuumEndables() {\n  endablesByRank.filterInPlace((_, v) => v.ended !== true)\n  logger().debug(\n    \"vacuumEndables()\",\n    endablesByRank.entriesArray().map(([k, v]) => [k, v.map(ea => ea.name)])\n  )\n}\n\nexport const endEndables = lazy(async () => {\n  const endTimeoutMs = isSingleSpecTests() ? 500 : undefined\n  logger().info(\"endEndables()\", {\n    isTest,\n    isSingleSpecTests: isSingleSpecTests()\n  })\n  if (!isTest) _ending = true\n  vacuumEndables()\n  for (const rank of EndableRanks.values) {\n    const arr = endablesByRank.get(rank) ?? []\n    if (isNotEmpty(arr)) {\n      logger().debug(\"endEndables(): ending \" + rank)\n      await Promise.allSettled(arr.map(ea => end(ea, endTimeoutMs)))\n    }\n  }\n})\n\nexport function endablesStats() {\n  const result: any = {}\n  for (const rank of EndableRanks.values) {\n    const arr = endablesByRank.get(rank) ?? []\n    result[rank] = arr.map(ea => ({ name: ea.name, ended: ea.ended }))\n  }\n  return result\n}\n","import { clearInterval, clearTimeout, setInterval, setTimeout } from \"timers\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, toInt } from \"../../fe/Number\"\nimport { pick } from \"../../fe/Object\"\nimport { EndableRank, EndableRanks, ending } from \"./Endable\"\nimport { EndableWrapper } from \"./EndableWrapper\"\n\nexport class EndableInterval extends EndableWrapper {\n  #timer: Maybe<NodeJS.Timeout>\n  #timeout: Maybe<NodeJS.Timeout>\n  constructor(\n    readonly opts: {\n      name: string\n      callback: (...args: any[]) => any\n      intervalMs: number\n      initialDelayMs?: number\n      rank?: EndableRank\n      endTimeoutMs?: number\n      unref?: boolean // < defaults to false to prevent tools from exiting unexpectedly\n      onEnd?: () => unknown\n    }\n  ) {\n    super(\n      opts.name,\n      () => this.#clear(),\n      opts.rank ?? EndableRanks.first,\n      opts.endTimeoutMs\n    )\n    if (opts.onEnd != null) {\n      this.onEnds.push(opts.onEnd)\n    }\n    this.setIntervalMs(this.opts.intervalMs, this.opts.initialDelayMs, true)\n  }\n\n  #clear() {\n    map(this.#timer, clearInterval)\n    this.#timer = undefined\n    map(this.#timeout, clearTimeout)\n    this.#timeout = undefined\n  }\n\n  hasTimer() {\n    return this.#timer != null\n  }\n\n  hasTimeout() {\n    return this.#timeout != null\n  }\n\n  get timingOpts() {\n    return pick(this.opts, \"intervalMs\", \"initialDelayMs\")\n  }\n\n  readonly #callback = () => {\n    if (!ending() && !this.ended) {\n      this.opts.callback()\n    }\n  }\n\n  get #canRun() {\n    return !ending() && !this.ended\n  }\n\n  /**\n   * @return true if the given args or state resulted in new intervals being scheduled\n   */\n  setIntervalMs(\n    intervalMs: number,\n    initialDelayMs?: number,\n    force = false\n  ): boolean {\n    if (ending() || this.ended) return false\n\n    intervalMs = toInt(intervalMs) ?? 0\n    initialDelayMs = toInt(initialDelayMs) ?? 0\n    if (\n      !force &&\n      this.opts.intervalMs === intervalMs &&\n      (this.opts.initialDelayMs ?? 0) === initialDelayMs\n    ) {\n      // no-op if these are already the correct value\n      return false\n    }\n\n    this.opts.intervalMs = intervalMs\n    this.opts.initialDelayMs = initialDelayMs\n\n    this.#clear()\n\n    const maybeScheduleInterval = () => {\n      if (this.#canRun && gt0(this.opts.intervalMs)) {\n        this.#timer = setInterval(this.#callback, this.opts.intervalMs)\n        if (this.opts.unref === true) this.#timer.unref()\n      }\n    }\n\n    if (gt0(this.opts.initialDelayMs)) {\n      this.#timeout = setTimeout(() => {\n        if (this.#canRun) {\n          this.#callback()\n          maybeScheduleInterval()\n        }\n      }, this.opts.initialDelayMs)\n      if (this.opts.unref === true) this.#timeout.unref()\n    } else {\n      maybeScheduleInterval()\n    }\n    return true\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { Latch } from \"../../fe/Latch\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { Endable, EndableRank, EndableRanks, addEndable } from \"./Endable\"\nimport { awaitSettled } from \"./Promise\"\n\n/**\n * Base class for Endables.\n */\nexport class EndableWrapper implements Endable {\n  #name!: string\n  logger!: Logger\n\n  protected readonly onEnds: (() => any)[] = []\n  readonly #endPromise = lazy(() => new Latch())\n  /**\n   * @param name for logging\n   * @param onEnd called by `this.end()`. May return a promise.\n   * @param _isEnded if the wrapped instance can end from other state mutations,\n   * providing this method will allow this wrapper to be garbage collected.\n   */\n  constructor(\n    name: string,\n    onEnd?: () => Promise<any> | any,\n    rank: EndableRank = EndableRanks.first,\n    readonly endTimeoutMs?: number\n  ) {\n    this.name = name\n    if (onEnd != null) this.onEnds.push(onEnd)\n    addEndable(rank, this)\n  }\n\n  get name() {\n    return this.#name\n  }\n\n  set name(n: string) {\n    this.#name = n\n    this.logger = mkLogger(n)\n  }\n\n  get ended() {\n    return this.end.hasPrior()\n  }\n\n  end = lazy(async () => {\n    await awaitSettled(this.onEnds.map(ea => ea()))\n    void this.#endPromise().resolve()\n  })\n\n  awaitEnd(): Promise<void> {\n    return this.#endPromise()\n  }\n}\n","import process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { toNotBlank } from \"../../fe/Blank\"\nimport { magenta } from \"../Chalk\"\nimport { mkLogger } from \"../Logger\"\nimport { stderrWrite } from \"../StdoutWrite\"\nimport { toWrappedError } from \"../error/WrappedError\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { endEndables, ending } from \"./Endable\"\n\nconst logger = lazy(() => mkLogger(magenta(\"Exit\")))\n\nexport const onFatalHandlers: ((reason: string) => any)[] = []\n\nexport async function exit(args: {\n  reason?: string\n  status?: number\n  error?: any\n}) {\n  logger().log(args.status === 0 ? LogLevels.info : LogLevels.warn, \"exit()\", {\n    ...args,\n    ending: ending()\n  })\n  const error = toWrappedError(args.error, {\n    message: args.reason,\n    errno: args.status\n  })\n  if (error.errno !== 0 || error.fatal === true) {\n    stderrWrite({ fatal: true, ...args })\n    const reason = toNotBlank(args?.reason) ?? error.toString()\n    for (const ea of onFatalHandlers) {\n      await ea(reason)\n    }\n  }\n\n  if (!ending()) {\n    await endEndables()\n    process.exit(args.status)\n  }\n}\n\nexport const exitOnStdStream = lazy(() => {\n  for (const streamName of [\"stdin\", \"stdout\", \"stderr\"] as const) {\n    for (const eventName of [\"close\", \"error\", \"disconnect\", \"end\"] as const) {\n      process[streamName].on(eventName, (error: any) => {\n        void exit({\n          reason: `${streamName}:${eventName}`,\n          status: 0,\n          error\n        })\n      })\n    }\n  }\n})\n","import { MultiMap } from \"../../fe/MultiMap\"\nimport { Primitive } from \"../../fe/Primitive\"\nimport { Thunk } from \"../../fe/Thunk\"\nimport { toS } from \"../../fe/toS\"\nimport { maxCpus } from \"../work/MaxCpus\"\nimport { Promises } from \"./Promises\"\n\nexport class LastOneInWins<K extends Primitive> {\n  readonly p: Promises\n  readonly #id2ac = new MultiMap<K, AbortController>()\n\n  constructor(\n    readonly name: string,\n    readonly maxConcurrency: Thunk<number> = maxCpus\n  ) {\n    this.p = new Promises(name, maxConcurrency)\n  }\n\n  vacuum() {\n    this.#id2ac.filterInPlace((_, v) => !v.signal.aborted)\n  }\n\n  enqueue<V>(key: K, fn: (ac: AbortController) => Promise<V>) {\n    for (const ea of this.#id2ac.get(key) ?? []) {\n      ea.abort()\n    }\n    // vacuum after aborting prior work:\n    this.vacuum()\n    const ac = new AbortController()\n    this.#id2ac.add(key, ac)\n    return this.p.serial(toS(key), () => fn(ac))\n  }\n}\n","import { Later } from \"../../fe/Later\"\nimport { Maybe, MaybePromiseMaybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { MaybeSyncOrAsync } from \"../../fe/SyncOrAsync\"\n\nexport interface LaterMaybe<T> {\n  (): PromiseMaybe<T>\n}\n\nexport interface MaybeLaterMaybe<T> {\n  (): MaybePromiseMaybe<T>\n}\n\n/**\n * Wrap a Later to get a promise that will be resolved or rejected when the\n * returned thunk is called.\n */\nexport function laterPromise<T>(later: () => T | Promise<T>): {\n  promise: Promise<T>\n  later: Later<T>\n} {\n  // We could use Deferred here, but I want to minimize cross-dependencies.\n  let resolve: (t: T | Promise<T>) => void\n  let reject: (error: any) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return {\n    promise,\n    later: async () => {\n      try {\n        const r = await later()\n        resolve(r)\n        return r\n      } catch (err) {\n        reject(err)\n        throw err\n      }\n    }\n  }\n}\n\nexport async function firstDefinedLater<T>(\n  ...arr: Maybe<() => MaybeSyncOrAsync<T>>[]\n): PromiseMaybe<T> {\n  if (arr == null) return\n  for (const ea of arr) {\n    if (ea == null) continue\n    const result = await ea()\n    if (result != null) return result\n  }\n  return\n}\n","import { eql } from \"../../fe/Eql\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { toErr } from \"../../fe/toErr\"\nimport { Deferred } from \"./Deferred\"\n\nexport type MemoizedDeferredListener<T> = {\n  onChange(newResult: T): any\n  onError(error: Error): any\n}\n\nexport interface MemoizedDeferred<T> {\n  (): Deferred<T>\n\n  /**\n   * Clears the prior value but doesn't return it (so we don't have to\n   * explicitly ignore unawaited promises)\n   */\n  unset(): void\n\n  /**\n   * Force the prior value to be `t`\n   */\n  set(t: T): void\n\n  /**\n   * Forces the underlying thunk or later to be applied\n   */\n  refresh(): Deferred<T>\n\n  /**\n   * @return the milliseconds a prior result may be returned by `apply`, or\n   * undefined if no TTL is set\n   */\n  ttl(): Maybe<number>\n\n  /**\n   * @param ttl undefined to remove TTL expirations\n   */\n  setTTL(ttl: Maybe<number>): void\n\n  /**\n   * Calls the listener if the result changes later. The underlying thunk is\n   * not applied now (like with {@link MemoizedThunk.watch}).\n   */\n  watchLater(watcher: MemoizedDeferredListener<T>): void\n\n  /**\n   * @return undefined if unset\n   */\n  lastSetAgoMs(): Maybe<number>\n\n  /**\n   * @return the previously-memoized Deferred, if it isn't stale (according to\n   * `ttl()`)\n   */\n  prior(): Maybe<Deferred<T>>\n\n  /**\n   * @return the last memoized awaited result (even if it's stale!).\n   */\n  lastValue(): Maybe<T>\n\n  /**\n   * @return the number of times the underlying thunk has been applied\n   */\n  settledCount(): number\n\n  /**\n   * Has a result not been calculated, or was calculated more than `ttl()` ms\n   * ago?\n   */\n  isStale(): boolean\n\n  /**\n   * How long did the last fulfilled result take to calculate?\n   */\n  elapsedMs(): Maybe<number>\n\n  toString(): string\n}\n\n/**\n * @param ttlMs if 0 or null, the result of `later` will be cached forever.\n */\nexport function lazyAsync<T>({\n  later,\n  desc,\n  ttlMs,\n  timeoutMs\n}: {\n  later: () => Promise<T>\n  desc?: string\n  ttlMs?: number\n  timeoutMs?: number\n}): MemoizedDeferred<T> {\n  let lastSetTs: number | undefined\n  let settledCount = 0\n  let lastValue: T | undefined\n  let result: Deferred<T> | undefined\n  const watchers: MemoizedDeferredListener<T>[] = []\n\n  async function onSetResult(\n    priorD: Deferred<T> | undefined,\n    resultD: Deferred<T>\n  ) {\n    const resultIdAtStart = result?.id\n    try {\n      // There's a chance that the prior or current result has already\n      // changed. Don't submit onChanges or change priorValue if the current\n      // Deferred result has changed.\n\n      const current = await resultD\n      if (result?.id === resultIdAtStart) {\n        lastValue = current\n      }\n\n      if (\n        result?.id === resultIdAtStart &&\n        !eql(priorD?.value ?? (await priorD?.promise), current)\n      ) {\n        for (const ea of watchers) {\n          await ea.onChange(current)\n        }\n      }\n    } catch (err) {\n      const error = toErr(err)\n      if (error != null) for (const ea of watchers) ea.onError(error)\n    } finally {\n      settledCount++\n    }\n  }\n\n  function setResult(t: Promise<T>): Deferred<T> {\n    lastSetTs = Date.now()\n    const priorResult = result\n    result =\n      t instanceof Deferred\n        ? t\n        : new Deferred<T>(desc ?? \"lazyAsync\").observe(t)\n    if (gt0(timeoutMs)) {\n      void result.setTimeout(timeoutMs)\n    }\n    void onSetResult(priorResult, result)\n    return result\n  }\n\n  function isStale() {\n    return lastSetTs == null || (gt0(ttlMs) && lastSetTs + ttlMs < Date.now())\n  }\n\n  const f = (() =>\n    // NO PROMISE AWAITING HERE. Otherwise N calls would go through while we\n    // wait for the promise to resolve.\n    result == null || isStale() ? setResult(later()) : result) as any\n\n  f.unset = () => {\n    settledCount = 0\n    lastSetTs = undefined\n    lastValue = undefined\n    result = undefined\n  }\n\n  f.set = (t: T) => setResult(Deferred.resolve(t))\n\n  f.isStale = isStale\n\n  f.settledCount = () => settledCount\n\n  f.prior = () => {\n    if (isStale()) f.unset()\n    return result\n  }\n\n  f.lastValue = () => {\n    return result?.value ?? lastValue\n  }\n\n  f.refresh = () => setResult(later())\n\n  f.ttl = () => ttlMs\n\n  f.setTTL = (ttl: Maybe<number>) => {\n    ttlMs = gt0(ttl) ? ttl : undefined\n  }\n\n  f.watchLater = (watcher: MemoizedDeferredListener<T>) => {\n    watchers.push(watcher)\n  }\n\n  f.toString = f.toLogJSON = f.toJSON = () => desc ?? \"[LazyAsync]\"\n\n  f.lastSetAgoMs = () =>\n    lastSetTs == null ? undefined : Date.now() - lastSetTs\n\n  f.elapsedMs = () => result?.settledMs ?? result?.elapsedMs\n\n  return f\n}\n","import { stringify } from \"../../fe/JSON\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { FifoCacheAsync, FifoCacheAsyncOpts } from \"../FifoCacheAsync\"\n\nexport interface MemoizedAsyncFunc<A, R> {\n  (a: A): Promise<R>\n  clear(a?: A): void | Promise<void>\n  size(): number\n  callCount(): number\n}\n\nexport function memoizeAsync<A, R>(\n  f: (a: A) => SyncOrAsync<R>,\n  opts: FifoCacheAsyncOpts\n): MemoizedAsyncFunc<A, R> {\n  let callCount = 0\n  const store = new FifoCacheAsync<R>(opts)\n  const r: any = (a: A) => {\n    callCount++\n    return store.getOrSetAsync(stringify(a), async () => f(a))\n  }\n  r.clear = (a?: A) => {\n    if (a == null) {\n      return store.clear()\n    } else {\n      const aKey = stringify(a)\n      return store.deleteIf(ea => aKey === ea)\n    }\n  }\n  r.size = () => store.size\n  r.callCount = () => callCount\n  return r\n}\n","import { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { postrun } from \"./Postrun\"\n\nexport interface OneAtATime<T> {\n  (): Promise<T>\n  isRunning(): boolean\n  force(): Promise<T>\n  prior(): Promise<T>\n}\n\nexport function oneAtATime<R>({\n  fn,\n  runLaterIfBusy = false,\n  undefinedIfBusy\n}: {\n  fn: () => SyncOrAsync<R>\n  runLaterIfBusy?: boolean\n  undefinedIfBusy?: boolean\n}): OneAtATime<R> {\n  let prior: Promise<R>\n  let running = false\n  let runAgain = false\n  // this isn't async just to reduce promise creation:\n  const result = () => {\n    if (running) {\n      runAgain = true\n      return true === undefinedIfBusy ? (undefined as any) : prior\n    } else {\n      running = true\n      return (prior = postrun({\n        fn,\n        postrun: () => {\n          running = false\n          if (runLaterIfBusy === true && runAgain) {\n            runAgain = false\n            setImmediate(result)\n          }\n        }\n      }))\n    }\n  }\n  result.isRunning = () => running\n\n  result.prior = () => prior\n\n  result.force = async () => {\n    await prior\n    return result()\n  }\n\n  return result\n}\n","import { SyncOrAsync } from \"../../fe/SyncOrAsync\"\n\nexport async function postrun<T>(args: {\n  fn: () => SyncOrAsync<T>\n  postrun: () => SyncOrAsync<any>\n}): Promise<T> {\n  try {\n    return await args.fn()\n  } finally {\n    await args.postrun()\n  }\n}\n","import { compact, isEmpty, uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { isFalse, isTrue } from \"../../fe/Boolean\"\nimport { secondMs } from \"../../fe/Date\"\nimport { delay } from \"../../fe/Delay\"\nimport { orElse } from \"../../fe/Maybe\"\nimport {\n  Maybe,\n  MaybeNull,\n  MaybePromiseMaybe,\n  PromiseMaybe\n} from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { Primitive } from \"../../fe/Primitive\"\nimport { thenMap } from \"../../fe/Promise\"\nimport { MaybeSyncOrAsync, SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { thenOrTimeout, thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { Thunk, ThunkOrLater, tol } from \"../../fe/Thunk\"\nimport { TimeoutError } from \"../../fe/TimeoutError\"\nimport { isFunction } from \"../../fe/isFunction\"\nimport { toA } from \"../../fe/toA\"\nimport { toErr } from \"../../fe/toErr\"\nimport { Arg0 } from \"../Args\"\nimport { batches } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { identity } from \"../Object\"\nimport { Predicate } from \"../predicates/Predicates\"\nimport { maxCpus } from \"../work/MaxCpus\"\nimport { PermissivePromises, Promises } from \"./Promises\"\n\n// TODO: INLINE\nexport { thenMap } from \"../../fe/Promise\"\n\nexport async function someOrTimeout<T>(\n  arr: ThunkOrLater<T>[],\n  opts: { timeoutMs: number }\n): Promise<(T | TimeoutError | Error)[]> {\n  return Promise.all(\n    arr.map(ea => thenOrTimeoutError(tol(ea), opts.timeoutMs).catch(err => err))\n  )\n}\n\nexport async function thenCompact<T>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T>[]>\n): Promise<T[]> {\n  if (arr == null) return []\n  const c = compact(await arr)\n  return isEmpty(c) ? [] : compact(await Promise.all(c))\n}\n\nexport async function thenCollectBatched<T1, T2>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T1>[]>,\n  batchSize: number,\n  f: (batch: T1[]) => MaybeSyncOrAsync<T2[]>\n) {\n  const result: T2[] = []\n  for (const batchArr of batches(toA(await arr), batchSize)) {\n    const batchInput: T1[] = await thenCompact(batchArr)\n    result.push(...(await thenCompact(f(batchInput))))\n  }\n  return result\n}\n\nexport async function thenMapResolved<T1, T2>(\n  objP: MaybeSyncOrAsync<T1>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>\n): PromiseMaybe<T2> {\n  if (objP == null) return Promise.resolve(undefined)\n  try {\n    return await thenMap(objP, f)\n  } catch (e) {\n    return undefined\n  }\n}\n\nexport function resolvedWithin<T>(\n  p: Promise<T>,\n  withinMs: number\n): Promise<boolean> {\n  return Promise.race([\n    p.then(() => true),\n    delay(withinMs).then(() => false)\n  ]).catch(() => false)\n}\n\nexport async function resolved(p: Promise<any>): Promise<boolean> {\n  try {\n    await p\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nexport async function rejected(p: Promise<any>): Promise<boolean> {\n  return !(await resolved(p))\n}\n\nexport async function thenDefined(p: Promise<any>): Promise<boolean> {\n  return (await p) != null\n}\n\nexport async function allSerial<T>(\n  arr: Maybe<() => MaybeSyncOrAsync<T>>[]\n): Promise<T[]> {\n  const result: T[] = []\n  for (const ea of compact(arr)) {\n    const v = await ea()\n    if (v != null) result.push(v)\n  }\n  return result\n}\n\nexport async function awaitAll(\n  arr: Maybe<(PromiseMaybe<any> | any)[]>\n): Promise<void> {\n  for (const ea of toA(arr)) {\n    if (ea != null) await ea\n  }\n}\n\nexport async function awaitSettled(\n  arr: Maybe<(PromiseMaybe<any> | any)[]>\n): Promise<void> {\n  for (const ea of toA(arr)) {\n    try {\n      if (ea != null) await ea\n    } catch {\n      //\n    }\n  }\n}\n\n// maybeist champion:\nexport async function thenFlatten<T>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T | MaybeSyncOrAsync<T>[]>[]>\n): Promise<T[]> {\n  const result: T[] = []\n  for (const ea of toA(await arr)) {\n    const v = await ea\n    if (v != null) {\n      if (Array.isArray(v)) {\n        for (const ea2 of v) {\n          const v2 = await ea2\n          if (v2 != null) result.push(v2)\n        }\n      } else {\n        result.push(v)\n      }\n    }\n  }\n  return result\n}\n\nexport async function thenUniq<T>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T>[]>\n): Promise<T[]> {\n  const result: T[] = []\n  for (const ea of toA(await arr)) {\n    const v = await ea\n    if (v != null) {\n      result.push(v)\n    }\n  }\n  return uniq(result)\n}\n\nexport async function asyncFind<T>(\n  arr: T[],\n  f: (t: T) => Promise<boolean>\n): PromiseMaybe<T> {\n  for (const ea of arr) {\n    if (await f(ea)) return ea\n  }\n  return\n}\n\n/**\n * @see thenCollect in fe -- which doesn't have logging or timeout support\n */\nexport async function thenCollectSerial<T, V>({\n  name,\n  arr,\n  f,\n  timeoutMs\n}: {\n  name: string\n  arr: Maybe<MaybeSyncOrAsync<Maybe<T>[]>>\n  f: (t: T) => SyncOrAsync<Maybe<V>>\n  timeoutMs?: number\n}): Promise<[V, T][]> {\n  const result: [V, T][] = []\n  for (const ea of compact(await arr)) {\n    try {\n      const v = await (gt0(timeoutMs)\n        ? thenOrTimeoutError(f(ea), timeoutMs)\n        : f(ea))\n      if (v != null) result.push([v, ea])\n    } catch (error) {\n      mkLogger(name).warn(\"failed to apply\", {\n        ea,\n        error\n      })\n    }\n  }\n  return result\n}\n\nexport async function mapAsyncSerial<T, V>(\n  args: Arg0<typeof thenCollectSerial<T, V>>\n): Promise<V[]> {\n  return (await thenCollectSerial(args)).map(ea => ea[0])\n}\n\n/**\n * For each in `V[]`, apply `f(v)` concurrently, returning `[v, await f(v)]`\n * @see thenCollect\n */\nexport async function thenCollectParallel<T, V>({\n  arr,\n  f,\n  name,\n  maxConcurrent,\n  timeoutMs,\n  promises\n}: {\n  arr: Maybe<MaybeSyncOrAsync<Maybe<T>[]>>\n  f: (t: T) => SyncOrAsync<Maybe<V>>\n  name: string\n  maxConcurrent?: number\n  timeoutMs?: number\n  promises?: Promises\n}): Promise<[V, T][]> {\n  if (arr == null) return []\n  const array = compact(await arr)\n  if (isEmpty(array)) return []\n  maxConcurrent = Math.round(maxConcurrent ?? maxCpus())\n  if (maxConcurrent <= 1) return thenCollectSerial({ arr, f, name, timeoutMs })\n  const p =\n    promises ??\n    (array.length <= maxConcurrent\n      ? PermissivePromises\n      : new Promises(name, () => maxConcurrent))\n  // ^ creating new Promises() is expensive\n  const func = gt0(timeoutMs)\n    ? (t: T) => thenOrTimeoutError(f(t), timeoutMs)\n    : f\n  const t = await p.enqueueAll(\n    name,\n    array.map(ea => async () => {\n      try {\n        return [await func(ea), ea] as [V, T]\n      } catch (error) {\n        mkLogger(name).warn(\"failed to apply\", {\n          ea,\n          error\n        })\n        return\n      }\n    })\n  )\n  // compact prevents TypeError: undefined is not iterable:\n  return compact(t).filter(([k, v]) => k != null && v != null)\n}\n\n/**\n * Apply `f` to each element of `arr` concurrently, returning the results\n */\nexport async function mapAsync<T, V>({\n  arr,\n  f,\n  name,\n  maxConcurrent,\n  timeoutMs,\n  promises\n}: {\n  arr: Maybe<MaybeSyncOrAsync<Maybe<T>[]>>\n  f: (t: T) => SyncOrAsync<Maybe<V>>\n  name: string\n  maxConcurrent?: number\n  timeoutMs?: number\n  promises?: Promises\n}): Promise<V[]> {\n  return (\n    await thenCollectParallel({\n      arr,\n      f,\n      name,\n      maxConcurrent,\n      timeoutMs,\n      promises\n    })\n  ).map(ea => ea[0])\n}\n\n/**\n * @return all items in `arr` that `f` doesn't reject and returns true or\n * Promise<true>\n */\nexport async function filterAsync<T>({\n  name,\n  arr,\n  f,\n  maxConcurrent,\n  timeoutMs\n}: {\n  name: string\n  arr: Maybe<T>[]\n  f: Predicate<T>\n  maxConcurrent?: number\n  timeoutMs?: number\n}): Promise<T[]> {\n  const t = await thenCollectParallel({\n    name,\n    arr: compact(arr),\n    f,\n    maxConcurrent,\n    timeoutMs\n  })\n  return t.filter(([b]) => b).map(([, v]) => v)\n}\n\nexport async function partitionAsync<T>(\n  arr: T[],\n  filter: (t: T) => MaybeSyncOrAsync<boolean>\n): Promise<[T[], T[]]> {\n  const t = await thenCollectParallel({\n    name: \"partitionAsync\",\n    arr,\n    f: filter\n  })\n  return [\n    t.filter(([ea]) => isTrue(ea)).map(([, ea]) => ea),\n    t.filter(([ea]) => isFalse(ea)).map(([, ea]) => ea)\n  ]\n}\n\nexport async function tryAsync<T>(f: () => T | Promise<T>) {\n  try {\n    return await f()\n  } catch {\n    return\n  }\n}\n\nexport const DefaultTryAllTimeoutMs = 30 * secondMs\n\nexport async function tryAll(\n  arr: (any | (() => any))[],\n  onError = (err: Error) => console.error(err),\n  timeoutMs = DefaultTryAllTimeoutMs\n): Promise<void> {\n  for (const ea of arr) {\n    try {\n      await thenOrTimeout(ea, timeoutMs)\n    } catch (err) {\n      onError(toErr(err)!)\n    }\n  }\n  return\n}\n\nexport async function thenFinally<T>(\n  p: SyncOrAsync<T> | (() => SyncOrAsync<T>),\n  err_: (err: Error | any) => any = () => {\n    // no-op\n  },\n  finally_: (r: T | Error) => any = () => {\n    // no-op\n  }\n): Promise<T> {\n  let result: T\n  let caught = null\n  try {\n    result = await (isFunction(p) ? p() : p)\n  } catch (err) {\n    caught = toErr(err)\n    try {\n      await err_(err)\n    } catch {\n      // no-op\n    }\n  }\n  try {\n    await finally_(caught ?? result!)\n  } catch {\n    // no-op\n  }\n  if (caught != null) {\n    throw caught\n  } else {\n    return result!\n  }\n}\n\nexport async function thenNot(\n  p: Maybe<boolean> | MaybePromiseMaybe<boolean>,\n  defaultIfNull = true\n): Promise<boolean> {\n  if (p == null) return defaultIfNull\n  const r = await p\n  return r == null ? defaultIfNull : !isTrue(r)\n}\n\nexport async function thenMap2<T1, T2, T3>(\n  objP1: MaybeSyncOrAsync<T1>,\n  objP2: MaybeSyncOrAsync<T2>,\n  f: (t1: T1, t2: T2) => MaybeSyncOrAsync<T3>\n): PromiseMaybe<T3> {\n  const o1 = await objP1\n  if (o1 == null) return\n  const o2 = await objP2\n  if (o2 == null) return\n  return f(o1, o2)\n}\n\n/**\n * Safe calls for Optional promises, with default\n */\nexport async function thenMapOr<T1, T2, T3>(\n  objP: MaybeSyncOrAsync<T1>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>,\n  ifUndefined: () => SyncOrAsync<T3>\n): Promise<T2 | T3> {\n  const obj = await objP\n  if (obj == null) return ifUndefined()\n  const result = await f(obj)\n  return result == null ? ifUndefined() : result\n}\n/**\n * Safe calls for Optional promises, with default\n */\nexport async function thenMap2Or<A1, A2, R1, R2>(\n  objP1: MaybeSyncOrAsync<A1>,\n  objP2: MaybeSyncOrAsync<A2>,\n  f: (t1: A1, t2: A2) => MaybeSyncOrAsync<R1>,\n  ifUndefined: () => SyncOrAsync<R2>\n): Promise<R1 | R2> {\n  const o1 = await objP1\n  if (o1 == null) return ifUndefined()\n  const o2 = await objP2\n  if (o2 == null) return ifUndefined()\n  const result = await f(o1, o2)\n  return result == null ? ifUndefined() : result\n}\n\n/**\n * Only call f if the promise resolves to truthy\n */\nexport async function thenAnd<T>(\n  predicatePromise: MaybeNull<Promise<true | any>>,\n  f: () => SyncOrAsync<T>\n): PromiseMaybe<T> {\n  return predicatePromise != null && isTrue(await predicatePromise)\n    ? f()\n    : undefined\n}\n\nexport async function thenOrElse<T>(\n  objP: Promise<MaybeNull<T>> | MaybeNull<T>,\n  f: () => SyncOrAsync<T>\n): Promise<T> {\n  return orElse(await objP, f)\n}\n\n/**\n * Just like `firstDefinedPromise` but applies a function to all defined\n * elements in `arr`.\n */\nexport async function first<T, R>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T, index: number) => SyncOrAsync<MaybeNull<R>>\n): PromiseMaybe<R> {\n  if (arr != null) {\n    let index = -1\n    for (const t of arr) {\n      index++\n      try {\n        if (t == null) continue\n        const r = await f(t, index)\n        if (r != null) {\n          return r\n        }\n      } catch {\n        // no-op\n      }\n    }\n  }\n  return undefined\n}\n\n/**\n * @see #firstDefinedLater\n */\nexport async function firstDefinedPromise<T, U = T>(\n  promiseThunks: Thunk<MaybeSyncOrAsync<T>>[],\n  filter: (t: T) => SyncOrAsync<Maybe<U>> = identity as any\n): PromiseMaybe<U> {\n  for (const ea of promiseThunks) {\n    const o = await ea()\n    if (o != null) {\n      const result = await filter(o)\n      if (result != null) {\n        return result\n      }\n    }\n  }\n  return\n}\n\nexport async function firstResolvedDefinedPromise<T>(\n  promiseThunks: Thunk<MaybeSyncOrAsync<T>>[],\n  onError: (err: Error) => void\n): PromiseMaybe<T> {\n  for (const t of promiseThunks) {\n    try {\n      const result = await t()\n      if (result != null) {\n        return result\n      }\n    } catch (err) {\n      onError(toErr(err)!)\n    }\n  }\n  return\n}\n\nexport async function firstTruePromise<T>(\n  predicate: (t: T) => Maybe<boolean> | PromiseMaybe<boolean>,\n  ...promiseThunks: (() => MaybeSyncOrAsync<T>)[]\n): PromiseMaybe<T> {\n  for (const thunk of promiseThunks) {\n    try {\n      const ea = await thunk()\n      if (ea != null && (await predicate(ea)) === true) {\n        return ea\n      }\n    } catch (_) {\n      //\n    }\n  }\n  return\n}\n\n/**\n * @return `arr` sorted by the tuples in f. elements that `f` returns undefined\n * will be removed from the returned array.\n * @see https://en.wikipedia.org/wiki/Schwartzian_transform\n */\nexport async function sortByAsync<T, V extends Primitive | Primitive[]>({\n  name,\n  arr,\n  f\n}: {\n  name: string\n  arr: Maybe<MaybeSyncOrAsync<Maybe<T>[]>>\n  f: (t: T) => PromiseMaybe<V>\n}): Promise<T[]> {\n  const unsorted: [V, T][] = await thenCollectParallel({ name, arr, f })\n  return sortBy(unsorted, ea => ea[0]).map(ea => ea[1])\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mapNotEmpty } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, mapFinite, round, sigFigs } from \"../../fe/Number\"\nimport {\n  Obj,\n  compactValues,\n  fromEntries,\n  mapCompactObj,\n  omit\n} from \"../../fe/Object\"\nimport { opt } from \"../../fe/Opt\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { Thunk, tot } from \"../../fe/Thunk\"\nimport { toErr } from \"../../fe/toErr\"\nimport { CountingSet } from \"../CountingSet\"\nimport { Elapsed } from \"../Elapsed\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { ee } from \"../event/EventEmitter\"\nimport { Average, AverageStats } from \"../math/Average\"\nimport { EndableRanks } from \"./Endable\"\nimport { EndableWrapper } from \"./EndableWrapper\"\nimport { setUnrefTimeout } from \"./Timers\"\n\nconst MinMs = 15\n\n// by undocumented convention, names are\n// ${section}.${filename}.${function?}?:${context?}\n\nfunction normalizeName(name: string) {\n  return name.split(\":\")[0].trim()\n}\n\nexport class PromiseTimer {\n  static readonly instance = lazy(() => {\n    const pt = new PromiseTimer()\n    new EndableWrapper(\n      \"PromiseTimer\",\n      () => {\n        const logger = mkLogger(\"async.PromiseTimer\")\n        mapCompactObj(pt.report(), ea => logger.info(\"timings:\", ea))\n        mapNotEmpty(pt.errorCounts(), err =>\n          logger.warn(\"error counts:\", fromEntries(err))\n        )\n      },\n      EndableRanks.stats\n    )\n    ee().on(\"timing\", (name: string, elapsedMs: number) =>\n      pt.push(name, elapsedMs)\n    )\n    // no need to clear stats except in tests:\n    if (isTest) ee().on(\"clearCache\", () => pt.clear())\n    return pt\n  })\n  private readonly errors = new CountingSet<string>()\n  private readonly times = new Map<string, Average>()\n\n  clear() {\n    this.errors.clear()\n    this.times.clear()\n  }\n\n  async time<T>(\n    desc: string,\n    p: Promise<T> | (() => SyncOrAsync<T>),\n    post?: (result: T | Error, elapsed: number) => void\n  ): Promise<T> {\n    const start = Date.now()\n    const expectedTime = clamp(\n      10 * secondMs,\n      minuteMs,\n      Math.round(this.times.get(desc)?.p98 ?? 0)\n    )\n    const slowTimer = setUnrefTimeout(\n      () =>\n        mkLogger(\"time(\" + desc + \")\").warn(\n          \"unsettled for \" + (Date.now() - start) + \"ms\"\n        ),\n      expectedTime\n    )\n\n    try {\n      const result = await tot(p)\n      const elapsed = Date.now() - start\n      post?.(result, elapsed)\n      this.push(desc, elapsed)\n      return result\n    } catch (err) {\n      this.errors.incr(desc)\n      post?.(toErr(err)!, Date.now() - start)\n      throw err\n    } finally {\n      clearTimeout(slowTimer)\n    }\n  }\n\n  get entriesBySumDesc() {\n    return sortBy([...this.times.entries()], ([, v]) => -v.sum)\n  }\n\n  stats(namePrefix: string) {\n    const arr = this.entriesBySumDesc.filter(([k]) => k.startsWith(namePrefix))\n    const merged = arr.reduce(\n      (agg, ea) => Average.merge(ea[1], agg),\n      new Average()\n    )\n    const stats = arr.map(\n      ([name, avg]) => [name, avg.stats()] as [string, AverageStats]\n    )\n    return fromEntries([[\"merged\", merged.stats()], ...stats])\n  }\n\n  mkElapsed(l: Logger) {\n    return new Elapsed(l, (s, ts) => this.push(s, ts))\n  }\n\n  push(name: string, elapsedMs: number) {\n    if (elapsedMs > MinMs) {\n      getOrSet(this.times, normalizeName(name), () => new Average()).push(\n        elapsedMs\n      )\n    }\n  }\n\n  weightedAvg(name: string): Maybe<number> {\n    return opt(this.times.get(normalizeName(name)))\n      .map(avg => avg.weightedSampleAvg)\n      .get()\n  }\n\n  errorCounts() {\n    return this.errors.top(10)\n  }\n\n  callCounts(): { [name: string]: number } {\n    return [...this.times.entries()].reduce(\n      (o, [k, v]) => ({ ...o, [k]: v.n }),\n      {}\n    )\n  }\n\n  weightedAvgs(): { [name: string]: number } {\n    return compactValues(\n      [...this.times.entries()].reduce(\n        (o, [k, v]) => ({ ...o, [k]: mapFinite(v.weightedSampleAvg, round) }),\n        {}\n      )\n    ) as any\n  }\n\n  toJSON() {\n    return this.entriesBySumDesc.reduce(\n      (o, [k, v]) => ({\n        ...o,\n        [k]: v.toJSON()\n      }),\n      {}\n    )\n  }\n\n  report(): { [name: string]: Obj } {\n    // Sort by most time first:\n    return this.entriesBySumDesc.reduce(\n      (o, [k, v]) => ({\n        ...o,\n        [k]: {\n          sumSec: sigFigs(v.sum / secondMs, 3),\n          ...omit(v.stats(), \"sum\")\n        }\n      }),\n      {}\n    )\n  }\n}\n\nexport function mkElapsed(name: string) {\n  return PromiseTimer.instance().mkElapsed(mkLogger(name))\n}\n\nexport function time<T>(\n  name: string,\n  p: Promise<T> | (() => SyncOrAsync<T>),\n  post?: (result: T | Error, elapsed: number) => void\n): Promise<T> {\n  return PromiseTimer.instance().time(name, p, post)\n}\n\nexport function timeSync<T>(name: string, t: Thunk<T>): T {\n  const start = Date.now()\n  const result = t()\n  pushTime(name, Date.now() - start)\n  return result\n}\n\nexport function pushTime(name: string, elapsedMs: number) {\n  PromiseTimer.instance().push(name, elapsedMs)\n}\n\nexport function timeStats(namePrefix: string) {\n  return PromiseTimer.instance().stats(namePrefix)\n}\n\nexport function timedLazy<T>(\n  name: string,\n  thunk: () => SyncOrAsync<T>,\n  ttlMs?: number\n) {\n  return lazy(async () => time(name, thunk), ttlMs)\n}\n","import events from \"events\"\nimport { compact, count, filterInPlace, isEmpty, remove } from \"../../fe/Array\"\nimport { Later } from \"../../fe/Later\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { Comparable } from \"../../fe/Primitive\"\nimport { Thunk, tot } from \"../../fe/Thunk\"\nimport { toS } from \"../../fe/toS\"\nimport { BoundedList } from \"../BoundedList\"\nimport { TypedEventEmitter } from \"../event/TypedEventEmitter\"\nimport { Average } from \"../math/Average\"\nimport { maxCpus } from \"../work/MaxCpus\"\nimport { Deferred } from \"./Deferred\"\n\nexport type NamedObject = Record<string, any> & { name: string }\n\nexport function toName(o: string | NamedObject) {\n  return (o as any)?.name ?? toS(o)\n}\n\nexport interface PromisesEvents {\n  vacancy: () => void\n  drain: () => void\n}\n\n/**\n * Aggregate promises efficiently\n *\n * Note that `N` is either a descriptive name for the promise, or can be a data\n * payload associated to the promise.\n */\nexport class Promises {\n  readonly ee = new events.EventEmitter() as TypedEventEmitter<PromisesEvents>\n\n  #maxConcurrency: Maybe<Thunk<Maybe<number>>>\n  lastWorkTs = 0\n  settleMsAvg = new Average()\n\n  #settledCount = 0\n  readonly #running: Deferred<any>[] = []\n  readonly #pending: {\n    d: Deferred<any>\n    l: Later<any>\n  }[] = []\n\n  readonly lastPushedNames = new BoundedList<string>(16)\n\n  constructor(\n    readonly name: string,\n    maxConcurrency?: Thunk<Maybe<number>>\n  ) {\n    this.#maxConcurrency = maxConcurrency\n  }\n\n  get maxConcurrency(): number {\n    return Math.floor(\n      clamp(1, maxCpus(), this.#maxConcurrency?.() ?? maxCpus())\n    )\n  }\n\n  end() {\n    this.#pending.length = 0\n    return this.awaitAll()\n  }\n\n  vacuum() {\n    filterInPlace(this.#running, ea => ea.isPending)\n  }\n\n  private get running() {\n    this.vacuum()\n    return this.#running\n  }\n\n  /**\n   * @return the total number of promises that have settled\n   */\n  get settledCount() {\n    return this.#settledCount\n  }\n\n  stats() {\n    return {\n      maxConcurrency: this.maxConcurrency,\n      lastPushMsAgo: Date.now() - this.lastWorkTs,\n      freeSlots: this.freeSlots(),\n      unsettledCount: this.unsettledCount(),\n      runningNames: this.#running.map(ea => ea.name),\n      pendingNames: this.#pending.map(ea => ea.d.name),\n      totalWorkCount: this.#settledCount\n    }\n  }\n\n  #enqueue<T>({\n    name,\n    l,\n    payload,\n    serialId\n  }: {\n    name: string\n    l: Later<T>\n    payload?: any\n    serialId?: Comparable\n  }) {\n    const d = new Deferred<T>(name, { payload, serialId })\n    this.#pending.push({ d, l })\n    return d\n  }\n\n  /**\n   * Start the given promise once concurrency is below\n   */\n  enqueue<T>({\n    name,\n    l,\n    payload,\n    serialId\n  }: {\n    name: string\n    l: Later<T>\n    payload?: any\n    serialId?: Comparable\n  }): Deferred<T> {\n    const d = this.#enqueue({ name, l, payload, serialId })\n    this.laterPop()\n    return d\n  }\n\n  enqueueAll<T>(name: string, laters: Later<T>[]): Promise<T[]> {\n    const p = laters.map(l => this.#enqueue({ name, l }).promise)\n    this.laterPop()\n    return Promise.all(p)\n  }\n\n  /**\n   * Run f() after all prior-enqueued promises with the same name have resolved.\n   */\n  serial<T>(name: string, f: () => Promise<T>): Promise<T> {\n    return this.enqueue({ name, l: f, serialId: name })\n  }\n\n  /**\n   * Immediately run the given promise\n   */\n  push<T>(\n    name: string,\n    promiseOrLater: Promise<T> | Later<T>,\n    payload?: any\n  ): Promise<T> {\n    return this.#pushDeferred(\n      new Deferred<T>(name, { payload }),\n      promiseOrLater\n    ).promise\n  }\n\n  #pushDeferred<T>(d: Deferred<T>, promiseOrLater: Promise<T> | Later<T>) {\n    const start = Date.now()\n    this.lastWorkTs = start\n\n    void d.observe(tot(promiseOrLater)).finally(() => {\n      this.#settledCount++\n      remove(this.#running, d)\n      this.settleMsAvg.push(Date.now() - start)\n      this.laterPop()\n    })\n    this.lastPushedNames.push(d.name)\n    this.#running.push(d)\n    return d\n  }\n\n  /**\n   * If there are any free slots and pending work, this may enqueue pending\n   * work.\n   */\n  laterPop() {\n    setImmediate(() => this.maybePopPendingWork())\n  }\n\n  // this doesn't need a mutex (like oneAtATime) because it's not async:\n  maybePopPendingWork() {\n    this.vacuum()\n    const maxJobsToStart = this.maxConcurrency - this.#running.length\n    if (maxJobsToStart === 0) {\n      return\n    }\n    // vacancy AND drain TESTS MUST BE DONE IN THIS ORDER:\n    if (isEmpty(this.#pending) && maxJobsToStart > 0) {\n      // listeners may add pending work, so this should be first:\n      this.ee.emit(\"vacancy\")\n    }\n    // If we're still empty after emitting vacancy, we're drained:\n    if (this.isIdle()) {\n      this.ee.emit(\"drain\")\n    }\n    const jobsToStart = Math.min(this.#pending.length, maxJobsToStart)\n    const runningSerialIds = compact(this.#running.map(ea => ea.serialId))\n    const blockedBySerialId = []\n    for (let i = 0; i < jobsToStart; i++) {\n      const pending = this.#pending.shift()!\n      if (pending == null) break // < shouldn't happen, but it's a backstop for Later Me to hit.\n      if (\n        pending.d.serialId != null &&\n        runningSerialIds.includes(pending.d.serialId)\n      ) {\n        // Nope, shove it to the back of the queue.\n        blockedBySerialId.push(pending)\n        // But keep going: other pending tasks may be eligible to run now!\n      } else {\n        if (pending.d.serialId != null) {\n          // Don't push another of these!\n          runningSerialIds.push(pending.d.serialId)\n        }\n        void this.#pushDeferred(pending.d, pending.l)\n      }\n    }\n    this.#pending.push(...blockedBySerialId)\n  }\n\n  isTaskRunning(taskName: string) {\n    return this.#running.some(ea => ea.name === taskName)\n  }\n\n  /**\n   * If you don't care about the returned promise: only run f() if all prior\n   * with the same name have finished, and return no-op otherwise\n   */\n  maybeRun<T>(name: string, f: () => Promise<T>): Maybe<Promise<T>> {\n    return this.freeSlots() > 0 && !this.isTaskRunning(name)\n      ? this.push(name, f)\n      : undefined\n  }\n\n  runningCount() {\n    return count(this.#running, ea => ea.isPending)\n  }\n\n  /**\n   * @return the count of both currently-running *and* enqueued jobs.\n   */\n  unsettledCount() {\n    // We don't want to muck with _arr state, so use this._arr directly:\n    return this.runningCount() + this.#pending.length\n  }\n\n  /**\n   * @return true if there are jobs that are running or enqueued.\n   */\n  hasPending() {\n    return this.#pending.length > 0 || this.running.length > 0\n  }\n\n  isIdle() {\n    return !this.hasPending()\n  }\n\n  freeSlots() {\n    return clamp(\n      0,\n      this.maxConcurrency,\n      this.maxConcurrency - this.unsettledCount()\n    )\n  }\n\n  isFull() {\n    return this.freeSlots() === 0\n  }\n\n  pendingNames(): string[] {\n    return [\n      ...this.#pending.map(ea => ea.d.name),\n      ...this.running.map(ea => ea.name)\n    ]\n  }\n\n  get deferreds() {\n    return [...this.running, ...this.#pending.map(ea => ea.d)]\n  }\n\n  pendingWithName(name: string) {\n    return this.deferreds.filter(ea => ea.name === name)\n  }\n\n  payloadsWithName(name: string) {\n    return this.pendingWithName(name)\n      .filter(ea => ea.payload != null)\n      .map(ea => ea.payload!)\n  }\n\n  get pendingPromises() {\n    return this.deferreds.map(ea => ea.promise)\n  }\n\n  /**\n   * @return a promise that will be resolved when all previously pushed and\n   * enqueued Promises are resolved. Rejections are swallowed.\n   * @see Promise.allSettled\n   */\n  async awaitSettled() {\n    await Promise.allSettled(this.pendingPromises)\n  }\n\n  /**\n   * @return a promise that will be resolved when all previously pushed and\n   * enqueued Promises are resolved, or any promises are rejected.\n   * @see Promise.all\n   */\n  async awaitAll() {\n    await Promise.all(this.pendingPromises)\n  }\n\n  async awaitAllByName(name: string) {\n    await Promise.all(\n      this.deferreds.filter(ea => ea.name === name).map(ea => ea.promise)\n    )\n  }\n}\n\n/**\n * Run the given thunk never more than once concurrently. Invocations while\n * prior runs were invoked will return after prior runs have completed but will\n * be no-ops.\n */\nexport function maybeRun<T>(\n  name: string,\n  l: Later<T>\n): () => Maybe<Promise<T>> {\n  const p = new Promises(name)\n  return () => p.maybeRun(name, l)\n}\n\nexport async function withBoundedConcurrency<T>({\n  name,\n  laters,\n  maxConcurrent\n}: {\n  name: string\n  laters: Later<T>[]\n  maxConcurrent?: number\n}): Promise<T[]> {\n  // SITS: NOTE: if we share the same Promises instance, and a code block within\n  // withBoundedConcurrency calls withBoundedConcurrency, we'll starve.\n  return new Promises(\n    name,\n    map(maxConcurrent, ea => () => ea)\n  ).enqueueAll(name, laters)\n}\n\nexport const PermissivePromises: Pick<Promises, \"enqueueAll\"> = {\n  enqueueAll<T>(_name: string, laters: Later<T>[]): Promise<T[]> {\n    return Promise.all(laters.map(f => f()))\n  }\n}\n","import { Later } from \"../../fe/Later\"\n\nexport class SerialLaterQueue<T> {\n  #prior: Promise<any> = Promise.resolve()\n\n  enqueue(later: Later<T>): Promise<T> {\n    return (this.#prior = this.#prior.catch().then(later))\n  }\n}\n","import { asPromise } from \"../../fe/AsPromise\"\nimport { delay } from \"../../fe/Delay\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\n\nexport const timeoutStacks: string[][] = []\n\n// TODO: convert consumers to fe/thenOrTimeout?\nexport async function thenOrTimeout<T>(\n  p: T | (() => T | Promise<T>),\n  timeoutMs: number,\n  onTimeout?: () => any,\n  onSuccess?: (t: T) => any | Promise<any>\n): PromiseMaybe<T> {\n  if (!gt0(timeoutMs)) {\n    const result = await asPromise(p)\n    await onSuccess?.(result)\n    return result\n  }\n  let _resolved = false\n  let timedOut = false\n  let result: Maybe<T>\n  await Promise.race([\n    asPromise(p).then(ea => {\n      if (!timedOut) {\n        result = ea\n        _resolved = true\n        return ea\n      } else {\n        return\n      }\n    }),\n    // This delay must be unref'ed so as to not prevent node from exitting:\n    delay(timeoutMs).then(() => {\n      if (!_resolved) {\n        timedOut = true\n      }\n    })\n  ])\n  if (_resolved) {\n    await onSuccess?.(result!)\n  } else {\n    await onTimeout?.()\n  }\n  return result\n}\n","// no-dependency onTimeout, to be set to ../work/WorkTimeout.onTimeout by\n// SyncService to avoid dependency loops\n\nlet timeoutHandler = (_soft?: boolean) => null\n\nexport function setTimeoutHandler(f: typeof timeoutHandler) {\n  timeoutHandler = f\n}\n\nexport function onTimeout({ soft }: { soft?: boolean } = {}) {\n  timeoutHandler(soft)\n}\n","import { setInterval, setTimeout } from \"timers\"\n\nexport function setUnrefTimeout(\n  callback: (...ea: any[]) => void,\n  ms: number,\n  ...args: any[]\n): NodeJS.Timeout {\n  return setTimeout(callback, Math.round(ms), ...args).unref()\n}\n\nexport function setUnrefInterval(\n  callback: (...ea: any[]) => void,\n  ms: number,\n  ...args: any[]\n): NodeJS.Timeout {\n  return setInterval(callback, Math.round(ms), ...args).unref()\n}\n","import { isTrue } from \"../../fe/Boolean\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { delay } from \"../../fe/Delay\"\nimport { isFunction } from \"../../fe/isFunction\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { MaybeSyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { onTimeout } from \"./TimeoutHandler\"\n\nexport type UntilOpts<T> = {\n  timeoutMs?: number\n  intervalMs?: number\n  acceptable?: (t: Maybe<T>) => boolean\n  timeoutResult?: T\n  unref?: boolean\n}\n\n/**\n * Run `f()` until the result either passes `acceptable`, or is not `null`,\n * `undefined` or `false`.\n */\nexport async function until<T>(\n  f: () => MaybeSyncOrAsync<T>,\n  { timeoutMs, intervalMs, acceptable, timeoutResult, unref }: UntilOpts<T> = {}\n): PromiseMaybe<T> {\n  let sentSoftTimeout = false\n  const timeoutAt = timeoutMs == null ? undefined : timeoutMs + Date.now()\n  let delayCount = 1\n  while (timeoutAt == null || Date.now() < timeoutAt) {\n    const start = Date.now()\n    const result = await f()\n    const accept =\n      result != null &&\n      (isFunction(acceptable) ? acceptable(result) : (result as any) !== false)\n\n    if (accept) {\n      return result\n    } else {\n      const elapsedMs = Date.now() - start\n      if (timeoutMs != null && elapsedMs > timeoutMs / 2 && !sentSoftTimeout) {\n        sentSoftTimeout = true\n        onTimeout({ soft: true })\n      }\n      const delayMs =\n        intervalMs ??\n        clamp(\n          10 * delayCount, // < wait longer for subsequent delays.\n          ShortCommandTimeoutMs,\n          (timeoutMs ?? minuteMs) / 5\n        )\n      await delay(delayMs, unref)\n      delayCount++\n    }\n  }\n  if (!sentSoftTimeout) onTimeout({ soft: false })\n  return timeoutResult\n}\n\n/**\n * Run the given thunk until the promise is resolved to true, or the timeout\n * passes.\n * @return false on timeout, or true when the the given Later returned true.\n */\nexport async function untilTrue(\n  f: () => MaybeSyncOrAsync<boolean>,\n  opts: Omit<UntilOpts<boolean>, \"acceptable\" | \"timeoutResult\"> = {}\n): Promise<boolean> {\n  return until(f, {\n    ...opts,\n    acceptable: isTrue,\n    timeoutResult: false\n  }) as Promise<boolean>\n}\n","import child_process from \"child_process\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport {\n  compactValues,\n  entries,\n  filter,\n  fromEntries,\n  omit,\n  StringValued,\n  values\n} from \"../../fe/Object\"\nimport { partition } from \"../Array\"\nimport { env } from \"../env/Env\"\nimport {\n  ELECTRON_RUN_AS_NODE,\n  PS_IS_CHILD_PROCESS,\n  PS_IS_DOCKER\n} from \"../env/EnvKeys\"\nimport { caseInsensitiveEnv } from \"../env/GetEnv\"\nimport { ee } from \"../event/EventEmitter\"\nimport { childProcLocale } from \"../Locale\"\nimport { isLogged } from \"../log/LogFilter\"\nimport { mkLogger } from \"../Logger\"\nimport { nodeEnv } from \"../NodeEnv\"\nimport { mapEntries, sortedKeys } from \"../Object\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { isElectron, isPosix } from \"../platform/Platform\"\nimport {\n  allSettings,\n  getSettingByNameOrKey,\n  pathWithDefaults,\n  persistedSettings,\n  Settings,\n  transientSettings\n} from \"../settings/Settings\"\n\nconst SettingsKeys = lazy(() => new Set(values(Settings).map(ea => ea.key)))\n\nexport function psenv(): StringValued {\n  const set = SettingsKeys()\n  return sortedKeys(filter(env(), k => k === \"NODE_ENV\" || set.has(k)))\n}\n\nconst sensitiveEnvRE = lazy(() => {\n  try {\n    return new RegExp(Settings.sensitiveEnvRegExp.valueOrDefault, \"i\")\n  } catch (err) {\n    console.error(\n      `Invalid setting for \"sensitiveEnvRegExp\": ${err}. Using default value.`\n    )\n    return new RegExp(Settings.sensitiveEnvRegExp.defaultValue, \"i\")\n  }\n})\n\nlater(() => {\n  function unset() {\n    sensitiveEnvRE.unset()\n    sanitizedEnv.unset()\n  }\n  ee().on(\"clearCache\", unset)\n  ee().on(\"settingsChanged\", unset)\n  for (const ea of allSettings()) {\n    // allSettings because anything might need to be included in the child env!\n    ea.watchLater(unset)\n  }\n})\n\nconst RequiredPosixEnv = [\"HOME\", \"LANG\", \"USER\"]\nconst RequiredWindowsEnv = [\n  \"APPDATA\",\n  \"HOME\",\n  \"HOMEDRIVE\",\n  \"LOCALAPPDATA\",\n  \"SYSTEMDRIVE\",\n  \"SYSTEMROOT\",\n  \"TEMP\"\n]\n\nconst requiredEnv = lazy(() => {\n  const result = caseInsensitiveEnv().pick(\n    ...(isPosix ? RequiredPosixEnv : RequiredWindowsEnv)\n  )\n  // set PATH, and respect prior case:\n  const p = caseInsensitiveEnv().lookup(\"PATH\")\n  result[p?.key ?? \"PATH\"] = pathWithDefaults()\n  return result\n})\n\nexport const sanitizedEnv = lazy(() => {\n  const re = sensitiveEnvRE()\n  return mapEntries(process.env, (k, v) => (re.exec(k) == null ? v : undefined))\n})\n\nexport function childProcEnvSettings(forWorker: boolean) {\n  const result: StringValued = {\n    NODE_ENV: nodeEnv,\n    NO_COLOR: \"1\" // children shouldn't be rendering anything to the terminal\n  }\n  result[PS_IS_CHILD_PROCESS] = \"1\"\n\n  if (isDocker()) {\n    result[PS_IS_DOCKER] = \"1\"\n  }\n  if (isElectron) {\n    result[ELECTRON_RUN_AS_NODE] = \"1\"\n  }\n\n  for (const s of persistedSettings().filter(ea => ea.hasValue())) {\n    forWorker ? s.addToEnv(result) : s.addToEnvMaybe(result)\n  }\n  return result\n}\n\nexport type SpawnOptionsWithLocale = child_process.SpawnOptions & {\n  forceCLocale?: boolean\n  forThread?: boolean\n}\n\nexport function spawnOptions(\n  maybeOpts?: SpawnOptionsWithLocale\n): child_process.SpawnOptions {\n  const opts: SpawnOptionsWithLocale = maybeOpts ?? {}\n  return {\n    ...omit(opts, \"forceCLocale\"),\n    env: childEnv({\n      overrides: opts.env,\n      forceCLocale: opts.forceCLocale\n    }),\n    detached: false,\n    shell: false\n    // NOTE: don't use `windowsHide: true`, it doesn't work!\n  }\n}\n\nlet childEnvLogged = false\n\nexport function childEnv({\n  overrides,\n  forceCLocale = true,\n  forWorker = false\n}: {\n  overrides?: Maybe<StringValued>\n  forceCLocale?: boolean\n  forWorker?: boolean\n} = {}) {\n  const e: StringValued = compactValues({\n    // Include all (non-sensitive) env values, because things like `gio` need\n    // GNOME* and DBUS* variables set:\n    ...sanitizedEnv(),\n    ...requiredEnv(),\n    ...(forceCLocale ? childProcLocale() : {}),\n    ...childProcEnvSettings(forWorker),\n    ...(overrides ?? {}) // < env param wins\n  })!\n\n  // Don't let parent ENV set transients:\n  for (const s of transientSettings()) {\n    s.deleteFromEnv(e)\n  }\n\n  if (isLogged(\"debug\") && !childEnvLogged) {\n    childEnvLogged = true\n    const logger = mkLogger(\"child.ChildEnv\")\n    const arr = entries(e)\n    const [ps, nonPs] = partition(\n      arr,\n      ([k]) =>\n        k === \"TZ\" ||\n        k === \"NODE_ENV\" ||\n        k.startsWith(\"LC_\") ||\n        // we have some env that aren't settings (like PS_KEEP_LIBRARY):\n        k.startsWith(\"PS_\") ||\n        getSettingByNameOrKey(k) != null\n    )\n    logger.debug(\"PS env:\", fromEntries(ps))\n    logger.debug(\"non PS env:\", fromEntries(nonPs))\n  }\n\n  return sortedKeys(e)\n}\n","import child_process from \"child_process\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Latch } from \"../../fe/Latch\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt, gt0, isNumber } from \"../../fe/Number\"\nimport { omit, pick } from \"../../fe/Object\"\nimport { trimLastNewline } from \"../../fe/String\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { mkLogger } from \"../Logger\"\nimport { isSingleSpecTests } from \"../NodeEnv\"\nimport { Try } from \"../Object\"\nimport { waitForPidExit } from \"../Pid\"\nimport { Pids, addPid, killPid } from \"../Pids\"\nimport { niceable, renice } from \"../Renice\"\nimport { Deferred } from \"../async/Deferred\"\nimport { setUnrefTimeout } from \"../async/Timers\"\nimport { isIgnorableError } from \"../error/ErrorTypes\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { closeStreams, endStream } from \"../fs/Streams\"\nimport { isLogged } from \"../log/LogFilter\"\nimport { spawnOptions } from \"./ChildEnv\"\n\nconst logger = lazy(() => mkLogger(\"child.ChildProcess\"))\n\nfunction cp2log(cp: child_process.ChildProcess) {\n  return pick(\n    cp as any,\n    \"pid\",\n    \"killed\",\n    \"connected\",\n    \"exitCode\",\n    \"signalCode\",\n    \"spawnfile\",\n    \"spawnargs\"\n  )\n}\n\nexport async function endProcess(\n  cp: Maybe<child_process.ChildProcess>,\n  timeoutMs = 30 * secondMs\n): Promise<boolean> {\n  if (cp == null) return false\n  logger().debug(\"endProcess()\", cp2log(cp))\n\n  const pid = cp.pid\n\n  if (pid == null || pid <= 0) {\n    logger().warn(\"endProcess(): asked to end invalid pid\", cp2log(cp))\n    return false\n  }\n  if (pid === process.pid) {\n    logger().warn(\"endProcess(): asked to end MY pid\", cp2log(cp))\n    return false\n  }\n  if (pid === process.ppid) {\n    logger().warn(\"endProcess(): asked to end my parent pid\", cp2log(cp))\n    return false\n  }\n\n  closeStreams(cp)\n\n  {\n    // Send a SIGTERM\n    const killResult = cp.kill()\n    logger().debug(\"endProcess(\" + pid + \")\", {\n      killResult,\n      childGotSigterm: cp.killed\n    })\n    if (!killResult) {\n      await killPid(pid).catch(err => {\n        logger().warn(\"endProcess(): kill(\" + pid + \",false) failed: \" + err)\n      })\n    }\n  }\n\n  // We don't use messaging, but in case we do later:\n  // TODO: do we need to do this?\n  // if (cp.connected) Try(() => cp.disconnect())\n\n  // We can exit even if this child is still running:\n  Try(() => cp.unref())\n\n  // don't wait for cleanup if we're running tests:\n  if (isSingleSpecTests()) return true\n\n  if (await waitForPidExit(pid, timeoutMs)) {\n    logger().debug(\"endProcess(): exitted\", cp2log(cp))\n    return true\n  }\n\n  {\n    // OK, shite got real. time for kill -9.\n    void Pids.instance()?.onKill(pid)\n    const killResult = cp.kill(\"SIGKILL\")\n    logger().warn(\"endProcess(\" + pid + \") had to resort to SIGKILL\", {\n      killResult\n    })\n    if (!killResult) {\n      await killPid(pid, true).catch(err => {\n        logger().warn(\"endProcess(): kill(\" + pid + \",true) failed: \" + err)\n      })\n    }\n  }\n\n  // Give the OS some time to clean up:\n  return waitForPidExit(pid, 5000)\n}\n\nexport const ReniceAfterMs = lazy(() => 15 * secondMs)\nexport const AddPidAfterMs = lazy(() => 30 * secondMs)\n\n// NOTE: MUST NOT BE ASYNC\nfunction newProc(\n  cp: child_process.ChildProcess,\n  cmd: string,\n  args: ReadonlyArray<string>,\n  timeoutMs = 0\n) {\n  const start = new Date()\n  // If we write the pidfile now and hold up processing, `cp.stderr` and\n  // `cp.stdout` event listeners will miss initial data, so we put this in a\n  // timeout for later.\n\n  // Note that THIS IS NOT UNREF'ed! We want pids to be cleaned up!\n\n  const timeouts: NodeJS.Timeout[] = []\n\n  // Renice after a second\n  if (niceable(cmd, args)) {\n    timeouts.push(\n      setUnrefTimeout(\n        () => {\n          if (gt0(cp.pid)) {\n            void renice(cp.pid)\n          }\n        },\n        ReniceAfterMs() // only track and renice processes that run for a while\n      )\n    )\n  }\n\n  // Force-end processes after maxAgeMs\n  if (gt(timeoutMs, secondMs)) {\n    timeouts.push(\n      setUnrefTimeout(() => {\n        if (gt0(cp.pid)) {\n          void endProcess(cp)\n        }\n      }, timeoutMs - 250)\n    )\n  }\n\n  // Track long-lived processes:\n  timeouts.push(\n    setUnrefTimeout(\n      () => {\n        if (gt0(cp.pid)) {\n          return addPid(\n            { pid: cp.pid, cmd, timeoutMs, ppid: process.pid },\n            start\n          )\n        }\n        return\n      },\n      AddPidAfterMs() // only track and renice processes that run for a while\n    )\n  )\n  // This allows cp resources to be GC'ed:\n  cp.on(\"exit\", () => timeouts.forEach(clearTimeout))\n\n  return cp\n}\n\nexport function spawn(\n  command: string,\n  args: ReadonlyArray<string>,\n  maxAgeMs: number,\n  options?: child_process.SpawnOptions\n): child_process.ChildProcess {\n  const opts = spawnOptions(options)\n  logger().debug(\"spawn()\", { command, args, maxAgeMs })\n  return newProc(\n    child_process.spawn(command, args, opts),\n    command,\n    args,\n    maxAgeMs\n  )\n}\n\nexport type ExecFileOptions =\n  | child_process.ExecFileOptions\n  | child_process.ExecFileOptionsWithBufferEncoding\n  | child_process.ExecFileOptionsWithStringEncoding\n\nexport function execFile(\n  command: string,\n  args: ReadonlyArray<string>,\n  timeoutMs?: number,\n  options?: ExecFileOptions\n): child_process.ChildProcess {\n  const opts = spawnOptions(options)\n  // Only log the opts (which are long: they include ENV!) if we're tracing:\n  if (isLogged(\"trace\", logger().context)) {\n    logger().debug(\"execFile()\", { command, args, timeoutMs, opts })\n  } else {\n    logger().debug(\"execFile()\", { command, args, timeoutMs })\n  }\n\n  return newProc(\n    child_process.execFile(command, args, opts),\n    command,\n    args,\n    timeoutMs\n  )\n}\n\nexport type StdoutOpts = {\n  timeoutMs: number\n  quiet?: boolean\n  disconnect?: boolean\n  ignoreStderr?: boolean\n  ignoreExitCode?: boolean\n  isIgnorableError?: (err: any) => boolean\n} & child_process.ExecFileOptions\n\nexport type StdoutResult = {\n  result: string\n  pid?: number\n  code?: number\n  signal?: string\n}\n\nexport async function stdoutResult_(\n  cmd: string,\n  args: string[],\n  opts: StdoutOpts\n): Promise<StdoutResult> {\n  const quiet = opts.quiet ?? false\n  const ignoreStderr = opts.ignoreStderr ?? false\n  const ignoreExitCode = opts.ignoreExitCode ?? false\n  const proc: child_process.ChildProcess = execFile(\n    cmd,\n    args,\n    opts.timeoutMs,\n    omit(opts, \"timeout\", \"quiet\", \"ignoreStderr\", \"ignoreExitCode\")\n  )\n\n  if (opts.disconnect === true) {\n    try {\n      // disconnect may not exist!\n      proc.disconnect?.()\n    } catch {\n      //\n    }\n    return { result: \"\", pid: proc.pid! }\n  }\n\n  const pid = proc.pid\n  // don't panic if we don't have a pid yet: this happens on Windows!\n\n  const name = stringify({ pid, cmd, args })\n  const stdoutChunks: (Buffer | string)[] = []\n  const stderrChonks: (Buffer | string)[] = []\n  const errors: Error[] = []\n  const exitCode = new Deferred<number>(name)\n\n  proc.on(\"error\", err => errors.push(err))\n  proc.on(\"exit\", e => {\n    if (isNumber(e) && exitCode.isPending) void exitCode.resolve(e)\n  })\n  proc.on(\"close\", e => {\n    if (isNumber(e) && exitCode.isPending) void exitCode.resolve(e)\n  })\n\n  void endStream(proc.stdin)\n\n  const stdoutEnded = new Latch()\n\n  if (proc.stdout == null) {\n    void stdoutEnded.resolve()\n  } else {\n    proc.stdout.on(\"error\", err => errors.push(err))\n    proc.stdout.on(\"data\", data => stdoutChunks.push(data))\n    proc.stdout.on(\"end\", () => stdoutEnded.resolve())\n  }\n\n  const stderrEnded = new Latch()\n\n  if (proc.stderr == null || ignoreStderr) {\n    void stderrEnded.resolve()\n  } else {\n    proc.stderr?.on(\"error\", err => errors.push(err))\n    proc.stderr?.on(\"data\", err => stderrChonks.push(err))\n    proc.stderr?.on(\"end\", () => stderrEnded.resolve())\n  }\n\n  logger().debug(\"stdoutResult_() invoked and waiting for completion...\", {\n    name\n  })\n\n  // Wait for the process to finish...\n  await thenOrTimeoutError(exitCode.promise, opts.timeoutMs)\n\n  logger().debug(\"stdoutResult_() exitCode settled...\", {\n    name,\n    exitCode: exitCode.value,\n    stdout: stdoutEnded.state(),\n    stderr: stderrEnded.state()\n  })\n\n  // Wait for chonks (which may show up AFTER the process exits). It shouldn't\n  // take long to flush these streams.\n  await thenOrTimeoutError(stdoutEnded.promise, 2 * secondMs)\n\n  await thenOrTimeoutError(stderrEnded.promise, 2 * secondMs)\n\n  // Add stderr chunks to errors:\n  const stderr = stderrChonks.join(\"\")\n  if (notBlank(stderr)) errors.push(new Error(stderr))\n  if (!quiet && isNotEmpty(errors)) {\n    logger().warn(name + \" resulted in errors:\", errors)\n  }\n\n  // Any errors that we can't ignore?\n  const isIgnorableFunc = opts.isIgnorableError ?? isIgnorableError\n  const causes = errors.filter(ea => isIgnorableFunc(ea) !== true)\n  if (causes.length > 0) {\n    throw causes.length === 1\n      ? causes[0]\n      : new WrappedError(\"Failed to run \" + cmd + \" \" + args.join(\" \"), {\n          causes\n        })\n  }\n\n  // Was the exit code sad?\n  if (!ignoreExitCode && exitCode.value !== 0) {\n    throw new Error(name + \": exit code \" + exitCode.value)\n  }\n\n  const result = stdoutChunks.join(\"\")\n\n  return {\n    result,\n    pid,\n    code: exitCode.value\n  }\n}\n\n/**\n * @return just the stdout stream\n * @see stdoutResult_ if you need more information about the command.\n */\nexport async function stdout_(\n  cmd: string,\n  args: string[],\n  opts: StdoutOpts\n): Promise<string> {\n  const result = await stdoutResult_(cmd, args, opts)\n  return logger().tap({\n    level: \"trace\",\n    msg: \"stdout_()\",\n    result: trimLastNewline(result.result),\n    meta: { cmd, args, opts, result }\n  })\n}\n","import child_process from \"child_process\"\nimport { randomInt } from \"crypto\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { orElse } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { Obj, pick } from \"../../fe/Object\"\nimport { ServiceName } from \"../../fe/ServiceNames\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { KB } from \"../../fe/Units\"\nimport { toA } from \"../../fe/toA\"\nimport { toErr } from \"../../fe/toErr\"\nimport { toS } from \"../../fe/toS\"\nimport { parseJSON } from \"../JSON\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { ensureSuffix } from \"../String\"\nimport { Endable, EndableRanks, addEndable } from \"../async/Endable\"\nimport { isIgnorableError } from \"../error/ErrorTypes\"\nimport { BaseFile } from \"../fs/BaseFile\"\nimport { isPacked } from \"../platform/IsPacked\"\nimport { isElectron } from \"../platform/Platform\"\nimport { SpawnOptionsWithLocale } from \"./ChildEnv\"\nimport { spawn } from \"./ChildProcess\"\nimport { ChildServiceExitCommand } from \"./ChildServiceExitCommand\"\nimport { serviceExitTimeoutMs } from \"./ServiceExitTimeoutMs\"\nimport {\n  WatchedChild,\n  WatchedChildListener,\n  WatchedChildOpts\n} from \"./WatchedChild\"\n\nconst logger = lazy(() => mkLogger(\"child.ChildService\"))\n\n/**\n * Find the path the given command.\n *\n * If we're running from mocha, we want callerDirname + cmdBase. If this is\n * running in packaged electron, the script will live in the asar bundle.\n */\nexport async function pathToService(cmdBase: ServiceName): Promise<BaseFile> {\n  const cmd = ensureSuffix(cmdBase, \".js\")\n  const root = BaseFile.projectRoot()\n  const currDir = BaseFile.for(process.cwd())\n  const paths = isPacked()\n    ? [\n        // Expected path for PhotoStructure for Servers:\n        root.join(\"bin\", cmd),\n        // Expected electron production path is in the root of app.asar:\n        isElectron ? root.join(\"app.asar\", cmd) : undefined\n      ]\n    : [\n        // library tests:\n        currDir.join(\"dist\", \"library\", cmd),\n        // core tests (worker, logtail, and logcat are in core):\n        currDir.join(\"dist\", \"core\", cmd),\n        // desktop tests:\n        currDir.join(\"lib\", \"library\", cmd)\n      ]\n\n  // for running out of src/desktop:\n  paths.push(currDir.join(\"dist\", \"app\", cmd))\n\n  for (const ea of paths) {\n    if (\n      ea != null &&\n      true === (await ea.isNonEmptyFile(isPacked() ? KB : 128))\n    ) {\n      return logger().tap({\n        msg: \"pathToService()\",\n        level: \"info\",\n        result: ea,\n        meta: { cmd, isPacked, paths: paths.map(toS) }\n      })\n    }\n  }\n  return logger().throw(\"Failed to find path to \" + cmdBase, {\n    paths,\n    fatal: true\n  })\n}\n\nexport interface ChildServiceOpts {\n  nodeArgs?: string[]\n  args?: string[]\n  onData?(obj: Obj): void\n  healthy?: () => SyncOrAsync<Maybe<boolean>>\n  onPreRestart?: () => any\n  /** only for the test service: */\n  pathToService?: BaseFile\n}\n\nexport function inspectPort(cmd: ServiceName): number {\n  switch (cmd) {\n    case \"web\":\n      return 9223\n    case \"sync\":\n      return 9224\n    default:\n      return randomInt(9225, 9600)\n  }\n}\n\n/**\n * ChildService configures a WatchedChild for use by a PhotoStructure service,\n * like `web` or `sync`, and adds health checks.\n */\nexport class ChildService implements Endable {\n  static async mk(\n    cmd: ServiceName,\n    opts: Partial<WatchedChildOpts & WatchedChildListener> &\n      ChildServiceOpts &\n      Partial<child_process.SpawnOptions> = {}\n  ): PromiseMaybe<ChildService> {\n    const pathTo = opts.pathToService ?? (await pathToService(cmd))\n    if (blank(pathTo)) throw new Error(\"Failed to find path to \" + cmd)\n    opts.nodeArgs = toA(opts.nodeArgs)\n    return new ChildService(cmd, pathTo, opts)\n  }\n  readonly name: string\n  restartCount = 0\n\n  private readonly logger: Logger\n  readonly wc: WatchedChild\n  readonly spawnOpts: SpawnOptionsWithLocale\n\n  readonly endTimeoutMs: Maybe<number>\n\n  private constructor(\n    readonly serviceName: ServiceName,\n    readonly cmd: BaseFile,\n    readonly opts: Partial<WatchedChildOpts & WatchedChildListener> &\n      ChildServiceOpts &\n      Partial<SpawnOptionsWithLocale>\n  ) {\n    this.name = \"ChildService(\" + serviceName + \")\"\n    this.endTimeoutMs = serviceExitTimeoutMs(serviceName)\n    this.logger = mkLogger(this.name)\n    const spawnArgs = [...toA(opts.nodeArgs), cmd.nativePath]\n    if (isNotEmpty(opts.args)) {\n      spawnArgs.push(...opts.args)\n    }\n    this.spawnOpts = pick(\n      this.opts,\n      \"argv0\",\n      \"cwd\",\n      \"detached\",\n      \"env\",\n      \"gid\",\n      \"shell\",\n      \"stdio\",\n      \"timeout\",\n      \"uid\",\n      \"windowsHide\",\n      \"windowsVerbatimArguments\",\n      \"forceCLocale\"\n    )\n    // We don't want to force the locale for photostructure services\n    this.spawnOpts.forceCLocale = false\n    const maxAgeMs = -1\n    this.wc = new WatchedChild({\n      name: serviceName,\n      childFactory: async () => {\n        if (this.restartCount > 0 && this.opts.onPreRestart != null) {\n          await this.opts.onPreRestart()\n        }\n        this.restartCount++\n        return spawn(process.execPath, spawnArgs, maxAgeMs, this.spawnOpts)\n      },\n      // other things may rely on the child to get cleanup work done:\n      endableRank: EndableRanks.service,\n      endTimeoutMs: this.endTimeoutMs,\n      onStdout: this.onStdout.bind(this),\n      onStderr: this.onStderr.bind(this),\n      onError: orElse<WatchedChildListener[\"onError\"]>(\n        this.opts.onError,\n        () => (ea: any) => true !== isIgnorableError(ea) // < restart on any error emitted to stderr or stdout\n      ),\n      ignoreStopErrors: false,\n      exitCommand: ChildServiceExitCommand,\n      ...opts\n    })\n\n    addEndable(EndableRanks.first, this)\n  }\n\n  get startMs() {\n    return this.wc.startTs\n  }\n\n  private onStderr(data: string) {\n    const obj = parseJSON(data)\n    this.logger.warn(\".onStderr()\", obj ?? data)\n    return obj?.fatal === true\n  }\n\n  private onStdout(data: string) {\n    if (blank(data)) return\n    try {\n      const obj = parseJSON(data)\n      if (obj == null) {\n        this.logger.info(\".onStdout(): non-JSON payload\", data)\n        return\n      }\n      if (true === obj?.fatal) {\n        void this.wc.onError(this.name + \".onStdout()\", obj)\n      } else if (null != this.opts.onData) {\n        this.opts.onData(obj)\n      }\n    } catch (err) {\n      // Pass it on:\n      console.log(data)\n      // Don't grump too much:\n      // this.logger.warn(\"invalid JSON: \" + err, data)\n      // this.wc.onError(\"onStdout()\", err)\n    }\n  }\n\n  start() {\n    return this.wc.start()\n  }\n\n  stop() {\n    return this.wc.stop()\n  }\n\n  restart(force?: boolean) {\n    return this.wc.restart(force)\n  }\n\n  get ended() {\n    return this.wc.ended\n  }\n\n  async end() {\n    if (!this.wc.ended) this.write(ChildServiceExitCommand)\n    return this.wc.end()\n  }\n\n  get pid() {\n    return this.wc.pid\n  }\n\n  running() {\n    return this.wc.running()\n  }\n\n  notRunning() {\n    return this.wc.notRunning()\n  }\n\n  write(toStdin: string, retries = 2): boolean {\n    if (retries < 0) {\n      this.logger.warn(\"write(): no more retries\", { toStdin })\n      return false\n    }\n\n    // Don't check for ended, because end() uses this.\n    try {\n      const childProc = this.wc.proc\n      if (true !== childProc?.stdin?.writable) {\n        this.logger.warn(\"write(): childProc isn't open, ignoring\", { toStdin })\n        return false\n      }\n      return childProc.stdin.write(ensureSuffix(toStdin, \"\\n\"))\n    } catch (err) {\n      this.logger.warn(\"write(): caught \" + err)\n      // The only reason for an error here is if the proc is gone.\n      // onError returns the result of restart--if that is successful,\n      // try again.\n      this.wc.onError(\"onStdout()\", toErr(err)!)\n      return this.write(toStdin, retries - 1)\n    }\n  }\n}\n","export const ChildServiceExitCommand = \"--exit\"\n","import { ServiceName } from \"../../fe/ServiceNames\"\nimport { isSyncService } from \"../ServiceNames\"\nimport { Settings } from \"../settings/Settings\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\n\nexport function serviceExitTimeoutMs(name?: ServiceName) {\n  return isSyncService(name)\n    ? Settings.syncExitTimeoutMs.valueOrDefault\n    : ShortCommandTimeoutMs\n}\n","import { pidExists, Rate } from \"batch-cluster\"\nimport { ChildProcess } from \"child_process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { denull, map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt, gt0, lt } from \"../../fe/Number\"\nimport { Obj } from \"../../fe/Object\"\nimport { toS } from \"../../fe/toS\"\nimport {\n  addEndable,\n  Endable,\n  EndableRank,\n  EndableRanks,\n  ending\n} from \"../async/Endable\"\nimport { Promises } from \"../async/Promises\"\nimport { isRecentMs } from \"../date/Date\"\nimport { FatalErrorFlag } from \"../error/ErrorFlags\"\nimport { onError } from \"../error/OnError\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { onDataChunked } from \"../fs/StreamChunker\"\nimport { mkLogger } from \"../Logger\"\nimport { waitForPidExit } from \"../Pid\"\nimport { Settings } from \"../settings/Settings\"\nimport { endProcess, spawn } from \"./ChildProcess\"\n\nexport interface WatchedChildOpts {\n  name: string\n  childFactory: () => ChildProcess | Promise<ChildProcess>\n  dataSep?: string | RegExp\n  maxErrorsPerMinute?: number\n  endableRank?: EndableRank\n  exitCommand?: string\n  restartOnExit?: boolean // should only be false when we test sync\n  endTimeoutMs?: number | null\n}\n\nexport interface WatchedChildListener {\n  onStdout(data: string): void\n\n  /**\n   * @return true if the error should be propagated to onError\n   */\n  onStderr?(data: string): boolean\n\n  /**\n   * @return true if the error requires the child process to be restarted\n   */\n  onError(source: string, error: any): boolean\n\n  onRestart?(): void\n\n  /**\n   * Is it OK to start if we can't shut down a prior child process?\n   */\n  ignoreStopErrors: boolean // should be true for non-PS daemons\n}\n\n// so basic\nexport function mkBasicWatchedChild(\n  args: {\n    cmd: string\n    args: string[]\n  } & Partial<WatchedChildListener>\n) {\n  const wc: WatchedChild = new WatchedChild({\n    name: compact([args.cmd, ...args.args]).join(\" \"),\n    childFactory: () => {\n      // Restart every 30 minutes to prevent memory leaks:\n      return spawn(args.cmd, args.args, 30 * minuteMs)\n    },\n    onStdout: () => undefined,\n    onError: () => true,\n    ignoreStopErrors: true,\n    ...args\n  })\n  return wc\n}\n\n/**\n * BatchCluster is for ephemeral clusters of stateless processes.\n *\n * To watch a single, long-lived process, though, we need different management\n * heuristics than what batch-cluster gives us:\n *\n * 1. Start the child on construction\n * 2. Delegate all stdout, and errors to the provided listener\n * 3. Restart the child if it crashes/ends and this process hasn't ended\n * 4. The caller may need to specifically stop(), and then arbitrarily later, start()\n * 5. Notify the listener if the error rate is too high, or restarts are\n *    \"flapping\" (more than N restarts per some period of where the child spins\n *    up and immediately fails). It's up to the listener to then do something\n *    with that state information (including potentially end the current\n *    process).\n *\n * This class is used for `gio`, `findmnt`, `diskutil`, as well as the `sync`\n * and `web` PhotoStructure daemons.\n */\nexport class WatchedChild implements Endable {\n  readonly name: string\n  readonly startTs = Date.now()\n  private _stopped = false\n  private readonly logger = lazy(() =>\n    mkLogger(\"WatchedChild(\" + compact([this.name, this.pid]).join(\":\") + \")\")\n  )\n  readonly startRate = new Rate()\n  readonly mutex = new Promises(\"child.WatchedChild.mutex\", () => 1)\n  readonly opts: Required<WatchedChildOpts> & WatchedChildListener\n  #ended = false\n  private lastError?: WrappedError\n  private cp?: ChildProcess\n\n  constructor(opts: WatchedChildOpts & WatchedChildListener) {\n    this.name = opts.name\n    this.opts = {\n      dataSep: \"\\n\",\n      maxErrorsPerMinute: Settings.fatalErrorRatePerMinute.valueOrDefault,\n      endableRank: EndableRanks.first,\n      exitCommand: \"\",\n      restartOnExit: true,\n      endTimeoutMs: null,\n      ...opts\n    }\n    // Let the web or db service take some time to close, vacuum, and back up the db.\n    addEndable(this.opts.endableRank, this)\n    void this.#restart()\n  }\n\n  get endTimeoutMs() {\n    return denull(this.opts.endTimeoutMs)\n  }\n\n  get stopped() {\n    return this._stopped\n  }\n\n  get ended() {\n    return this.#ended\n  }\n\n  async end() {\n    this.#ended = true\n    return this.#stop()\n  }\n\n  get proc(): Maybe<ChildProcess> {\n    return this.cp\n  }\n\n  get pid(): Maybe<number> {\n    return map(this.cp, ea => ea.pid)\n  }\n\n  running(): boolean {\n    return pidExists(this.pid)\n  }\n\n  notRunning(): boolean {\n    return !this.running()\n  }\n\n  /**\n   * Shuts down the current process. The process won't start again until restart() is called.\n   * @return false if stop failed\n   */\n  async stop(): Promise<boolean> {\n    this.logger().info(\"stop()\")\n    this._stopped = true\n    return this.mutex.serial(\"\", () => {\n      this._stopped = true\n      return this.#stop()\n    })\n  }\n\n  async #stop(): Promise<boolean> {\n    this.logger().info(\"#stop()\", {\n      stopped: this._stopped,\n      ended: this.#ended\n    })\n    const cp = this.cp\n    this.cp = undefined\n    if (cp == null) return true // nothing to stop\n    return this.#stopChild(cp)\n  }\n\n  async #stopChild(cp: ChildProcess) {\n    // Send the exit command, if it isn't blank, and stdin is still open:\n    if (\n      gt0(cp.pid) &&\n      notBlank(this.opts.exitCommand) &&\n      true === cp.stdin?.writable\n    ) {\n      try {\n        cp.stdin.write(this.opts.exitCommand + \"\\n\")\n        // Given the child a chance to exit gracefully before we call\n        // endProcess:\n        await waitForPidExit(cp.pid, (this.endTimeoutMs ?? secondMs) / 2)\n      } catch (error) {\n        this.logger().warn(\"stopChild: error writing to stdin\", { error })\n      }\n    }\n    return endProcess(cp, this.endTimeoutMs)\n  }\n\n  readonly onError = (src: string, cause: Buffer | string | Error | Obj) => {\n    const error = new WrappedError(src, {\n      cause\n    })\n    const ignorable = error.ignorable !== false\n    this.logger().log(ignorable ? \"warn\" : \"error\", \"onError()\", error)\n    if (this.#ended || ignorable) {\n      return\n    }\n\n    this.lastError = error\n    onError(error)\n\n    if (error.fatal === true) {\n      void this.end()\n      return\n    }\n\n    const requiresRestart = this.opts.onError(src, error)\n    if (requiresRestart) {\n      this.logger().warn(\"onError requested restart\", { src, error })\n      void this.#restart()\n    }\n    return\n  }\n\n  isErrorRateExceeded() {\n    return this.logger().tap({\n      msg: \"isErrorRateExceeded()\",\n      result: gt(this.startRate.eventsPerMinute, this.opts.maxErrorsPerMinute),\n      meta: {\n        startRatePerMin: this.startRate.eventsPerMinute,\n        maxErrorsPerMin: this.opts.maxErrorsPerMinute\n      }\n    })\n  }\n\n  async restart(force = false) {\n    this.logger().info(\"restart()\", {\n      stopped: this._stopped,\n      ended: this.#ended\n    })\n    if (this.#ended || ending()) return false\n    if (\n      !force &&\n      lt(\n        this.startRate.msSinceLastEvent,\n        Settings.minTimeBetweenServiceRestartsMs.valueOrDefault\n      )\n    ) {\n      this.logger().info(\"restart(): last restart was too recent. Ignoring.\", {\n        msSinceLastEvent: this.startRate.msSinceLastEvent,\n        minTimeBetweenServiceRestartsMs:\n          Settings.minTimeBetweenServiceRestartsMs.valueOrDefault\n      })\n      return\n    }\n    return this.mutex.serial(\"\", async () => {\n      await this.#stop()\n      this._stopped = false\n      return this.#start()\n    })\n  }\n\n  async start() {\n    this.logger().info(\"start()\", {\n      stopped: this._stopped,\n      ended: this.#ended\n    })\n    return this.mutex.serial(\"\", async () => {\n      this._stopped = false\n      return this.#start()\n    })\n  }\n\n  /**\n   * Only called by onError/onExit, and pauses restarts if error rate is too high.\n   * @return false if errors\n   */\n  async #restart() {\n    this.logger().info(\"#restart()\", {\n      stopped: this._stopped,\n      ended: this.#ended\n    })\n    return this.mutex.maybeRun(\"\", async () => {\n      await this.#stop()\n      if (this._stopped || this.#ended) return false\n      if (this.isErrorRateExceeded()) {\n        this.logger().warn(\"Cannot restart, error/restart rate is too high.\", {\n          errorsPerMinute: this.startRate.eventsPerMinute,\n          msSinceLastStart: this.startRate.msSinceLastEvent\n        })\n        // If we're just spinning up, die.\n        if (isRecentMs(this.startTs, Settings.probationMs.valueOrDefault)) {\n          onError(\n            \"Can't restart \" +\n              this.name +\n              \", failure rate is too high.\" +\n              FatalErrorFlag,\n            this.lastError\n          )\n        }\n        return false\n      }\n      this.logger().info(\"#restart()\", {\n        currentPid: this.pid,\n        startRate: this.startRate,\n        maxErrorsPerMinute: this.opts.maxErrorsPerMinute\n      })\n\n      // eslint-disable-next-line no-unused-expressions\n      this.opts.onRestart?.()\n\n      return this.#start()\n    })\n  }\n\n  // CAREFUL: this must be protected by this.mutex!\n\n  /**\n   * @return true if new pid was started\n   */\n  async #start(): Promise<boolean> {\n    this.logger().info(\"#start()\", {\n      stopped: this._stopped,\n      ended: this.#ended\n    })\n    if (this._stopped || this.#ended) return false\n    if (this.running()) return false\n    this.startRate.onEvent()\n    const cp = (this.cp = await this.opts.childFactory())\n\n    // Pick up the new PID:\n    this.logger.unset()\n    this.logger().info(\"#start(): spawned pid \" + this.pid)\n\n    const ctx = \"cp(\" + cp.pid + \")\"\n    ;[\n      { o: cp, desc: \"\" },\n      { o: cp.stdin, desc: \".stdin\" },\n      { o: cp.stdout, desc: \".stdout\" },\n      { o: cp.stderr, desc: \".stderr\" }\n    ].forEach(({ o, desc }) => {\n      map(o, ea =>\n        ea.on(\"error\", err => this.onError(ctx + desc + \".on(error)\", err))\n      )\n    })\n\n    void map(this.cp.stdout, sout =>\n      onDataChunked(sout, this.opts.dataSep, ea => {\n        this.logger().trace(\"onDataChunked()\", ea)\n        this.opts.onStdout(ea)\n      })\n    )\n\n    void map(this.cp.stderr, serr =>\n      serr.on(\"data\", s => {\n        if (toS(s).includes(\"Error: Cannot find module\")) {\n          onError(\"Failed to start \" + this.name + FatalErrorFlag, new Error(s))\n        }\n        if (this.opts.onStderr?.(s) === true) {\n          void this.onError(ctx + \".stderr.on(data)\", s)\n        }\n      })\n    )\n\n    this.cp.on(\"exit\", async (code: number | null, signal: string | null) => {\n      this.logger().info(\"onExit\", {\n        code,\n        signal,\n        stopped: this._stopped,\n        ended: this.#ended\n      })\n      if (ending()) {\n        return\n      } else if (this.opts.restartOnExit) {\n        await this.#restart()\n        this.logger().info(\"onExit(): finished setting up new child\", {\n          pid: this.pid\n        })\n      } else {\n        this.logger().info(\n          \"onExit(): this.opts.restartOnExit is false. Ending.\",\n          { pid: this.pid }\n        )\n        void this.end()\n      }\n    })\n    return true\n  }\n}\n","import * as path_posix from \"node:path/posix\"\nimport { SimpleFileOrString } from \"../core/fs/SimpleFile\"\nimport { examples } from \"./ExamplesDir\"\nimport { TestLibraryDirPrefix } from \"./TestLibraryDirPrefix\"\nimport { originalsDir } from \"./dir/LibraryDir\"\nimport { BaseFile } from \"./fs/BaseFile\"\nimport { stripCopySuffixFromName } from \"./fs/FuzzyNames\"\nimport { PosixFile } from \"./fs/PosixFile\"\n\n/**\n * Directories end with a \"/\"\n */\n\nexport function ciSafePath(nativePath: SimpleFileOrString): string {\n  const pf = PosixFile.for(nativePath)\n  const f = pf.sibling(stableBasename(pf))\n\n  if (f.isSelfOrDescendantOf(examples())) {\n    return path_posix.join(\"$examples\", f.posixPathFrom(examples()))\n  }\n\n  const origDir = originalsDir()\n\n  if (f.isSelfOrDescendantOf(origDir)) {\n    return path_posix.join(\"$library\", f.posixPathFrom(origDir!))\n  }\n\n  const anc = pf.findAncestor(ea => ea.base.startsWith(TestLibraryDirPrefix))\n  if (anc != null) {\n    return path_posix.join(\"$library\", f.posixPathFrom(anc))\n  }\n  // well crap, we don't know what to do with this path:\n  return pf.baseWithGrandparent\n}\n\nexport function stableBasename(f: BaseFile): string {\n  return stripCopySuffixFromName(f, { aggressive: false }) + f.ext\n}\n","import { Command, program } from \"commander\"\nimport { argv, exit } from \"process\"\nimport { version } from \"../../core/Version\"\nimport { mapNotBlankOr } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Obj } from \"../../fe/Object\"\nimport { ServiceName } from \"../../fe/ServiceNames\"\nimport { EditionName } from \"../EditionName\"\nimport { isTest } from \"../NodeEnv\"\nimport { setServiceName } from \"../SetServiceName\"\nimport { joinLines } from \"../fs/CRLF\"\nimport { isMainElectron } from \"../platform/Platform\"\nimport { CliDesc, addFooter } from \"./CliConstants\"\nimport { cliWrap } from \"./CliWrap\"\nimport { DescriptionFooter } from \"./DescriptionFooter\"\nimport { verifyUidGid } from \"./VerifyUidGid\"\n\nexport interface CommandPlugin {\n  beforeParse(cmd: Command): Command\n  afterParse?(opts: Obj): void\n}\n\nexport class CLI {\n  private readonly plugins: CommandPlugin[] = []\n\n  /**\n   * @param args if non-empty, passed to `Command.arguments()`\n   */\n  constructor(\n    readonly serviceName: keyof typeof CliDesc & ServiceName,\n    readonly args?: string,\n    readonly additionalDescription?: string\n  ) {\n    setServiceName(serviceName)\n    verifyUidGid()\n  }\n\n  add(...plugins: CommandPlugin[]) {\n    this.plugins.push(...plugins)\n    return this\n  }\n\n  parse() {\n    let cmd = addFooter(\n      program.description(\n        cliWrap(\n          CliDesc[this.serviceName] +\n            mapNotBlankOr(\n              this.additionalDescription,\n              ea => \"\\n\\n\" + ea,\n              () => \"\"\n            )\n        ).join(\"\\n\")\n      ) as Command\n    )\n\n    map(this.args, ea => {\n      cmd = cmd.arguments(ea)\n    })\n\n    for (const ea of this.plugins) {\n      cmd = ea.beforeParse(cmd)\n    }\n\n    cmd.option(\n      \"-V, --version\",\n      \"Output version information (spoiler: it's \" +\n        (isTest ? \"1.2.3-test\" : version) +\n        \")\"\n    )\n\n    cmd.on(\"option:version\", () => {\n      console.log(\n        joinLines(\n          ...cliWrap(EditionName() + \" v\" + version + \"\\n\" + DescriptionFooter)\n        )\n      )\n      exit(0)\n    })\n\n    cmd.parse(argv, { from: isMainElectron ? \"electron\" : \"node\" })\n\n    const opts = cmd.opts()\n\n    for (const ea of this.plugins) {\n      ea.afterParse?.(opts)\n    }\n\n    return cmd\n  }\n}\n","import { Command } from \"commander\"\nimport { joinLines } from \"../fs/CRLF\"\nimport { cliWrap } from \"./CliWrap\"\nimport { DescriptionFooter } from \"./DescriptionFooter\"\n\nexport const CliDesc = {\n  main: \"PhotoStructure's main process manager. Runs and manages web and sync services.\",\n  desktop: \"PhotoStructure for Desktops. Manages web and sync services.\",\n  info: \"Configuration, file metadata and import diagnostics tool.\",\n  list: \"List paths in a PhotoStructure Library.\",\n  logcat: \"Chronologically sort and pretty-print PhotoStructure logfiles.\",\n  logtail:\n    \"View the log messages of currently-running PhotoStructure processes as they are emitted. (Like `tail -f`).\",\n  web: \"PhotoStructure's web service. Automatically started by main.\",\n  sync: \"PhotoStructure's directory synchronization service. Automatically started by main.\"\n  // worker doesn't have a CLI.\n}\n\nexport function addFooter(c: Command): Command {\n  return c.on(\"--help\", () => {\n    console.log(joinLines(...cliWrap(DescriptionFooter)))\n  })\n}\n","import { env, stdout } from \"process\"\nimport { toInt } from \"../../fe/Number\"\nimport { wrap } from \"../../fe/String\"\n\nexport function cliWrap(\n  s: string,\n  opts?: { maxLineLen?: number; prefix?: string }\n) {\n  const maxLineLen =\n    opts?.maxLineLen ?? toInt(env.maxLineLen) ?? stdout.columns ?? 75\n  return wrap(s, { maxLineLen, prefix: opts?.prefix ?? \"\" })\n}\n","import { Command } from \"commander\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { map } from \"../../fe/Maybe\"\nimport { Obj } from \"../../fe/Object\"\nimport { isEnvTrue } from \"../env/GetEnv\"\nimport { CommandPlugin } from \"./CLI\"\n\nexport const ColorArgs: CommandPlugin = {\n  beforeParse: (cmd: Command) =>\n    cmd\n      .option(\n        \"--color\",\n        \"Enable ASCII terminal colors (this overrides NO_COLOR, if set)\"\n      )\n      .option(\n        \"--no-color\",\n        \"Disable ASCII terminal colors (see https://no-color.org/)\"\n      ),\n\n  afterParse: (opts: Obj) => {\n    // these don't need to be assigned to .envValue, but it means info\n    // --child-env will emit these changes (and avoid confusion)\n    if (isEnvTrue(\"NO_COLOR\")) Settings.logColor.envValue = false\n    // but let the env to be overridden by an arg:\n    map(opts.color, ea => (Settings.logColor.envValue = ea))\n  }\n}\n","export const DescriptionFooter = [\n  \"\",\n  `Copyright © 2017-${new Date().getFullYear()}, PhotoStructure Inc.`,\n  \"\",\n  \"BY USING THIS SOFTWARE, YOU ARE ACCEPTING ALL THE TERMS AND CONDITIONS OF THIS LICENSE: https://photostructure.com/eula/\",\n  \"\",\n  \"User guide: https://photostructure.com/user-guide/\",\n  \"\",\n  \"Questions, bug reports, and feature requests: https://forum.photostructure.com/\",\n  \"\"\n].join(\"\\n\")\n","import process from \"process\"\nimport { blank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\n\nexport interface DaemonOptions {\n  daemon?: boolean\n  pidfile?: string\n  stop?: boolean\n}\n\nexport function isDaemon(opts?: DaemonOptions) {\n  return (\n    isTrue(process.env.__is_daemon) ||\n    isTrue(opts?.daemon) ||\n    !blank(opts?.pidfile)\n  )\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toGt0 } from \"../../fe/Number\"\nimport { groupids, userids } from \"../UserInfo\"\nimport { env } from \"../env/Env\"\nimport { isDocker } from \"../platform/isDocker\"\n\nfunction whyMismatched(\n  desc: string,\n  envKey: string,\n  actual: number[]\n): Maybe<string> {\n  const val = toGt0(env()[envKey])\n  return val != null && !actual.includes(val)\n    ? `WARNING: ${desc} is running as ${actual} but $${envKey}=${val}`\n    : undefined\n}\n\nexport function whyUidGidMismatched(): Maybe<string[]> {\n  const arr = compactBlanks([\n    whyMismatched(\"user id\", \"PUID\", userids()),\n    whyMismatched(\"group id\", \"PGID\", groupids())\n  ])\n  return arr.length === 0 ? undefined : arr\n}\n\nexport const verifyUidGid = lazy(() => {\n  if (isDocker()) {\n    map(whyUidGidMismatched(), why =>\n      console.log(\n        [\n          \"\",\n          ...why,\n          \"This may result in file permission issues!\",\n          // Angle-bracket-surrounded URLs may be included in the URL (!!) by UnRAID. BOO\n          \"See https://forum.photostructure.com/t/1597/2 for details.\",\n          \"\"\n        ].join(\"\\n\")\n      )\n    )\n  }\n})\n","import { Command } from \"commander\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport {\n  writeLibrarySettings_,\n  writeSystemSettings_\n} from \"../../core/settings/SettingsIO\"\nimport { blank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { Obj } from \"../../fe/Object\"\nimport { osConfigDirs } from \"../dir/ConfigDir\"\nimport { CommandPlugin } from \"./CLI\"\n\nexport const WriteSettingsArg: CommandPlugin = {\n  beforeParse: (cmd: Command) =>\n    cmd.option(\"--write-settings\", \"Write out system and library settings\"),\n\n  afterParse: async (opts: Obj) => {\n    if (isTrue(opts.writeSettings)) {\n      const systemSettingsFile = await writeSystemSettings_()\n      if (systemSettingsFile == null) {\n        console.info(\n          \"--write-settings: Failed write system settings: no system configuration directory was found.\",\n          { checkedDirectories: osConfigDirs() }\n        )\n      } else {\n        console.info(\n          `--write-settings: Wrote system settings to ${systemSettingsFile}`\n        )\n      }\n\n      if (blank(Settings.libraryDir.valueOrDefault)) {\n        console.error(\n          \"--write-settings: Failed to write library settings: no PS_LIBRARY_DIR is set.\"\n        )\n      } else {\n        const librarySettingsFile = await writeLibrarySettings_()\n        console.info(\n          `--write-settings: Wrote library settings to ${librarySettingsFile}`\n        )\n      }\n    }\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { compact, pushUniq } from \"../../fe/Array\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gte0 } from \"../../fe/Number\"\nimport { leastBy } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { capitalize } from \"../String\"\nimport {\n  lab2rgbhex,\n  rgb2lab,\n  rgbhex2Lab,\n  rgbhex2Labhash,\n  toLabhash,\n  unlabhash\n} from \"./Colorspace\"\nimport { CrayonColors, CrayonSupplements } from \"./CrayonColors\"\nimport { DarkWikipediaColors } from \"./DarkWikipediaColors\"\nimport { ciede2000_delta_e } from \"./DeltaE\"\nimport { Greys } from \"./Greys\"\nimport { LightWikipediaColors } from \"./LightWikipediaColors\"\nimport { ModeBits } from \"./ModeBits\"\nimport { normalizeRgbHex } from \"./RGB\"\nimport { Triplet } from \"./Triplet\"\n\nconst logger = lazy(() => mkLogger(\"color.ColorNames\"))\n\n/* \nhttps://en.wikipedia.org/wiki/List_of_colors:_A%E2%80%93F\nhttps://en.wikipedia.org/wiki/List_of_colors:_G%E2%80%93M\nhttps://en.wikipedia.org/wiki/List_of_colors:_N%E2%80%93Z\n\nhttps://en.wikipedia.org/wiki/List_of_colors_by_shade\n\nTry not to include any color names that are names of people, organizations, or\nplaces. Flower names are fine.\n\n*/\n\nexport const ColorNames = lazy<LabNamedRgbHexColor[]>(() =>\n  compact(\n    [\n      ...CrayonColors,\n      ...CrayonSupplements,\n      ...DarkWikipediaColors,\n      ...LightWikipediaColors,\n      ...Greys\n    ].map(colorToTuple)\n  )\n)\n\nexport type NamedRgbHexColor = {\n  name: string\n  rgb: string\n}\n\nexport type LabNamedRgbHexColor = NamedRgbHexColor & {\n  lab: Triplet\n\n  /**\n   * Best-matching labhash for this RGB color\n   */\n  labhash: number\n\n  /**\n   * All the labhashes that map to this color\n   */\n  closeLabhashes: number[]\n\n  closeRgb: string[]\n}\n\nexport function bestRgbTripletName<T extends LabNamedRgbHexColor>(\n  rgb: Triplet,\n  colors = ColorNames() as T[]\n) {\n  return bestLabName(rgb2lab(rgb), colors)\n}\n\nexport function colorToTuple(\n  color: NamedRgbHexColor\n): Maybe<LabNamedRgbHexColor> {\n  const rgb = normalizeRgbHex(color.rgb)\n  if (rgb == null) {\n    logger().warn(`skipping invalid entry (bad rgb): ${color.rgb}`, color)\n    return\n  }\n  const lab = rgbhex2Lab(rgb)\n  if (lab == null) {\n    logger().warn(\n      `skipping invalid entry (failed to convert to L*a*b): ${rgb}`,\n      color\n    )\n    return\n  }\n\n  const labhash = toLabhash(lab, ModeBits)\n  return {\n    ...color,\n    rgb,\n    lab,\n    labhash,\n    // This is set later by labhashToColor()\n    closeLabhashes: [labhash],\n    closeRgb: [rgb],\n    name: capitalize(color.name)\n  }\n}\n\nexport function bestRgbName(rgb: string): Maybe<LabNamedRgbHexColor> {\n  return bestLabhashName(rgbhex2Labhash(rgb))\n}\n\nexport function bestLabName(\n  lab: Maybe<Triplet>,\n  colors?: LabNamedRgbHexColor[]\n): Maybe<LabNamedRgbHexColor> {\n  return lab == null\n    ? undefined\n    : leastBy(colors ?? ColorNames(), ea => ciede2000_delta_e(ea.lab, lab))\n}\n\nconst labhashToColor = new Map<number, LabNamedRgbHexColor>()\n\nexport function bestLabhashName(\n  labhash: Maybe<number>\n): Maybe<LabNamedRgbHexColor> {\n  return gte0(labhash)\n    ? getOrSet(labhashToColor, labhash, () => {\n        const exact = ColorNames().find(ea => ea.labhash === labhash)\n        if (exact != null) return exact\n        const lab = unlabhash(labhash)\n        const result = bestLabName(lab)\n        if (lab != null && result != null) {\n          pushUniq(result.closeLabhashes, labhash)\n          pushUniq(result.closeRgb, lab2rgbhex(lab))\n        }\n        return result\n      })\n    : undefined\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { stepRange } from \"../../fe/Array\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, round } from \"../../fe/Number\"\nimport { leastBy } from \"../Array\"\nimport { BitZip } from \"../math/Bits\"\nimport { matXvec, vecXvec } from \"../math/Matrix\"\nimport { ciede2000_delta_e } from \"./DeltaE\"\nimport { ModeBits } from \"./ModeBits\"\nimport { clampRGB, rgbTriplet2hex, rgbhex2triplet } from \"./RGB\"\nimport { Triplet } from \"./Triplet\"\n\n// From http://www.brucelindbloom.com\nconst srgb2xyz = [\n  [0.4124564, 0.3575761, 0.1804375],\n  [0.2126729, 0.7151522, 0.072175],\n  [0.0193339, 0.119192, 0.9503041]\n]\nconst xyz2srgb = [\n  [3.2404542, -1.5371385, -0.4985314],\n  [-0.969266, 1.8760108, 0.041556],\n  [0.0556434, -0.2040259, 1.0572252]\n]\n\nexport function rgbhex2Lab(rgbHex: string): Maybe<Triplet> {\n  return map(rgbhex2triplet(rgbHex), rgb2lab)\n}\n\nexport function rgbhex2Labhash(\n  rgbHex: string,\n  bitDepth: number = ModeBits\n): Maybe<number> {\n  return map(rgbhex2triplet(rgbHex), ea => toLabhash(rgb2lab(ea), bitDepth))\n}\n\nexport function lab2rgbhex(lab: Triplet): string {\n  return rgbTriplet2hex(lab2rgb(lab))\n}\n\n/**\n * Convert from flattened RGB triplets to [[CIELAB triplet]]\n */\nexport function rgb2labTriplets(rgb: Buffer): Triplet[] {\n  return stepRange(0, rgb.length, 3).map(i =>\n    rgb2lab([rgb[i], rgb[i + 1], rgb[i + 2]])\n  )\n}\n\n/**\n * Convert from flattened RGB triplets to [[L* values], [a* values], [b* values]]\n */\nexport function rgb2labArray(rgb: Buffer): [number[], number[], number[]] {\n  const l = []\n  const a = []\n  const b = []\n  for (let i = 0; i < rgb.length; i += 3) {\n    const lab = rgb2lab([rgb[i], rgb[i + 1], rgb[i + 2]])\n    l.push(lab[0])\n    a.push(lab[1])\n    b.push(lab[2])\n  }\n  return [l, a, b]\n}\n\n/**\n * where rgb values are [0,255]\n */\nexport function rgb2lab(rgb: Triplet): Triplet {\n  return xyz2lab(rgb2xyz(rgb))\n}\n\nexport function lab2rgb(lab: Triplet): Triplet {\n  return clampRGB(xyz2rgb(lab2xyz(lab)))\n}\n\nexport function clampLab(lab: Triplet): Triplet {\n  return 1 < 2\n    ? [\n        clamp(0, 100, lab[0]),\n        clamp(-100, 100, lab[1]),\n        // -108 seems to be wrong, but RGB(0,0,255) ->\n        // L*a*b*(32.297,79.188,-107.860) according to\n        // http://www.easyrgb.com/en/convert.php#inputFORM and\n        // http://colormine.org/convert/rgb-to-lab\n        clamp(-108, 100, lab[2])\n      ]\n    : (LabBitZip().clampValue(lab) as Triplet)\n}\n\nexport function rgb2xyz(rgb: Triplet): Triplet {\n  // See http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n  const srgb = clampRGB(rgb)\n    .map(ea => ea / 255)\n    .map(ea =>\n      ea > 0.04045 ? Math.pow((ea + 0.055) / 1.055, 2.4) : ea / 12.92\n    )\n  return matXvec(srgb2xyz, srgb) as any // because TS doesn't support tuples well\n}\n\n// https://en.wikipedia.org/wiki/Lab_color_space#CIELAB in D65\n\nconst RefWhite = {\n  X: 0.95047,\n  Y: 1,\n  Z: 1.08883\n}\n\n// http://www.brucelindbloom.com/index.html?Eqn_XYZ_to_Lab.html\n\nconst epsilon = 216 / 24389 // 0.00885\nconst kappa = 24389 / 27 // 903.3\n\nexport function xyz2lab(xyz: Triplet): Triplet {\n  const [fx, fy, fz] = vecXvec(xyz, [\n    1 / RefWhite.X,\n    1 / RefWhite.Y,\n    1 / RefWhite.Z\n  ]).map(t => (t > epsilon ? Math.pow(t, 1 / 3) : (kappa * t + 16) / 116))\n\n  return clampLab([116 * fy - 16, 500 * (fx - fy), 200 * (fy - fz)])\n}\n\nexport function lab2xyz(lab: Triplet): Triplet {\n  // the [0], [1], [2] allows lab to be a Buffer.slice:\n  const [l, a, b] = clampLab(lab)\n  const fy = (l + 16) / 116\n  const fx = a / 500 + fy\n  const fz = fy - b / 200\n\n  const fx3 = fx * fx * fx\n  const fz3 = fz * fz * fz\n\n  const xr = fx3 > epsilon ? fx3 : (116.0 * fx - 16.0) / kappa\n  const yr = l > 8 ? Math.pow(fy, 3.0) : l / kappa\n  const zr = fz3 > epsilon ? fz3 : (116.0 * fz - 16.0) / kappa\n\n  return [xr * RefWhite.X, yr * RefWhite.Y, zr * RefWhite.Z]\n}\n\nexport function xyz2rgb(xyz: Triplet): Triplet {\n  return matXvec(xyz2srgb, xyz).map(v => {\n    const sign = v < 0 ? -1 : 1\n    const l = v * sign\n    return round(\n      255 *\n        sign *\n        (l <= 0.0031308 ? 12.92 * l : 1.055 * Math.pow(l, 1 / 2.4) - 0.055)\n    )\n  }) as Triplet\n}\n\nexport const LabBitZip = lazy(\n  () =>\n    new BitZip([\n      { min: 0, max: 100 }, // L\n      // see findBestLabhashDims:\n      { min: -79, max: 90 },\n      { min: -102, max: 89 }\n    ])\n)\n\nexport function toLabhash(lab: Triplet, bitDepth: number = ModeBits): number {\n  return LabBitZip().zip(lab, bitDepth)\n}\n\nconst labhash2lab = new Map<number, Triplet>()\n\nexport function unlabhash(\n  hash: number,\n  bitDepth: number = ModeBits\n): Maybe<Triplet> {\n  return 1 > 2 && bitDepth === ModeBits\n    ? getOrSet(labhash2lab, hash, () => _unlabhash(hash, bitDepth))\n    : _unlabhash(hash, bitDepth)\n}\n\nfunction _unlabhash(hash: number, bitDepth: number = ModeBits): Maybe<Triplet> {\n  return LabBitZip().unzip(hash, bitDepth) as Triplet\n}\n\nexport const minLabhash = lazy(() => LabBitZip().zipMin(ModeBits))\nexport const maxLabhash = lazy(() => LabBitZip().zipMax(ModeBits))\n\nexport function closestLab(haystack: Triplet[], needle: Triplet) {\n  return leastBy(haystack, ea => ciede2000_delta_e(ea, needle))\n}\n\nexport function rgb2hsv(rgb: Triplet): Triplet {\n  const [r, g, b] = clampRGB(rgb)\n\n  const max = Math.max(r, g, b)\n  const delta = max - Math.min(r, g, b)\n\n  const hh = delta\n    ? max === r\n      ? (g - b) / delta\n      : max === g\n      ? 2 + (b - r) / delta\n      : 4 + (r - g) / delta\n    : 0\n\n  return [\n    60 * (hh < 0 ? hh + 6 : hh),\n    max ? (delta / max) * 100 : 0,\n    (max / 255) * 100\n  ]\n}\n\nexport function rgbhex2hsl(rgbhex: string): Triplet {\n  return rgb2hsl(rgbhex2triplet(rgbhex)!)\n}\n\nexport function rgb2hsl(rgb: Triplet): Triplet {\n  return hsv2hsl(rgb2hsv(rgb))\n}\n\nexport function hsl2rgb(hsl: Triplet): Triplet {\n  return hsv2rgb(hsl2hsv(hsl))\n}\n\nexport function hsv2hsl(hsv: Triplet): Triplet {\n  // https://github.com/omgovich/colord/blob/3f859e03b0ca622eb15480f611371a0f15c9427f/src/colorModels/hsl.ts#L44\n\n  const [h, s, v] = hsv\n\n  const hh = ((200 - s) * v) / 100\n\n  return [\n    h,\n    hh > 0 && hh < 200\n      ? ((s * v) / 100 / (hh <= 100 ? hh : 200 - hh)) * 100\n      : 0,\n    hh / 2\n  ]\n}\n\nexport function hsl2hsv(hsl: Triplet): Triplet {\n  const [h, s, l] = hsl\n  const s0 = (s * (l < 50 ? l : 100 - l)) / 100\n  return [h, s0 > 0 ? ((2 * s0) / (l + s0)) * 100 : 0, l + s0]\n}\n\nexport function hsv2rgb(hsv: Triplet) {\n  const h = (hsv[0] / 360) * 6\n  const s = hsv[1] / 100\n  const v = hsv[2] / 100\n\n  const hh = Math.floor(h),\n    b = v * (1 - s),\n    c = v * (1 - (h - hh) * s),\n    d = v * (1 - (1 - h + hh) * s),\n    mod6 = hh % 6\n\n  return clampRGB([\n    [v, c, b, b, d, v][mod6] * 255,\n    [d, v, v, c, b, b][mod6] * 255,\n    [b, b, d, v, v, c][mod6] * 255\n  ])\n}\n\nif (require.main === module) {\n  console.log(toLabhash([0, 0, 0]))\n}\n","export const CrayonColors = [\n  // { name: \"Almond\", rgb: \"#EED9C4\" }, // unneeded\n  // { name: \"Antique Brass\", rgb: \"#C88A65\" },\n  // { name: \"Apricot\", rgb: \"#FDD5B1\" }, // unused?\n  { name: \"Aquamarine\", rgb: \"#95E0E8\" },\n  { name: \"Asparagus\", rgb: \"#7BA05B\" },\n  // { name: \"Banana Mania\", rgb: \"#FBE7B2\" },\n  // { name: \"Beaver\", rgb: \"#926F5B\" }, // NO\n  // { name: \"Bittersweet\", rgb: \"#FE6F5E\" }, // NO\n  // { name: \"Black\", rgb: \"#000000\" }, // in Greys\n  // { name: \"Blue bell\", rgb: \"#9999CC\" },\n  { name: \"Blue-green\", rgb: \"#0095B7\" },\n  // { name: \"Bluetiful\", rgb: \"#3C69E7\" }, // I HATE FUN\n  { name: \"Royal blue\", rgb: \"#273BE2\" }, // replaces Bluetiful\n  { name: \"Blush\", rgb: \"#DB5079\" },\n  // { name: \"Brick red\", rgb: \"#C62D42\" }, // dupe of Maroon\n  { name: \"Brilliant rose\", rgb: \"#E667CE\" },\n  { name: \"Brown\", rgb: \"#AF593E\" },\n  // { name: \"Burnt orange\", rgb: \"#FF7034\" }, // dupe of Red-orange\n  { name: \"Burnt sienna\", rgb: \"#E97451\" },\n  { name: \"Burnt umber\", rgb: \"#805533\" },\n  { name: \"Cadet blue\", rgb: \"#A9B2C3\" },\n  { name: \"Canary\", rgb: \"#FFFF99\" },\n  // { name: \"Caribbean Green\", rgb: \"#00CC99\" }, // dupe of Shamrock\n  { name: \"Carmine\", rgb: \"#E62E6B\" },\n  { name: \"Carnation pink\", rgb: \"#FFA6C9\" },\n  { name: \"Celestial blue\", rgb: \"#7070CC\" },\n  { name: \"Cerise\", rgb: \"#DA3287\" },\n  { name: \"Cerulean blue\", rgb: \"#339ACC\" },\n  // { name: \"Cerulean\", rgb: \"#02A4D3\" },\n  // { name: \"Charcoal grey\", rgb: \"#736A62\" },\n  { name: \"Chestnut\", rgb: \"#B94E48\" },\n  { name: \"Cobalt blue\", rgb: \"#8C90C8\" },\n  { name: \"Copper\", rgb: \"#DA8A67\" },\n  { name: \"Cornflower\", rgb: \"#93CCEA\" },\n  { name: \"Cotton candy\", rgb: \"#FFB7D5\" },\n  // { name: \"Dandelion\", rgb: \"#FED85D\" }, // dupe of Goldenrod\n  // { name: \"Dark Venetian Red\", rgb: \"#B33B24\" }, // place name, see below\n  { name: \"Denim\", rgb: \"#1560BD\" },\n  // { name: \"Desert sand\", rgb: \"#EDC9AF\" }, // dupe of Peach\n  { name: \"Eggplant\", rgb: \"#614051\" },\n  // { name: \"English Vermilion\", rgb: \"#CC474B\" }, // see below\n  { name: \"Fern\", rgb: \"#63B76C\" },\n  // { name: \"Forest green\", rgb: \"#5FA777\" },\n  { name: \"Fuchsia\", rgb: \"#C154C1\" },\n  // { name: \"Fuzzy Wuzzy\", rgb: \"#87421F\" }, // LIKE I SAID, I HATE FUN\n  { name: \"Russet\", rgb: \"#87421F\" }, // replaces Fuzzy Wuzzy\n  // { name: \"Goldenrod\", rgb: \"#FCD667\" }, // dupe of Maize\n  // { name: \"Granny Smith Apple\", rgb: \"#9DE093\" }, // GRANNY H8R\n  // { name: \"Gray\", rgb: \"#8B8680\" }, // Handled by Greys\n  { name: \"Green\", rgb: \"#01A638\" },\n  { name: \"Green-yellow\", rgb: \"#F1E788\" },\n  // { name: \"Inchworm\", rgb: \"#AFE313\" },\n  { name: \"Indigo\", rgb: \"#4F69C6\" },\n  // { name: \"Jazzberry Jam\", rgb: \"#A50B5E\" },\n  { name: \"Jungle green\", rgb: \"#29AB87\" },\n  // { name: \"Lemon Yellow\", rgb: \"#FFFF9F\" }, // dupe of Canary\n  // { name: \"Light blue\", rgb: \"#8FD8D8\" }, // dupe of Aquamarine\n  // { name: \"Light chrome green\", rgb: \"#BEE64B\" }, // dupe of Pear\n  // { name: \"Light Venetian Red\", rgb: \"#E6735C\" }, // place name, see below\n  // { name: \"Macaroni and Cheese\", rgb: \"#FFB97B\" }, NO FUN\n  // { name: \"Madder Lake\", rgb: \"#CC3336\" }, // dupe of Mahogany\n  { name: \"Magenta\", rgb: \"#F653A6\" },\n  // { name: \"Mahogany\", rgb: \"#CA3435\" }, // dupe of brick red\n  { name: \"Maize\", rgb: \"#F2C649\" },\n  // { name: \"Manatee\", rgb: \"#8D90A1\" },\n  // { name: \"Mango Tango\", rgb: \"#E77200\" }, NO FUN\n  { name: \"Maroon\", rgb: \"#C32148\" },\n  // { name: \"Mauvelous\", rgb: \"#F091A9\" }, I SAID, NO FUN\n  // { name: \"Maximum blue-green\", rgb: \"#30BFBF\" },\n  // { name: \"Maximum blue-purple\", rgb: \"#ACACE6\" }, // renamed to \"vivid\"\n  // { name: \"Maximum blue\", rgb: \"#47ABCC\" },\n  // { name: \"Maximum green\", rgb: \"#5E8C31\" },\n  // { name: \"Maximum green yellow\", rgb: \"#D9E650\" },\n  // // { name: \"Maximum purple\", rgb: \"#733380\" },\n  // { name: \"Maximum red-purple\", rgb: \"#A63A79\" },\n  // { name: \"Maximum red\", rgb: \"#D92121\" },\n  // { name: \"Maximum yellow-red\", rgb: \"#F2BA49\" },\n  // { name: \"Maximum yellow\", rgb: \"#FAFA37\" },\n  { name: \"Medium chrome green\", rgb: \"#6CA67C\" },\n  // { name: \"Medium rose\", rgb: \"#D96CBE\" }, // dupe of Brillian rose (!!)\n  { name: \"Medium violet\", rgb: \"#8F47B3\" },\n  { name: \"Melon\", rgb: \"#FEBAAD\" },\n  { name: \"Middle blue-green\", rgb: \"#8DD9CC\" },\n  { name: \"Middle blue-purple\", rgb: \"#8B72BE\" },\n  // { name: \"Middle Blue\", rgb: \"#7ED4E6\" }, // dupe of sky blue\n  // { name: \"Middle green\", rgb: \"#4D8C57\" },\n  { name: \"Middle green-yellow\", rgb: \"#ACBF60\" },\n  { name: \"Middle purple\", rgb: \"#D982B5\" },\n  // { name: \"Middle red-purple\", rgb: \"#A55353\" }, // NOT RED PURPLE!\n  // { name: \"Middle red\", rgb: \"#E58E73\" }, // duplicates copper\n  { name: \"Middle yellow-red\", rgb: \"#ECAC76\" },\n  // { name: \"Middle yellow\", rgb: \"#FFEB00\" }, //  dupe of Yellow\n  { name: \"Midnight blue\", rgb: \"#003366\" },\n  // { name: \"Mountain meadow\", rgb: \"#1AB385\" }, // dupe of jungle green\n  { name: \"Mulberry\", rgb: \"#C8509B\" },\n  { name: \"Navy blue\", rgb: \"#0066CC\" },\n  { name: \"Olive green\", rgb: \"#B5B35C\" },\n  // { name: \"Orange-Red\", rgb: \"#FF5349\" }, // dupe of Sunset Orange\n  { name: \"Orange\", rgb: \"#FF8833\" },\n  // { name: \"Orange-Yellow\", rgb: \"#F8D568\" }, // dupe of Goldenrod\n  { name: \"Orchid\", rgb: \"#E29CD2\" },\n  // { name: \"Outer space\", rgb: \"#2D383A\" }, // dupe of 80% black\n  // { name: \"Pacific blue\", rgb: \"#009DC4\" },\n  { name: \"Peach\", rgb: \"#FFCBA4\" },\n  { name: \"Periwinkle\", rgb: \"#C3CDE6\" },\n  // { name: \"Permanent Geranium Lake\", rgb: \"#E12C2C\" }, // replaced by Alizarin crimson\n  // { name: \"Piggy pink\", rgb: \"#FDD7E4\" },\n  { name: \"Pine green\", rgb: \"#01796F\" },\n  { name: \"Pink flamingo\", rgb: \"#FC74FD\" },\n  // { name: \"Pink sherbert\", rgb: \"#F7A38E\" }, // dupe of Salmon\n  { name: \"Plum\", rgb: \"#8E3179\" },\n  // { name: \"Purple heart\", rgb: \"#652DC1\" },\n  // { name: \"Purple Mountains' Majesty\", rgb: \"#D6AEDD\" },\n  // { name: \"Raw sienna\", rgb: \"#D27D46\" }, // this is too light for \"raw sienna\".\n  { name: \"Raw umber\", rgb: \"#665233\" },\n  // { name: \"Razzmatazz\", rgb: \"#E30B5C\" }, // NO FUN\n  { name: \"Red-orange\", rgb: \"#FF681F\" },\n  { name: \"Red\", rgb: \"#ED0A3F\" },\n  // { name: \"Robin's egg blue\", rgb: \"#00CCCC\" },\n  // { name: \"Royal purple\", rgb: \"#6B3FA0\" }, // dupe of Rebecca purple\n  { name: \"Salmon\", rgb: \"#FF91A4\" },\n  // { name: \"Scarlet\", rgb: \"#FD0E35\" }, // it's quite vivid\n  { name: \"Vivid scarlet\", rgb: \"#FD0E35\" }, // it's quite vivid\n  { name: \"Sea green\", rgb: \"#93DFB8\" },\n  { name: \"Sepia\", rgb: \"#9E5B40\" },\n  // { name: \"Shadow\", rgb: \"#837050\" }, // not really intuitive\n  { name: \"Shamrock\", rgb: \"#33CC99\" },\n  // { name: \"Silver\", rgb: \"#C9C0BB\" }, in Greys\n  { name: \"Sky blue\", rgb: \"#76D7EA\" },\n  { name: \"Spring green\", rgb: \"#ECEBBD\" },\n  { name: \"Sunset orange\", rgb: \"#FE4C40\" },\n  { name: \"Tan\", rgb: \"#FA9D5A\" },\n  { name: \"Teal blue\", rgb: \"#008080\" },\n  { name: \"Thistle\", rgb: \"#D8BFD8\" },\n  // { name: \"Tickle Me Pink\", rgb: \"#FC80A5\" }, NO FUN\n  // { name: \"Timberwolf\", rgb: \"#D9D6CF\" }, WTH, also, NO FUN\n  // { name: \"Tropical Rain Forest\", rgb: \"#00755E\" }, NO FUN\n  // { name: \"Tumbleweed\", rgb: \"#DEA681\" }, // NO FUN\n  // { name: \"Turquoise blue\", rgb: \"#6CDAE7\" }, // dupe of Aquamarine\n  // { name: \"Ultramarine blue\", rgb: \"#3F26BF\" }, // dupe of Phthalo blue\n  // { name: \"Van Dyke Brown\", rgb: \"#664228\" }, // uh wat\n  // { name: \"Venetian Red\", rgb: \"#CC553D\" },\n  // { name: \"Vivid Tangerine\", rgb: \"#FF9980\" }, NOT VIVID!\n  { name: \"Vivid tangerine\", rgb: \"#ED3C10\" },\n  // { name: \"Vivid Violet\", rgb: \"#803790\" }, // not vivid enough!\n  { name: \"Vivid violet\", rgb: \"#a625c3\" },\n  // { name: \"Wild Blue Yonder\", rgb: \"#7A89B8\" }, NO\n  // { name: \"Wild Strawberry\", rgb: \"#FF3399\" },\n  { name: \"Wisteria\", rgb: \"#C9A0DC\" },\n  { name: \"Yellow-green\", rgb: \"#C5E17A\" },\n  { name: \"Yellow-orange\", rgb: \"#FFAE42\" },\n  { name: \"Yellow\", rgb: \"#FBE870\" }\n]\n\nexport const CrayonSupplements = [\n  // { name: \"Alizarin crimson\", rgb: \"#E32636\" }, // BOB ROSS FTW replaces Permanent Geranium Lake and English Vermilion\n  { name: \"Artichoke\", rgb: \"#8F9779\" },\n  { name: \"Aubergine\", rgb: \"#48213A\" },\n  // { name: \"Birch brown\", rgb: \"#B14A30\" }, // replaces Dark Venetian Red, but duplicates Brown\n  { name: \"Brandy rose\", rgb: \"#B1847F\" }, // fills gap around Copper\n  { name: \"Burgundy\", rgb: \"#800020\" },\n  { name: \"Burnt sienna\", rgb: \"#E97451\" }, // replaces Light Venetian Red\n  // { name: \"Cadmium yellow\", rgb: \"#F9DA03\" },\n  { name: \"Crimson red\", rgb: \"#990000\" },\n  { name: \"Dark brown\", rgb: \"#664228\" }, // replaces Van Dyke Brown\n  { name: \"Dark coral\", rgb: \"#CD5B45\" }, // replaces Venetian Red\n\n  { name: \"Dark raspberry\", rgb: \"#872657\" }, // replaces Jazzberry Jam\n  { name: \"Dark turquoise\", rgb: \"#610079\" },\n  // { name: \"Dark violet\", rgb: \"#722E72\" }, // dupe of plum\n  { name: \"Deep coffee\", rgb: \"#704241\" },\n  { name: \"Ecru\", rgb: \"#BCAC7C\" },\n  { name: \"Evergreen\", rgb: \"#05472A\" },\n  { name: \"Eggplant\", rgb: \"#380835\" },\n  { name: \"Eggplant purple\", rgb: \"#430541\" },\n  { name: \"Emerald green\", rgb: \"#028F1E\" },\n  { name: \"Flamingo pink\", rgb: \"#D67C99\" }, // replaces Tickle Me Pink\n  { name: \"Grape\", rgb: \"#6C3461\" },\n  // { name: \"Italian roast\", rgb: \"#906652\" }, // replaces BEAVER\n  { name: \"Kelly green\", rgb: \"#4CBB17\" },\n  { name: \"Light forest green\", rgb: \"#4F9153\" },\n  { name: \"Medium dark brown\", rgb: \"#AF7200\" },\n  { name: \"Medium dark cyan-blue\", rgb: \"#2D537C\" },\n  { name: \"Mustard\", rgb: \"#FAAF18\" },\n  { name: \"Neon green\", rgb: \"#39FF14\" }, // missing\n  { name: \"Pear\", rgb: \"#D1E231\" },\n  { name: \"Pewter blue\", rgb: \"#8BA8B7\" },\n  { name: \"Phthalo blue\", rgb: \"#0016C7\" }, // BOB ROSS FTW\n  // { name: \"Phthalo green\", rgb: \"#123524\" }, // dupe of Forest green\n  { name: \"Pink lace\", rgb: \"#FFDDF4\" },\n  { name: \"Raw sienna\", rgb: \"#884B15\" },\n  { name: \"Rebecca purple\", rgb: \"#663399\" }, // https://meyerweb.com/eric/thoughts/2014/06/19/rebeccapurple/\n  { name: \"Sap green\", rgb: \"#536916\" },\n  { name: \"Blue sapphire\", rgb: \"#133ECB\" },\n  { name: \"Shadow blue\", rgb: \"#778BA5\" },\n  { name: \"Shadow green\", rgb: \"#121E06\" },\n  { name: \"Swamp green\", rgb: \"#748500\" },\n  { name: \"Verdigris\", rgb: \"#43B3AE\" },\n  { name: \"Vivid blue-magenta\", rgb: \"#4817E8\" },\n  { name: \"Vivid blue-purple\", rgb: \"#ACACE6\" },\n  { name: \"Vivid blue\", rgb: \"#47ABCC\" },\n  { name: \"Vivid green-yellow\", rgb: \"#D9E650\" },\n  { name: \"Vivid green\", rgb: \"#7BE214\" },\n  { name: \"Vivid lavender\", rgb: \"#A354FD\" },\n  { name: \"Vivid mint\", rgb: \"#00F28C\" },\n  { name: \"Vivid red-purple\", rgb: \"#C31D7E\" },\n  { name: \"Vivid red\", rgb: \"#D92121\" },\n  { name: \"Vivid yellow-red\", rgb: \"#F2BA49\" },\n  { name: \"Vivid yellow\", rgb: \"#FAFA37\" }\n  // { name: \"Vivid purple\", rgb: \"#733380\" }, // dupe of vivid violet\n\n  // { name: \"Tropical violet\", rgb: \"#CDA4DE\" }, // replaces Purple Mountains' Majesty, but too close to Wisteria\n]\n","export const DarkWikipediaColors = [\n  { name: \"Bistre\", rgb: \"#3D2B1F\" }, // very dark brown\n  { name: \"Black bean\", rgb: \"#3D0C02\" },\n  // { name: \"Black coffee\", rgb: \"#3B2F2F\" },\n  { name: \"Black pearl\", rgb: \"#041322\" },\n  { name: \"Shadow blue\", rgb: \"#001440\" },\n  { name: \"Charcoal\", rgb: \"#36454F\" },\n  // { name: \"Dark cyan-blue\", rgb: \"#002f76\" }, // dupe of Midnight blue\n  { name: \"Dark indigo\", rgb: \"#1F0A52\" },\n  { name: \"Dark magenta\", rgb: \"#8B008B\" },\n  { name: \"Dark moss green\", rgb: \"#4A5D23\" },\n  { name: \"Dark navy\", rgb: \"#02075D\" },\n  { name: \"Dark pastel blue\", rgb: \"#779ECB\" },\n  { name: \"Dark purple\", rgb: \"#580040\" },\n  { name: \"Dark tan\", rgb: \"#918151\" },\n  { name: \"Dark yellow-green\", rgb: \"#304000\" },\n  { name: \"Dark yellow\", rgb: \"#9B870C\" },\n  { name: \"Deep violet\", rgb: \"#330066\" },\n  { name: \"Dusk\", rgb: \"#4E5481\" },\n  { name: \"Elderberry\", rgb: \"#1d1a34\" },\n  // no one knows what celadon is\n  // { name: \"Grey celadon\", rgb: \"#90906E\" },\n  { name: \"Grey jade\", rgb: \"#757C55\" },\n  { name: \"Grey magenta\", rgb: \"#83667F\" },\n  { name: \"Grey ochre\", rgb: \"#716659\" },\n  { name: \"Grey olive\", rgb: \"#656c5a\" }, // my name\n  { name: \"Grey sage\", rgb: \"#69724d\" }, // my name\n  { name: \"Taupe\", rgb: \"#483C32\" }\n\n  // { name: \"Black olive\", rgb: \"#3B3C36\" }, // duplicate of 75% black\n  // { name: \"Dark slate grey\", rgb: \"#580040\" },\n\n  // { name: \"Cool grey\", rgb: \"#8C92AC\" },\n  // { name: \"Onyx\", rgb: \"#353839\" },\n  // { name: \"Raisin black\", rgb: \"#242124\" }\n]\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { sqrt } from \"../Number\"\nimport { Triplet } from \"./Triplet\"\n\nexport function cie76_delta_e(lab1: Triplet, lab2: Triplet): number {\n  return Math.sqrt(\n    (lab2[0] - lab1[0]) ** 2 +\n      (lab2[1] - lab1[1]) ** 2 +\n      (lab2[2] - lab1[2]) ** 2\n  )\n}\n\n/**\n * @see https://en.wikipedia.org/wiki/Color_difference#CIE94\n * @return the perceptual difference. <= 2 is not perceptable.\n */\nexport function cie94_delta_e(lab1: Triplet, lab2: Triplet) {\n  const [L1, a1, b1] = lab1\n  const [L2, a2, b2] = lab2\n\n  // http://www.brucelindbloom.com/index.html?ColorDifferenceCalc.html\n\n  const _Kl = 1.0\n  const _K1 = 0.045\n  const _K2 = 0.015\n\n  const dL = L1 - L2\n  const dA = a1 - a2\n  const dB = b1 - b2\n  const c1 = sqrt(a1 ** 2 + b1 ** 2)\n  const c2 = sqrt(a2 ** 2 + b2 ** 2)\n  const dC = c1 - c2\n\n  const deltaH = sqrt(dA ** 2 + dB ** 2 - dC ** 2)\n\n  return sqrt(\n    (dL / _Kl) ** 2 +\n      (dC / (1.0 + _K1 * c1)) ** 2 +\n      (deltaH / (1.0 + _K2 * c1)) ** 2\n  )\n}\n\nexport const MinCie = 2 // barely perceptable\nexport const MaxCie = 20 // very perceptable\n\n/**\n * Use `diffCIE94` to return a correlation value between 1 (imperceptible\n * difference) and 0 (largest possible difference)).\n */\nexport function diffCIECorr(\n  lab1: Maybe<Triplet>,\n  lab2: Maybe<Triplet>\n): number {\n  if (lab1 == null || lab2 == null) return 1\n  return clamp(0, MaxCie, ciede2000_delta_e(lab1, lab2) - MinCie) / MaxCie\n}\n\nconst kL = 1 // 1 for graphic arts, 2 for textiles\nconst kC = 1 // unity factor\nconst kH = 1 // weighting factor\n\n// https://github.com/omgovich/colord/blob/master/src/get/getPerceivedDifference.ts failed tests\n\n// This is from https://github.com/Evercoder/d3-color-difference/blob/master/src/ciede2000.js\n\nexport function ciede2000_delta_e(std: Triplet, smp: Triplet): number {\n  const [lStd, aStd, bStd] = std\n  const cStd = sqrt(aStd ** 2 + bStd ** 2)\n\n  const [lSmp, aSmp, bSmp] = smp\n  const cSmp = sqrt(aSmp ** 2 + bSmp ** 2)\n\n  const cAvg = (cStd + cSmp) / 2\n\n  const G =\n    0.5 * (1 - sqrt(Math.pow(cAvg, 7) / (Math.pow(cAvg, 7) + Math.pow(25, 7))))\n\n  const apStd = aStd * (1 + G)\n  const apSmp = aSmp * (1 + G)\n\n  const cpStd = sqrt(apStd * apStd + bStd * bStd)\n  const cpSmp = sqrt(apSmp * apSmp + bSmp * bSmp)\n\n  let hpStd: number =\n    Math.abs(apStd) + Math.abs(bStd) === 0 ? 0 : Math.atan2(bStd, apStd)\n  hpStd += (hpStd < 0 ? 1 : 0) * 2 * Math.PI\n\n  let hpSmp =\n    Math.abs(apSmp) + Math.abs(bSmp) === 0 ? 0 : Math.atan2(bSmp, apSmp)\n  hpSmp += (hpSmp < 0 ? 1 : 0) * 2 * Math.PI\n\n  const dL = lSmp - lStd\n  const dC = cpSmp - cpStd\n\n  let dhp = cpStd * cpSmp === 0 ? 0 : hpSmp - hpStd\n  dhp -= (dhp > Math.PI ? 1 : 0) * 2 * Math.PI\n  dhp += (dhp < -Math.PI ? 1 : 0) * 2 * Math.PI\n\n  const dH = 2 * sqrt(cpStd * cpSmp) * Math.sin(dhp / 2)\n\n  const Lp = (lStd + lSmp) / 2\n  const Cp = (cpStd + cpSmp) / 2\n\n  let hp\n  if (cpStd * cpSmp === 0) {\n    hp = hpStd + hpSmp\n  } else {\n    hp = (hpStd + hpSmp) / 2\n    hp -= (Math.abs(hpStd - hpSmp) > Math.PI ? 1 : 0) * Math.PI\n    hp += (hp < 0 ? 1 : 0) * 2 * Math.PI\n  }\n\n  const Lpm50 = (Lp - 50) ** 2\n  const T =\n    1 -\n    0.17 * Math.cos(hp - Math.PI / 6) +\n    0.24 * Math.cos(2 * hp) +\n    0.32 * Math.cos(3 * hp + Math.PI / 30) -\n    0.2 * Math.cos(4 * hp - (63 * Math.PI) / 180)\n\n  const Sl = 1 + (0.015 * Lpm50) / sqrt(20 + Lpm50)\n  const Sc = 1 + 0.045 * Cp\n  const Sh = 1 + 0.015 * Cp * T\n\n  const deltaTheta =\n    ((30 * Math.PI) / 180) *\n    Math.exp(-1 * (((180 / Math.PI) * hp - 275) / 25) ** 2)\n  const Rc = 2 * sqrt(Math.pow(Cp, 7) / (Math.pow(Cp, 7) + Math.pow(25, 7)))\n\n  const Rt = -1 * Math.sin(2 * deltaTheta) * Rc\n\n  return sqrt(\n    Math.pow(dL / (kL * Sl), 2) +\n      Math.pow(dC / (kC * Sc), 2) +\n      Math.pow(dH / (kH * Sh), 2) +\n      (((Rt * dC) / (kC * Sc)) * dH) / (kH * Sh)\n  )\n}\n","import { compact } from \"../../fe/Array\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, closeTo, fmtPct, gt0, times } from \"../../fe/Number\"\nimport { PartiallyNull } from \"../../fe/PartiallyNull\"\nimport { Centroid } from \"../math/Kmeans\"\nimport { mapGt0 } from \"../Number\"\nimport { bestLabhashName } from \"./ColorNames\"\nimport { lab2rgbhex, toLabhash, unlabhash } from \"./Colorspace\"\nimport { ModeBits } from \"./ModeBits\"\nimport { ModeCount } from \"./ModeCount\"\nimport { WithModeData } from \"./ModeData\"\nimport { Triplet } from \"./Triplet\"\n\nexport function dominantColorsToRgbHex(arr: DominantColor[]) {\n  return compact(arr.map(ea => [ea.rgbhex, fmtPct(ea.pct)]))\n}\n\nexport class DominantColor {\n  static fromModeData(md: Partial<WithModeData>): DominantColor[] {\n    return compact(\n      times(ModeCount, i =>\n        DominantColor.fromLabhash({\n          labhash: (md as any)[`mode${i}`],\n          pct: (md as any)[`mode${i}pct`]\n        })\n      )\n    )\n  }\n\n  static toModeData(arr: DominantColor[]): PartiallyNull<WithModeData> {\n    const md: PartiallyNull<WithModeData> = {} as any\n    times(ModeCount, i => {\n      // We _really_ want all the fields here, to make sure we fully overwrite\n      // prior dominant colors (especially if there are fewer now than\n      // before), hence the `?? null`:\n      ;(md as any)[\"mode\" + i] = arr[i]?.labhash ?? null\n      ;(md as any)[\"mode\" + i + \"pct\"] = arr[i]?.pct ?? null\n    })\n    return md\n  }\n\n  static fromLabhash({\n    labhash,\n    labhashBits = ModeBits,\n    pct\n  }: {\n    labhash: Maybe<number>\n    labhashBits?: number\n    pct?: number\n  }): Maybe<DominantColor> {\n    const lab = mapGt0(labhash, ea => unlabhash(ea, labhashBits))\n    return lab == null || !gt0(pct) // < drops [0% - 0.5%]\n      ? undefined\n      : new DominantColor(lab, pct, labhash)\n  }\n\n  /**\n   * @param c.centroid is in L*a*b space\n   */\n  static fromCentroid(c: Centroid, totalPixels: number) {\n    return new DominantColor(\n      c.centroid as Triplet,\n      Math.round(100 * (c.size / totalPixels))\n    )\n  }\n\n  readonly labhash: number\n\n  readonly pct: number\n\n  constructor(\n    public readonly lab: Triplet,\n    pct: number,\n    labhash?: number\n  ) {\n    this.pct = clamp(0, 100, pct)\n    this.labhash = labhash ?? toLabhash(lab, ModeBits)\n  }\n\n  get rgbhex() {\n    return lab2rgbhex(this.lab)\n  }\n\n  get color() {\n    return bestLabhashName(this.labhash)\n  }\n\n  toGreyscale() {\n    return new DominantColor([this.lab[0], 0, 0], this.pct)\n  }\n\n  eql(other: DominantColor) {\n    return this.labhash === other.labhash && closeTo(this.pct, other.pct, 5)\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { compact, isEmpty, sum } from \"../../fe/Array\"\nimport { clamp } from \"../../fe/Number\"\nimport { leastBy } from \"../Array\"\nimport { Point, lerp2d } from \"../math/Lerp\"\nimport { avg } from \"../math/Vector\"\nimport { ciede2000_delta_e } from \"./DeltaE\"\nimport { DominantColor } from \"./DominantColor\"\n\nexport function dominantColorCorrelation(\n  a: DominantColor[],\n  b: DominantColor[]\n): number {\n  a = compact(a)\n  b = compact(b)\n  if (isEmpty(a) || isEmpty(b)) return 0\n  return avg([_impl(a, b), _impl(b, a)])!\n}\n\nfunction _impl(a: DominantColor[], b: DominantColor[]): number {\n  const totalCoverage = sum(a, ea => clamp(0, 100, ea.pct))\n  const totalMatch = sum(a, ea => _match(ea, b))\n  const result = totalMatch / totalCoverage\n  // console.log(\"_impl()\", { result, totalCoverage, totalMatch })\n  return result\n}\n\n/**\n * For the given color in a, find the closest match in b\n */\nfunction _match(a: DominantColor, b: DominantColor[]): number {\n  const nearest = leastBy(b, ea => ciede2000_delta_e(a.lab, ea.lab))\n  if (nearest == null) return 0\n  const delta_e = ciede2000_delta_e(a.lab, nearest.lab)\n  const pct = clamp(0, a.pct, avg([a.pct, nearest.pct])!)\n  const scaled = scaled_delta_e(delta_e)\n  const result = clamp(0, 100, pct) * scaled\n  // console.log(\"_match()\", {\n  //   name: a.color?.name,\n  //   rgb: a.rgbhex,\n  //   result,\n  //   nearest: nearest.rgbhex,\n  //   pct,\n  //   scaled,\n  //   delta_e\n  // })\n  return result\n}\n\nconst DeltaEMatchPoints = lazy<Point[]>(() => {\n  return [\n    { x: 0, y: 1 },\n    { x: 9, y: 0.8 }, // < still pretty good, you get a B\n    { x: 16, y: 0.3 }, // < oof those are pretty different, you get an F\n    { x: 20, y: 0 } // delta_e of 20 or 30 are different colors. No credit.\n  ]\n})\n\nexport function scaled_delta_e(delta_e: number): number {\n  return clamp(0, 1, lerp2d(delta_e, ...DeltaEMatchPoints()))\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { compact } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { later } from \"../../fe/Delay\"\nimport { stringify } from \"../../fe/JSON\"\nimport { gt0, round, times } from \"../../fe/Number\"\nimport { pick } from \"../../fe/Object\"\nimport { leastBy, leastByCtx } from \"../Array\"\nimport { CountingSet } from \"../CountingSet\"\nimport { mkLogger } from \"../Logger\"\nimport { timeSync } from \"../async/PromiseTimer\"\nimport { Average } from \"../math/Average\"\nimport { Centroid, KMeansOptions, kmeans } from \"../math/Kmeans\"\nimport { sumf } from \"../math/Vector\"\nimport { ColorDistanceFunction } from \"../settings/ColorDistanceFunctions\"\nimport { Settings } from \"../settings/Settings\"\nimport { toLabhash, unlabhash } from \"./Colorspace\"\nimport { cie76_delta_e, cie94_delta_e, ciede2000_delta_e } from \"./DeltaE\"\nimport { DominantColor, dominantColorsToRgbHex } from \"./DominantColor\"\nimport { ModeCount } from \"./ModeCount\"\nimport { Triplet } from \"./Triplet\"\n\nconst logger = lazy(() => mkLogger(\"color.DominantColors\"))\n\nexport interface DominantColorsResult {\n  dominantColors: DominantColor[]\n  description?: string\n  dominantColorScore?: number\n}\n\nexport function extractDominantColors(\n  labs: Triplet[],\n  k = ModeCount\n): DominantColorsResult {\n  return timeSync(\"img.extractDominantColors\", () =>\n    _extractDominantColors(labs, k)\n  )\n}\n\nexport function centroidsScore(labs: Triplet[], centroids: Centroid[]) {\n  const avg = new Average()\n  for (const lab of labs) {\n    const closest = leastBy(centroids, ea =>\n      ciede2000_delta_e(ea.centroid as Triplet, lab)\n    )\n    if (closest != null)\n      avg.push(ciede2000_delta_e(closest.centroid as Triplet, lab))\n  }\n  return avg\n}\n\n// // This is a stable set of seeds so modes are consistent across runs,\n// // generated by\n\n// // [...Array(128)].map(() => Math.round(Math.random() * Number.MAX_SAFE_INTEGER))\n\nconst Seeds = [\n  6147062518717073, 8176726750919909, 5426648081701673, 3626890591152700,\n  1992286907770916, 6348935463312109, 5900323173950995, 7358780886584433,\n  5704068712193493, 1439187428792466, 3964117351448708, 3732669315077812,\n  3584643590221450, 6738189173486085, 8537822851166899, 5390086061821835,\n  7712057976331355, 4111632552143076, 3262039419431488, 7036994544380825,\n  5353634786120155, 2702673693873340, 2977285826783918, 2051993783175518,\n  5481147022770415, 5347523348244809, 1479740947861756, 2855268408168642,\n  2122782837478138, 6354921850669697, 1993285398366740, 8622097963014773,\n  1969625934696118, 1820973444720312, 7128984079394103, 4062676716762962,\n  5088704486053871, 3523794113298350, 8018285280412081, 4524300326741245,\n  8307147030534695, 8135486835878813, 7699950603263999, 3140795115333806,\n  5903399874280295, 7462660765348991, 6442509751447017, 3977540297510326,\n  7214173935589545, 6001326758941961, 1476334133689168, 3441998479348530,\n  1379784479491042, 6757635537583321, 8501611905255957, 1434039221010556,\n  5958243312989149, 8928005021308717, 5032083390680559, 3155422458748008,\n  4437089545223804, 3682643804036758, 3837314353184286, 4753952745315177\n]\n\nconst DeltaEImpls: Record<ColorDistanceFunction, typeof ciede2000_delta_e> = {\n  cie76: cie76_delta_e,\n  cie94: cie94_delta_e,\n  ciede2000: ciede2000_delta_e\n} as const\n\nconst KmeansDefaults = lazy<Partial<KMeansOptions>>(() => ({\n  maxIterations: 50,\n  initialization: \"kmeans++\",\n  // ok to be undefined. kmeans will use euclidean distance.\n  distanceFunction: (DeltaEImpls as any)[\n    Settings.dominantColorDeltaE.valueOrDefault\n  ]\n}))\n\nlater(() => {\n  Settings.dominantColorDeltaE.watchLater(() => {\n    KmeansDefaults.unset()\n  })\n})\n\nfunction _extractDominantColors(\n  input: Triplet[],\n  k = ModeCount\n): DominantColorsResult {\n  const start = Date.now()\n  const runs = Settings.dominantColorKmeansRuns.valueOrDefault\n\n  const cs = new CountingSet<number>()\n  for (const lab of maybeFilterGrey({ labs: input, minK: k })) {\n    cs.incr(toLabhash(lab))\n  }\n\n  const distFunc =\n    (DeltaEImpls as any)[Settings.dominantColorDeltaE.valueOrDefault] ??\n    ciede2000_delta_e\n\n  function centroidDeltaP84(centroids: Centroid[]) {\n    const avg = new Average()\n    for (const [labhash, count] of cs.entries()) {\n      const lab = unlabhash(labhash)!\n      const nearest = leastByCtx(centroids, ea =>\n        distFunc(ea.centroid as Triplet, lab)\n      )\n      if (nearest != null) {\n        times(count, () => avg.push(nearest.value as number))\n      }\n    }\n    return avg.p84!\n  }\n\n  const labs = cs.sortedByKey().valuesToA(ea => unlabhash(ea)!)\n  let kActual = round(k + Settings.dominantColorMergeThreshold.valueOrDefault) // so merging doesn't leave insufficient colors\n\n  function setKActual(i: number) {\n    const minK = k\n    const maxK = k * 4\n    kActual = Math.round(Math.max(minK, Math.min(maxK, i)))\n  }\n\n  const kmeansResults =\n    // don't bother with kmeans if we have fewer colors than k!\n    labs.length <= kActual\n      ? []\n      : compact(\n          Seeds.slice(0, runs).map(seed => {\n            const km = kmeans(labs, kActual, {\n              ...KmeansDefaults,\n              seed\n            })\n            // truncate centroids to at most k elements:\n            const merged = mergeNearCentroids(km.centroids, labs.length)\n            if (merged.length < k) {\n              setKActual(kActual + k / 3)\n              return // < we need more centroids\n            } else if (merged.length > k) {\n              setKActual(kActual - 1)\n            }\n\n            const centroids = merged.slice(0, k)\n            const score = centroidDeltaP84(centroids)\n\n            return {\n              ...km,\n              centroids,\n              description: {\n                kIn: kActual,\n                kOut: km.centroids.length,\n                kMerged: merged.length,\n                score,\n                iterations: km.iterations,\n                uniqColors: cs.size,\n                elapsedMs: Date.now() - start\n              },\n              score\n            }\n          })\n        )\n\n  logger().trace(\"extractDominantColors()\", {\n    kmeansResults: kmeansResults.map(ea => pick(ea, \"description\", \"score\"))\n  })\n\n  const bestResult = leastBy(kmeansResults, ea => ea.score)\n\n  if (bestResult == null) {\n    logger().info(\n      \"kmeans failed or was disabled, using dominantColorsFromModes\",\n      { runs }\n    )\n    return dominantColorsFromModes(cs, k)\n  }\n\n  const description = stringify({\n    ...bestResult?.description,\n    elapsedMs: Date.now() - start\n  })\n\n  const orderedCentroids = sortBy(bestResult?.centroids, (ea: any) => -ea.size)\n  const dominantColors = orderedCentroids.map(ea =>\n    DominantColor.fromCentroid(ea, labs.length)\n  )\n\n  logger().debug(\"extractDominantColors() result\", {\n    description,\n    score: bestResult?.score,\n    totalColors: cs.size,\n    totalPixels: labs.length,\n    iters: bestResult?.iterations,\n    dominantColors: dominantColorsToRgbHex(dominantColors),\n    pixelCount: labs.length\n  })\n\n  // We're not returning \"score\" because dominantColorsFromModes score isn't\n  // comparable to kmeans score\n  return {\n    dominantColors,\n    description,\n    dominantColorScore: bestResult?.score\n  }\n}\n\nexport function maybeFilterGrey({\n  labs,\n  minK,\n  thresh,\n  retries = 3 // < number of times we'll halve the threshold and try again\n}: {\n  labs: Triplet[]\n  minK: number\n  thresh?: number\n  retries?: number\n}): Triplet[] {\n  if (retries < 0) {\n    logger().debug(\n      \"maybeFilterGrey(): exhausted retries: grey filtering disabled.\"\n    )\n    return labs\n  }\n  const greyThreshold =\n    thresh ?? Settings.dominantColorGreyThreshold.valueOrDefault\n  if (!gt0(greyThreshold)) {\n    logger().debug(\n      \"maybeFilterGrey(): grey threshold is <= 0: grey filtering disabled.\"\n    )\n    return labs\n  }\n  const filtered = labs.filter(\n    ea => Math.abs(ea[1]) + Math.abs(ea[2]) >= greyThreshold\n  )\n\n  // Don't reject a majority of pixels:\n  if (filtered.length >= labs.length / 2) {\n    logger().debug(\n      \"maybeFilterGrey(): sufficient remaining pixels with this threshold.\",\n      {\n        greyThreshold,\n        minK,\n        pixelCount: labs.length,\n        filteredCount: filtered.length\n      }\n    )\n    return filtered\n  } else {\n    logger().debug(\n      \"maybeFilterGrey(): insufficient remaining pixels with this threshold. Retrying with smaller threshold.\",\n      {\n        greyThreshold,\n        minK,\n        retries,\n        pixelCount: labs.length,\n        filteredCount: filtered.length\n      }\n    )\n    return maybeFilterGrey({\n      labs,\n      minK,\n      thresh: greyThreshold * 0.75,\n      retries: retries - 1\n    })\n  }\n}\n\nexport function dominantColorsFromModes(\n  labhashCountingSet: CountingSet<number>,\n  k: number\n): DominantColorsResult {\n  // assumes labs is already filtered for greys!\n  const pixelCount = labhashCountingSet.countSum\n  const uniqColors = labhashCountingSet.size\n  mergeLabhashes(labhashCountingSet)\n  const mergedColors = labhashCountingSet.size\n\n  // .fromLabHash will return null if the pct is too low, so we need compact()\n  const dominantColors = compact(\n    labhashCountingSet.top(k).map(([lh, cnt]) =>\n      DominantColor.fromLabhash({\n        labhash: lh,\n        pct: Math.round((100 * cnt) / pixelCount)\n      })\n    )\n  )\n  const pctOmitted = 100 - sumf(dominantColors, ea => ea.pct)\n\n  return {\n    dominantColors,\n    description:\n      \"dominantColorsFromModes: \" +\n      stringify({ uniqColors, mergedColors, pixelCount, pctOmitted })\n    // lower score is better: 0 means all the colors were captured\n  }\n}\n\nexport function mergeLabhashes(\n  cs: CountingSet<number>,\n  threshold = Settings.dominantColorMergeThreshold.valueOrDefault\n): CountingSet<number> {\n  const winners: { lab: Triplet; labhash: number }[] = []\n  for (const [labhash, count] of [...cs.entriesByCountDesc()]) {\n    const lab = unlabhash(labhash)!\n    const prior = winners.find(\n      ea => ciede2000_delta_e(ea.lab, lab) <= threshold\n    )\n    if (prior == null) {\n      winners.push({ lab, labhash })\n    } else {\n      // Merging with winner:\n      cs.delete(labhash)\n      cs.incr(prior.labhash, count)\n    }\n  }\n  return cs\n}\n\nexport function mergeNearCentroids(\n  arr: Centroid[],\n  pixelCount: number,\n  threshold = Settings.dominantColorMergeThreshold.valueOrDefault\n): Centroid[] {\n  if (threshold <= 0) return arr\n  const winners: Centroid[] = []\n  for (const centroid of arr) {\n    const prior = winners.find(\n      ea =>\n        ciede2000_delta_e(\n          centroid.centroid as Triplet,\n          ea.centroid as Triplet\n        ) <= threshold\n    )\n    if (prior == null) {\n      winners.push(centroid)\n    } else {\n      prior.size += centroid.size\n    }\n  }\n  const minSize = pixelCount / 100\n  return sortBy(\n    winners.filter(ea => ea.size > minSize),\n    ea => -ea.size\n  )\n}\n","// HEY FUTURE ME: With 10 greys we're still only 3 Δe away from any greyscale\n// color, which is totally fine.\n\nexport const Greys = [\n  { name: \"Black\", rgb: \"#000000\" }, // in crayon colors\n  // This \"percent of grey\" instead of \"percent of white\" follows X11 color\n  // names.\n  // { name: \"95% black\", rgb: \"#111111\" },\n  { name: \"90% black\", rgb: \"#1b1b1b\" },\n  // { name: \"85% black\", rgb: \"#262626\" },\n  { name: \"80% black\", rgb: \"#303030\" },\n  // { name: \"75% black\", rgb: \"#3b3b3b\" },\n  { name: \"70% black\", rgb: \"#474747\" },\n  // { name: \"65% black\", rgb: \"#525252\" },\n  { name: \"60% black\", rgb: \"#5e5e5e\" },\n  // { name: \"55% black\", rgb: \"#6a6a6a\" },\n  { name: \"Grey\", rgb: \"#777777\" },\n  // { name: \"55% white\", rgb: \"#848484\" },\n  { name: \"60% white\", rgb: \"#919191\" },\n  // { name: \"65% white\", rgb: \"#9e9e9e\" },\n  { name: \"70% white\", rgb: \"#ababab\" },\n  // { name: \"75% white\", rgb: \"#b9b9b9\" },\n  { name: \"80% white\", rgb: \"#c6c6c6\" },\n  // { name: \"85% white\", rgb: \"#d4d4d4\" },\n  { name: \"90% white\", rgb: \"#e2e2e2\" },\n  // { name: \"95% white\", rgb: \"#f1f1f1\" },\n  { name: \"White\", rgb: \"#ffffff\" }\n]\n\n// for (const l of stepRange(0, 105, 5)) {\n//   console.log(\n//     JSON.stringify({\n//       name: fmtPct(l) + \" grey\",\n//       rgb: lab2rgbhex([l, 0, 0])\n//     })\n//   )\n// }\n","import { lazy } from \"../../core/Lazy\"\nimport { within } from \"../../fe/Number\"\nimport { mkLogger } from \"../Logger\"\nimport { Average } from \"../math/Average\"\nimport { Settings } from \"../settings/Settings\"\nimport { clampLab } from \"./Colorspace\"\nimport { Triplet } from \"./Triplet\"\n\nconst logger = lazy(() => mkLogger(\"color.Lab\"))\n\nexport function isLab(l: any): l is Triplet {\n  return (\n    Array.isArray(l) &&\n    l.length === 3 &&\n    within(0, 100, l[0]) &&\n    within(-110, 110, l[1]) &&\n    within(-110, 110, l[2])\n  )\n}\n\n/**\n * @param labs [[L* values], [a* values], [b* values]]\n */\nexport function labsAreGreyscale(labs: Triplet[]) {\n  const thresh = Settings.greyscaleColorThreshold.valueOrDefault\n  const a = new Average()\n  const b = new Average()\n  for (const ea of labs) {\n    const clamped = clampLab(ea)\n    a.push(clamped[1])\n    b.push(clamped[2])\n  }\n  const value = (a.stdDev ?? 0) + (b.stdDev ?? 0)\n  const result = value < thresh\n  return logger().tap({\n    msg: \"labsAreGreyscale()\",\n    result,\n    meta: { value, thresh }\n  })\n}\n","export const LightWikipediaColors = [\n  // { name: \"Alabaster\", rgb: \"#EDEAE0\" }, // dupe of Parchment\n  { name: \"Beige\", rgb: \"#F5F5DC\" },\n  // { name: \"Bone\", rgb: \"#E3DAC9\" },\n  // { name: \"Cornsilk\", rgb: \"#FFF8DC\" },\n  // { name: \"Ivory\", rgb: \"#FFFFF0\" },\n  { name: \"Laurel green\", rgb: \"#A9BA9D\" },\n  // { name: \"Light dusty yellow\", rgb: \"#E4D1A6\" }, dupe of vanilla\n  { name: \"Light sage\", rgb: \"#93A58B\" },\n  { name: \"Light green-cyan\", rgb: \"#CFEADE\" },\n  { name: \"Pastel purple\", rgb: \"#B39EB5\" },\n  // { name: \"Parchment\", rgb: \"#F1E9D2\" }, dupe of Beige\n  { name: \"Pewter blue\", rgb: \"#8BA8B7\" },\n  { name: \"Powder blue\", rgb: \"#B0E0E6\" },\n  // { name: \"Seashell\", rgb: \"#FFF5EE\" }, // dupe of Beige\n  { name: \"Vanilla\", rgb: \"#F3E5AB\" }\n  // { name: \"Champagne\", rgb: \"#F7E7CE\" }, // not needed\n]\n","// How many bits per color for N modes?\n// 6 bits shared across 3 channels means 2 bits (4 values) per channel, 4 ** 3 =\n// 64 colors, but ends up only being ~21 colors in practice due to the\n// non-uniform L*a*b* colorspace\n// Total possible uniq labhashes\n// for 6: 40\n// for 7: 70\n// for 8: 107\n// for 9: 172\n// for 10: 292\n// for 11: 460\n// for 12: 589\n// But in practice, photos only have a subset of the full colorspace:\n// for 8, ~35 colors.\n// for 9, ~38 colors.\n// for 10, ~49 colors\n// for 11, ~47 colors (! worse than 10)\n// for 12, ~80 colors\n// for 15, ~95 colors (still ample collisions)\n// HEY FUTURE ME. 12 bits is _fine_. It allows for reasonably good matching (average cie94 delta of 3)\n\nexport const ModeBits = 12 // 12 = 4 bits per L*, a*, and b channels\n","// with ModeBits = 12\n// with 5: labModesCorr: { k: 18, avg: 0.931, min: 0.69, max: 1, sd: 0.09 }\n// with 6: labModesCorr: { k: 18, avg: 0.942, min: 0.72, max: 1, sd: 0.08 }\n// with 7: labModesCorr: { k: 18, avg: 0.946, min: 0.74, max: 1, sd: 0.08 }\n// with ModeBits = 15\n// with 5: labModesCorr: { k: 18, avg: 0.962, min: 0.79, max: 1, sd: 0.06 }\n// with 6: labModesCorr: { k: 18, avg: 0.959, min: 0.79, max: 1, sd: 0.05 }\n// with 7: labModesCorr: { k: 18, avg: 0.954, min: 0.79, max: 1, sd: 0.06 }\n// 15 ModeBits means the modes are taken up with fairly similar colors (and\n// makes library preview-similarity tests fail). 12 seems to be a reasonable\n// compromize between accuracy and posterization.\n// SearchHash only looks at lightness, and needs to be < 52 bits. 7x7 is 49:\n// export const SearchHashDim = 5\n// export const SearchHashBits = SearchHashDim * SearchHashDim * 3\n// export const MaxSearchHash = 2 ** SearchHashBits\n\nexport const ModeCount = 7 // lucky. Make sure this matches the AssetFile.modeN fields!\n","import { Unpick } from \"../../fe/Maybe\"\nimport { gt0 } from \"../../fe/Number\"\nimport { Obj, omit, pick } from \"../../fe/Object\"\nimport { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\n\nexport interface WithModePcts {\n  mode0pct: number\n  mode1pct: number\n  mode2pct: number\n  mode3pct: number\n  mode4pct: number\n  mode5pct: number\n  mode6pct: number\n}\n\nexport interface WithModes {\n  mode0: number\n  mode1: number\n  mode2: number\n  mode3: number\n  mode4: number\n  mode5: number\n  mode6: number\n}\n\nexport type WithModeData = WithModes & WithModePcts\n\nexport function isModeData(ea: any): ea is Partial<WithModeData> {\n  // only require mode0\n  return gt0(ea.mode0) && gt0(ea.mode0pct)\n}\n\nexport const ModeDataKeys = strEnum(\n  \"mode0\",\n  \"mode0pct\",\n  \"mode1\",\n  \"mode1pct\",\n  \"mode2\",\n  \"mode2pct\",\n  \"mode3\",\n  \"mode3pct\",\n  \"mode4\",\n  \"mode4pct\",\n  \"mode5\",\n  \"mode5pct\",\n  \"mode6\",\n  \"mode6pct\"\n)\n\nexport type ModeDataKey = StrEnumKeys<typeof ModeDataKeys>\n\nexport function pickModeData(ea: any) {\n  return pick(ea, ...ModeDataKeys.values)\n}\n\nexport function omitModeData<T extends Obj>(ea: T): Unpick<T, ModeDataKey> {\n  return omit(ea, ...ModeDataKeys.values)\n}\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { leftPad } from \"../../fe/Pad\"\nimport { ensurePrefix } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { Triplet } from \"./Triplet\"\n\nconst RgbHexRe = /^#?([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})$/i\n\nexport function normalizeRgbHex(rgbhex: string): Maybe<string> {\n  const s = toS(rgbhex).trim()\n  return RgbHexRe.test(s) ? ensurePrefix(s, \"#\").toUpperCase() : undefined\n}\n\nexport function rgbhex2triplet(rgbHex: string): Maybe<Triplet> {\n  const m = toS(rgbHex).trim().match(RgbHexRe)\n  if (m == null) return\n  try {\n    // parseInt throws if the string is not a valid number, but the regex\n    // should only allow valid hex values.\n    return [m[1], m[2], m[3]].map(\n      ea => clamp(0, 255, parseInt(ea, 16)) // < no need to round\n    ) as Triplet\n  } catch {\n    return\n  }\n}\n\nexport function rgbTriplet2hex(rgb: Triplet): string {\n  return (\n    \"#\" +\n    clampRGB(rgb)\n      .map(ea => leftPad(Math.round(ea).toString(16).toUpperCase(), 2, \"0\"))\n      .join(\"\")\n  )\n}\n\nexport function clampRGB(rgb: Triplet): Triplet {\n  return (\n    // the [0], [1], [2] allows rgb to be a Buffer.slice:\n    [rgb[0], rgb[1], rgb[2]]\n      // clamp values to expected reasonable [0, 255] range:\n      .map(ea => clamp(0, 255, Math.round(ea))) as Triplet\n  )\n}\n","import { DateObjectUnits, DateTime, Duration, Zone } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { hourMs, isDate, secondMs } from \"../../fe/Date\"\nimport { mapOr } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { closeTo as closeToNumber, gt0, round } from \"../../fe/Number\"\nimport { isObject, omit } from \"../../fe/Object\"\nimport { cmp } from \"../../fe/Primitive\"\nimport { mkLogger } from \"../Logger\"\n\nconst logger = lazy(() => mkLogger(\"date.Date\"))\n\n// WHAT THE ACTUAL FLYING F luxon 2 removed zone from DateObject.\n\n// SITS: Luxon considers 0 to be INVALID for month, day, and hour, so these\n// are all optional.\nexport interface DateObject\n  extends Pick<\n      DateObjectUnits,\n      \"year\" | \"month\" | \"day\" | \"hour\" | \"minute\" | \"second\"\n    >,\n    Pick<DateObjectUnits, \"millisecond\"> {\n  zone?: string | Zone | undefined\n  rawValue?: string\n  tzoffsetMinutes?: number | undefined\n}\n\nexport function isDateObject(a: any): a is DateObject {\n  return isObject(a) && [\"year\", \"month\", \"day\"].every(k => k in a)\n}\n\nexport function cmpDate(a?: Date, b?: Date): number {\n  const aTime = mapOr(\n    a,\n    d => d.getTime(),\n    () => 0\n  )\n  const bTime = mapOr(\n    b,\n    d => d.getTime(),\n    () => 0\n  )\n  return cmp(aTime, bTime)\n}\n\nexport function msUntil(d?: Date): number {\n  if (d == null) return 0\n  const ts = d.getTime()\n  const n = Date.now()\n  return ts <= n ? 0 : ts - n\n}\n\nexport function closeTo(a: Maybe<Date>, b: Maybe<Date>, maxMsDelta: number) {\n  return (\n    a != null && b != null && Math.abs(a.getTime() - b.getTime()) <= maxMsDelta\n  )\n}\n\nexport function nowish(d: Maybe<number | Date>, maxMsDelta = 2500): boolean {\n  return d == null\n    ? false\n    : isDate(d)\n    ? closeTo(d, new Date(), maxMsDelta)\n    : Math.abs(d - Date.now()) < maxMsDelta\n}\n\nexport function isRecentMs(timeMs: Maybe<number>, deltaMs: number): boolean {\n  return closeToNumber(Date.now(), timeMs, deltaMs)\n}\n\nexport function fmtMs(ms: number): string {\n  return Duration.fromMillis(ms).toFormat(\"m:ss.SSS\")\n}\n\nexport function durationToPaddedHMS(ms: number): string {\n  return Duration.fromMillis(ms).toFormat(\"hhhh:mm:ss.SSS\")\n}\n\nexport function durationHMS(ms: number): string {\n  return Duration.fromMillis(round(ms / secondMs) * secondMs).toFormat(\n    ms < hourMs ? \"m:ss\" : \"h:mm:ss\"\n  )\n}\n\nexport function isoNow() {\n  return new Date().toISOString()\n}\n\nexport function utcIsoToTs(iso: Maybe<string>): Maybe<number> {\n  if (blank(iso)) return\n  const dt = DateTime.fromISO(iso, { zone: \"utc\" })\n  return dt.isValid ? dt.toMillis() : undefined\n}\n\nexport function dateObjectToDateTime(obj: Maybe<DateObject>): Maybe<DateTime> {\n  if (obj == null) return\n  try {\n    const dou: DateObjectUnits = omit(\n      obj,\n      \"zone\",\n      \"rawValue\",\n      \"tzoffsetMinutes\"\n    )\n    for (const k of [\"month\", \"day\", \"hour\"] as const) {\n      if (!gt0(dou[k])) {\n        delete dou[k]\n      }\n    }\n    const d = DateTime.fromObject(dou, { zone: obj.zone })\n    if (d != null && !d.isValid) {\n      logger().debug(\"dateObjectToDateTime() invalid\", {\n        obj,\n        why: d.invalidExplanation\n      })\n    }\n    return d?.isValid ? d : undefined\n  } catch (error) {\n    logger().debug(\"dateObjectToDateTime() failed\", { obj, error })\n    return\n  }\n}\n\n// DON'T USE JS DATE TO PARSE! js date parsing erases timezones and forces\n// everything to local or UTC.\n","import { ExifDateTime } from \"exiftool-vendored\"\nimport { ToISOTimeOptions, Zone, ZoneOptions } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, toInt } from \"../../fe/Number\"\nimport { toS } from \"../../fe/toS\"\nimport { RegExpOptional, concatRegexp } from \"../RegExp\"\nimport { Dated, datedOverlap, datedToPrecisionMs } from \"./Dated\"\nimport { parseExifDateTime } from \"./ExifDateTime\"\n\n// See https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n\nconst dateIntervalRE = lazy(() => {\n  const startRE = /(?<start>\\d{2,}[-+\\dTZ:.,]+?)/i\n  const endRE = /(?<end>\\d{2}[-+\\dTZ:.,]+)/\n  const solidusRE = /(?<solidus>:--|\\/)/\n  const splitInfoRE = /\\/(?<index>\\d+)\\/(?<splits>\\d+)/\n  return concatRegexp([\n    /^/,\n    startRE,\n    solidusRE,\n    endRE,\n    RegExpOptional.from(splitInfoRE),\n    /$/\n  ])\n})\n\nfunction edtField<F extends keyof ExifDateTime>({\n  start,\n  end,\n  middle,\n  field\n}: {\n  start: ExifDateTime\n  end: ExifDateTime\n  middle: ExifDateTime\n  field: F\n}): Maybe<ExifDateTime[F]> {\n  return start[field] != null && end[field] != null ? middle[field] : undefined\n}\n\nconst Fields = [\n  \"year\",\n  \"month\",\n  \"day\",\n  \"hour\",\n  \"minute\",\n  \"second\",\n  \"millisecond\"\n] as const satisfies Readonly<(keyof ExifDateTime)[]>\n\nexport class DateInterval {\n  static fromISO(s: string, defaultZone?: Maybe<string>): Maybe<DateInterval> {\n    const m = dateIntervalRE().exec(toS(s).trim())\n    const g = m?.groups\n\n    return g == null\n      ? undefined\n      : DateInterval.for(\n          parseExifDateTime(g.start, defaultZone),\n          parseExifDateTime(g.end, defaultZone),\n          toInt(g.index),\n          toInt(g.splits)\n        )\n  }\n\n  toJSON() {\n    return {\n      _ctor: \"DateInterval\",\n      start: this.start?.toJSON(),\n      end: this.end?.toJSON(),\n      index: this.index,\n      splits: this.splits\n    }\n  }\n\n  static fromJSON(obj: ReturnType<DateInterval[\"toJSON\"]>) {\n    return this.for(\n      map(obj.start, ea => ExifDateTime.fromJSON(ea)),\n      map(obj.end, ea => ExifDateTime.fromJSON(ea)),\n      obj.index,\n      obj.splits\n    )\n  }\n\n  static for(\n    start: Maybe<ExifDateTime>,\n    end: Maybe<ExifDateTime>,\n    index = 0,\n    splits = 1\n  ): Maybe<DateInterval> {\n    if (start == null || !start.isValid || end == null || !end.isValid) return\n    splits = clamp(1, 1000, toInt(splits, { defaultValue: 1 })!)\n    index = clamp(0, splits - 1, toInt(index, { defaultValue: 0 })!)\n\n    if (start.hasZone && !end.hasZone && start.zone != null) {\n      end = end.setZone(start.zone) ?? end\n    } else if (!start.hasZone && end.hasZone && end.zone != null) {\n      start = start.setZone(end.zone) ?? start\n    }\n\n    const startTs = start.toMillis()\n    const durationMs = end.toMillis() - startTs\n    const deltaMs = (durationMs / (splits + 1)) * (index + 1)\n    const middle = start.plus({ milliseconds: deltaMs })\n\n    // console.log(\"DateInterval.for\", {\n    //   start,\n    //   end,\n    //   index,\n    //   splits,\n    //   durationMs,\n    //   duration: fmtDuration(durationMs),\n    //   deltaMs,\n    //   delta: fmtDuration(deltaMs),\n    //   middle,\n    //   middle_ISO: middle?.toISOString()\n    // })\n\n    return middle == null\n      ? undefined\n      : new DateInterval(start, middle, end, index, splits)\n  }\n\n  readonly year: Maybe<number>\n  readonly month: Maybe<number>\n  readonly day: Maybe<number>\n  readonly hour: Maybe<number>\n  readonly minute: Maybe<number>\n  readonly second: Maybe<number>\n  readonly millisecond: Maybe<number>\n\n  private constructor(\n    readonly start: ExifDateTime,\n    readonly middle: ExifDateTime,\n    readonly end: ExifDateTime,\n    readonly index = 0,\n    readonly splits = 1\n  ) {\n    ;[\n      this.year,\n      this.month,\n      this.day,\n      this.hour,\n      this.minute,\n      this.second,\n      this.millisecond\n    ] = Fields.map(field => edtField({ start, middle, end, field }))\n  }\n\n  get intervalMs() {\n    return this.end.toMillis() - this.start.toMillis()\n  }\n\n  get precisionMs() {\n    return (\n      this.end.toMillis() -\n      this.start.toMillis() +\n      Math.max(datedToPrecisionMs(this.end), datedToPrecisionMs(this.start))\n    )\n  }\n\n  toDate() {\n    return this.middle.toDate()\n  }\n\n  toMillis() {\n    return this.middle.toMillis()\n  }\n\n  get isValid(): boolean {\n    // always validated prior to construction:\n    return true\n  }\n\n  get zone() {\n    return this.start.zone ?? this.end.zone\n  }\n\n  get hasZone() {\n    return this.start.hasZone || this.end.hasZone\n  }\n\n  /**\n   * This only complies with the ISO standard if the index and slots are 1.\n   */\n  toString(options: ToISOTimeOptions = {}): string {\n    return (\n      `${this.start.toISOString(options)}/${this.end.toISOString(options)}` +\n      (this.index === 0 && this.splits === 1\n        ? \"\"\n        : `/${this.index}/${this.splits}`)\n    )\n  }\n\n  toISOString(options: ToISOTimeOptions = {}) {\n    return this.toString(options)\n  }\n\n  contains(d: Maybe<Dated>): boolean {\n    return true === datedOverlap({ a: this, b: d })?.aContainsB\n  }\n\n  overlaps(d: Maybe<Dated>): boolean {\n    return true === datedOverlap({ a: this, b: d })?.aOverlapsB\n  }\n\n  setZone(zone: string | Zone, opts?: ZoneOptions): DateInterval {\n    return new DateInterval(\n      this.start.setZone(zone, opts) ?? this.start,\n      this.middle.setZone(zone, opts) ?? this.middle,\n      this.end.setZone(zone, opts) ?? this.end,\n      this.index,\n      this.splits\n    )\n  }\n}\n","import { ExifDate, ExifDateTime } from \"exiftool-vendored\"\nimport { DateTime } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport {\n  dayMs,\n  hourMs,\n  minuteMs,\n  monthMs,\n  secondMs,\n  yearMs\n} from \"../../fe/Date\"\nimport { Json } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, isNumber } from \"../../fe/Number\"\nimport { maybeCall } from \"../../fe/Object\"\nimport { isString } from \"../../fe/String\"\nimport { mkLogger } from \"../Logger\"\nimport { DateObject, isDateObject } from \"./Date\"\nimport { DateInterval } from \"./DateInterval\"\nimport { datedToMillis } from \"./DatedToMillis\"\nimport { dateObjectToExifDateTime, parseExifDateTime } from \"./ExifDateTime\"\nimport { FuzzyDate, setZone } from \"./FuzzyDate\"\nimport {\n  getDay,\n  getHour,\n  getMillisecond,\n  getMinute,\n  getMonth,\n  getSecond\n} from \"./GetDateField\"\nimport { hasTime } from \"./HasTime\"\nimport { isDateTime } from \"./IsDateTime\"\nimport { getZoneName } from \"./getZoneName\"\n\nconst logger = lazy(() => mkLogger(\"date.Dated\"))\n\n// can't IDate because IMarried HUR HUR LOL DADJOKES FTW\n\n// references to exiftool-vendored must only be in this type signature to\n// prevent account from depending on exiftool-vendored.\n\nexport type Dated =\n  | FuzzyDate\n  | ExifDate\n  | ExifDateTime\n  | Date\n  | DateInterval\n  | DateTime\n  | DateObject\n\n// we don't include luxon.Interval here because our DateInterval supports\n// slots and index.\n\nexport function isDated(d: any): d is Dated {\n  // My proudest moment in coding:\n\n  // oh wait this is all just garbage bailing wire and duct tape *tear*.\n  return (\n    d != null &&\n    (d instanceof FuzzyDate ||\n      d instanceof ExifDate ||\n      d instanceof ExifDateTime ||\n      d instanceof Date ||\n      d instanceof DateInterval ||\n      isDateTime(d) ||\n      isDateObject(d))\n  )\n}\n\nexport function toDated(obj: any): Maybe<Dated> {\n  return isDated(obj) ? obj : undefined\n}\n\nexport function mapDated<T>(obj: any, f: (d: Dated) => T): Maybe<T> {\n  return isDated(obj) ? f(obj) : undefined\n}\n\nexport function toDate(d: Maybe<Dated>): Maybe<Date> {\n  if (d == null) return\n  if (typeof d === \"number\") {\n    return new Date(d)\n  }\n  if (d instanceof Date) {\n    return d\n  }\n  return maybeCall(d, \"toJSDate\") ?? maybeCall(d, \"toDate\")\n}\n\nexport function datedToStartTs(d: Maybe<Dated>): Maybe<number> {\n  if (d == null) return\n  else if (d instanceof DateInterval) {\n    return d.start.toMillis()\n  } else if (d instanceof ExifDate) {\n    return d.toMillis(0) // < defaults to 12 hours!\n  } else {\n    return datedToMillis(d)\n  }\n}\n\nexport function datedToStartDateTime(d: Dated): Maybe<DateTime> {\n  return d instanceof DateInterval\n    ? d.start.toDateTime()\n    : d instanceof ExifDate\n    ? DateTime.fromObject(d) // < defaults to noon, but we want midnight.\n    : datedToDateTime(d)\n}\n\n/**\n * If you don't care about timezone offsets (you're just wanting `.isValid`,\n * right?), otherwise, use `toExifDateTime`.\n */\nexport function datedToDateTime(d: Maybe<Dated>): Maybe<DateTime> {\n  try {\n    if (d == null || isString(d) || isNumber(d)) return\n    if (isDateTime(d)) return d\n    if (d instanceof ExifDateTime || d instanceof FuzzyDate)\n      return d.toDateTime()\n    if (d instanceof DateInterval) return d.middle.toDateTime()\n    if (d instanceof Date) return DateTime.fromJSDate(d)\n    return dateObjectToExifDateTime(d as any)?.toDateTime()\n  } catch (error) {\n    logger().warn(\"datedToDateTime() failed\", { d, error })\n    return\n  }\n}\n\nexport function datedToPrecisionMs(d: Dated): number {\n  if (d instanceof DateInterval) {\n    return d.precisionMs\n  }\n\n  if (hasTime(d)) {\n    if (gt0(getMillisecond(d))) return 0\n    if (gt0(getSecond(d))) return secondMs - 1\n    if (gt0(getMinute(d))) return minuteMs - 1\n    if (gt0(getHour(d))) return hourMs - 1\n  }\n\n  return gt0(getDay(d))\n    ? dayMs - 1\n    : gt0(getMonth(d))\n    ? monthMs - 1\n    : yearMs - 1\n}\n\nexport function isoToPrecisionMs(iso: string): Maybe<number> {\n  return map(isoToDated(iso), datedToPrecisionMs)\n}\n\nconst NoOverlap = {\n  aContainsB: false,\n  aOverlapsB: false\n}\n\nexport function datedOverlap({\n  a,\n  b,\n  aPrecisionMs,\n  bPrecisionMs\n}: {\n  a: Maybe<Dated>\n  b: Maybe<Dated>\n  aPrecisionMs?: number\n  bPrecisionMs?: number\n}): typeof NoOverlap {\n  if (a == null || b == null) return NoOverlap\n\n  aPrecisionMs ??= datedToPrecisionMs(a)\n  bPrecisionMs ??= datedToPrecisionMs(b)\n\n  // Eek: if one of the dates (but not the other) are missing a timezone, we\n  // want to assume the other is in the same timezone (or it'll be incorrectly\n  // wrong by the timezone offset)\n  const aZone = getZoneName(a)\n  const bZone = getZoneName(b)\n\n  if (aZone == null && bZone != null) {\n    a = setZone(a, bZone) ?? a\n  }\n\n  if (bZone == null && aZone != null) {\n    b = setZone(b, aZone) ?? b\n  }\n\n  const a0 = datedToStartTs(a)\n  const b0 = datedToStartTs(b)\n\n  if (a0 == null || b0 == null) return NoOverlap\n\n  const a1 = a0 + aPrecisionMs\n  const b1 = b0 + bPrecisionMs\n\n  const adjacent = a0 !== b0 && (a1 === b0 || a0 === b1)\n  const aOverlapsB = !adjacent && !(a1 < b0 || a0 > b1)\n  const aContainsB = aOverlapsB && a0 <= b0 && a1 >= b1\n  return logger().tap({\n    msg: \"datedOverlap()\",\n    result: {\n      aOverlapsB,\n      aContainsB\n    },\n    meta: {\n      a,\n      b,\n      aPrecisionMs,\n      bPrecisionMs\n    }\n  })\n}\n\nexport function isoToDated(iso: Maybe<string>, defaultZone?: Maybe<string>) {\n  return blank(iso)\n    ? undefined\n    : DateInterval.fromISO(iso, defaultZone) ??\n        parseExifDateTime(iso, defaultZone) ??\n        FuzzyDate.fromISO(iso)\n}\n\nexport function datedToJson(d: Dated): Json {\n  const j = (d as any).toJSON?.()\n  if (j != null) return j\n  if (d instanceof DateTime)\n    return {\n      ...d.toObject(),\n      zone: d.zoneName\n    }\n  return d as Json\n}\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { isNumber } from \"../../fe/Number\"\nimport { isString } from \"../String\"\nimport { Dated } from \"./Dated\"\n\n// CAREFUL! Don't reference exiftool-vendored here, because it will cause\n// account to depend on it.\n\nexport function datedToMillis(\n  d: Maybe<Dated | number | string>\n): Maybe<number> {\n  // invalid tag from ExifTool:\n  if (d == null || isString(d)) return\n\n  // Assume we're already in milliseconds (!! :hope:)\n  if (isNumber(d)) return d\n\n  return d instanceof Date\n    ? d.getTime()\n    : // FuzzyDate, ExifDateTime, ExifDate, DateTime all have a .toMillis() method:\n      (d as any).toMillis?.()\n}\n","// See https://moment.github.io/luxon/docs/manual/parsing.html#table-of-tokens\n// and https://en.wikipedia.org/wiki/Date_format_by_country\nexport const DefaultDateTimeFormats = [\n  \"y-M-d 'at' H.m.s\", // macOS screenshots\n  \"y-M-d H-m-s\", // gnome screenshots\n  \"y-MM-dd HH-mm-ss\", // gnome screenshots\n  \"y-MMM-d HH-mm-ss\", // reasonable timestamp with short month name\n  \"y-MMM-dd HH-mm-ss\", // reasonable timestamp with short month name\n  \"y-MMMM-d HH-mm-ss\", // reasonable timestamp with full month name\n  \"y-MMMM-dd HH-mm-ss\", // reasonable timestamp with full month name\n  \"y-MM-dd HHmmss\", // windows screenshots\n  \"yMMdd_HHmmss\", // smartphone camera filenames\n  \"yMMdd-HHmmss\", // smartphone camera filenames\n  \"y_MMdd_HHmmss\", // dashcam video timestamps may look like 2019_0624_181144_290.MOV\n  \"MM.dd.yyyy HH:mm:ss\", // old LG datestamps\n  \"F\", // short localized date and time with seconds, may have slashes\n  \"FF\" // less short localized date and time with seconds\n\n  // We don't need to add y-m-d parsers here--those are handled automatically\n  // by FuzzyDateParser.\n]\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isNumber } from \"../../fe/Number\"\nimport { FifoCache } from \"../FifoCache\"\nimport { fmtFullDuration, parseDuration } from \"./DurationFormat\"\n\nconst decCache = new FifoCache<Maybe<number>>(512)\n\n/**\n * @param s either number in milliseconds or an ISO 8601 duration string\n * @return milliseconds encoded by `s`\n */\nexport function decodeDuration(s: Maybe<string | number>): Maybe<number> {\n  return isNumber(s)\n    ? s\n    : blank(s)\n    ? undefined\n    : decCache.getOrSet(s, () => parseDuration(s))\n}\n\nconst encCache = new FifoCache<Maybe<string>>(512)\n\n/**\n * @param value either number in milliseconds or an ISO 8601 duration string\n * @return ISO 8601 duration string\n */\nexport function encodeDuration(value: Maybe<number | string>): Maybe<string> {\n  return blank(value)\n    ? undefined\n    : encCache.getOrSet(value, () =>\n        fmtFullDuration(isNumber(value) ? value : decodeDuration(value))\n      )\n}\n","import { Duration } from \"luxon\"\nimport { compact } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport {\n  dayMs,\n  hourMs,\n  minuteMs,\n  secondMs,\n  weekMs,\n  yearMs\n} from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gte0, isDigits, isNumber, lt0, toFloat, toInt } from \"../../fe/Number\"\nimport { isString } from \"../../fe/String\"\nimport { captures } from \"../RegExp\"\nimport { sum } from \"../math/Vector\"\n\nexport function parseDuration(str: number | string): Maybe<number> {\n  try {\n    if (str == null || (!isString(str) && !isNumber(str))) return\n\n    // Assume milliseconds if the string is just a number.\n    if (isNumber(str)) return str\n    if (isDigits(str)) return toInt(str)\n\n    str = str.trim().toUpperCase()\n    if (str.length === 0) return\n\n    // Is it ISO formatted?\n    const d = Duration.fromISO(str)\n    if (d.isValid) return d.toMillis()\n\n    // Nope, not ISO. Maybe something like \"1d 2h 3m 4s 5ms\"?\n\n    const re =\n      /[\\s,]*(?<value>-?\\d*\\.?\\d+)\\s*(?<type>milliseconds?|msecs?|millis|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?[\\s,]*?/gi\n\n    const groups = captures(re, str)\n    if (groups.length === 0) return\n\n    const units = compact(\n      groups.map(ea => parseUnit(ea.groups?.value, ea.groups?.type))\n    )\n\n    // if the first value is negative, flip the sign of the remainder of the values.\n    const values = lt0(units[0])\n      ? [units[0], ...units.slice(1).map(ea => -ea)]\n      : units\n\n    return sum(values)\n  } catch {\n    return\n  }\n}\n\nfunction parseUnit(value?: string, type?: string): Maybe<number> {\n  const n = toFloat(value)\n  if (n == null) return\n  if (blank(type)) {\n    // assume milliseconds\n    return n\n  }\n  switch (type.toLowerCase()) {\n    case \"years\":\n    case \"year\":\n    case \"yrs\":\n    case \"yr\":\n    case \"y\":\n      return n * yearMs\n    case \"weeks\":\n    case \"week\":\n    case \"w\":\n      return n * weekMs\n    case \"days\":\n    case \"day\":\n    case \"d\":\n      return n * dayMs\n    case \"hours\":\n    case \"hour\":\n    case \"hrs\":\n    case \"hr\":\n    case \"h\":\n      return n * hourMs\n    case \"minutes\":\n    case \"minute\":\n    case \"mins\":\n    case \"min\":\n    case \"m\":\n      return n * minuteMs\n    case \"seconds\":\n    case \"second\":\n    case \"secs\":\n    case \"sec\":\n    case \"s\":\n      return n * secondMs\n    case \"milliseconds\":\n    case \"millisecond\":\n    case \"millis\":\n    case \"msecs\":\n    case \"msec\":\n    case \"ms\":\n      return n\n    default:\n      // This should never occur.\n      throw new Error(\n        `parseDuration(): unit ${type} was matched, but no matching case exists.`\n      )\n  }\n}\n\nconst Units = [\n  { ms: yearMs, s: \"y\" },\n  { ms: weekMs, s: \"w\" },\n  { ms: dayMs, s: \"d\" },\n  { ms: hourMs, s: \"h\" },\n  { ms: minuteMs, s: \"m\" },\n  { ms: secondMs, s: \"s\" },\n  { ms: 1, s: \"ms\" }\n]\n\nexport function fmtFullDuration(\n  ms: Maybe<number>,\n  sep: \"\" | \" \" | \",\" = \"\"\n): Maybe<string> {\n  if (!isNumber(ms)) return\n  if (ms === 0) return \"0\"\n  if (!gte0(ms)) {\n    return !isNumber(ms) ? undefined : \"-\" + fmtFullDuration(Math.abs(ms))\n  }\n  const result = []\n  for (const unit of Units.slice(Units.findIndex(ea => ea.ms <= ms!))) {\n    const i = Math.floor(ms / unit.ms)\n    ms -= i * unit.ms\n    if (i > 0) result.push(i + unit.s)\n  }\n  return result.join(sep)\n}\n","import { ExifDateTime, UnsetZoneOffsetMinutes } from \"exiftool-vendored\"\nimport { DateTime, Info, Zone } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toFloat, toInt, within } from \"../../fe/Number\"\nimport { isEmptyObj } from \"../../fe/Object\"\nimport { toS } from \"../../fe/toS\"\nimport { mapEntries } from \"../Object\"\nimport { RegExpOptional, concatRegexp } from \"../RegExp\"\nimport { Settings } from \"../settings/Settings\"\nimport { DateObject } from \"./Date\"\nimport { zoneOffsetToName } from \"./FuzzyDate\"\nimport {\n  dayRE,\n  hourRE,\n  minuteRE,\n  monthRE,\n  nonNumericLookbackRE,\n  secondRE,\n  subsecRE,\n  yearRE\n} from \"./FuzzyDateParser\"\nimport { hasTime } from \"./HasTime\"\nimport {\n  TimezoneOffsetRE,\n  timezoneOffsetFromRegExpMatch,\n  zoneToTzOffsetMinutes\n} from \"./Timezone\"\n\n// If `exiftool-vendored` and PhotoStructure's versions of Luxon are\n// different, Luxon doesn't work correctly unless we do this:\n\nexport const UnsetZone = Info.normalizeZone(UnsetZoneOffsetMinutes)\n\nexport function parseExifDateTimeFormat({\n  input,\n  format,\n  defaultZone\n}: {\n  input: Maybe<string>\n  format: string\n  defaultZone?: string | Zone\n}): Maybe<ExifDateTime> {\n  return blank(input)\n    ? undefined\n    : // use ExifDateTime to clear the UnsetZone:\n      ExifDateTime.fromDateTime(\n        DateTime.fromFormat(input, format, {\n          zone: defaultZone ?? UnsetZone,\n          setZone: true\n        }),\n        { rawValue: input, unsetMilliseconds: true }\n      )\n}\n\nexport function parseExifDateTimeFromRFC2822(\n  input: Maybe<string>\n): Maybe<ExifDateTime> {\n  return blank(input)\n    ? undefined\n    : ExifDateTime.fromDateTime(\n        DateTime.fromRFC2822(input, { zone: UnsetZone, setZone: true })\n      )\n}\n\nexport function parseExifDateTime(\n  input: Maybe<string>,\n  defaultZone?: string\n): Maybe<ExifDateTime> {\n  return blank(input)\n    ? undefined\n    : // fromEXIF also calls fromISO, and only returns valid instances.\n      ExifDateTime.from(input, defaultZone) ??\n        parseExifDateTimeRe(input, ymd_hmsRegExp(), defaultZone)\n}\n\nexport function parseExifDateTimeRe(\n  input: string,\n  re: RegExp,\n  defaultZone?: string\n): Maybe<ExifDateTime> {\n  const m = re.exec(input)\n  if (m == null || isEmptyObj(m.groups)) return\n\n  const { year, month, day, hour, minute, second } = mapEntries(\n    m.groups,\n    (_k, v) => toInt(v)\n  )\n\n  if (year == null || month == null || day == null) {\n    return\n  }\n  if (\n    !Settings.fuzzyDateParsing.valueOrDefault &&\n    (hour == null || minute == null)\n  ) {\n    return\n  }\n\n  const millisecond = map(toFloat(m.groups.subsec), f =>\n    within(0, 1, f) ? Math.round(f * 1000) : undefined\n  )\n\n  const tzoffsetMinutes = timezoneOffsetFromRegExpMatch(m)\n  const zone = zoneOffsetToName(tzoffsetMinutes) ?? defaultZone\n  const obj = {\n    year,\n    month,\n    day,\n    hour: hour ?? 0,\n    minute: minute ?? 0,\n    second: second ?? 0,\n    millisecond,\n    zone,\n    rawValue: input,\n    tzoffsetMinutes\n  }\n  return dateObjectToExifDateTime(obj)\n}\n\nconst sep = /[-:_\\s]?/\n\nconst ymd_hmsRegExp = lazy(() =>\n  concatRegexp([\n    nonNumericLookbackRE,\n    yearRE,\n    sep,\n    monthRE,\n    sep,\n    dayRE,\n    /[T\\s]/,\n    hourRE,\n    sep,\n    minuteRE,\n    sep,\n    secondRE,\n    subsecRE,\n    /\\s?/,\n    RegExpOptional.from(TimezoneOffsetRE())\n  ])\n)\n\nexport function dateObjectToExifDateTime(\n  obj: Maybe<DateObject>\n): Maybe<ExifDateTime> {\n  if (obj == null || !hasTime(obj)) return\n  if (obj instanceof ExifDateTime && obj.isValid) return obj\n  try {\n    const tzoffsetMinutes =\n      obj.tzoffsetMinutes ??\n      zoneToTzOffsetMinutes(\n        new Date(obj.year, obj.month - 1, obj.day).getTime(),\n        obj.zone\n      )\n    const edt = ExifDateTime.fromJSON({\n      ...obj,\n      tzoffsetMinutes,\n      zoneName: map(obj.zone, toS)\n    } as any)\n\n    return edt.isValid ? edt : undefined\n  } catch {\n    return\n  }\n}\n","import { DateTime, DateTimeFormatOptions } from \"luxon\"\nimport { blank, mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { mapNumeric } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { isString } from \"../String\"\nimport { closeTo, isRecentMs } from \"./Date\"\nimport { DateInterval } from \"./DateInterval\"\nimport { Dated } from \"./Dated\"\nimport { datedToMillis } from \"./DatedToMillis\"\nimport { isValidDate, mapValidDate } from \"./ValidDate\"\n\nexport function recent(d: Maybe<Date | number>, delta = 5 * secondMs): boolean {\n  return isRecentMs(datedToMillis(d), delta)\n}\n\nexport function fmtDateTime(\n  dateTime?: DateTime,\n  locale?: string,\n  // Don't use FULL, because the friendly human offset name isn't known.\n  opts: DateTimeFormatOptions = DateTime.DATETIME_MED\n) {\n  return mapValidDate(dateTime, dt => {\n    mapNotBlank(locale, ea => (dt = dt.setLocale(ea)))\n    return dt.toLocaleString(opts)\n  })\n}\n\nconst BadMsRE = /(\\.\\d\\d\\d)\\d+/\n\nexport function isoToDateTime(iso: Maybe<string>): Maybe<DateTime> {\n  if (blank(iso)) return\n  if (iso.includes(\"/\")) {\n    // DateInterval will only build if .middle is valid.\n    const m = DateInterval.fromISO(iso)?.middle.toDateTime()\n    if (m != null) return m\n  }\n  const dt = DateTime.fromISO(\n    iso.replace(BadMsRE, (_, m) => m),\n    { setZone: true }\n  )\n  return dt.isValid ? dt : undefined\n}\n\nconst locale2dtf = new Map<string, Intl.DateTimeFormat>()\n\nexport function shortDateTimeFormat(locale = \"en-US\"): Intl.DateTimeFormat {\n  return getOrSet(\n    locale2dtf,\n    locale,\n    () =>\n      new Intl.DateTimeFormat(locale, {\n        year: \"numeric\",\n        month: \"short\",\n        day: \"numeric\",\n        hour: \"numeric\",\n        minute: \"numeric\"\n      })\n  )\n}\n\nexport function fmtDateShort(d: number | Dated, locale = \"en-US\"): string {\n  return shortDateTimeFormat(locale).format(datedToMillis(d))\n}\n\nexport function fmtDateIso(\n  isoDate: string,\n  locale?: string,\n  // Don't use FULL, because the friendly human offset name isn't known.\n  opts: DateTimeFormatOptions = DateTime.DATETIME_MED\n): string {\n  return opt(DateTime.fromISO(isoDate, { setZone: true }))\n    .filter(isValidDate)\n    .orElse(() =>\n      map(DateInterval.fromISO(isoDate), ea => ea.middle.toDateTime())\n    )\n    .map(ea => fmtDateTime(ea, locale, opts))\n    .getOrElse(() => isoDate)!\n}\n\nexport function parseJsonDate(\n  d: Maybe<string | { formatted: string; timestamp: number }>\n) {\n  if (d == null) return\n  if (isString(d)) return isoToDateTime(d)?.toJSDate()\n  const ts = d?.timestamp\n  const fmt = d?.formatted\n  const tsDate = mapNumeric(ts, ea => new Date(ea * secondMs))\n  if (notBlank(fmt)) {\n    const fmtDate = new Date(fmt)\n    if (!closeTo(tsDate, fmtDate, secondMs)) return\n  }\n  return tsDate\n}\n","import { pad2 } from \"../../fe/Pad\"\n\n/**\n * Filesystem-character-safe date and timestamp\n */\n\nexport function filestamp(d: Date = new Date()): string {\n  return [\n    d.getFullYear(),\n    pad2(d.getMonth() + 1),\n    pad2(d.getDate()),\n    \"-\",\n    pad2(d.getHours()),\n    pad2(d.getMinutes()),\n    pad2(d.getSeconds())\n  ].join(\"\")\n}\n\nexport function filestampUTC(d: Date = new Date()): string {\n  return [\n    d.getUTCFullYear(),\n    pad2(d.getUTCMonth() + 1),\n    pad2(d.getUTCDate()),\n    \"-\",\n    pad2(d.getUTCHours()),\n    pad2(d.getUTCMinutes()),\n    pad2(d.getUTCSeconds())\n  ].join(\"\")\n}\n","import { ExifDateTime } from \"exiftool-vendored\"\nimport { DateTime, Zone, ZoneOptions } from \"luxon\"\nimport { inspect } from \"util\"\nimport { compact } from \"../../fe/Array\"\nimport { blank, mapNotBlank } from \"../../fe/Blank\"\nimport { dayMs } from \"../../fe/Date\"\nimport { map, mapOr } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, isNumber, lte, round, toGt0 } from \"../../fe/Number\"\nimport { compactValues, pick } from \"../../fe/Object\"\nimport { leftPad, pad2 } from \"../../fe/Pad\"\nimport { Settings } from \"../settings/Settings\"\nimport { DateObject } from \"./Date\"\nimport { DateInterval } from \"./DateInterval\"\nimport { Dated, datedToDateTime, datedToPrecisionMs } from \"./Dated\"\nimport { datedToMillis } from \"./DatedToMillis\"\nimport { dateObjectToExifDateTime } from \"./ExifDateTime\"\nimport { ISO_YMD_LAX_RE, ISO_YMD_RE } from \"./FuzzyDateParser\"\nimport {\n  getDay,\n  getHour,\n  getMillisecond,\n  getMinute,\n  getMonth,\n  getSecond,\n  getYear\n} from \"./GetDateField\"\nimport { hasTime } from \"./HasTime\"\nimport { isDateTime } from \"./IsDateTime\"\nimport { datedToLocal } from \"./Localtime\"\nimport { normalizeZone, zoneToTzOffsetMinutes } from \"./Timezone\"\nimport { validYMD } from \"./ValidDate\"\nimport { getZoneName, hasZone } from \"./getZoneName\"\n\nfunction pad(n?: number, minLength: number = 2): string {\n  return n == null ? \"\" : leftPad(n, minLength, \"0\")\n}\n\nexport interface FuzzyDateObject {\n  year: number\n  month?: number\n  day?: number\n}\n\nexport type FuzzyDateInput = Partial<{\n  year: number | string\n  month: number | string\n  day: number | string\n}>\n\nexport class FuzzyDate implements FuzzyDateObject {\n  constructor(\n    readonly year: number,\n    readonly month?: number,\n    readonly day?: number\n  ) {}\n\n  static fromISO(s: Maybe<string>): Maybe<FuzzyDate> {\n    if (blank(s)) return\n    return this.for(\n      (ISO_YMD_RE.exec(s)?.groups ?? ISO_YMD_LAX_RE.exec(s)?.groups) as any\n    )\n  }\n\n  toJSON(): FuzzyDateObject {\n    return {\n      _ctor: \"FuzzyDate\",\n      ...this\n    }\n  }\n\n  static fromJSON(obj: Maybe<FuzzyDateObject>) {\n    return this.for(obj)\n  }\n\n  static for(obj: Maybe<FuzzyDateInput>): Maybe<FuzzyDate> {\n    const year = toGt0(obj?.year)\n    if (\n      obj == null ||\n      year == null ||\n      year < Settings.minValidYear.valueOrDefault\n    ) {\n      return\n    }\n    const fd =\n      obj instanceof FuzzyDate\n        ? obj\n        : new FuzzyDate(year, toGt0(obj.month), toGt0(obj.day))\n    return fd.isValid ? fd : undefined\n  }\n\n  static localToday() {\n    return toFuzzyDate(new Date())!\n  }\n\n  get isValid() {\n    // year is required:\n    if (!isNumber(this.year)) return false\n    // if day is not null, month and year must be defined:\n    if (isNumber(this.day) && !isNumber(this.month)) return false\n    return validYMD(this.year, this.month, this.day)\n  }\n\n  toString() {\n    return this.toISOString()\n  }\n\n  [inspect.custom]() {\n    return this.toISOString()\n  }\n\n  toISOString() {\n    return compact([this.year, this.month, this.day])\n      .map(ea => pad(ea))\n      .join(\"-\")\n  }\n\n  toLocal() {\n    return datedToLocal(this)\n  }\n\n  toDateTime() {\n    return DateTime.fromObject(pick(this, \"year\", \"month\", \"day\"))\n  }\n\n  toDate() {\n    return this.toDateTime().toJSDate()\n  }\n\n  toMillis() {\n    return this.toDateTime().toMillis()\n  }\n\n  /**\n   * @return the following date to this date:\n   * - if this is a year, return the following year\n   * - if this has month precision, return the next month\n   * - if this has day precision, return the following day\n   */\n  following() {\n    const dt = this.toDateTime()\n    const obj: DateObject =\n      this.day != null\n        ? pick(dt.plus({ day: 1 }), \"year\", \"month\", \"day\")\n        : this.month != null\n        ? pick(dt.plus({ month: 1 }), \"year\", \"month\")\n        : pick(dt.plus({ year: 1 }), \"year\")\n    // HEY FUTURE ME: we don't want to use .for() here, because the\n    // FuzzyDate.isValid is false for future dates.\n    return new FuzzyDate(obj.year!, obj.month, obj.day)\n  }\n}\n\nexport const ignorableSubpaths: string[][] = []\n\nexport function addIgnorableSubpath(subpath: string[]) {\n  ignorableSubpaths.push(subpath)\n}\n\n// Only for tests\nexport function clearIgnorableSubpaths() {\n  ignorableSubpaths.length = 0\n}\n\nexport function zoneOffsetToName(\n  offsetMinutes: Maybe<number>,\n  includeUTCPrefix = true\n): Maybe<string> {\n  if (offsetMinutes == null) return\n  if (offsetMinutes === 0) return includeUTCPrefix ? \"UTC\" : \"\"\n  const sign = offsetMinutes < 0 ? \"-\" : \"+\"\n  // Round to nearest :15 minute:\n  const rounded = round(offsetMinutes / 15) * 15\n  const abs = Math.abs(rounded)\n  const hours = Math.floor(abs / 60)\n  const minutes = Math.floor(Math.abs(abs % 60))\n  return `${includeUTCPrefix ? \"UTC\" : \"\"}${sign}${pad(hours)}:${pad(minutes)}`\n}\n\n/**\n * DateTime doesn't retain timezone offsets being \"set\" or \"unset\", so we prefer\n * ExifDateTime.\n *\n * @param zoneName if undefined, the returned ExifDateTime will not have a zone or tzOffset\n */\nexport function toExifDateTime(\n  d: Maybe<Dated>,\n  zoneName?: Maybe<string>\n): Maybe<ExifDateTime> {\n  if (d instanceof ExifDateTime && (zoneName == null || d.zone === zoneName)) {\n    return d\n  }\n  if (d == null || !hasTime(d)) {\n    return\n  }\n\n  // DON'T USE ExifDateTime.fromDateTime(): it uses UnsetZoneOffsetMinutes.\n\n  const tzoffsetMinutes = mapNotBlank(zoneName, ea =>\n    zoneToTzOffsetMinutes(datedToMillis(d), ea)\n  )\n  if (zoneName != null && tzoffsetMinutes == null) {\n    return\n  }\n  return map(getYear(d), year =>\n    map(getMonth(d), month =>\n      map(getDay(d), day =>\n        map(getHour(d), hour =>\n          dateObjectToExifDateTime({\n            year,\n            month,\n            day,\n            hour,\n            minute: getMinute(d) ?? 0,\n            second: getSecond(d) ?? 0,\n            millisecond: getMillisecond(d),\n            tzoffsetMinutes,\n            rawValue: (d as any).rawValue,\n            zone: zoneName\n          })\n        )\n      )\n    )\n  )\n}\n\nexport function datedToOffsetMinutes(d: Maybe<Dated>): Maybe<number> {\n  return map(d, ea =>\n    ea instanceof ExifDateTime\n      ? ea.tzoffsetMinutes\n      : isDateTime(ea)\n      ? ea.offset\n      : undefined\n  )\n}\n\nexport function datedToISO(\n  d: Maybe<Dated>,\n  includeOffset?: boolean,\n  precisionMs?: number\n): Maybe<string> {\n  if (d == null) {\n    return\n  } else if (d instanceof DateInterval) {\n    return d.toString({ includeOffset })\n  } else if (!hasTime(d) || (precisionMs ?? datedToPrecisionMs(d)) >= dayMs) {\n    return datedToYMD(d)\n  } else {\n    return toExifDateTime(d, getZoneName(d))?.toISOString({ includeOffset })\n  }\n}\n\nconst ExifFmt = \"yyyy:MM:dd HH:mm:ss.SSS\"\nconst ExifFmtWithZone = ExifFmt + \"ZZ\"\n\nexport function datedToEXIF(d: Maybe<Dated | number>): Maybe<string> {\n  if (d == null) return\n  if (d instanceof DateInterval) {\n    // EXIF dates don't support date intervals. Just render the middle\n    // datetime:\n    return datedToEXIF(d.middle)\n  }\n\n  const dt = isNumber(d) ? DateTime.fromMillis(d) : datedToDateTime(d)\n  return dt == null || !dt.isValid\n    ? undefined\n    : dt.toFormat(hasZone(d) ? ExifFmtWithZone : ExifFmt)\n}\n\nexport function datedToYMD(d: Dated, separator = \"-\"): string {\n  return compact([getYear(d), getMonth(d), getDay(d)])\n    .map(ea => pad(ea))\n    .join(separator)\n}\n\nexport function toFuzzyDate(d: Maybe<Dated>): Maybe<FuzzyDate> {\n  return map(d, ea =>\n    map(getYear(ea), y => new FuzzyDate(y, getMonth(ea), getDay(ea)))\n  )\n}\n\nexport function sameDay(dis: Maybe<Dated>, dat: Maybe<Dated>): boolean {\n  return lte(diffMillis(dis, dat), dayMs)\n}\n\nexport function diffMillis(\n  a: Maybe<Dated | number>,\n  b: Maybe<Dated | number>\n): Maybe<number> {\n  const [aMs, bMs] = [a, b].map(datedToMillis)\n  return aMs == null || bMs == null ? undefined : aMs - bMs\n}\n\nexport function closeTo(\n  a: Maybe<Dated | number>,\n  b: Maybe<Dated | number>,\n  maxDiffMs: number\n): boolean {\n  return mapOr(\n    diffMillis(a, b),\n    ea => Math.abs(ea) < maxDiffMs,\n    () => false\n  )\n}\n\nexport function gtDated(a: Maybe<Dated>, b: Maybe<Dated>): boolean {\n  if (a == null || b == null) return false\n  for (const f of [\n    getYear,\n    getMonth,\n    getDay,\n    getHour,\n    getMinute,\n    getSecond,\n    getMillisecond\n  ]) {\n    if (lte(f(a), f(b))) return false\n  }\n  return true\n}\n\n/**\n * @param index must be [0, splits]\n * @param splits must be >= 1\n */\nexport function dateBetween(\n  a: Maybe<Dated>,\n  b: Maybe<Dated>,\n  index = 1,\n  splits = 1\n): Maybe<Dated> {\n  if (datedToMillis(a) == null || datedToMillis(b) == null) return\n  const [start, end] = [a, b].map(d => datedToMillis(d)!).sort()\n  const diff = end - start\n  const delta = diff / (splits + 1)\n  const zoneA = getZoneName(a!)\n  const zoneB = getZoneName(b!)\n  const zone = zoneA === zoneB ? zoneA : undefined\n  const result = DateTime.fromMillis(start + delta * index, { zone })\n  return [a, b].some(ea => !hasTime(ea)) ? toFuzzyDate(result) : result\n}\n\nexport function setZone(\n  d: Maybe<Dated>,\n  zone: Maybe<string | number | Zone>,\n  opts?: ZoneOptions\n) {\n  const o = {\n    ...compactValues(opts),\n    keepLocalTime: opts?.keepLocalTime ?? !hasZone(d)\n  }\n  const z = normalizeZone(zone)\n  if (d == null || z == null || !hasTime(d)) return\n  return d instanceof DateInterval\n    ? d.setZone(z, o)\n    : toExifDateTime(d)?.setZone(z, o)\n}\n\nexport function toIsoDate(d: Maybe<Dated>): Maybe<string> {\n  if (d == null) return\n  const arr = [getYear(d), getMonth(d), getDay(d)]\n  return gt0(arr[0]) ? compact(arr).map(pad2).join(\"-\") : undefined\n}\n\nexport function utcToZone(\n  dated: Dated,\n  zoneName: string | Zone\n): Maybe<DateTime> {\n  // don't use setZone() here: we want to adjust the local time.\n  let date = datedToDateTime(dated)\n  if (date == null) return\n  const priorZone = getZoneName(dated)\n  if (priorZone == null || priorZone === \"UTC\") {\n    date = date.toUTC(0, { keepLocalTime: true })\n  }\n  return date.setZone(zoneName)\n}\n","import { ExifDate, ExifDateTime } from \"exiftool-vendored\"\nimport { DateTime } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks, startsWith, uniq } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { Maybe, MaybeNull } from \"../../fe/MaybeTypes\"\nimport { mapNumeric, toInt } from \"../../fe/Number\"\nimport { entries } from \"../../fe/Object\"\nimport { toA } from \"../../fe/toA\"\nimport { first } from \"../Array\"\nimport { FifoCache } from \"../FifoCache\"\nimport { mkLogger } from \"../Logger\"\nimport {\n  RegExpEscaped,\n  RegExpOptional,\n  concatRegexp,\n  escapeRegExp\n} from \"../RegExp\"\nimport { stripDSC } from \"../fs/FuzzyNames\"\nimport { Settings } from \"../settings/Settings\"\nimport { DateInterval } from \"./DateInterval\"\nimport { Dated, isDated } from \"./Dated\"\nimport { datedToMillis } from \"./DatedToMillis\"\nimport {\n  parseExifDateTime,\n  parseExifDateTimeFormat,\n  parseExifDateTimeFromRFC2822\n} from \"./ExifDateTime\"\nimport { FuzzyDate, ignorableSubpaths } from \"./FuzzyDate\"\nimport { isExifDateTime } from \"./HasTime\"\nimport { isDateTime } from \"./IsDateTime\"\nimport { monthName2index, monthNames } from \"./Month\"\nimport { TimezoneOffsetRE } from \"./Timezone\"\nimport { isValidDate } from \"./ValidDate\"\n\nconst logger = lazy(() => mkLogger(\"date.FuzzyDateParser\"))\n\nexport interface FuzzyDateParserOptions {\n  fuzzyDateParsing?: boolean\n  fuzzyYearParsing?: boolean\n}\n\nexport function extractDateFromPath(path: string[]): Maybe<Dated> {\n  return logger().tap({\n    msg: \"extractDateFromPath\",\n    result: FuzzyDateParser.instance().extractDateFromPath(path),\n    meta: { path }\n  })\n}\n\nexport function parseYMD(s: string): Maybe<FuzzyDate | ExifDateTime> {\n  return FuzzyDateParser.instance().parseYMD(s)\n}\n\nexport function parseFuzzyDate(s: string): Maybe<FuzzyDate> {\n  return FuzzyDateParser.instance().parse(s)\n}\n\n// We're using literal RegExps here so syntax highlighting can help find\n// issues:\n\n// negative numeric lookbehind to prevent \"1992 AUG 1971\" from being parsed as\n// \"2 AUG 1971\":\nexport const nonNumericLookbackRE = /(?<!\\d)/\n\nexport const yearRE = /(?<year>(?:19|20)\\d{2})/ // 1975, 2014\nexport const yearishRE = /(?<year>(?:19|20)?\\d{2})/ // 1975, 2014\n\nexport const monthRE = /(?<month>[0-3]\\d)/ // < requires 0-padded month\nexport const monthishRE = /(?<month>[0-3]?\\d)/\n\nexport const dayRE = /(?<day>[1-3]\\d|0[1-9])/ // < requires 0-padded day\nexport const dayishRE = /(?<day>[1-3]\\d|0?[1-9])/\n\nexport const hourRE = /(?<hour>1\\d|2[0-3]|0\\d)/\n\nexport const minuteRE = /(?<minute>[0-5]\\d)/\n\nexport const secondRE = /(?<second>[0-5]\\d)/\n\nexport const seps = /([-.,:_/ |])/\nexport const optSeps = new RegExp(seps.source + \"?\")\n\nexport const subsecRE = /(?<subsec>\\.\\d+)?/\n\nconst PatternToRE = lazy(() =>\n  entries({\n    \" \": /\\s+/,\n    \"-\": /-/,\n    _: /_/,\n    \".\": /\\./,\n    \",\": /,/,\n    yyyy: /\\d{4}/,\n    yy: /\\d+/,\n    y: /\\d+/,\n    MMMM: /\\S{3,12}/,\n    MM: /\\d{2}/,\n    M: /\\d+/,\n    dd: /\\d{2}/,\n    d: /\\d+/,\n    HH: /\\d{2}/,\n    H: /\\d+/,\n    mm: /\\d{2}/,\n    m: /\\d+/,\n    ss: /\\d{2}/,\n    s: /\\d+/,\n    ZZ: TimezoneOffsetRE(),\n    \"'Z'\": /Z/,\n    \"'at'\": /at/\n  }).map(\n    ([token, re]) =>\n      // we need to remove the names from the capture groups--we don't need\n      // them, and we may get spurious duplicate group name errors otherwise:\n      [token, new RegExp(re.source.replace(/\\(\\?<.+?>/g, \"(\"))] as const\n  )\n)\n\nfunction token2re(s: string) {\n  for (const [token, re] of PatternToRE()) {\n    if (s.startsWith(token)) return { token, re }\n  }\n  return\n}\n\nconst formatRegexCache = new FifoCache<RegExp | null>(256)\n\nexport function regexFromDateFormat(dateFormat: string): RegExp | null {\n  let s = dateFormat\n  return formatRegexCache.getOrSet(dateFormat, () => {\n    const arr: RegExp | string | RegExpEscaped[] = []\n    while (!blank(s)) {\n      const ea = token2re(s)\n      if (ea == null) {\n        logger().debug(\n          \"regexFromDateFormat(): unknown token starting with \" +\n            s +\n            \", bailing\",\n          { dateFormat }\n        )\n        return null\n      }\n      arr.push(ea.re)\n      s = s.slice(ea.token.length)\n    }\n    const result = concatRegexp([\n      new RegExpEscaped(\"(\"),\n      ...arr,\n      new RegExpEscaped(\")\")\n    ])\n    logger().trace(\"regexFromDateFormat()\", {\n      dateFormat,\n      result: result.source\n    })\n    return result\n  })\n}\n\nexport function dateTimeBetween(a: DateTime, b: DateTime): DateTime {\n  // When would this ever be invalid (and therefor null)?\n\n  // Assuming it can't ever be invalid, we're bang-ing the end. Yeah. We're\n  // end bangers over here. JOIN US WE KNOW YOU ARE BANGCURIOUS\n  return a.until(b).divideEqually(2)[0].end!\n}\n\nexport function agoMs(dated: Maybe<Dated>): Maybe<number> {\n  return mapNumeric(datedToMillis(dated), ea => Date.now() - ea)\n}\n\nexport const ISO_YMD_RE = concatRegexp([\n  /^/,\n  yearRE,\n  RegExpOptional.from(/-/, monthRE, RegExpOptional.from(/-/, dayRE)),\n  /$/\n])\n\nexport const ISO_YMD_LAX_RE = concatRegexp([\n  /^/,\n  yearishRE,\n  RegExpOptional.from(/-/, monthishRE, RegExpOptional.from(/-/, dayishRE)),\n  /$/\n])\n\nexport function parseDateTime(\n  s: Maybe<string> | Maybe<string>[],\n  defaultZone?: string\n): Maybe<DateTime> {\n  const d = parseDated({\n    input: s,\n    defaultZone,\n    descPredicate: ea => ea.match(/DateTime/i) != null\n  })\n\n  return isDateTime(d) ? d : isExifDateTime(d) ? d.toDateTime() : undefined\n}\n\nfunction extractDateTime(\n  input: string,\n  format: string,\n  defaultZone?: string\n): Maybe<ExifDateTime> {\n  const d = parseExifDateTimeFormat({\n    input,\n    format,\n    defaultZone\n  })\n  if (d != null) return d\n  const str = regexFromDateFormat(format)?.exec(input)?.[0]\n  if (str != null) {\n    return parseExifDateTimeFormat({\n      input: str,\n      format,\n      defaultZone\n    })\n  }\n  return\n}\n\nfunction* parsers(args: {\n  defaultZone: Maybe<string>\n  includeDate?: boolean\n  includeFuzzyDate?: boolean\n}) {\n  yield {\n    desc: \"DateInterval.fromISO\",\n    f: (ea: string) => DateInterval.fromISO(ea)\n  }\n\n  // date and time:\n  yield {\n    desc: \"parseExifDateTime\",\n    // this calls ExifDateTime.fromISO and ExifDateTime.fromEXIF\n    f: (ea: string) => parseExifDateTime(ea, args.defaultZone)\n  }\n\n  yield { desc: \"ExifDateTime.fromRFC2822\", f: parseExifDateTimeFromRFC2822 }\n\n  for (const format of compactBlanks(Settings.extraDateTimeFormats.values)) {\n    yield {\n      desc: `extractDateTime(${format})`,\n      f: (ea: string) => extractDateTime(ea, format, args.defaultZone)\n    }\n  }\n\n  if (args.includeDate === true) {\n    // HEY FUTURE ME DO NOT RE-ADD JS DATE PARSING it forces everything to UTC\n    yield {\n      desc: \"ExifDate.fromEXIF\",\n      f: (ea: string) => ExifDate.fromEXIF(ea)\n    }\n  }\n\n  if (args.includeFuzzyDate === true) {\n    for (const parser of FuzzyDateParser.instance().allParsers) {\n      yield {\n        desc: \"FuzzyDateParser \" + parser.source,\n        f: (ea: string) => parser.apply(ea)\n      }\n    }\n  }\n}\n\n/**\n * Parses ISO, EXIF, and screenshot-formatted dates.\n */\nexport function parseDated({\n  input,\n  defaultZone,\n  includeDate = true,\n  includeFuzzyDate = true,\n  descPredicate = () => true\n}: {\n  input: MaybeNull<Dated | string | Maybe<string>[]>\n  defaultZone?: string\n  /**\n   * Include ISO-compliant YMD parsers (no time component)\n   */\n  includeDate?: boolean\n  /**\n   * Include fuzzy YMD parsers (no time component)\n   */\n  includeFuzzyDate?: boolean\n  descPredicate?: (desc: string) => boolean\n}): Maybe<Dated> {\n  if (input == null) return\n  if (isDated(input)) return input\n  const arr = uniq(compactBlanks(toA(input)).map(stripDSC))\n  if (arr.length === 0) return\n  // date interval (must be first):\n  for (const { desc, f } of parsers({\n    defaultZone,\n    includeDate,\n    includeFuzzyDate\n  })) {\n    if (descPredicate(desc)) {\n      for (const s of arr) {\n        const result = f(s)\n        if (result == null || !isValidDate(result)) continue\n        // Don't set zone here: that was the parser's job.\n        return logger().tap({\n          msg: \"parseDated()\",\n          result,\n          meta: {\n            s,\n            desc,\n            defaultZone\n          }\n        })\n      }\n    }\n  }\n  return\n}\n\nexport class FuzzyDateParser {\n  static readonly instance = lazy(() => new FuzzyDateParser())\n\n  readonly ymdParsers: Parser[] = []\n  readonly ymParsers: Parser[] = []\n  readonly yParsers: Parser[] = []\n  readonly allParsers: Parser[] = []\n\n  constructor(readonly opts: FuzzyDateParserOptions = {}) {\n    if (opts.fuzzyDateParsing == null) {\n      Settings.fuzzyDateParsing.watchLater(() => this.#setup())\n    }\n    if (opts.fuzzyYearParsing == null) {\n      Settings.fuzzyYearParsing.watchLater(() => this.#setup())\n    }\n    this.#setup()\n  }\n\n  get fuzzyDateParsing() {\n    return (\n      this.opts.fuzzyDateParsing ?? Settings.fuzzyDateParsing.valueOrDefault\n    )\n  }\n\n  get fuzzyYearParsing() {\n    return (\n      this.opts.fuzzyYearParsing ?? Settings.fuzzyYearParsing.valueOrDefault\n    )\n  }\n\n  parse(input: string, arr = this.allParsers): Maybe<FuzzyDate> {\n    for (const parser of arr) {\n      const result = parser.apply(input)\n      if (result != null) {\n        return result\n      }\n    }\n    return\n  }\n\n  parseYMD(input: string): Maybe<FuzzyDate> {\n    return this.parse(input, this.ymdParsers)\n  }\n\n  parseYM(input: string): Maybe<FuzzyDate> {\n    return this.parse(input, this.ymParsers)\n  }\n\n  parseY(input: string): Maybe<FuzzyDate> {\n    return this.parse(input, this.yParsers)\n  }\n\n  #addParser(arr: RegExp | (RegExp | string | RegExpEscaped)[]) {\n    const p = new Parser(arr)\n    if (p.hasDay) {\n      this.ymdParsers.push(p)\n    } else if (p.hasMonth) {\n      if (this.fuzzyDateParsing) {\n        this.ymParsers.push(p)\n      }\n    } else if (this.fuzzyYearParsing) {\n      this.yParsers.push(p)\n    }\n  }\n\n  #setup() {\n    try {\n      this.ymdParsers.length = 0\n      this.ymParsers.length = 0\n      this.yParsers.length = 0\n      this.allParsers.length = 0\n\n      const allMonthsRE = new RegExpEscaped(\n        \"(?<monthname>\" + monthNames().map(escapeRegExp).join(\"|\") + \")\"\n      )\n\n      // Very conservative/restrictive patterns to guard against mmddyy or ddmmyy:\n      // ISO 8601: 1999-11-11 (the /\\2/ ensures consistent seps).\n      // Seps are required if month and day aren't padded:\n      // eslint-disable-next-line regexp/strict\n      this.#addParser([yearRE, seps, monthishRE, /\\2/, dayishRE])\n\n      // If month and day are padded, seps are optional:\n      // eslint-disable-next-line regexp/strict\n      this.#addParser([yearRE, optSeps, monthRE, /\\2/, dayRE])\n\n      // 2011:Feb:6\n      // eslint-disable-next-line regexp/strict\n      this.#addParser([yearRE, optSeps, allMonthsRE, /\\2/, dayishRE])\n\n      // August 6, 1994\n      // eslint-disable-next-line regexp/strict\n      this.#addParser([allMonthsRE, optSeps, dayishRE, /,?\\2/, yearRE])\n\n      // 6 August 1994\n      this.#addParser([\n        nonNumericLookbackRE,\n        dayishRE,\n        optSeps,\n        allMonthsRE,\n        // eslint-disable-next-line regexp/strict\n        /,?\\2/,\n        yearRE\n      ])\n\n      // This needs to be the last ymdParser, as m and d are optional:\n      // See https://forum.photostructure.com/t/photostructure-ignored-the-date-metadata-of-some-photos-marked-them-as-taken-in-2002/340/17?u=mrm\n      this.#addParser([\n        /^(?<year>\\d\\d\\d\\d):(?<month> {2}|\\d\\d):(?<day> {2}|\\d\\d)( ( {2}|00):( {2}|00):( {2}|00))?$/\n      ])\n\n      // The following are only year + month (no date):\n      // 1994-08\n      this.#addParser([yearRE, seps, monthishRE])\n\n      // Sept 1994 or September 1994\n      this.#addParser([allMonthsRE, seps, yearRE])\n\n      // 2001 August or 2001 AUG\n      this.#addParser([yearRE, seps, allMonthsRE])\n\n      this.#addParser([nonNumericLookbackRE, yearRE])\n\n      this.allParsers.push(\n        // order matters! We want the most specific parsers first:\n        ...this.ymdParsers,\n        ...this.ymParsers,\n        ...this.yParsers\n      )\n    } catch (e) {\n      console.error(e)\n    }\n  }\n\n  extractDateFromPath(path: string[]): Maybe<Dated> {\n    if (!Settings.usePathsToInferDates.valueOrDefault) return\n\n    // https://en.wikipedia.org/wiki/Design_rule_for_Camera_File_system\n    ignorableSubpaths.forEach(ea => {\n      if (startsWith(path, ea)) {\n        path.splice(0, ea.length)\n      }\n    })\n\n    // No one (!!) will ever encode only the year in the filename--we want to either pull the date from the basename, or from the dirname, but not both.\n\n    path = path.filter(\n      // If it's a camera-provided serial number, ignore that part of the path.\n      ea => notBlank(ea) && path[0].match(ignorableDCF) == null\n    )\n    // Don't modify path!\n    const reversePath = [...path].reverse()\n\n    // First try to find a YMD in one of the path elements individually:\n    for (const ea of reversePath) {\n      const result =\n        parseDated({\n          input: ea,\n          includeDate: false,\n          includeFuzzyDate: false\n        }) ?? this.parseYMD(ea)\n      if (result != null) return result\n    }\n    return (\n      // Then try to find YMD by joining the paths (reverse first, so nearer\n      // datestamps get picked first)\n      this.parseYMD(reversePath.slice(1, 4).join(\" \")) ??\n      // is it a path like 2019/08/01?\n      this.parseYMD(path.slice(0, -1).join(\" \")) ??\n      // the ymParsers will be empty if fuzzy date parsing is off\n      first(reversePath, ea => this.parseYM(ea)) ??\n      this.parseYM(path.join(\" \")) ??\n      // we're at the bottom of the barrel here. Does any path element contain a valid year?\n      first(reversePath.slice(1), ea => this.parseY(ea))\n    )\n  }\n}\n\nclass Parser {\n  readonly regex: RegExp\n  constructor(arr: RegExp | Maybe<RegExp | string | RegExpEscaped>[]) {\n    // We always add a negative lookahead to the end of the regex to avoid\n    // matching against long numeric strings:\n    this.regex =\n      arr instanceof RegExp ? arr : concatRegexp([...arr, /(?:$|\\D)/], \"i\")\n  }\n\n  get source() {\n    return this.regex.source\n  }\n\n  get hasDay() {\n    return this.source.includes(\"(?<day>\")\n  }\n\n  get hasMonth() {\n    return (\n      this.source.includes(\"(?<month>\") || this.source.includes(\"(?<monthname>\")\n    )\n  }\n\n  apply(s: string) {\n    const g = this.regex.exec(s)?.groups\n    if (g == null) return\n    return FuzzyDate.for({\n      year: toInt(g.year),\n      month: toInt(g.month) ?? monthName2index(g.monthname),\n      day: toInt(g.day)\n    })\n  }\n}\n\nconst ignorableDCF =\n  /^((DCIM)|(DSC[_F]?|IMG[-_]|GOPRO|MOV[-_]|MVI[-_]|P_?)\\d+)$/i\n","import { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { Dated } from \"./Dated\"\nimport { hasTime } from \"./HasTime\"\n\nexport function getYear(d: Maybe<Dated>): Maybe<number> {\n  return d instanceof Date ? d.getFullYear() : d?.year\n}\n\n/**\n * @return 1-12, like normal humans\n */\nexport function getMonth(d: Maybe<Dated>): Maybe<number> {\n  return d instanceof Date ? d.getMonth() + 1 : d?.month\n}\n\nexport function getDay(d: Maybe<Dated>): Maybe<number> {\n  return d instanceof Date ? d.getDate() : d?.day\n}\n\nexport function getHour(d: Maybe<Dated>): Maybe<number> {\n  return d instanceof Date ? d.getHours() : (d as any)?.hour\n}\n\nexport function getMinute(d: Maybe<Dated>): Maybe<number> {\n  return d instanceof Date ? d.getMinutes() : (d as any)?.minute\n}\n\nexport function getSecond(d: Maybe<Dated>): Maybe<number> {\n  return d instanceof Date ? d.getSeconds() : (d as any)?.second\n}\n\nexport function getMillisecond(d: Maybe<Dated>): Maybe<number> {\n  return d instanceof Date ? d.getMilliseconds() : (d as any)?.millisecond\n}\n\nexport function getCentisecond(d: Maybe<Dated>): Maybe<number> {\n  // NOTE: we floor here rather than rounding as we don't want to deal with\n  // rounding up to a different minute or hour (or day or year)\n  // HONEST IT'S OK IT'S ONLY +/- 5 milliseconds.\n  return map(getMillisecond(d), ea => Math.floor(ea / 10))\n}\n\nexport function hasSeconds(d: Maybe<Dated>): boolean {\n  return (\n    hasTime(d) &&\n    (gt0(getMinute(d)) || gt0(getSecond(d)) || gt0(getMillisecond(d)))\n  )\n}\n/**\n * \".###\" or \".#####\" from the milliseconds in `d`.\n */\n\nexport function getSecMs(d: Maybe<Dated>): Maybe<string> {\n  return map(getSecond(d), sec => {\n    const ms = getMillisecond(d) ?? 0\n    let s = (sec + ms / 1000).toString()\n    if (sec < 10) s = \"0\" + s\n    if (ms === 0) s = s + \".\"\n    while (s.length < 6) {\n      s = s + \"0\"\n    }\n    return s\n  })\n}\n","import { ExifDateTime } from \"exiftool-vendored\"\nimport { DateTime } from \"luxon\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { isObject } from \"../../fe/Object\"\nimport { DateInterval } from \"./DateInterval\"\nimport { Dated } from \"./Dated\"\n\n/**\n * @return true iff `d` is a class type that supports time resolution\n */\nexport function hasTime(\n  d: Maybe<Dated>\n): d is Date | ExifDateTime | DateTime | DateInterval {\n  if (!isObject(d)) return false\n\n  // We can't do any safe heuristics here:\n  if (d instanceof Date) return true\n\n  const a = d as any\n  return gt0(a.hour) || gt0(a.minute) || gt0(a.second) || gt0(a.millisecond)\n}\n\nexport function isExifDateTime(d: any): d is ExifDateTime {\n  return d instanceof ExifDateTime\n}\n","import { DateTime } from \"luxon\"\n\nexport function isDateTime(d: any): d is DateTime {\n  // We may get a DateTime from exiftool-vendored, which may be running a\n  // different version of Luxon, so we can't just check with instanceof:\n  return DateTime.isDateTime(d) ?? false\n}\n","import { DateTime, Zone } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { localToDate } from \"../../fe/Date\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isNumber, toGt0 } from \"../../fe/Number\"\nimport { Settings } from \"../settings/Settings\"\nimport { DateObject, dateObjectToDateTime } from \"./Date\"\nimport { Dated, datedToDateTime, isoToDated } from \"./Dated\"\nimport { datedToMillis } from \"./DatedToMillis\"\nimport { shortDateTimeFormat } from \"./ExtendedDate\"\nimport { FuzzyDate } from \"./FuzzyDate\"\nimport {\n  getCentisecond,\n  getDay,\n  getHour,\n  getMinute,\n  getMonth,\n  getSecond,\n  getYear\n} from \"./GetDateField\"\nimport { hasTime } from \"./HasTime\"\nimport { normalizeZone } from \"./Timezone\"\n\nconst datesBeforeAreEstimated = lazy(\n  () =>\n    isoToLocal(Settings.datesBeforeAreEstimated.valueOrDefault) ??\n    isoToLocal(Settings.datesBeforeAreEstimated.defaultValue)!\n)\n\nexport function localIsFuzzy(localCs: Maybe<number>): boolean {\n  return (\n    localCs == null ||\n    // If no minute, second, or centisecond, it's fuzzy\n    localCs % 100_00_00 === 0 ||\n    localCs < datesBeforeAreEstimated()\n  )\n}\n\nexport function isoToLocal(iso: Maybe<string>): Maybe<number> {\n  return map(isoToDated(iso), datedToLocal)\n}\n\nexport function maybeDatedToLocal(d: Maybe<Dated | number>): Maybe<number> {\n  return map(d, datedToLocal)\n}\n\nexport function datedToLocal(d: Dated | number): number {\n  if (isNumber(d)) return tsToLocal(d)\n  const s = datedToLocalSec(d)\n  return s * 100 + (getCentisecond(d) ?? 0)\n}\n\nexport function datedToLocalSec(d: Dated | number): number {\n  if (isNumber(d)) return Math.floor(tsToLocal(d) / 100)\n  let result = 0\n  for (const f of [getYear, getMonth, getDay, getHour, getMinute, getSecond]) {\n    result = result * 100 + (f(d) ?? 0)\n  }\n  return result\n}\n\nexport function localToDateObject(\n  local: Maybe<number>,\n  offset?: Maybe<string | number | Zone>\n): Maybe<DateObject> {\n  if (local == null || local < 0) return\n  let i = local\n  const pop2 = () => {\n    const result = i % 100\n    i = Math.floor(i / 100)\n    return result\n  }\n  const millisecond = 10 * pop2() // < because centiseconds\n  const second = pop2()\n  const minute = pop2()\n\n  // DateTime freaks out if hour, day, or month is 0.\n  const hour = toGt0(pop2())\n  const day = toGt0(pop2())\n  const month = toGt0(pop2())\n\n  // the remainders are the year\n  const year = i\n\n  return {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    zone: normalizeZone(offset)\n  }\n}\n\nexport function fmtLocalDateShort(\n  local: number,\n  locale: Maybe<string>\n): string {\n  return shortDateTimeFormat(locale).format(localToDate(local))\n}\n\nexport function localToDateTime(\n  local: Maybe<number>,\n  offset?: Maybe<number>\n): Maybe<FuzzyDate | DateTime> {\n  const obj = localToDateObject(local, offset)\n  return hasTime(obj) ? dateObjectToDateTime(obj) : FuzzyDate.for(obj)\n}\n\n/**\n * Convert local numeric to millis-from-common-epoch timestamp\n */\nexport function localToTs(\n  local: Maybe<number>,\n  offset?: Maybe<number>\n): Maybe<number> {\n  return map(localToDateTime(local, offset), datedToMillis)\n}\n\nexport function nowLocal(zone?: Maybe<string | Zone>) {\n  return agoLocal(0, zone)\n}\n\nexport function agoLocal(agoMs: number, zone?: Maybe<string | Zone>) {\n  return tsToLocal(Date.now() - agoMs, zone)\n}\n\n/**\n * This should only be used by tests, as a timestamp has already lost it's\n * relevant timezone offset.\n * @param ts is a millis-from-common-epoch timestamp\n */\nexport function tsToLocal(ts: number, zone?: string | Zone): number {\n  return datedToLocal(DateTime.fromMillis(ts, { zone }))!\n}\n\n/**\n * @return local numeric of `local` plus `ms` millis\n */\nexport function localPlusMs(local: number, ms: number): number {\n  return datedToLocal(datedToDateTime(localToDateTime(local))!.plus(ms))!\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { sort } from \"../../fe/ArraySort\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { times } from \"../../fe/Number\"\nimport { CaseInsensitiveMap } from \"../CaseInsensitiveMap\"\n\nconst m = lazy(() => {\n  const result = new CaseInsensitiveMap<number>()\n  // `undefined` uses the system locale:\n  for (const locale of [\"en-US\", undefined]) {\n    // Accept \"sep\" or \"sept\" for September:\n    result.set(\"Sept\", 9)\n    result.set(\"Sept.\", 9)\n    for (const flavorOfTheMonth of [\"short\", \"long\"] as const) {\n      const dtf = new Intl.DateTimeFormat(locale, {\n        month: flavorOfTheMonth\n      })\n      times(12, index => {\n        const monthName = dtf.format(new Date(2017, index))\n        result.set(monthName, index + 1)\n        if (flavorOfTheMonth === \"short\" && locale === \"en-US\") {\n          // TODO: do other locales add a period after the abbreviated month name?\n          result.set(monthName + \".\", index + 1)\n        }\n      })\n    }\n  }\n  return result\n})\n\nexport function monthName2index(monthName: Maybe<string>): Maybe<number> {\n  return monthName == null ? undefined : m().get(monthName)\n}\n\nexport function monthNames(): string[] {\n  return sort([...m().keys()])\n}\n","import { Settings as LuxonSettings } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { locale } from \"../Locale\"\nimport { Settings } from \"../settings/Settings\"\n\nexport const setupLuxon = lazy(async () => {\n  LuxonSettings.throwOnInvalid = false\n  Settings.twoDigitCutoffYear.watch(\n    // TODO: fix Luxon types!\n    ea => ((LuxonSettings as any).twoDigitCutoffYear = ea)\n  )\n  LuxonSettings.defaultLocale = await locale()\n})\n","import { UnsetZoneName, UnsetZoneOffsetMinutes } from \"exiftool-vendored\"\nimport { FixedOffsetZone, Info, Zone } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isInvalidNumber, isNumber, toInt } from \"../../fe/Number\"\nimport { isEmptyObj } from \"../../fe/Object\"\nimport { pad2 } from \"../../fe/Pad\"\nimport { isString } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { leastBy } from \"../Array\"\nimport { RegExpEscaped, RegExpOptional, concatRegexp } from \"../RegExp\"\n\n// Pacific/Kiritimati is +14:00 TIL\n// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\nexport const MaxTzOffsetHours = 14\n\n// Unique values from https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\nexport const ValidTimezoneOffsets = [\n  \"-12:00\",\n  \"-11:00\",\n  \"-10:30\",\n  \"-10:00\",\n  \"-09:30\",\n  \"-09:00\",\n  \"-08:30\",\n  \"-08:00\",\n  \"-07:30\",\n  \"-07:00\",\n  \"-06:00\",\n  \"-05:00\",\n  \"-04:30\",\n  \"-04:00\",\n  \"-03:30\",\n  \"-03:00\",\n  \"-02:30\",\n  \"-02:00\",\n  \"-01:00\",\n  \"-00:44\",\n  // \"-00:25:21\", // LOL https://en.wikipedia.org/wiki/UTC%E2%88%9200:25:21\n  \"+00:00\",\n  \"+00:20\",\n  \"+00:30\",\n  \"+01:00\",\n  \"+01:24\",\n  \"+01:30\",\n  \"+02:00\",\n  \"+02:30\",\n  \"+03:00\",\n  \"+03:30\",\n  \"+04:00\",\n  \"+04:30\",\n  \"+04:51\", // LOL https://en.wikipedia.org/wiki/UTC%2B04:51\n  \"+05:00\",\n  \"+05:30\",\n  \"+05:40\",\n  \"+05:45\",\n  \"+06:00\",\n  \"+06:30\",\n  \"+07:00\",\n  \"+07:20\",\n  \"+07:30\",\n  \"+08:00\",\n  \"+08:30\",\n  \"+08:45\",\n  \"+09:00\",\n  \"+09:30\",\n  \"+09:45\",\n  \"+10:00\",\n  \"+10:30\",\n  \"+11:00\",\n  \"+11:30\",\n  \"+12:00\",\n  \"+12:45\",\n  \"+13:00\",\n  \"+13:45\",\n  \"+14:00\"\n] as const\n\nexport type TimezoneOffset = (typeof ValidTimezoneOffsets)[number]\n\nexport function offsetToMinutes(offset: TimezoneOffset): number {\n  const [h, m] = offset.split(\":\").map(Number)\n  // we can't just return `h * 60 + m`: that doesn't work with negative offsets!\n  const sign = offset.startsWith(\"-\") ? -1 : 1\n  return sign * (Math.abs(h) * 60 + m)\n}\n\n// export const localTzOffsetMinutes = lazy(() => DateTime.local().offset, hourMs)\n\nconst AllZoneOffsetMinutes = lazy(() =>\n  ValidTimezoneOffsets.map(offsetToMinutes)\n)\n\nexport function normalizeZoneOffsetMinutes(\n  tzoffsetMinutes: Maybe<number>,\n  allowedSlopMinutes = 14\n): Maybe<number> {\n  if (\n    !isNumber(tzoffsetMinutes) ||\n    Math.abs(tzoffsetMinutes) > MaxTzOffsetHours * 60\n  ) {\n    return\n  }\n\n  const closest = leastBy(AllZoneOffsetMinutes(), ea =>\n    Math.abs(ea - tzoffsetMinutes)\n  )\n  return closest != null &&\n    Math.abs(closest - tzoffsetMinutes) < allowedSlopMinutes\n    ? closest\n    : undefined\n}\n\n/**\n * @param s if number, it's assumed to be a zone offset in minutes\n */\nexport function isValidZone(s: Maybe<number | string | Zone>): boolean {\n  return normalizeZone(s) != null\n}\n\nconst ZuluPrimitives = [\n  0,\n  \"0\",\n  \"Z\",\n  \"GMT\",\n  \"UTC\",\n  \"GMT+0\",\n  \"Etc/UTC\",\n  \"GMT+00:00\"\n]\n\nfunction isUTCPrimitive(s: any): boolean {\n  return ZuluPrimitives.includes(s as any)\n}\n\nexport function isUTCZone(s: Maybe<number | string | Zone>): boolean {\n  return isUTCPrimitive(s) || normalizeZone(s)?.offset(Date.now()) === 0\n}\n\n/**\n * Attempt to avoid https://github.com/moment/luxon/issues/923\n *\n * @param s if number, it's assumed to be a zone offset in minutes\n *\n * @return a valid Zone, or undefined\n */\nexport function normalizeZone(s: Maybe<number | string | Zone>): Maybe<Zone> {\n  if (s == null || blank(s) || isInvalidNumber(s)) return\n\n  if (isUTCPrimitive(s)) return FixedOffsetZone.utcInstance\n\n  const input = isNumber(s)\n    ? normalizeZoneOffsetMinutes(s)\n    : (isString(s)\n        ? isoToOffsetMinutes(s) ?? ianaZoneToOffsetMinutes(s)\n        : undefined) ?? s\n  if (\n    input == null ||\n    input === UnsetZoneOffsetMinutes ||\n    input === UnsetZoneName\n  ) {\n    return undefined\n  }\n  // CAREFUL! If this gets null/undefined, it returns LocalTimeZone!\n  const z = Info.normalizeZone(input)\n  return !z.isValid || z.offset(Date.now()) === UnsetZoneOffsetMinutes\n    ? undefined\n    : z\n}\n\ninterface HasZone {\n  zone?: Maybe<Zone>\n  tzoffsetMinutes?: Maybe<number>\n  offset?: Maybe<number>\n  toMillis(): number\n}\n\nexport function zoneOffsetMinutes(d: HasZone) {\n  return (\n    normalizeZoneOffsetMinutes(d.tzoffsetMinutes) ??\n    normalizeZoneOffsetMinutes(d.offset) ??\n    map(d.zone, z => z.offset(d.toMillis()))\n  )\n}\n\n/**\n * @param ts timestamp\n */\nexport function zoneToTzOffsetMinutes(\n  ts: Maybe<number>,\n  zone: Maybe<number | string | Zone>\n): Maybe<number> {\n  if (ts == null || zone == null) return\n  const z = normalizeZone(zone)\n  return true === z?.isValid ? (z as Zone).offset(ts) : undefined\n}\n\nexport function fmtOffsetMinutes(minutes: number): string {\n  if (!isValidZone(minutes)) return \"\"\n  const abs = Math.abs(Math.round(minutes))\n  const h = Math.floor(abs / 60)\n  const m = abs - h * 60\n  return (minutes >= 0 ? \"+\" : \"-\") + pad2(h) + \":\" + pad2(m)\n}\n\nexport function zoneToExifOffsetMinutes(\n  ts: Maybe<number>,\n  zone: Maybe<number | string | Zone>\n): Maybe<string> {\n  const mins = zoneToTzOffsetMinutes(ts, zone)\n  return mins == null ? undefined : fmtOffsetMinutes(mins)\n}\n\n// these group names can't collide with FuzzyDate: this RegExp gets concatted\n// with the other patterns!\nconst utcRE = /\\b(?<utc>Z|UTC|GMT)\\b/ // case sensitive, as per ISO\n\n// https://en.wikipedia.org/wiki/ISO_8601#Time_offsets_from_UTC\n// ±[hh]:[mm], ±[hh][mm], or ±[hh]\n\n// (PESKY: both hyphen-minus and minus sign are valid)\nconst signRE = /(?<tzSign>[-±+−])/\nconst negativeRE = /[-−]/\n\n// HOUR OFFSET REQUIRES PADDING! DateInterval parsing will fail otherwise\nconst paddedHourRE = /(?<tzHour>[01]\\d)/\nconst hourRE = /(?<tzHour>[01]?\\d)/\n// colons are optional (!!)\nconst minRE = /(?::(?<tzMinutes>\\d\\d))/\n\nexport const TimezoneOffsetRE = lazy(() =>\n  concatRegexp([\n    new RegExpEscaped(\"(?:\"),\n    utcRE,\n    new RegExpEscaped(\"|\"),\n    signRE,\n    paddedHourRE,\n    RegExpOptional.from(minRE),\n    new RegExpEscaped(\")\"),\n    // Either match the end of the string, or NOT a bit of an ISO timestamp\n    // (like \"T\" or \"/\"),\n    /(?:$|[^-−+:_\\d.T/])/\n  ])\n)\n\nexport function isoToOffsetMinutes(iso: string): Maybe<number> {\n  return isUTCPrimitive(iso)\n    ? 0\n    : timezoneOffsetFromRegExpMatch(TimezoneOffsetRE().exec(iso))\n}\n\nexport function timezoneOffsetFromRegExpMatch(\n  m: RegExpExecArray | null\n): Maybe<number> {\n  if (m == null || isEmptyObj(m.groups)) return\n  if (!blank(m.groups.utc)) return 0\n  const hours = toInt(m.groups.tzHour)\n  const sign = negativeRE.test(toS(m.groups.tzSign)) ? -1 : 1\n  const minutes = toInt(m.groups.tzMinutes) ?? 0\n  const result = hours == null ? undefined : sign * (hours * 60 + minutes)\n  return isValidZone(result) ? result : undefined\n}\n\nconst IanaZonePrefixRE = /\\b(?<ianaPrefix>(?:Etc\\/)?GMT)\\b/\n\nconst IanaTimezoneOffsetRE = lazy(() =>\n  concatRegexp([IanaZonePrefixRE, signRE, hourRE, RegExpOptional.from(minRE)])\n)\n\nexport function ianaZoneToOffsetMinutes(iana: string): Maybe<number> {\n  return timezoneOffsetFromRegExpMatch(IanaTimezoneOffsetRE().exec(iana))\n}\n\nexport function luxonTzOffsetToOffsetMinutes(\n  tz: Maybe<string>,\n  ts: Maybe<number>\n): Maybe<string> {\n  if (blank(tz)) return\n  // Is this a specific offset, like \"Etc/GMT+3\" or \"+03:00\"?\n  const offsetMinutes = ianaZoneToOffsetMinutes(tz) ?? isoToOffsetMinutes(tz)\n  if (offsetMinutes != null) {\n    return fmtOffsetMinutes(offsetMinutes)\n  }\n  //\n  if (ts != null) {\n    const z = normalizeZone(tz)\n    if (z != null) {\n      return fmtOffsetMinutes(z.offset(ts))\n    }\n  }\n  return\n}\n","import { ExifDate, ExifDateTime } from \"exiftool-vendored\"\nimport { DateTime } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact } from \"../../fe/Array\"\nimport { dayMs, hourMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { gt, gte } from \"../../fe/Primitive\"\nimport { mkLogger } from \"../Logger\"\nimport { within } from \"../Number\"\nimport { errorToS } from \"../error/Error\"\nimport { ee } from \"../event/EventEmitter\"\nimport { Settings } from \"../settings/Settings\"\nimport { DateInterval } from \"./DateInterval\"\nimport { Dated, isDated, isoToDated } from \"./Dated\"\nimport { datedToMillis } from \"./DatedToMillis\"\nimport { FuzzyDate, datedToISO } from \"./FuzzyDate\"\nimport { datedToLocal } from \"./Localtime\"\n\nconst logger = lazy(() => mkLogger(\"date.ValidDate\"))\n\nconst badDates = lazy(() =>\n  compact(Settings.badDates.values.map(ea => isoToDated(ea)))\n)\nconst badDatesISO = lazy(() => compact(badDates().map(ea => datedToISO(ea))))\nconst badDatesLocal = lazy(() =>\n  compact(badDates().map(ea => datedToLocal(ea)))\n)\nconst badDatesTs = lazy(() => compact(badDates().map(ea => datedToMillis(ea))))\n\nexport function isValidDate(d: Dated | any): d is Dated {\n  if (d == null) return false\n  const why = whyNotValidDate(d)\n  return logger().tap({\n    msg: \"isValidDate()\",\n    result: why == null,\n    meta: { d, why }\n  })\n}\n\nexport function whyNotValidDate(d: Dated) {\n  try {\n    if (!isDated(d)) return \"not Dated\"\n    else if (\n      d instanceof ExifDateTime ||\n      d instanceof DateInterval ||\n      d instanceof DateTime ||\n      d instanceof FuzzyDate\n    ) {\n      if (!d.isValid)\n        return compact([\"not valid\", (d as any)?.invalidExplanation]).join(\": \")\n    } else if (d instanceof Date) {\n      if (isNaN(d.getTime())) return \"not valid js Date\"\n    } else if (d instanceof ExifDate) {\n      if (!validYMD(d.year, d.month, d.day)) {\n        return \"not valid YMD\"\n      }\n    } else {\n      const dt = DateTime.fromObject(d)\n      if (!dt.isValid) {\n        return \"not valid: \" + dt.invalidExplanation\n      }\n    }\n\n    if (badDatesTs().includes(datedToMillis(d)!)) {\n      return \"bad date (via millis)\"\n    } else if (badDatesLocal().includes(datedToLocal(d))) {\n      return \"bad date (via localtime)\"\n    } else if (badDatesISO().includes(datedToISO(d)!)) {\n      return \"bad date (via ISO)\"\n    } else {\n      return\n    }\n  } catch (error) {\n    logger().warn(\"whyNotValidDate() caught error\", { input: d, error })\n    return errorToS(error)\n  }\n}\n\nexport function mapValidDate<D extends Dated, T>(\n  obj: Maybe<D>,\n  f: (date: D) => T\n): Maybe<T> {\n  return isValidDate(obj) ? f(obj) : undefined\n}\n\nconst minYear = lazy(() => Settings.minValidYear.valueOrDefault, hourMs)\nconst maxYear = lazy(() => new Date(Date.now() + dayMs).getFullYear(), hourMs)\nconst maxMonth = lazy(() => new Date(Date.now() + dayMs).getMonth() + 1, hourMs)\nlater(() => {\n  Settings.minValidYear.watchLater(() => minYear.unset())\n  ee().on(\"clearCache\", () => {\n    minYear.unset()\n    maxYear.unset()\n    maxMonth.unset()\n  })\n})\n\nexport function validYear(year: Maybe<number>) {\n  return within(minYear(), maxYear(), year)\n}\n\nexport function validMonth(month: Maybe<number>, year?: number) {\n  return gte(year, maxYear()) && gt(month, maxMonth())\n    ? false\n    : within(1, 12, month)\n}\n/**\n * @return true iff the given month and day values are valid for the given year\n */\n\nexport function validDay(\n  year: Maybe<number>,\n  month: Maybe<number>,\n  day: Maybe<number>\n) {\n  // If Date doesn't change the day, that month and day exist for that year.\n  return gt0(day) && DateTime.fromObject({ year, month, day }).isValid\n}\n\nexport function validYMD(year?: number, month?: number, day?: number): boolean {\n  return (\n    validYear(year) &&\n    (gt0(month) ? validMonth(month, year) : true) &&\n    (gt0(day) ? validDay(year, month, day) : true)\n  )\n}\n","import {\n  ExifDateTime,\n  UnsetZoneName,\n  UnsetZoneOffsetMinutes\n} from \"exiftool-vendored\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isNumber } from \"../../fe/Number\"\nimport { DateInterval } from \"./DateInterval\"\nimport { Dated } from \"./Dated\"\nimport { isDateTime } from \"./IsDateTime\"\n\nexport function hasZone(dated: Maybe<Dated | number>): boolean {\n  if (dated == null || isNumber(dated)) {\n    return false\n  }\n\n  if (dated instanceof DateInterval || dated instanceof ExifDateTime) {\n    return dated.hasZone\n  }\n\n  if (isDateTime(dated)) {\n    return (\n      dated.zone != null &&\n      dated.zone.isValid &&\n      dated.zone.type !== \"local\" &&\n      dated.zone.name !== UnsetZoneName &&\n      dated.zone.offset(Date.now()) !== UnsetZoneOffsetMinutes\n    )\n  }\n\n  return false\n}\n\n// Used for creating DateTime. \"UTC\", or something like \"UTC+07:30\"\n\nexport function getZoneName(d: Maybe<Dated>): Maybe<string> {\n  if (d == null || d instanceof Date) {\n    return\n  } else if (isDateTime(d)) {\n    return d.zoneName === UnsetZoneName ? undefined : d.zone?.name\n  } else if (d instanceof ExifDateTime) {\n    return d.zone\n  } else {\n    // don't retain the timezone offset of the source date.\n    return\n  }\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\n/**\n * @see https://sqlite.org/pragma.html#pragma_auto_vacuum\n */\nexport const AutoVacuumModes = strEnum(\"NONE\", \"FULL\", \"INCREMENTAL\")\nexport type AutoVacuumMode = StrEnumKeys<typeof AutoVacuumModes>\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { wrap } from \"../../fe/String\"\nimport { cacheDir_ } from \"../dir/CacheDir\"\nimport { NoLibraryErrorFlag } from \"../error/ErrorFlags\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFileOrString } from \"../fs/SimpleFile\"\nimport { libraryUidStore } from \"../fs/UIDStore\"\nimport { writeTextfile_ } from \"../fs/WriteFile\"\nimport { Settings } from \"../settings/Settings\"\nimport { Schema, Schemas } from \"./Schemas\"\n\n/**\n * The \"cache\" db is the local replica of the library database\n */\nexport async function cacheDbDir_(\n  libraryDir: Maybe<SimpleFileOrString> = Settings.libraryDir.valueOrDefault,\n  schema: Schema = Schemas.models\n): Promise<PosixFile> {\n  const store = libraryUidStore(libraryDir)\n  if (store == null) {\n    throw new Error(\"Library directory is not set\" + NoLibraryErrorFlag)\n  }\n\n  // Adding the UUID ensures that other libraries don't overwrite eachother:\n  const libraryUid = (await store.readUid_())!\n  const result = PosixFile.for(cacheDir_()).join(\n    schema + \"-live-db\",\n    libraryUid\n  )\n  await result.mkdirp_()\n  const readme = result.join(\"README.txt\")\n  await writeTextfile_(\n    readme.nativePath,\n    ...wrap(\n      [\n        \"This folder is used by PhotoStructure for your library stored in\",\n        libraryDir,\n        \"You will corrupt your library if you remove this directory while PhotoStructure is running.\",\n        \"See https://forum.photostructure.com/t/whats-ps-force-local-db-replica/837 for details.\"\n      ].join(\"\\n\\n\")\n    )\n  )\n  return result\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { setupLibraryDataDir_ } from \"../dir/LibraryDirs\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFileOrString } from \"../fs/SimpleFile\"\nimport { mkLogger } from \"../Logger\"\nimport { Settings } from \"../settings/Settings\"\nimport { cacheDbDir_ } from \"./CacheDbDir\"\nimport { pathToDb, Schema, Schemas, SqliteBase } from \"./Schemas\"\nimport { assertDirSQLiteReadWrite_ } from \"./SQLiteReadWrite\"\n\nconst logger = lazy(() => mkLogger(\"db.CheckLocalDbReplica\"))\n\nexport async function cacheDbFile_({\n  libraryDir = Settings.libraryDir.valueOrDefault,\n  schema = Schemas.models\n}: { libraryDir?: Maybe<SimpleFileOrString>; schema?: Schema } = {}) {\n  return (await cacheDbDir_(libraryDir, schema)).join(SqliteBase)\n}\n\n/**\n * @throw if the library is blank\n */\nexport async function getLiveDbDir_(\n  libraryDir: Maybe<SimpleFileOrString> = Settings.libraryDir.valueOrDefault\n): Promise<{ db: PosixFile; useReplica: boolean }> {\n  // If the user has explicitly set this to true, we can't use the library dir.\n  if (!Settings.forceLocalDbReplica.valueOrDefault) {\n    // If this throws, the library isn't going to spin up in any event.\n    const libraryDb = pathToDb(\n      await setupLibraryDataDir_(libraryDir),\n      Schemas.models\n    )\n    try {\n      await assertDirSQLiteReadWrite_(libraryDb.parent())\n      return { db: libraryDb, useReplica: false }\n    } catch (error) {\n      logger().info(\n        \"SQLite cannot directly write to the library: trying to use a local db replica.\",\n        {\n          libraryDb,\n          error\n        }\n      )\n    }\n  }\n\n  const cacheDbFile = await cacheDbFile_({ libraryDir, schema: Schemas.models })\n\n  try {\n    await assertDirSQLiteReadWrite_(cacheDbFile.parent())\n    return { db: cacheDbFile, useReplica: true }\n  } catch (error) {\n    return logger().throw(\n      \"SQLite cannot directly write to the library or the cacheDir.\",\n      {\n        cacheDbFile,\n        error\n      }\n    )\n  }\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const CheckpointTypes = strEnum(\n  \"AUTO\",\n  \"PASSIVE\",\n  \"FULL\",\n  \"RESTART\",\n  \"TRUNCATE\"\n)\nexport type CheckpointType = StrEnumKeys<typeof CheckpointTypes>\n","import { lazy } from \"../../core/Lazy\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { mkLogger } from \"../Logger\"\nimport { sqliteFiles } from \"./SQLiteFiles\"\n\nconst logger = lazy(() => mkLogger(\"db.DbBackupCold\"))\n\n/**\n * SQLite's db backup tries to acquired filesystem locks when it backs up.\n * This won't work if the db is on a remote filesystem.\n *\n * If you don't care about running a \"hot\" backup, this implementation is\n * simpler.\n */\nexport async function dbBackupCold_(\n  srcDbFile: PosixFile,\n  destDir: PosixFile\n): Promise<PosixFile[]> {\n  await destDir.mkdirp_()\n  const wips = []\n  try {\n    for (const ea of sqliteFiles(srcDbFile)) {\n      const wip = destDir.join(ea.base).wip()\n      wips.push(wip)\n      await ea.copyFile_(wip)\n    }\n    // OK! All the copies worked! Now we can rename the wips to the final\n    // names.\n    return logger().tap({\n      msg: \"completed\",\n      level: \"info\",\n      result: await Promise.all(wips.map(ea => ea.unwip_())),\n      meta: { srcDbFile, destDir }\n    })\n  } catch (error) {\n    await Promise.all(wips.map(ea => ea.unlink()))\n    throw error\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport {\n  isRetriableError,\n  isSqliteBusyError\n} from \"../../core/error/ErrorTypes\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { delay } from \"../../fe/Delay\"\nimport { randomInt } from \"../../fe/Random\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\n\nconst logger = lazy(() => mkLogger(\"db.DbRetries\"))\n\n/**\n * @param f MUST BE IDEMPOTENT\n */\nexport async function handleDbRetries<T>(\n  f: () => SyncOrAsync<T>,\n  onRetry?: () => any\n): Promise<T> {\n  const start = Date.now()\n  let retries = 0\n  const timeoutAt = start + Settings.maxBusyDbMs.valueOrDefault\n  while (Date.now() < timeoutAt) {\n    try {\n      return await f()\n    } catch (error) {\n      if (\n        isRetriableError(error) === false ||\n        !isSqliteBusyError(error) ||\n        Date.now() >= timeoutAt\n      ) {\n        logger().error(\"Caught db error. Not retrying.\", { error })\n        throw error\n      } else {\n        const ms = randomInt(500, 1500) * ++retries\n        logger().error(\"Caught db error. Retrying in \" + ms + \"ms.\", { error })\n        onRetry?.()\n        // give the other process time to unlock:\n        await delay(ms)\n      }\n    }\n  }\n  throw new Error(\n    \"handleDbRetries(): timeout after \" +\n      Settings.maxBusyDbMs.valueOrDefault +\n      \"ms\"\n  )\n}\n","import { dirname } from \"path\"\nimport { clamp } from \"../../fe/Number\"\nimport { MiB } from \"../../fe/Units\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { isDbJanitorService } from \"../ServiceNames\"\nimport { uid } from \"../UID\"\nimport { mkdirpSync_, posixPathFromGrandparent, resolve } from \"../fs/Path\"\nimport { nativePathSizeSync } from \"../fs/StatSync\"\nimport { defaultLogLevel } from \"../log/LogFilter\"\nimport { Settings } from \"../settings/Settings\"\nimport { maxCpus } from \"../work/MaxCpus\"\nimport { DatabaseWithUid } from \"./DatabaseWithUid\"\nimport bs = require(\"better-sqlite3\")\n\nconst DbCacheScalar = 1.5\n\n// don't cache this\nexport function mkdb_({\n  nativePath,\n  timeoutMs = Settings.dbBusyTimeoutMs.valueOrDefault,\n  logSql = Settings.logSql.valueOrDefault\n}: {\n  nativePath: string\n  timeoutMs?: any\n  logSql?: boolean\n}): DatabaseWithUid {\n  nativePath = resolve(nativePath)\n  mkdirpSync_(dirname(nativePath))\n\n  let verbose: any\n  // The better-sqlite logger truncates variables very oddly, so we log in\n  // DbRequest instead:\n  const partialPath = posixPathFromGrandparent(nativePath)\n\n  if (logSql) {\n    const l = mkLogger(\"SQLite(\" + partialPath + \")\")\n    const ll = defaultLogLevel()\n    verbose = (sql: string) => l.log(ll, sql.replace(/\\s{2,}/g, \" \"))\n  }\n\n  const dbFileSize = nativePathSizeSync(nativePath)\n\n  const logger = mkLogger(\"db.mkdb(\" + partialPath + \")\")\n\n  if (dbFileSize != null) {\n    // nuc library (is big!) and is 179M\n    const dbFileSizeMb = Math.round(dbFileSize / MiB)\n    const minDbCacheSizeMb = Math.ceil(DbCacheScalar * dbFileSizeMb)\n    if (minDbCacheSizeMb > Settings.dbCacheSizeMb.valueOrDefault) {\n      logger.info(\n        \"Dynamically setting dbCacheSize to \" + Settings.dbCacheSizeMb.value,\n        { db: nativePath, dbFileSizeMb }\n      )\n      Settings.dbCacheSizeMb.envValue = minDbCacheSizeMb\n    }\n\n    const minRamMb = Math.round(dbFileSizeMb * DbCacheScalar)\n\n    if (minRamMb > Settings.maxMemoryMb.valueOrDefault) {\n      logger.warn(\"Large database: setting maxMemoryDb to \" + minRamMb + \"MB\", {\n        dbFileSizeMb,\n        \"Settings.maxMemoryMb\": Settings.maxMemoryMb.valueOrDefault\n      })\n      Settings.maxMemoryMb.envValue = minRamMb\n    }\n  }\n\n  logger.info(\"Opening \" + nativePath + \"...\")\n  const db = new bs(nativePath, {\n    fileMustExist: false,\n    readonly: false,\n    timeout: timeoutMs,\n    verbose: 2 < 1 ? ea => console.log(\"SQLITE: \", ea) : verbose\n  })\n  logger.info(\"Open. Setting PRAGMAs...\")\n\n  for (const pragma of [\n    // List of PRAGMAs: https://sqlite.org/pragma.html#toc\n    // https://wiki.mozilla.org/Performance/Avoid_SQLite_In_Your_Next_Firefox_Feature\n\n    'encoding = \"UTF-8\"',\n\n    // https://sqlite.org/pragma.html#pragma_threads\n\n    // This limit sets an upper bound on the number of auxiliary threads that a\n    // prepared statement is allowed to launch to assist with a query.\n    \"threads = \" + maxCpus(),\n\n    // Doesn't default to ON. WTH.\n    \"foreign_keys = ON\",\n\n    // https://sqlite.org/pragma.html#pragma_page_size\n\n    // page_size defaults to 4k, and seems to work fine.\n    \"page_size = \" + pageSizeBytes(),\n\n    // https://sqlite.org/pragma.html#pragma_trusted_schema\n\n    // There are advantages to turning it off, and most applications will be\n    // unaffected if it is turned off. For that reason, all applications are\n    // encouraged to switch this setting off on every database connection as soon\n    // as that connection is opened.\n    \"trusted_schema = 0\",\n\n    // https://sqlite.org/pragma.html#pragma_cache_size\n\n    // If the argument N is negative, then the number of cache pages is adjusted\n    // to be a number of pages that would use approximately abs(N*1024) bytes of\n    // memory based on the current page size.\n\n    \"cache_size = -\" +\n      Math.round((Settings.dbCacheSizeMb.valueOrDefault * MiB) / 1024),\n\n    // setting this to EXCLUSIVE prevents concurrent read /or/ write access.\n    \"locking_mode = NORMAL\",\n\n    // to improve performance and support concurrent writers:\n    \"journal_mode = WAL\",\n\n    // This PRAGMA may hang if the DB is locked or stored on a remote\n    // filesystem:\n    \"busy_timeout = \" + Settings.dbBusyTimeoutMs.valueOrDefault,\n\n    // https://sqlite.org/pragma.html#pragma_synchronous\n\n    // Windows (the worst for File IO) drops latency from ~17ms to ~5ms for\n    // upserts if `synchronous = OFF`, but that doesn't end up being substantive\n    // to processing rate, and OFF means library DBs can be corrupt from power\n    // cuts, so let's just use NORMAL and be safe (and a bit slower)\n\n    // With no dbrpc, synchronous = NORMAL made updates sometimes not \"stick\",\n    // causing Heartbeat to not get updated.\n\n    // With FULL, inserts on linux are 10-20x slower.\n    \"synchronous = \" + Settings.dbSynchronousMode.valueOrDefault,\n\n    // DON'T SET THIS ON! Tags are case-insensitive!\n    // This is required for tag path LIKE clauses:\n    // (see https://stackoverflow.com/a/8586390/1268016)\n    \"case_sensitive_like = 0\",\n\n    // https://sqlite.org/pragma.html#pragma_wal_autocheckpoint\n    \"wal_autocheckpoint = \" +\n      (isDbJanitorService()\n        ? toS(Settings.dbWalAutoCheckpoint.valueOrDefault)\n        : \"0\"),\n\n    // https://sqlite.org/pragma.html#pragma_auto_vacuum\n    \"auto_vacuum = \" + Settings.dbAutoVacuumMode.valueOrDefault\n  ]) {\n    logger.tapThunk({\n      msg: \"PRAGMA \" + pragma,\n      result: () => db.pragma(pragma)\n    })\n  }\n  // Used for prepared statement invalidation:\n  const result: DatabaseWithUid = db as any\n  result.__uid = uid()\n  return result\n}\n\nexport function pageSizeBytes(): number {\n  const i = Settings.dbPageSizeBytes.valueOrDefault\n  // Must be a power of 2:\n  return Math.pow(2, clamp(1, 28, Math.round(Math.log2(i))))\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const RepairModes = strEnum(\"dump\", \"recover\")\nexport type RepairMode = StrEnumKeys<typeof RepairModes>\n","import { PosixFile } from \"../fs/PosixFile\"\nimport { SQLiteSuffixes } from \"./SQLiteSuffixes\"\n\n/**\n * @return an empty array if dbfile doesn't exist\n */\nexport function sqliteFiles(dbFile: PosixFile): PosixFile[] {\n  return [\n    dbFile,\n    ...SQLiteSuffixes.map(ea => dbFile.sibling(dbFile.base + ea))\n  ].filter(ea => ea.existsSync({ refresh: true }))\n}\n\n/**\n * Upper bound for the size of the db\n */\nexport async function sqliteSizeBytes(dbFile: PosixFile): Promise<number> {\n  return (\n    ((await dbFile.size({ refresh: true })) ?? 0) +\n    ((await dbFile.sibling(dbFile.base + \"-wal\").size({ refresh: true })) ?? 0)\n  )\n}\n","import { Database } from \"better-sqlite3\"\nimport { lazy } from \"../../core/Lazy\"\nimport { eql } from \"../../fe/Eql\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { randomChars } from \"../../fe/Random\"\nimport { mkLogger } from \"../Logger\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFileOrString } from \"../fs/SimpleFile\"\nimport { mkdb_ } from \"./MkDb\"\nimport { sqliteFiles } from \"./SQLiteFiles\"\n\nconst logger = lazy(() => mkLogger(\"db.SQLiteReadWrite\"))\n\nexport async function firstDirSQLiteReadWrite<T extends SimpleFileOrString>(\n  ...dirs: Maybe<T>[]\n): PromiseMaybe<T> {\n  for (const dir of dirs) {\n    if (dir != null && (await isDirSQLiteReadWrite(dir))) {\n      return dir\n    }\n  }\n  return\n}\n\nexport async function isDirSQLiteReadWrite(dirNativePath: SimpleFileOrString) {\n  try {\n    await assertDirSQLiteReadWrite_(dirNativePath)\n    logger().info(\"isDirSQLiteReadWrite(): true\", { dirNativePath })\n    return true\n  } catch (error) {\n    logger().warn(\"isDirSQLiteReadWrite(): false\", { dirNativePath, error })\n    return false\n  }\n}\n\nexport async function assertDirSQLiteReadWrite_(\n  dirNativePath: SimpleFileOrString\n): Promise<void> {\n  const dir = PosixFile.for(dirNativePath)\n  const s = randomChars(8)\n  const dbFile = dir.child(\".test-\" + s + \".sqlite\")\n  let db: Database | null = null\n  try {\n    await dir.mkdirp_()\n    db = mkdb_({\n      nativePath: dbFile.nativePath,\n      timeoutMs: 1000\n    })\n    db.exec(\"CREATE TABLE t (s VARCHAR(16) NOT NULL)\")\n    db.exec(`INSERT INTO t (s) VALUES ('${s}')`)\n    {\n      const rows = db.prepare(\"SELECT s FROM t\").all()\n      if (!eql(rows, [{ s }])) {\n        logger().throw(\"unexpected rows\", { rows })\n      }\n    }\n    db.exec(\"VACUUM\")\n    db.close()\n    db = mkdb_({\n      nativePath: dbFile.nativePath,\n      timeoutMs: 1000\n    })\n    {\n      const s2 = randomChars(8)\n      db.exec(`INSERT INTO t (s) VALUES ('${s2}')`)\n      const rows = db.prepare(\"SELECT s FROM t ORDER BY s\").pluck().all()\n      if (!eql(rows, [s, s2].sort())) {\n        logger().throw(\"unexpected rows\", { rows })\n      }\n    }\n  } finally {\n    try {\n      db?.close()\n    } catch {\n      // ignore\n    }\n    await Promise.all(sqliteFiles(dbFile).map(ea => ea.rm()))\n  }\n}\n","// No need for the -shm file:  The WAL-index or \"shm\" file is used to\n// coordinate access to the database by multiple clients, and as a cache to\n// help clients quickly locate frames within the wal file.\n\n// See https://sqlite.org/walformat.html#the_wal_index_file_format\n\n// Because the shm file is not involved in recovery, the shm file does not\n// need to be machine byte-order independent. Hence, numeric values in the shm\n// file are written in the native byte order of the host computer, rather than\n// being converted into a specific cross-platform byte order as is done with\n// the main database file and the wal file.\n\n// The -journal file may be needed if it is \"hot\": Before reading from a\n// database file, SQLite always checks to see if that database file has a hot\n// journal. If the file does have a hot journal, then the journal is rolled\n// back before the file is read. In this way, we ensure that the database file\n// is in a consistent state before it is read.\n\n// See https://sqlite.org/lockingv3.html and\n// https://www.sqlite.org/howtocorrupt.html\n\nexport const SQLiteSuffixes = [\"-wal\", \"-journal\"]\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { lazyAsync } from \"../async/LazyAsync\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { sqliteNativePath_ } from \"../fs/Tools\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport bs = require(\"better-sqlite3\")\n\nexport const sqliteVersion_ = lazyAsync({\n  later: async function () {\n    let db: Maybe<bs.Database>\n    try {\n      db = new bs(\":memory:\")\n      const libraryVersion = db\n        .prepare(\"select sqlite_version()\")\n        .pluck()\n        .get() as string\n\n      const sqliteNativePath = await sqliteNativePath_()\n      const fullToolVersion = (\n        await stdout_(sqliteNativePath, [\"-version\"], {\n          timeoutMs: commandTimeoutMs()\n        })\n      ).trim()\n\n      // expected: \"3.31.1 2020-01-27 19:55:54 3bfa9cc97da1059852...16eaa837bb4d6\"\n      const toolVersion = fullToolVersion.split(/\\s+/, 1)[0]\n      return { libraryVersion, toolVersion, fullToolVersion, sqliteNativePath }\n    } finally {\n      db?.close()\n    }\n  },\n  timeoutMs: commandTimeoutMs()\n})\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\nimport { BaseFile } from \"../fs/BaseFile\"\n\nexport const Schemas = strEnum(\"models\", \"stats\")\nexport type Schema = StrEnumKeys<typeof Schemas>\n\nexport const SqliteExt = \".sqlite3\"\n\nexport const SqliteBase = \"db\" + SqliteExt\n\nexport function pathToDbDir<T extends BaseFile>(dataDir: T, schema: Schema): T {\n  return dataDir.join(schema)\n}\nexport function pathToDb<T extends BaseFile>(dataDir: T, schema: Schema): T {\n  return pathToDbDir(dataDir, schema).join(SqliteBase)\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const SynchronousModes = strEnum(\"OFF\", \"NORMAL\", \"FULL\", \"EXTRA\")\nexport type SynchronousMode = StrEnumKeys<typeof SynchronousModes>\n","import _path, { join } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact, compactBlanks } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { SimpleAppName, SimpleAppNameLC } from \"../AppName\"\nimport { userid } from \"../UserInfo\"\nimport { env } from \"../env/Env\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { onError } from \"../error/OnError\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { mkNoMedia_ } from \"../fs/MkNoMedia\"\nimport { mkdirpSync_ } from \"../fs/Path\"\nimport { isLinux, isMac, isWin } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { Settings } from \"../settings/Settings\"\nimport { setSettingsDefaults } from \"../settings/SettingsDefaults\"\nimport { DefaultDockerLibraryDir } from \"./DefaultDockerLibraryDir\"\nimport { FirstDirArg, filterDirs, firstDir } from \"./FirstDir\"\nimport { homeDir } from \"./HomeDir\"\n\nconst uidSuffix = lazy(() => map(userid(), ea => \"-\" + ea) ?? \"\")\n\nexport function tmpCacheDirs(): FirstDirArg[] {\n  if (isDocker()) {\n    return [\n      {\n        dir: \"/tmp/.photostructure-cache\" + uidSuffix(),\n        preexistingDir: \"/tmp\"\n      }\n    ]\n  } else {\n    // Fallback to /tmp and /var/tmp on Linux and macOS, and %TEMP% on Windows:\n    const result: FirstDirArg[] = []\n    const dirs = isWin ? [getEnv(\"TEMP\"), getEnv(\"TMP\")] : [\"/tmp\", \"/var/tmp\"]\n    for (const tmpDir of dirs) {\n      if (!blank(tmpDir)) {\n        result.push({\n          dir: join(tmpDir, \".photostructure-cache\" + uidSuffix()),\n          preexistingDir: tmpDir\n        })\n      }\n    }\n    return result\n  }\n}\n\nexport function tmpDirs(): string[] {\n  return filterDirs({ dirs: tmpCacheDirs(), desc: \"tmp\" })\n}\n\nexport function cacheDirs(): FirstDirArg[] {\n  if (isDocker()) {\n    return compact([\n      map(env().XDG_CACHE_HOME, ea => ({\n        dir: join(ea, SimpleAppNameLC),\n        preexistingDir: ea\n      })),\n      // these should be mountpoints. We shouldn't make them.\n      { dir: \"/ps/tmp\", preexistingDir: \"/ps/tmp\" },\n      { dir: \"/ps/cache\", preexistingDir: \"/ps/cache\" },\n      {\n        dir: DefaultDockerLibraryDir + \"/.photostructure/cache\" + uidSuffix(),\n        preexistingDir: DefaultDockerLibraryDir\n      },\n      ...tmpCacheDirs()\n    ])\n  }\n\n  const dirs = compactBlanks(\n    isWin\n      ? [getEnv(\"LOCALAPPDATA\"), _path.resolve(homeDir(), \"AppData\", \"Local\")]\n      : isMac\n      ? [_path.resolve(homeDir(), \"Library\", \"Caches\")]\n      : // see https://forum.photostructure.com/t/1471/6\n        [env().XDG_CACHE_HOME, join(homeDir(), \".cache\")]\n  )\n\n  // .cache directories on linux seem to be uniformly lowercase, and uniformly\n  // UpperCased on macOS and Windows.\n  const cacheSubDir = isLinux ? SimpleAppNameLC : SimpleAppName\n\n  // These directories should exist already:\n  const result: FirstDirArg[] = dirs.map(ea => ({\n    dir: join(ea, cacheSubDir),\n    preexistingDir: ea\n  }))\n  result.push(...tmpCacheDirs())\n  return result\n}\n\n/**\n * Should only be used by Settings.cacheDir.defaultValue\n */\n// lazy for tests\nexport const defaultCacheDir = lazy<string>(() => {\n  return firstDir({ dirs: cacheDirs(), desc: \"cache\" })!\n})\n\nconst addSettingsListener = lazy(() => {\n  // make sure the config dir setting has the default wired up:\n  setSettingsDefaults()\n  Settings.cacheDir.watchLater(resetCacheDir)\n})\n\nexport const cacheDir = lazy<Maybe<string>>(() => {\n  try {\n    return cacheDir_()\n  } catch (error) {\n    onError(\"cacheDir_() failed\", { error })\n    return undefined\n  }\n})\n\nexport const cacheDir_ = lazy<string>(() => {\n  addSettingsListener()\n  const nativePath = Settings.cacheDir.valueOrDefault\n  try {\n    mkdirpSync_(nativePath) // < throw if we can't mkdirp\n    void mkNoMedia_(nativePath)\n    return nativePath\n  } catch (cause) {\n    throw new WrappedError(\"Failed to set up cacheDir, \" + nativePath, {\n      path: nativePath,\n      fatal: true,\n      cause\n    })\n  }\n})\n\nexport function resetCacheDir() {\n  Settings.cacheDir.refreshEnvValue({ broadcastChange: false })\n  defaultCacheDir.unset()\n  cacheDir.unset()\n  cacheDir_.unset()\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { setSettingsDefaults } from \"../settings/SettingsDefaults\"\nimport { DefaultDockerLibraryDir } from \"./DefaultDockerLibraryDir\"\nimport { desktopConfigDir, desktopConfigDirs } from \"./DesktopConfigDir\"\nimport { envConfigDir } from \"./EnvConfigDir\"\nimport { firstDir } from \"./FirstDir\"\n\n// PhotoStructure's \"system\" config dir is not backed by a Setting, but will\n// respect customizations via env.PS_CONFIG_DIR (but not configDir, because that\n// may not be photostructure-specific)\n\nexport const configDir = lazy(() => {\n  setSettingsDefaults()\n  return envConfigDir() ?? (isDocker() ? dockerConfigDir() : desktopConfigDir())\n})\n\nconst dockerConfigDirs = [\n  {\n    dir: \"/ps/config\",\n    preexistingDir: \"/ps/config\"\n  },\n  {\n    dir: DefaultDockerLibraryDir + \"/.photostructure/docker-config\",\n    preexistingDir: DefaultDockerLibraryDir\n  }\n]\n\nfunction dockerConfigDir() {\n  return firstDir({\n    dirs: dockerConfigDirs,\n    desc: \"config\"\n  })\n}\n\nexport function resetConfigDir() {\n  configDir.unset()\n}\n\nexport function osConfigDirs() {\n  return (isDocker() ? dockerConfigDirs : desktopConfigDirs()).map(ea => ea.dir)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { mkLogger } from \"../Logger\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { isReadableDirectory } from \"../fs/Stat\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { isMac } from \"../platform/Platform\"\n\nconst logger = lazy(() => mkLogger(\"dir.DefaultApplePhotosLibrary\"))\n\nconst ReadPhotoLibraryDir = [\n  \"read\",\n  \"com.apple.photolibraryd\",\n  \"SystemLibraryPath\"\n]\n\nexport async function defaultApplePhotosLibrary(): PromiseMaybe<string> {\n  if (!isMac) return\n  try {\n    const result = await stdout_(\"defaults\", ReadPhotoLibraryDir, {\n      timeoutMs: ShortCommandTimeoutMs\n    })\n    if (blank(result)) {\n      logger().warn(\n        `\"defaults ${ReadPhotoLibraryDir.join(\" \")}\" returned blank (!!)`\n      )\n      return\n    } else {\n      const isReadable = await isReadableDirectory(result)\n      return logger().tap({\n        msg: \"defaultApplePhotosLibrary()\",\n        level: LogLevels.info,\n        result: isReadable ? result : undefined,\n        meta: { isReadable }\n      })\n    }\n  } catch (error) {\n    logger().warn(\"defaultApplePhotosLibrary()\", error)\n    return\n  }\n}\n","export const DefaultDockerLibraryDir = \"/ps/library\"\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { isReadWriteableDirectorySync } from \"../fs/StatSync\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { DefaultDockerLibraryDir } from \"./DefaultDockerLibraryDir\"\n\n// This was extracted from LibraryDir to break a deploop with PosixFile\n\nexport function defaultLibraryDir(): Maybe<string> {\n  return isDocker() ? DefaultDockerLibraryDir : undefined\n}\n\nexport function defaultOriginalsDir(): string {\n  return isDocker() && isReadWriteableDirectorySync(\"/ps/originals\")\n    ? \"/ps/originals\"\n    : \".\" // < relative to $PS_LIBRARY\n}\n","import path from \"path\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { AppName } from \"../AppName\"\nimport { env } from \"../env/Env\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { isMac, isWin } from \"../platform/Platform\"\nimport { FirstDirArg, firstDir } from \"./FirstDir\"\nimport { homeDir } from \"./HomeDir\"\n\nexport function desktopConfigDir() {\n  return firstDir({\n    dirs: desktopConfigDirs(),\n    desc: \"config\"\n  })!\n}\n\nexport function desktopConfigDirs(): FirstDirArg[] {\n  const dirs: Maybe<string>[] = []\n\n  // Note that process.env.PS_CONFIG_DIR is examined before this method is invoked.\n\n  if (isWin) {\n    dirs.push(getEnv(\"APPDATA\"), path.resolve(homeDir(), \"AppData\", \"Roaming\"))\n  } else if (isMac) {\n    dirs.push(path.resolve(homeDir(), \"Library\", \"Application Support\"))\n  } else {\n    dirs.push(\n      env().XDG_DATA_HOME,\n      env().XDG_CONFIG_HOME,\n      path.resolve(homeDir(), \".config\")\n    )\n  }\n\n  return compactBlanks(dirs).map(ea => ({\n    dir: path.join(ea, AppName()),\n    preexistingDir: ea\n  }))\n}\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { mkdirpSync_ } from \"../fs/Path\"\n\nexport function envConfigDir(): Maybe<string> {\n  // not \"configDir\", because that could be something else:\n  const fromEnv = getEnv(\"PS_CONFIG_DIR\")\n  if (!blank(fromEnv)) {\n    try {\n      mkdirpSync_(fromEnv)\n      return fromEnv\n    } catch (cause) {\n      console.error(\n        \"The environment variable PS_CONFIG_DIR is set to \" +\n          fromEnv +\n          \", but mkdir failed.\",\n        cause\n      )\n    }\n  }\n  return\n}\n","import { mkdirpSync } from \"fs-extra\"\nimport { compact } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isReadWriteableDirectorySync } from \"../fs/StatSync\"\n\nexport interface FirstDirArg {\n  dir: Maybe<string>\n  /**\n   * If set, and this dir does not exist, don't mkdirp `dir`.\n   */\n  preexistingDir?: Maybe<string>\n}\n\n/**\n * Return the first directory that exists (or whose required parent exists), and\n * that can be `mkdir -p`'ed with sufficient permissions.\n */\nexport function firstDir({\n  dirs,\n  desc\n}: {\n  dirs: Maybe<FirstDirArg>[]\n  desc: string\n}): Maybe<string> {\n  for (const { dir, preexistingDir } of compact(dirs)) {\n    if (blank(dir)) continue\n    if (isReadWriteableDirectorySync(dir)) return dir\n    if (blank(preexistingDir) || isReadWriteableDirectorySync(preexistingDir)) {\n      try {\n        mkdirpSync(dir)\n        return dir\n      } catch (err) {\n        console.error(\"Failed to mkdir for \" + desc, err)\n      }\n    }\n  }\n  return\n}\n\nexport function filterDirs({\n  dirs,\n  desc\n}: {\n  dirs: Maybe<FirstDirArg>[]\n  desc: string\n}): string[] {\n  return compact(dirs.map(dir => firstDir({ dirs: [dir], desc })))\n}\n","import { homedir } from \"os\"\nimport { resolve } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { isDirectorySync } from \"../fs/StatSync\"\nimport { isWin } from \"../platform/Platform\"\n\nexport const homeDir = lazy(() => {\n  const paths = []\n  if (isWin) {\n    // cygwin may mess with HOMEPATH and HOME. Only trust USERPROFILE.\n    paths.push(getEnv(\"USERPROFILE\"))\n  } else {\n    paths.push(getEnv(\"HOME\"))\n  }\n  for (const ea of compactBlanks(paths)) {\n    const d = resolve(ea)\n    if (isDirectorySync(d)) return d\n  }\n  return homedir()\n})\n","import { containedByNativePath, toPathnames } from \"../fs/Path\"\nimport { SimpleFileOrString } from \"../fs/SimpleFile\"\nimport { cacheDir } from \"./CacheDir\"\nimport { libraryDataDir, libraryPreviewsDir } from \"./LibraryDir\"\n\nexport function inHiddenPhotoStructureDir(child: SimpleFileOrString): boolean {\n  if (\n    toPathnames(child).some(\n      ea => ea.toLowerCase().startsWith(\".photostructure\") // < handle .photostructure-test\n    )\n  ) {\n    return true\n  }\n\n  for (const dir of [libraryDataDir, libraryPreviewsDir, cacheDir]) {\n    if (\n      containedByNativePath({\n        descendant: child,\n        ancestor: dir(),\n        acceptSelf: true\n      })\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n","import { toNotBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { resolveMaybe } from \"../fs/Path\"\nimport { SimpleFileOrString } from \"../fs/SimpleFile\"\nimport { Settings } from \"../settings/Settings\"\n\nexport function libraryDir(libraryDirOverride?: Maybe<SimpleFileOrString>) {\n  return (\n    toNotBlank(toS(libraryDirOverride)) ?? Settings.libraryDir.valueOrDefault\n  )\n}\n\nexport function originalsDir(libraryDirOverride?: Maybe<SimpleFileOrString>) {\n  return resolveMaybe(\n    libraryDir(libraryDirOverride),\n    Settings.originalsDir.valueOrDefault\n  )\n}\n\nexport function libraryDataDir(libraryDirOverride?: Maybe<SimpleFileOrString>) {\n  return resolveMaybe(\n    libraryDir(libraryDirOverride),\n    // subdir is all lowercase to minimize case-(in)sensitive filesystem pain\n    // and suffering\n    \".photostructure\"\n  )\n}\n\nexport function libraryPreviewsDir(\n  libraryDirOverride?: Maybe<SimpleFileOrString>\n) {\n  return resolveMaybe(\n    libraryDir(libraryDirOverride),\n    Settings.previewsDir.valueOrDefault\n  )\n}\n","import { uniq } from \"../../fe/Array\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { version } from \"../Version\"\nimport { Schemas, pathToDbDir } from \"../db/Schemas\"\nimport { NoLibraryErrorFlag } from \"../error/ErrorFlags\"\nimport { mkNoMedia_ } from \"../fs/MkNoMedia\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFileOrString } from \"../fs/SimpleFile\"\nimport { writeTextfile_ } from \"../fs/WriteFile\"\nimport { imageCacheDir_ } from \"../img/ImageCache\"\nimport { Settings } from \"../settings/Settings\"\nimport {\n  libraryDataDir,\n  libraryDir,\n  libraryPreviewsDir,\n  originalsDir\n} from \"./LibraryDir\"\n\nconst README = `\nHello, and thank you for using PhotoStructure!\n\nThe files in this folder support your PhotoStructure Library, including\n\n  * a database with the filepaths to your photos and movies\n  * previews and thumbnails of your photos and movies\n  * content metadata about these assets, like ratings and sharing information\n  * albums that both you and PhotoStructure Curators have assembled\n  * synchronization reports describing what directories and files were synced (and why)\n\nMoving or deleting any files here will cause problems using your library.\n\nIf you have any questions, please visit https://forum.photostructure.com .\n\nSincerely,\n\nYour Friendly Neighborhood PhotoStructure, v${version}\n`\n\nexport function libraryDirPosixFile(\n  libraryDirOverride?: Maybe<SimpleFileOrString>\n): Maybe<PosixFile> {\n  return PosixFile.forMaybe(libraryDir(libraryDirOverride))\n}\n\n/**\n * libraryDataDir was pulled out of Library so settings could be written into\n * .photostructure, rather than directly into the library root.\n */\nexport function libraryDataDirPosixFile(\n  libraryDirOverride?: Maybe<SimpleFileOrString>\n): Maybe<PosixFile> {\n  return PosixFile.forMaybe(libraryDataDir(libraryDirOverride))\n}\n\nexport async function setupLibraryDirs_(\n  libraryDirOverride?: SimpleFileOrString\n): Promise<PosixFile[]> {\n  const l = libraryDirPosixFile(libraryDirOverride)\n  await mkdirRW_(l, false)\n  const dataDir = await setupLibraryDataDir_(l)\n  return uniq([\n    l,\n    dataDir,\n    // this _is not_ parallel to avoid DDOS on smaller boxen\n    await setupLibraryOriginalsDir_(l),\n    await setupLibraryPreviewsDir_(l),\n    await setupLibrarySyncReportsDir_(l),\n    await setupLibraryDbDir_(l),\n    await imageCacheDir_()\n  ])\n}\n\nasync function mkdirRW_(dir: Maybe<PosixFile>, neverIndex = true) {\n  if (dir == null) return\n  await dir?.mkdirp_() // if we can't make this directory, fail.\n  await dir?.assertReadWriteExecutable()\n  // Tell macOS Spotlight to not index this directory:\n  if (neverIndex) await dir?.join(\".metadata_never_index\").touch()\n  return dir\n}\n\n/**\n * @throws if there are issues\n */\nexport async function setupLibraryDataDir_(\n  libraryDirOverride?: SimpleFileOrString\n): Promise<PosixFile> {\n  const dataDir = libraryDataDirPosixFile(libraryDirOverride)\n  if (dataDir == null) {\n    throw new Error(\"empty libraryDataDir\" + NoLibraryErrorFlag)\n  }\n  await mkdirRW_(dataDir)\n  await mkNoMedia_(dataDir) // < optional, don't fail here\n  const readmeFile = dataDir.join(\"README.txt\")\n  await writeTextfile_(readmeFile.nativePath, README)\n  return dataDir\n}\n\nexport function libraryOriginalsDirPosixFile(\n  libraryDirOverride?: Maybe<SimpleFileOrString>\n): Maybe<PosixFile> {\n  return PosixFile.forMaybe(originalsDir(libraryDirOverride))\n}\n\nexport async function setupLibraryOriginalsDir_(\n  libraryDirOverride?: Maybe<SimpleFileOrString>\n): PromiseMaybe<PosixFile> {\n  return mkdirRW_(libraryOriginalsDirPosixFile(libraryDirOverride))\n}\n\nexport function libraryPreviewsDirPosixFile(\n  libraryDirOverride?: Maybe<SimpleFileOrString>\n): Maybe<PosixFile> {\n  return PosixFile.forMaybe(libraryPreviewsDir(libraryDirOverride))\n}\n\nexport async function setupLibraryPreviewsDir_(\n  libraryDirOverride?: Maybe<SimpleFileOrString>\n): PromiseMaybe<PosixFile> {\n  return mkdirRW_(libraryPreviewsDirPosixFile(libraryDirOverride))\n}\n\nexport function librarySyncReportsDir(\n  libraryDirOverride?: Maybe<SimpleFileOrString>\n): Maybe<PosixFile> {\n  return libraryDirPosixFile(libraryDirOverride)?.join(\n    // NOTE: the default is .photostructure/sync-reports, so don't add the data dir here!\n    Settings.syncReportsDir.valueOrDefault\n  )\n}\n\nexport async function setupLibrarySyncReportsDir_(\n  libraryDirOverride?: Maybe<SimpleFileOrString>\n): PromiseMaybe<PosixFile> {\n  return mkdirRW_(librarySyncReportsDir(libraryDirOverride))\n}\n\nexport async function setupLibraryDbDir_(\n  libraryDirOverride?: Maybe<SimpleFileOrString>\n): PromiseMaybe<PosixFile> {\n  return mkdirRW_(\n    map(libraryDataDirPosixFile(libraryDirOverride), ea =>\n      pathToDbDir(ea, Schemas.models)\n    )\n  )\n}\n","import _path from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { toS } from \"../../fe/toS\"\nimport { SimpleAppName } from \"../AppName\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { isMac } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { systemSettingsFile } from \"../settings/SystemSettings\"\nimport { readTomlFileSync } from \"../settings/Toml\"\nimport { cacheDirs } from \"./CacheDir\"\nimport { DefaultDockerLibraryDir } from \"./DefaultDockerLibraryDir\"\nimport { firstDir } from \"./FirstDir\"\nimport { homeDir } from \"./HomeDir\"\n\nexport function defaultLogDirs() {\n  if (isDocker()) {\n    return [\n      {\n        dir: \"/ps/logs\",\n        preexistingDir: \"/ps/logs\"\n      },\n      {\n        dir: DefaultDockerLibraryDir + \"/.photostructure/logs\",\n        preexistingDir: \"/ps/library\"\n      },\n      {\n        dir: \"/tmp/photostructure-logs\",\n        preexistingDir: \"/tmp\" // this will certainly exist, but not be persistent. It's only here as a backstop.\n      }\n    ]\n  } else if (isMac) {\n    return [\n      {\n        dir: _path.resolve(homeDir(), \"Library\", \"Logs\", SimpleAppName),\n        preexistingDir: homeDir()\n      }\n    ]\n  } else {\n    // Windows and Linux puts logs into the cache dir:\n    return compact(cacheDirs()).map(ea => ({\n      dir: map(ea.dir, dir => _path.resolve(dir, \"logs\")),\n      preexistingDir: ea.preexistingDir\n    }))\n  }\n}\n\nexport function defaultLogDir_() {\n  return firstDir({ dirs: defaultLogDirs(), desc: \"logs\" })!\n}\n\n// this bare-bones implementation means we can set up the logger without pulling\n// in Settings, SettingsIO and all those dependencies:\n\nexport const logDir = lazy(() => {\n  try {\n    const e = getEnv(\"logDir\") // < this will check logDir and PS_LOG_DIR\n    if (notBlank(e)) return e\n\n    const s = readTomlFileSync(systemSettingsFile())\n    const ld = toS(s?.logDir)\n    if (notBlank(ld)) return ld\n\n    return defaultLogDir_()\n  } catch (error) {\n    console.error(\"defaultLogDir_() failed\", error)\n    return _path.resolve(homeDir(), \"logs\")\n  }\n})\n","import { resolve } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { env } from \"../env/Env\"\nimport { isWin } from \"../platform/Platform\"\nimport { PowerShell } from \"../pwsh/PowerShell\"\nimport { homeDir } from \"./HomeDir\"\n\nexport async function picturesDirWindows() {\n  return isWin\n    ? (PowerShell.instance().executeJson(\n        `Get-ItemPropertyValue \"Registry::HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\" -name \"My Pictures\"`\n      ) as Promise<string>)\n    : undefined\n}\n\nexport const picturesDir = lazy<Promise<string>>(async () => {\n  if (isWin) {\n    const result = await picturesDirWindows()\n    if (notBlank(result)) return result\n    // else fall through and return default\n  }\n  return defaultPicturesDir()\n})\n\nexport const defaultPicturesDir = lazy<string>(\n  // See https://wiki.archlinux.org/title/XDG_user_directories\n  () => env().XDG_PICTURES_DIR ?? resolve(homeDir(), \"Pictures\")\n)\n","import { isTrue } from \"../../fe/Boolean\"\nimport { StrEnumKeys } from \"../../fe/StrEnum\"\nimport { isProd } from \"../NodeEnv\"\nimport { DevEnvFlags } from \"../env/EnvKeys\"\nimport { isPacked } from \"../platform/IsPacked\"\nimport { env } from \"./Env\"\n\nexport type DevFlag = StrEnumKeys<typeof DevEnvFlags>\n\nexport function getDevEnvFlag(key: DevFlag): boolean {\n  return !isProd && !isPacked() && isTrue(env()[key])\n}\n\nexport function setDevEnvFlag(key: DevFlag, b: boolean) {\n  if (b) {\n    env()[key] = \"true\"\n  } else {\n    delete env()[key]\n  }\n}\n","import fs from \"fs\"\nimport { delimiter } from \"path\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { uniq } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { later } from \"../../fe/Delay\"\nimport { entries, StringValued } from \"../../fe/Object\"\nimport { debom } from \"../Buffers\"\nimport { ee } from \"../event/EventEmitter\"\nimport { PS_ENV_KEYS } from \"./EnvKeys\"\nimport { parseEnvTokens } from \"./EnvTokens\"\nimport { SensitiveEnvRE } from \"./GetEnv\"\n\nexport const env = lazy<StringValued>(() => {\n  const paths = uniq(\n    PS_ENV_KEYS.map(k => process.env[k])\n      // handle FILE and PATH values:\n      .join(delimiter)\n      .split(delimiter)\n      .filter(notBlank)\n  )\n\n  const re = SensitiveEnvRE()\n  const result = { ...process.env }\n  for (const file of paths) {\n    try {\n      const input = debom(fs.readFileSync(file))\n      const tokens = parseEnvTokens({ input, lowerCaseKeys: false })\n      for (const [k, v] of entries(tokens)) {\n        if (!re.test(k)) {\n          result[k] = v\n        }\n      }\n    } catch (error) {\n      // not logger, as we may not have the logger up and running yet.\n      console.warn(\"env(): failed to read .env file, \" + file, error)\n    }\n  }\n  return result\n})\n\nlater(() => {\n  ee().on(\"clearCache\", () => env.unset())\n})\n","import { strEnum } from \"../../fe/StrEnum\"\n\nexport const PS_ENV_KEYS = [\"PS_ENV\", \"PS_ENV_FILE\", \"PS_ENV_PATH\"]\nexport const PS_IS_CHILD_PROCESS = \"PS_IS_CHILD_PROCESS\"\nexport const PS_IS_DOCKER = \"PS_IS_DOCKER\"\nexport const ELECTRON_RUN_AS_NODE = \"ELECTRON_RUN_AS_NODE\"\n\nexport const DevEnvFlags = strEnum(\n  \"PS_BAIL_ON_ERROR\",\n  \"PS_FAIL_DB_HEALTH_CHECK\",\n  \"PS_FAIL_SECURITY_HEALTH_CHECK\",\n  \"PS_FAIL_VOLUMES\",\n  \"PS_FORCE_FULLDISK\",\n  \"PS_FORCE_LITE\",\n  \"PS_FORCE_TRIAL\",\n  \"PS_KEEP_ENV\",\n  \"PS_NO_RANDOM_IMAGE_CACHE\",\n  \"PS_PRIVATE_KEYS\",\n  \"PS_SINGLE_SPEC_TESTS\",\n  \"PS_SKIP_ALL_TESTS\",\n  \"PS_SKIP_CLEANUP\",\n  \"PS_SKIP_RUN\",\n  \"PS_SLOMO\",\n  \"PS_TEST_HEALTH_CHECK_LEVEL\"\n)\n\nexport const DevEnvKeys = [\"PS_NO_PUID_CHOWN\", \"PS_TEST_VOLUME_UUIDS\"]\n\nexport const IgnorableEnvKeys = [\n  \"PS_CONFIG_DIR\",\n  PS_IS_DOCKER,\n  PS_IS_CHILD_PROCESS,\n  ...DevEnvKeys,\n  ...PS_ENV_KEYS,\n  ...DevEnvFlags.values\n]\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\nimport { SettingsName } from \"../settings/SettingsName\"\n\n// We don't need to check for PS_APP_DATA or PS_PATH:\n\nexport const EnvKeys = strEnum(\n  \"HOME\",\n  \"NO_COLOR\",\n  \"PATH\",\n  \"PS_CONFIG_DIR\",\n  \"TMP\",\n  \"TEMP\",\n  \"XDG_CACHE_HOME\",\n\n  // Windows ENV keys: inconsistent casing here matches windows 10 box via\n  // `node -e \"console.log(process.env)\"`:\n  \"APPDATA\",\n  \"LOCALAPPDATA\",\n  \"ProgramData\",\n  \"ProgramFiles\",\n  \"ProgramFiles(x86)\",\n  \"ProgramW6432\",\n  \"SystemDrive\",\n  \"SystemRoot\",\n  \"USERPROFILE\",\n  \"windir\" // < \"C:\\Windows\"\n)\nexport type EnvKey = StrEnumKeys<typeof EnvKeys>\n\nexport type EnvName = SettingsName | EnvKey\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { StringValued } from \"../../fe/Object\"\nimport { splitCompactLines } from \"../fs/CRLF\"\n\n/**\n * Parser for sh environment variable assignments, like `FOO=\"bar\"`.\n *\n * NO, WE DON'T SUPPORT NEWLINES IN VALUES. Use `\\n` like a reasonable person.\n *\n * Pairs may be one per line or joined on a single line.\n *\n * # Comments are removed.\n */\nexport function parseEnvTokens({\n  input,\n  lowerCaseKeys\n}: {\n  input: Maybe<string>\n  lowerCaseKeys: boolean\n}): StringValued {\n  const result: StringValued = {}\n  if (blank(input)) return result\n  let m\n  for (const line of splitCompactLines(input)) {\n    const re =\n      // eslint-disable-next-line regexp/no-potentially-useless-backreference\n      /#.*$|(?:export\\s+)?(?<key>[a-z_]+)=([\"'])?(?<val>(?:\\\\[\"']|.)*?)\\2(?=$|\\s|#)/gim\n\n    while ((m = re.exec(line)) != null) {\n      if (m.groups == null) continue\n      const { key, val } = m.groups\n      if (blank(key) || val == null) continue\n      const str = val.replace(/\\\\n/g, \"\\n\").replace(/\\\\([\"'])/g, \"$1\") // unescape escaped quotes\n      // DON'T DO THIS: it makes values like \"20.10\" turn into 20.1\n      // const val = blank(quot) && isNumeric(v) ? toFloat(v) : v\n      result[lowerCaseKeys ? key.toLowerCase() : key] = str\n    }\n  }\n  return result\n}\n","import process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { firstNotBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { CaseInsensitiveValued } from \"../CaseInsensitiveValued\"\nimport { DefaultSensitiveEnvRegexPattern } from \"../DefaultSensitiveEnvRegexPattern\"\nimport { camel2snake } from \"../StringCase\"\nimport { env } from \"./Env\"\nimport { EnvKeys, EnvName } from \"./EnvName\"\n\n// !!!!!!!!!!!!!!!!!!!\n// IMPORTANT: To avoid deploops: `Settings` can be referenced ONLY by TypeScript\n// types, BUT NOT ACTUAL FUNCTIONALITY.\n// !!!!!!!!!!!!!!!!!!!\n\nexport const SensitiveEnvRegexPattern = lazy(\n  () =>\n    firstNotBlank(\n      process.env.PS_SENSITIVE_ENV_REGEX_PATTERN,\n      process.env.sensitiveEnvRegexPattern,\n      DefaultSensitiveEnvRegexPattern\n    )!\n)\n\nexport const SensitiveEnvRE = lazy(() => {\n  try {\n    return new RegExp(SensitiveEnvRegexPattern(), \"i\")\n  } catch (err) {\n    console.error(\n      `Invalid setting for \"sensitiveEnvRegExp\": ${err}. Using default value.`\n    )\n    return new RegExp(DefaultSensitiveEnvRegexPattern, \"i\")\n  }\n})\n\nexport const caseInsensitiveEnv = lazy(() => {\n  return new CaseInsensitiveValued(env())\n})\n\nexport function onEnvChange() {\n  caseInsensitiveEnv.unset()\n  SensitiveEnvRegexPattern.unset()\n  SensitiveEnvRE.unset()\n}\n\nlater(() => {\n  env.watchLater(onEnvChange)\n})\n\n/**\n * Case-insensitive search for a given ENV key\n *\n * @param key either XDG_CACHE_HOME for non-settings, or camelCaseSettingsName\n */\nexport function getEnv(key: EnvName): Maybe<string> {\n  return (\n    caseInsensitiveEnv().get(key) ??\n    (EnvKeys.includes(key)\n      ? undefined // < no need to search for PS_windir\n      : caseInsensitiveEnv().get(\"PS_\" + camel2snake(key)))\n  )\n}\n\nexport function isEnvTrue(key: EnvName): boolean {\n  return isTrue(getEnv(key))\n}\n","import { Rate } from \"batch-cluster\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact, compactBlanks, isEmpty, uniqSubstrings } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport {\n  ErrorDelimiter,\n  IgnoredErrorNames,\n  errorCode,\n  errorName,\n  shortStack\n} from \"../../fe/Error\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isBuffer } from \"../../fe/String\"\nimport { isError } from \"../../fe/isError\"\nimport { toS } from \"../../fe/toS\"\nimport { BoundedList } from \"../BoundedList\"\nimport { mkLogger } from \"../Logger\"\nimport { ellipsize, isString, stripAnsiEsc } from \"../String\"\nimport { splitCompactLines } from \"../fs/CRLF\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { getErrorDescriptions } from \"./ErrorCodes\"\nimport { ErrorFlag, sortErrorFlags } from \"./ErrorFlags\"\nimport { extractErrorFlags, stripErrorFlags } from \"./ErrorTypes\"\nimport { WrappedError } from \"./WrappedError\"\n\nexport const StartTs = Date.now()\n\nexport const logger = lazy(() => mkLogger(\"Error\"))\n\nexport const errorRate = new Rate()\nexport const fatalErrorRate = new Rate()\nexport const internalErrorRate = new Rate()\nexport const lastInternalErrors = new BoundedList(10)\n\nexport function mapError<T>(obj: any, f: (error: Error) => T): Maybe<T> {\n  return obj instanceof Error ? f(obj) : undefined\n}\n\nexport function errorContains(err: any, re: RegExp): boolean {\n  return re.test(errorToS(err))\n}\n\nexport function throws(f: () => any): boolean {\n  try {\n    f()\n    return false\n  } catch {\n    return true\n  }\n}\n\nexport function addMessage(error: Maybe<Error>, message: Maybe<string>) {\n  if (error == null) return new Error(message)\n\n  if (notBlank(message)) {\n    if (!error.message.toLowerCase().includes(message.toLowerCase())) {\n      error.message += \": \" + message\n    }\n  }\n  return error\n}\n\nexport function errorsToPath(\n  ...errs: Maybe<Error | SimpleFile | { path: string }>[]\n): Maybe<string> {\n  for (const ea of errs as any[]) {\n    for (const k of [\"nativePath\", \"path\"]) {\n      const s = toS(ea?.[k])\n      if (notBlank(s)) return s\n    }\n  }\n  return\n}\n\n/**\n * Errors can contain a \"name\", a \"code\", and a \"message\". Wrapped Errors may\n * contain a concatenated set of errors (\"Error: failed to import foo: missing\n * database entry\")\n */\nexport function splitErrorMessage(...errs: Maybe<Error | string>[]): string[] {\n  if (isEmpty(errs)) return []\n\n  const messages: string[] = errs.map((ea: any) =>\n    isString(ea) ? ea : isBuffer(ea) ? ea.toString() : toS(ea?.message ?? ea)\n  )\n\n  messages.push(...getErrorDescriptions(errs))\n\n  const arr = [\n    ...errs.filter(isError).map(errorName),\n    ...errs.map(errorCode),\n    // only split(\": \") on message and strings to avoid URL splitting\n    ...compactBlanks(messages)\n      .map(stripAnsiEsc)\n      .flatMap(ea => splitCompactLines(ea))\n      .flatMap(ea => ea.split(ErrorDelimiter))\n  ]\n  return uniqSubstrings(normalizeErrorMessages(flatten(arr)))\n}\n\nexport function normalizeErrorMessages(arr: Maybe<string>[]): string[] {\n  return compact(arr)\n    .filter(ea => !IgnoredErrorNames.includes(ea))\n    .map(ea =>\n      ea\n        .replace(/\\s+/g, \" \")\n        .trim()\n        .replace(/^code ([A-Z]+)$/i, \"$1\")\n        .trim()\n    )\n    .filter(notBlank)\n}\n\nexport function joinErrorMessages(\n  arr: Maybe<string>[],\n  opts?: { maxLen?: number; trailingChars?: number; flags?: ErrorFlag[] }\n): string {\n  const trimmed = uniqSubstrings(normalizeErrorMessages(arr))\n  const maxLen = opts?.maxLen ?? 400\n  const trailingChars = opts?.trailingChars ?? 64\n  const flags = sortErrorFlags([\n    ...(opts?.flags ?? []),\n    ...extractErrorFlags(arr.join(\"\"))\n  ])\n  return (\n    ellipsize(\n      stripErrorFlags(trimmed.join(ErrorDelimiter)),\n      maxLen - flags.length,\n      trailingChars\n    ) + flags.sort().join(\"\")\n  )\n}\n\nexport function errorToS(\n  err: any,\n  opts?: { maxLen?: number; trailingChars?: number }\n): string {\n  if (err instanceof WrappedError) return err.toString()\n  if (blank(err)) {\n    return \"\"\n  }\n  const arr = splitErrorMessage(err)\n  return joinErrorMessages(arr, opts)\n}\n\nexport const MissingError = \"(missing error)\"\n\nexport function errorToVerbose(\n  err: any,\n  maxMsgLen = 256,\n  maxStackLines = 7\n): string {\n  if (blank(err)) err = MissingError // < if blank, at least fill in a stacktrace...\n  return (\n    errorToS(err, { maxLen: maxMsgLen }) +\n    \" at \" +\n    shortStack(err?.stack, maxStackLines).join(\"; \")\n  )\n}\n","import { uniq } from \"../../fe/Array\"\nimport { errorCode, errorErrno } from \"../../fe/Error\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { stripSuffix } from \"../String\"\n\nexport function describeError(ea: string) {\n  const key = stripSuffix(toS(ea).trim().toUpperCase(), \":\")\n  return (ErrorCodes as any)[key]?.description ?? ea\n}\n\nexport function getErrorDescriptions(...arr: (Error | any)[]) {\n  const result: Maybe<string>[] = []\n  for (const err of arr) {\n    map(errorErrno(err), ea => result.push(err2desc.get(ea)))\n    map(errorCode(err), ea => result.push((ErrorCodes as any)[ea]?.description))\n  }\n  return uniq(result)\n}\n\nconst ErrorCodes = {\n  UNKNOWN: { errno: -1, description: \"unknown error\" },\n  OK: { errno: 0, description: \"success\" },\n  EOF: { errno: 1, description: \"end of file\" },\n  EADDRINFO: { errno: 2, description: \"getaddrinfo error\" },\n  EACCES: { errno: 3, description: \"permission denied\" },\n  EAGAIN: { errno: 4, description: \"resource temporarily unavailable\" },\n  EADDRINUSE: { errno: 5, description: \"address already in use\" },\n  EADDRNOTAVAIL: { errno: 6, description: \"address not available\" },\n  EAFNOSUPPORT: { errno: 7, description: \"address family not supported\" },\n  EALREADY: { errno: 8, description: \"connection already in progress\" },\n  EBADF: { errno: 9, description: \"bad file descriptor\" },\n  EBUSY: { errno: 10, description: \"resource busy or locked\" },\n  ECONNABORTED: { errno: 11, description: \"software caused connection abort\" },\n  ECONNREFUSED: { errno: 12, description: \"connection refused\" },\n  ECONNRESET: { errno: 13, description: \"connection reset by peer\" },\n  EDESTADDRREQ: { errno: 14, description: \"destination address required\" },\n  EFAULT: { errno: 15, description: \"bad address in system call argument\" },\n  EHOSTUNREACH: { errno: 16, description: \"host is unreachable\" },\n  EINTR: { errno: 17, description: \"interrupted system call\" },\n  EINVAL: { errno: 18, description: \"invalid argument\" },\n  EISCONN: { errno: 19, description: \"socket is already connected\" },\n  EMFILE: { errno: 20, description: \"too many open files\" },\n  EMSGSIZE: { errno: 21, description: \"message too long\" },\n  ENETDOWN: { errno: 22, description: \"network is down\" },\n  ENETUNREACH: { errno: 23, description: \"network is unreachable\" },\n  ENFILE: { errno: 24, description: \"file table overflow\" },\n  ENOBUFS: { errno: 25, description: \"no buffer space available\" },\n  ENOMEM: { errno: 26, description: \"not enough memory\" },\n  ENOTDIR: { errno: 27, description: \"not a directory\" },\n  EISDIR: { errno: 28, description: \"illegal operation on a directory\" },\n  ENONET: { errno: 29, description: \"machine is not on the network\" },\n  ENOTCONN: { errno: 31, description: \"socket is not connected\" },\n  ENOTSOCK: { errno: 32, description: \"socket operation on non-socket\" },\n  ENOTSUP: { errno: 33, description: \"operation not supported on socket\" },\n  ENOENT: { errno: 34, description: \"no such file or directory\" },\n  ENOSYS: { errno: 35, description: \"function not implemented\" },\n  EPIPE: { errno: 36, description: \"broken pipe\" },\n  EPROTO: { errno: 37, description: \"protocol error\" },\n  EPROTONOSUPPORT: { errno: 38, description: \"protocol not supported\" },\n  EPROTOTYPE: { errno: 39, description: \"protocol wrong type for socket\" },\n  ETIMEDOUT: { errno: 40, description: \"connection timed out\" },\n  ECHARSET: { errno: 41, description: \"invalid Unicode character\" },\n  EAIFAMNOSUPPORT: {\n    errno: 42,\n    description: \"address family for hostname not supported\"\n  },\n  EAISERVICE: {\n    errno: 44,\n    description: \"servname not supported for ai_socktype\"\n  },\n  EAISOCKTYPE: { errno: 45, description: \"ai_socktype not supported\" },\n  ESHUTDOWN: {\n    errno: 46,\n    description: \"cannot send after transport endpoint shutdown\"\n  },\n  EEXIST: { errno: 47, description: \"file already exists\" },\n  ESRCH: { errno: 48, description: \"no such process\" },\n  ENAMETOOLONG: { errno: 49, description: \"name too long\" },\n  EPERM: { errno: 50, description: \"operation not permitted\" },\n  ELOOP: { errno: 51, description: \"too many symbolic links encountered\" },\n  EXDEV: { errno: 52, description: \"cross-device link not permitted\" },\n  ENOTEMPTY: { errno: 53, description: \"directory not empty\" },\n  ENOSPC: { errno: 54, description: \"no space left on device\" },\n  EIO: { errno: 55, description: \"i/o error\" },\n  EROFS: { errno: 56, description: \"read-only file system\" },\n  ENODEV: { errno: 57, description: \"no such device\" },\n  ESPIPE: { errno: 58, description: \"invalid seek\" },\n  ECANCELED: { errno: 59, description: \"operation canceled\" }\n} as const\n\nconst err2desc = new Map<number, string>(\n  Object.values(ErrorCodes).map(ea => [ea.errno, ea.description])\n)\n","import { uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\nimport { escapeRegExp } from \"../RegExp\"\n\nexport const ErrorFlags = strEnum(\n  \"⁰\",\n  \"¹\",\n  \"²\",\n  \"³\",\n  \"⁴\",\n  \"⁵\",\n  \"⁶\",\n  \"⁷\",\n  \"⁸\",\n  \"⁹\",\n  \"₀\",\n  \"₁\",\n  \"₂\"\n  // \"₃\",\n  // \"₄\",\n  // \"₅\",\n  // \"₆\",\n  // \"₇\",\n  // \"₈\",\n  // \"₉\"\n)\nexport type ErrorFlag = StrEnumKeys<typeof ErrorFlags>\n// I could also go with a ⚠️🛑💥 or \"🔁⏹⏏️\" ️but these seem less cutesy:\n\nexport function sortErrorFlags(arr: Maybe<ErrorFlag>[]): ErrorFlag[] {\n  return sortBy(uniq(arr), ea => ErrorFlags.indexOf(ea))\n}\n\nexport const FatalErrorFlag = ErrorFlags[\"¹\"]\nexport const NonRetriableErrorFlag = ErrorFlags[\"²\"]\nexport const IgnorableErrorFlag = ErrorFlags[\"³\"]\nexport const PleaseSendErrorFlag = ErrorFlags[\"⁴\"]\nexport const HealthCheckErrorFlag = ErrorFlags[\"⁵\"]\nexport const DoNotSendErrorFlag = ErrorFlags[\"⁶\"]\nexport const RetriableErrorFlag = ErrorFlags[\"⁷\"]\nexport const HealthCheckWarningFlag = ErrorFlags[\"⁸\"]\nexport const InternalErrorFlag = ErrorFlags[\"⁹\"]\nexport const NoLibraryErrorFlag = ErrorFlags[\"₀\"]\nexport const DbSetupErrorFlag = ErrorFlags[\"₁\"]\nexport const NonFatalErrorFlag = ErrorFlags[\"₂\"]\n\nexport const ErrorFlagsRE = new RegExp(\n  \"(\" + ErrorFlags.values.join(\"|\") + \")\",\n  \"g\"\n)\n\nexport const FailStr = JSON.stringify({ fatal: true })\n\nexport const FatalErrorPatterns = [\n  \"SQLITE_FULL\",\n  \"SQLITE_CORRUPT\",\n  \"SQLITE_IOERR\", // there are a ton with this prefix, like SQLITE_IOERR_TRUNCATE\n  \"SQLITE_NOMEM\",\n  \"SQLITE_NOTADB\",\n  \"ON CONFLICT\",\n  \"SQLITE_CONSTRAINT_NOTNULL\",\n  \"Error: Cannot find module\",\n  FatalErrorFlag,\n  FailStr\n]\n\n/**\n * Default errors that indicate serious problems\n */\nexport const FatalErrorRe = new RegExp(\n  FatalErrorPatterns.map(escapeRegExp).join(\"|\"),\n  \"i\"\n)\n\nexport const InternalErrorRe = /⁹|internal ?error/i\n","import { lazy } from \"../../core/Lazy\"\nimport { dayMs, secondMs } from \"../../fe/Date\"\nimport { fmtDuration } from \"../../fe/FmtDuration\"\nimport { map } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { within } from \"../../fe/Number\"\nimport { Obj, omit } from \"../../fe/Object\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { shortStringSha } from \"../StringHash\"\nimport { ending } from \"../async/Endable\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { PleaseSendErrorFlag } from \"../error/ErrorFlags\"\nimport { isJsonExt } from \"../fs/FileExt\"\nimport { isHiddenBasename } from \"../fs/Path\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { GeoRadix } from \"../math/Radix\"\nimport { Settings } from \"../settings/Settings\"\n\nconst logger = lazy(() => mkLogger(\"error.EventStore\"))\n\nexport const ExtraEventsForPlease = 7\n\nexport type StoredError = Obj & {\n  message: string\n  timestamp: number // UNIX TIMESTAMP, not millis!\n}\n\nfunction event2log(event: StoredError) {\n  // Skip breadcrumbs (all recent logs) because they are enormous.\n  return omit(event, \"breadcrumbs\")\n}\n\n/**\n * We don't want the same event spammed N-thousand times from a given host. Send\n * the first, throttle the next N for the next time period.\n *\n * Everything is FS based (rather than using sqlite) to minimize deps and have\n * fewer moving parts.\n *\n * Files are placed in YYYY/MM/DD subdirectories so the current day's events are\n * in one place.\n */\nexport class ErrorStore<T extends StoredError> {\n  static readonly instance = lazy(() =>\n    map(configDir(), ea => new ErrorStore(PosixFile.for(ea).join(\"events\")))\n  )\n\n  constructor(readonly root: PosixFile) {}\n\n  // we only want to send the same message at most once a month per user.\n  datedRoot(d = new Date()) {\n    return this.root.join(toS(d.getFullYear()), toS(d.getMonth() + 1))\n  }\n\n  rmrf() {\n    return this.root.rmrf()\n  }\n\n  msg2file(e: StoredError): PosixFile {\n    return this.datedRoot(new Date(e.timestamp * secondMs)).join(\n      shortStringSha(e.message, 8, GeoRadix) + \".json\"\n    )\n  }\n\n  async eventsFrom(when = new Date(), deltaMs = dayMs) {\n    const at = when.getTime()\n    const lt = at - deltaMs\n    const gt = at + deltaMs\n    return logger().tap({\n      msg: \"eventsFrom()\",\n      result: toA(\n        await this.datedRoot(when)\n          .clear()\n          .childFiles(async ea =>\n            logger().tap({\n              msg: \"eventsFrom().childFiles() accept \" + ea.base,\n              result:\n                isJsonExt(ea) &&\n                !isHiddenBasename(ea.base) && // no WIPs\n                within(lt, gt, await ea.mtimeMs())\n            })\n          )\n      ),\n      meta: { when, deltaMs: fmtDuration(deltaMs) }\n    })\n  }\n\n  async eventCount(when = new Date()) {\n    const arr = await this.eventsFrom(when)\n    return arr.length\n  }\n\n  async eventQuotaExceeded(event: T | any) {\n    const pleaseSend =\n      toS(event).includes(PleaseSendErrorFlag) ||\n      toS(event.message).includes(PleaseSendErrorFlag)\n    const recentEventCount = await this.eventCount()\n    const maxErrorsPerDay =\n      Settings.maxErrorsPerDay.valueOrDefault +\n      (pleaseSend ? ExtraEventsForPlease : 0)\n    return logger().tap({\n      msg: \"eventQuotaExceeded()\",\n      result: recentEventCount >= maxErrorsPerDay,\n      meta: {\n        event: event2log(event),\n        recentEventCount,\n        maxErrorsPerDay,\n        pleaseSend\n      }\n    })\n  }\n\n  async maybeSendEvent(event: T): PromiseMaybe<T> {\n    event.timestamp = Math.floor(event.timestamp)\n    if (ending()) {\n      logger().error(\"maybeSendEvent(): REJECT: we're ending.\", {\n        event: event2log(event)\n      })\n      return\n    }\n    if (await this.eventQuotaExceeded(event)) {\n      logger().error(\"maybeSendEvent(): REJECT: too many recent events.\", {\n        event: event2log(event)\n      })\n      return\n    }\n    try {\n      const eventFile = await this.writeEvent_(event)\n      return logger().tap({\n        msg:\n          \"maybeSendEvent(): \" + eventFile == null\n            ? \"REJECT: previously sent this event already this month\"\n            : \"ACCEPT\",\n        result: eventFile != null ? event : undefined,\n        meta: { eventFile }\n      })\n    } catch (err) {\n      logger().error(\"maybeSendEvent(): REJECT: failed to write event.\", err)\n      return\n    }\n  }\n\n  /**\n   * Only send one of the same event\n   */\n  writeEvent_(event: T) {\n    const returnUndefinedIfNotEmpty = true\n    return this.msg2file(event).applyIfEmpty_({\n      fn_: ea => ea.writeJson_(event),\n      minSizeBytes: 3,\n      returnUndefinedIfNotEmpty,\n      timeoutMs: ShortCommandTimeoutMs\n    })\n  }\n}\n","import { compact } from \"../../fe/Array\"\nimport { isFalse, isTrue } from \"../../fe/Boolean\"\nimport { errorCode } from \"../../fe/Error\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { orRegExpPatterns } from \"../RegExp\"\nimport { errorToS } from \"../error/Error\"\nimport {\n  DoNotSendErrorFlag,\n  ErrorFlag,\n  ErrorFlags,\n  ErrorFlagsRE,\n  FatalErrorFlag,\n  FatalErrorRe,\n  HealthCheckErrorFlag,\n  IgnorableErrorFlag,\n  InternalErrorRe,\n  NonFatalErrorFlag,\n  NonRetriableErrorFlag,\n  PleaseSendErrorFlag,\n  RetriableErrorFlag\n} from \"./ErrorFlags\"\n\n/**\n * @param msg may contain error flags\n * @return `msg` with any included error flags, and all\n * non-null `flags`, sorted, at the end of the string.\n */\nexport function addErrorFlags(msg: string, ...flags: Maybe<ErrorFlag>[]) {\n  const s = toS(msg) + compact(flags).join(\"\")\n  return stripErrorFlags(s) + extractErrorFlags(s).join(\"\")\n}\n\nexport function stripErrorFlags(err: Maybe<string>): string {\n  return toS(err).replace(ErrorFlagsRE, \"\").trim()\n}\n\n/**\n * @return ordered and uniq'ed flags found in `err`\n */\nexport function extractErrorFlags(err: string): ErrorFlag[] {\n  return ErrorFlags.values.filter(ea => err.includes(ea))\n}\n\nexport function hasErrorFlag(err: string): boolean {\n  return ErrorFlags.values.some(ea => err.includes(ea))\n}\n\n// FUTURE ME: OMG, aren't all these errorToS calls inefficient?\n\n// NOW ME: WHY YES, future me, they are.\n\n// FUTURE ME: SWEET IMMA REFACTOR THIS\n\n// NOW ME: Dude, if error parsing is your big performance issue, you've got\n// bigger issues.\n\n// FUTURE ME: AW YOU RIGHT\n\nexport function isHealthCheckError(err: any): boolean {\n  return errorToS(err).includes(HealthCheckErrorFlag)\n}\n\nexport function isPleaseSendError(err: any): boolean {\n  return errorToS(err).includes(PleaseSendErrorFlag)\n}\n\nconst notIgnorablePatternRE = /Can't write [a-z\\d]+ files/i\n\nconst ignorablePatternsRE = orRegExpPatterns(\n  [\n    IgnorableErrorFlag,\n    \"0 output files created\", // From exiftool\n    \"debugger attached\", //nodeJS inspector issues\n    \"debugger listening on\", //nodeJS inspector issues\n    \"diskutil: interrupted\", // dang flaky macOS tool\n    \"ECONNRESET\", // read ECONNRESET from broken socket\n    \"EPIPE\", // meh whatev\n    \"for help\", //nodeJS inspector issues\n    \"Format error in file\", // from exiftool\n    \"https://nodejs.org/en/docs/inspector\", //nodeJS inspector issues\n    \"Missing expected status message\", // From exiftool\n    \"net::ERR_\", //See https://cs.chromium.org/codesearch/f/chromium/src/net/base/net_error_list.h  like net::ERR_TIMED_OUT\n    \"This socket has been ended by the other party\", // so rude\n    \"Unexpected error while trimming\", // From sharp\n    /\\bwarning:/i // I mean, it's _a warning_\n  ],\n  \"i\"\n)\n\n/**\n * Ignorable errors are expected, and not even important enough to log.\n */\nexport function isIgnorableError(err: any): Maybe<boolean> {\n  if (err == null) return true\n\n  const b = err?.ignorable\n  if (typeof b === \"boolean\") return b\n\n  const msg = errorToS(err)\n  return notIgnorablePatternRE.test(msg)\n    ? false\n    : ignorablePatternsRE.test(msg)\n    ? true\n    : undefined\n}\n\nconst BusyErrorRe = /SQLITE_BUSY|database is locked/i\n\nexport function isSqliteBusyError(err: any): boolean {\n  return err.code === \"SQLITE_BUSY\" || null != errorToS(err).match(BusyErrorRe)\n}\n\nexport function isSqliteDisconnectedError(err: any): boolean {\n  return null != errorToS(err).match(/database .+ not open/i)\n}\n\nexport function isSqliteConstraintError(err: any): boolean {\n  return null != errorToS(err).match(/SQLITE_CONSTRAINT|constraint failed/i)\n}\n\nexport function isRetriableError(err: any): Maybe<boolean> {\n  // NOTE: this certainly isn't the most efficient boolean logic.\n\n  // It's structured this way to be the easiest to read and be correct.\n\n  if (err == null) return\n\n  if (isNonRetriableError(err) === true) {\n    return false\n  }\n\n  const b = err?.retriable\n  if (typeof b === \"boolean\") {\n    return b\n  }\n\n  if (\n    errorCode(err) === \"EBUSY\" ||\n    isSqliteBusyError(err) ||\n    isSqliteDisconnectedError(err)\n  ) {\n    return true\n  }\n\n  const str = errorToS(err)\n\n  return str.includes(\"EBUSY\") || str.includes(RetriableErrorFlag)\n    ? true\n    : undefined\n}\n\nexport function isNonRetriableError(err: any): Maybe<boolean> {\n  return isFalse(err.retriable) ||\n    errorToS(err).includes(NonRetriableErrorFlag) ||\n    isSqliteConstraintError(err)\n    ? true\n    : undefined\n}\n\nconst doNotSendPatterns = [\n  // everything here isn't worth sending to Sentry\n  DoNotSendErrorFlag,\n  \"Corrupt JPEG data\", // invalid jpeg\n  \"ENOSPC\", // I can't help with that...\n  \"Invalid data found when processing input\", // from invalid ffmpeg file\n  \"premature end of data segment\", // invalid jpeg\n  \"VipsJpeg\" // invalid jpeg\n]\n\n/**\n * These may be fatal errors (like loss of library lock), and the user will care\n * about them, but we don't need to tell Sentry about them.\n */\nexport function isDoNotSendError(err: any): Maybe<boolean> {\n  const b = err?.doNotSend\n  if (typeof b === \"boolean\") return b\n\n  if (isPleaseSendError(err)) return false\n\n  const msg = errorToS(err).toLowerCase()\n  if (doNotSendPatterns.some(ea => msg.includes(ea))) return true\n  return // we don't know, AND THAT'S OK\n}\n\n/**\n * Does `err` represent a \"fatal\" error?\n */\nexport function isFatalError(err: any): boolean {\n  if (err == null) return false\n  if (isTrue(err.fatal)) return true\n  const s = errorToS(err)\n  return s.includes(FatalErrorFlag)\n    ? true\n    : s.includes(NonFatalErrorFlag)\n    ? false\n    : FatalErrorRe.test(s)\n}\n\nexport function isInternalError(err: any): boolean {\n  return err == null\n    ? false\n    : isTrue(err.internalError) || InternalErrorRe.test(errorToS(err))\n}\n","import { InternalErrorFlag } from \"./ErrorFlags\"\n\nexport class InternalError extends Error {\n  constructor(message: string) {\n    super(message + InternalErrorFlag)\n  }\n}\n","import { blank } from \"../../fe/Blank\"\nimport { lt, sigFigs } from \"../../fe/Number\"\nimport { isEmptyObj } from \"../../fe/Object\"\nimport { isTest } from \"../NodeEnv\"\nimport { isServiceThatAcceptsFatalErrors, isWebService } from \"../ServiceNames\"\nimport { exit } from \"../async/Exit\"\nimport { ee } from \"../event/EventEmitter\"\nimport { Settings } from \"../settings/Settings\"\nimport {\n  StartTs,\n  errorRate,\n  fatalErrorRate,\n  internalErrorRate,\n  lastInternalErrors,\n  logger\n} from \"./Error\"\nimport { InternalErrorFlag } from \"./ErrorFlags\"\nimport { isInternalError } from \"./ErrorTypes\"\nimport { NewWrappedError, toWrappedError } from \"./WrappedError\"\nimport { stack } from \"./stack\"\n\n/**\n * Got an error? Give it here, please!\n *\n * @return true iff fatal\n */\n\nexport function onError(\n  err: string | Error,\n  meta?: unknown | Error | (NewWrappedError & { error?: Error | unknown })\n): boolean {\n  try {\n    if (blank(err) && isEmptyObj(meta)) {\n      logger().warn(\"onError() with no args\", stack())\n      return false\n    }\n    const error = toWrappedError(err, meta)\n\n    const internalError = isInternalError(err)\n    if (internalError) {\n      internalErrorRate.onEvent()\n      lastInternalErrors.push(err)\n    }\n    const fatal = error.fatal === true\n    const ignorable = error.ignorable === true\n\n    if (!fatal && ignorable) {\n      logger().info(\"onError(): (ignorable)\", { error: err })\n      return false\n    }\n\n    errorRate.onEvent()\n    if (fatal) {\n      fatalErrorRate.onEvent()\n      ee().emit(\"fatal\", error)\n    }\n    const event = !fatal || isFatalErrorAllowed() ? \"nonFatal\" : \"fatal\"\n    logger().log(event === \"fatal\" ? \"error\" : \"warn\", \"onError()\", {\n      event,\n      error\n    })\n    if (fatal && !isTest && !isWebService()) {\n      void exit({ reason: error.toString(), status: error.errno ?? 13 })\n    }\n    return fatal\n  } catch {\n    // woof, something's really wrong\n    console.error(\"onError() threw an error!\", { err, meta })\n    return false\n  }\n}\n/**\n * Should this error be considered fatal to this process?\n */\n\nexport function isFatalErrorAllowed(): boolean {\n  const postProbation =\n    Date.now() > StartTs + Settings.probationMs.valueOrDefault\n\n  const lowErrorRate = lt(\n    fatalErrorRate.eventsPerMinute,\n    Settings.fatalErrorRatePerMinute.valueOrDefault\n  )\n\n  const acceptsFatalErrors = isServiceThatAcceptsFatalErrors()\n\n  // The only time a fatal error should not be considered fatal is by the main\n  // service, after passing probation, and the error rate is not too high:\n  return logger().tap({\n    level: \"info\",\n    msg: \"isFatalErrorAllowed()\",\n    result: acceptsFatalErrors && postProbation && lowErrorRate,\n    meta: {\n      acceptsFatalErrors,\n      postProbation,\n      lowErrorRate,\n      fatalErrorRatePerMin: sigFigs(fatalErrorRate.eventsPerMinute, 2),\n      errorRatePerMin: sigFigs(errorRate.eventsPerMinute, 2),\n      fatalErrorRatePerMinuteSetting:\n        Settings.fatalErrorRatePerMinute.valueOrDefault\n    }\n  })\n}\n\n/**\n * These should never happen!\n */\nexport function onInternalError(\n  message: string,\n  cause?: Error | unknown,\n  context?: any\n): boolean {\n  return onError(message + InternalErrorFlag, { cause, ...context })\n}\n","import { uniqBy } from \"../../fe/Array\"\nimport { blank, firstNotBlank, toNotBlank } from \"../../fe/Blank\"\nimport { maybeAnd } from \"../../fe/Boolean\"\nimport {\n  ErrorDelimiter,\n  errorCode,\n  errorErrno,\n  errorName\n} from \"../../fe/Error\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Obj, isEmptyObj, omit } from \"../../fe/Object\"\nimport { toA } from \"../../fe/toA\"\nimport { toErrs } from \"../../fe/toErr\"\nimport { first } from \"../Array\"\nimport { dedupeNeedle, ellipsize, isString, splitUniq } from \"../String\"\nimport { joinErrorMessages, splitErrorMessage } from \"./Error\"\nimport {\n  DoNotSendErrorFlag,\n  ErrorFlag,\n  FatalErrorFlag,\n  IgnorableErrorFlag,\n  NonRetriableErrorFlag,\n  PleaseSendErrorFlag,\n  RetriableErrorFlag,\n  sortErrorFlags\n} from \"./ErrorFlags\"\nimport {\n  extractErrorFlags,\n  isDoNotSendError,\n  isFatalError,\n  isIgnorableError,\n  isRetriableError,\n  stripErrorFlags\n} from \"./ErrorTypes\"\n\nexport function toWrappedError(\n  error: string | Error | unknown,\n  meta?: unknown | Error | (NewWrappedError & { error?: Error | unknown })\n): WrappedError {\n  const args: NewWrappedError =\n    meta == null\n      ? {}\n      : meta instanceof Error\n      ? { cause: meta }\n      : { cause: (meta as any)?.error, ...meta }\n\n  if (error instanceof WrappedError) {\n    // if meta doesn't do anything, don't re-wrap.\n    if (\n      meta == null ||\n      blank(args.message) ||\n      error.message.includes(args.message)\n    ) {\n      return error\n    }\n  }\n  const message = firstNotBlank(\n    isString(error) ? error : undefined,\n    (error as any)?.message,\n    args?.message\n  )\n\n  return new WrappedError(message ?? \"(missing error message)\", args)\n}\n\nexport interface NewWrappedError {\n  name?: string\n  message?: string\n  stack?: string\n  code?: string\n  codes?: string[]\n  errno?: number\n  syscall?: string\n  path?: string // this isn't \"nativePath\" because native Node errors may include a `path` field that we want to capture.\n  cause?: any // because catch(err) is `unknown`\n  causes?: (Error | string)[]\n  retriable?: boolean\n  ignorable?: boolean\n  fatal?: boolean\n  doNotSend?: boolean\n  flags?: ErrorFlag[]\n  meta?: Obj\n}\n\nfunction mkCtx(opts?: NewWrappedError) {\n  if (opts == null) return\n\n  const ctx = omit(\n    opts as any,\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\",\n    \"codes\",\n    \"errno\",\n    \"syscall\",\n    \"path\",\n    \"cause\",\n    \"causes\",\n    \"retriable\",\n    \"ignorable\",\n    \"fatal\",\n    \"doNotSend\",\n    \"flags\"\n  )\n  return isEmptyObj(ctx) ? undefined : stringify(ctx)\n}\n\nfunction mkMessage(message?: string, opts?: NewWrappedError) {\n  let arr = splitErrorMessage(\n    message,\n    opts?.message,\n    opts?.cause,\n    ...(opts?.causes ?? [])\n  )\n  const path = opts?.path\n  if (!blank(path)) {\n    arr = dedupeNeedle(arr, path, \"file\")\n  }\n\n  return joinErrorMessages([\n    arr[0],\n    opts?.code,\n    ...toA(opts?.codes),\n    opts?.syscall,\n    message,\n    ...arr.slice(1)\n  ])\n}\n\nexport class WrappedError extends Error {\n  readonly code?: string\n  readonly codes?: string[]\n  readonly errno?: number\n  readonly syscall?: string\n  readonly path?: string\n  readonly causes: Error[]\n  readonly retriable?: boolean\n  readonly ignorable?: boolean\n  readonly fatal?: boolean\n  readonly doNotSend?: boolean\n  readonly flags: ErrorFlag[]\n\n  /**\n   * No string ellipsis-ing. Flags are shoved to the end and uniq'ed.\n   */\n  static mkMessage(message?: string, opts?: NewWrappedError) {\n    const s = splitErrorMessage(\n      message,\n      opts?.cause,\n      ...toA(opts?.causes),\n      mkCtx(opts)\n    ).join(ErrorDelimiter)\n    return stripErrorFlags(s) + extractErrorFlags(s).join(\"\")\n  }\n\n  constructor(message: string, opts: Partial<NewWrappedError> = {}) {\n    super(message)\n\n    this.causes = uniqBy(\n      toErrs(opts.cause, ...toA(opts.causes)),\n      ea => ea.message\n    )\n\n    this.name = errorName(opts) ?? first(this.causes, errorName) ?? \"Error\"\n\n    this.codes = splitUniq(\n      [opts.code, ...this.causes.map(errorCode)],\n      ErrorDelimiter\n    )\n    this.code = this.codes[0]\n    // unset this.codes if this.code is sufficient:\n    if (this.codes.length <= 1) this.codes = undefined\n\n    this.errno = opts.errno ?? first(this.causes, ea => errorErrno(ea))\n\n    this.syscall =\n      opts.syscall ?? first(this.causes, (ea: any) => toNotBlank(ea[\"syscall\"]))\n\n    this.path =\n      opts.path ?? first(this.causes, (ea: any) => toNotBlank(ea[\"path\"]))\n\n    this.flags = opts?.flags ?? []\n    const arr = [opts, this.flags.join(\"\"), ...this.causes]\n\n    // If any are fatal, we're fatal.\n    this.fatal = opts.fatal ?? arr.some(isFatalError)\n\n    // If any are NOT retriable, we aren't retriable. If none make an assertion,\n    // we shouldn't either.\n    this.retriable = opts.retriable ?? maybeAnd(arr.map(isRetriableError))\n\n    // If any are NOT ignorable, we aren't ignorable. If none make an assertion,\n    // we shouldn't either.\n    this.ignorable = opts.ignorable ?? maybeAnd(arr.map(isIgnorableError))\n\n    // If any say we need to send, we should.\n    this.doNotSend = opts.doNotSend ?? maybeAnd(arr.map(isDoNotSendError))\n\n    this.flags = sortErrorFlags([\n      ...this.flags,\n      this.fatal ? FatalErrorFlag : undefined,\n      this.retriable === true ? RetriableErrorFlag : undefined,\n      this.retriable === false ? NonRetriableErrorFlag : undefined,\n      this.ignorable === true ? IgnorableErrorFlag : undefined,\n      this.doNotSend === false ? PleaseSendErrorFlag : undefined,\n      this.doNotSend === true ? DoNotSendErrorFlag : undefined\n    ])\n\n    // Now that we have all the flags, rebuild the message:\n    this.message =\n      stripErrorFlags(mkMessage(message, this)) + this.flags.join(\"\")\n\n    this.stack = opts.stack ?? first(this.causes, (ea: any) => ea[\"stack\"])\n    if (this.stack == null) Error.captureStackTrace(this)\n  }\n\n  toJSON() {\n    return {\n      _ctor: \"WrappedError\",\n      ...this,\n      message: this.message\n    }\n  }\n\n  static fromJSON(json: any) {\n    return new WrappedError(json.message, json)\n  }\n\n  toString() {\n    return this.message\n  }\n\n  toS(opts?: { maxLen: number; trailingChars: number }): string {\n    return opts == null\n      ? this.message\n      : ellipsize(\n          this.message, // flags are already at the end--just don't\n          opts.maxLen,\n          Math.max(opts.trailingChars, this.flags.length + 1)\n        )\n  }\n}\n","export function stack(): string[] {\n  const e: any = {}\n  Error.captureStackTrace(e, stack)\n  return e.stack.split(/\\n(?:\\s*at\\s+)?/).slice(1)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { Args } from \"../Args\"\nimport { EventName, PhotoStructureEvents } from \"./PhotoStructureEvents\"\nimport { SharedState } from \"./SharedState\"\n\nexport function broadcastEvent_<E extends EventName>(\n  name: E,\n  ...args: Args<PhotoStructureEvents[E]>\n) {\n  return SharedState.instance()?.broadcastEvent_({ name, args })\n}\n\nexport function broadcastPause() {\n  return broadcastEvent_(\"pause\")\n}\n\nexport function broadcastResume() {\n  return broadcastEvent_(\"resume\")\n}\n\nexport const broadcastExit = lazy(() => broadcastEvent_(\"exit\"))\n","import { filterInPlace } from \"../../fe/Array\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { map } from \"../../fe/Maybe\"\nimport { toS } from \"../../fe/toS\"\nimport { Args } from \"../Args\"\nimport { Deferred } from \"../async/Deferred\"\nimport { BoundedList } from \"../BoundedList\"\nimport { isTest } from \"../NodeEnv\"\nimport { OmniEventListener } from \"./OmniEventListener\"\nimport { TypedEventEmitter } from \"./TypedEventEmitter\"\n\nexport interface CapturedEvent<T, E extends keyof T = keyof T> {\n  name: E\n  args: Args<T[E]>\n}\n\nexport class CapturingEventEmitter<T> implements TypedEventEmitter<T> {\n  readonly priorEvents: BoundedList<CapturedEvent<T>>\n  readonly omniListeners: OmniEventListener<T>[] = []\n  readonly #eventDeferreds = new Map<keyof T, Deferred<any>>()\n  readonly #eventDebounceTimers = new Map<keyof T, NodeJS.Timeout>()\n\n  constructor(\n    readonly target: TypedEventEmitter<T>,\n    readonly eventsToRetain = isTest ? 10 : 0\n  ) {\n    this.priorEvents = new BoundedList(eventsToRetain)\n  }\n\n  once<E extends keyof T>(\n    eventName: E,\n    listener: (...args: Args<T[E]>) => void\n  ) {\n    this.target.once(eventName, listener)\n    return this\n  }\n\n  // CAUTION: an omniEventListener that logs may cause a stack overflow on errors!\n\n  addOmniListener(l: OmniEventListener<T>) {\n    this.omniListeners.push(l)\n    return this\n  }\n\n  watchEvent<E extends keyof T>(eventName: E): Deferred<Args<T[E]>> {\n    return getOrSet(\n      this.#eventDeferreds,\n      eventName,\n      () => new Deferred<any>(\"watchEvent(\" + toS(eventName) + \")\")\n    )\n  }\n\n  removeOmniListener(l: OmniEventListener<T>) {\n    return filterInPlace(this.omniListeners, ea => ea !== l)\n  }\n\n  on<E extends keyof T>(eventName: E, listener: (...args: Args<T[E]>) => void) {\n    this.target.on(eventName, listener)\n    return this\n  }\n\n  off<E extends keyof T>(\n    eventName: E,\n    listener: (...args: Args<T[E]>) => void\n  ) {\n    this.target.off(eventName, listener)\n    return this\n  }\n\n  /**\n   * @return `true` if the event had listeners, `false` otherwise.\n   */\n  emit<E extends keyof T>(eventName: E, ...args: Args<T[E]>) {\n    map(this.#eventDebounceTimers.get(eventName), clearTimeout)\n    this.#eventDebounceTimers.delete(eventName)\n    for (const ea of this.omniListeners) {\n      ea(eventName, ...args)\n    }\n    if (this.eventsToRetain > 0) {\n      this.priorEvents.push({\n        name: eventName,\n        args\n      })\n    }\n    const result = this.target.emit(eventName, ...args)\n\n    const d = this.#eventDeferreds.get(eventName)\n    if (d != null) {\n      void d.resolve(args)\n      this.#eventDeferreds.delete(eventName)\n    }\n\n    return result\n  }\n\n  emitDebounced<E extends keyof T>(eventName: E, ...args: Args<T[E]>) {\n    map(this.#eventDebounceTimers.get(eventName), clearTimeout)\n    this.#eventDebounceTimers.set(\n      eventName,\n      setTimeout(() => this.emit(eventName, ...args), 50)\n    )\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  listeners<E extends keyof T>(event: E): Function[] {\n    return this.target.listeners(event)\n  }\n\n  removeAllListeners(eventName?: keyof T): this {\n    this.target.removeAllListeners(eventName)\n    return this\n  }\n}\n","import { cacheDir } from \"../dir/CacheDir\"\nimport { libraryDataDirPosixFile } from \"../dir/LibraryDirs\"\nimport { PosixFile } from \"../fs/PosixFile\"\n\nexport function DefaultSharedStateDir() {\n  return 1 > 2\n    ? PosixFile.forMaybe(cacheDir())?.join(\"shared-state\")\n    : libraryDataDirPosixFile()?.join(\"shared-state\")\n}\n","import { EventEmitter } from \"events\"\nimport { lazy } from \"../../core/Lazy\"\nimport { CapturingEventEmitter } from \"./CapturingEventEmitter\"\nimport {\n  PhotoStructureEmitter,\n  PhotoStructureEvents\n} from \"./PhotoStructureEvents\"\n\nexport function mkEE(\n  eventsToRetain?: number\n): CapturingEventEmitter<PhotoStructureEvents> {\n  const e = new EventEmitter()\n  e.setMaxListeners(70) // because of ee().on(\"clearCache\")\n  return new CapturingEventEmitter(e as PhotoStructureEmitter, eventsToRetain)\n}\n\nexport const ee = lazy(mkEE)\n","import { ee } from \"./EventEmitter\"\n\nlet syncing = false\n\nexport function isSyncing(): boolean {\n  return syncing\n}\n\nexport function setIsSyncing(val: boolean): void {\n  if (syncing !== val) {\n    // no infinite loops\n    syncing = val\n    ee().emit(\"syncing\", val)\n  }\n}\n","import { notBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { keys } from \"../../fe/Object\"\nimport { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\nimport { Args } from \"../Args\"\nimport { LogLevel, LogLevels } from \"../log/LogLevel\"\nimport { ProgressEvt } from \"../progress/ProgressEvt\"\nimport { ForceContext } from \"../settings/ForceContext\"\nimport { isUID } from \"../UID\"\nimport { TypedEventEmitter } from \"./TypedEventEmitter\"\n\n// THIS FILE CANNOT IMPORT ANY CORE CODE (other than SimpleEventEmitter): it's\n// used everywhere!\n\nexport interface UpdateAssetArgs extends ForceContext {\n  assetId: number\n}\nexport interface UpdateAssetFileArgs extends ForceContext {\n  assetFileId: number\n}\nexport interface UpdateAssetTagsArgs extends ForceContext {\n  assetId: number\n}\n\n/*\n * Some events (like \"progress\" or \"timing\") are transient and if there isn't\n * anything to handle it immediately (like in seconds), they should be\n * discarded.\n *\n * Non-transient events need to be handled and then explicitly removed by the\n * process that can service the request.\n */\n\nconst Events = {\n  exit: () => null,\n  updateReadyToInstall: () => null,\n  clearCache: () => null,\n  clearDbCache: () => null,\n  clearToolCache: () => null,\n  error: (_msg: string, _err?: Error | unknown, _ctx?: any) => null,\n  fatal: (_error: Error) => null,\n  nonFatal: (_error: Error) => null,\n  fileChanged: (_nativePath?: Maybe<string>) => null,\n  invalidFile: (_nativePath: string) => null,\n  mountpointsChanged: () => null,\n  reloadLicenses: () => null,\n  pause: () => null,\n  resume: () => null,\n  syncing: (_isSyncing: boolean) => null,\n  progress: (_p: ProgressEvt) => null,\n  updateProgress: () => null,\n  settingsChanged: () => null,\n  showAbout: () => null /* task for Desktop */,\n  taskResult: (_result: TaskResult) => null,\n  timing: (_name: string, _elapsedMs: number) => null,\n  vacuuming: (_isVacuuming: boolean) => null,\n  volumesChanged: () => null\n}\n\nexport type PhotoStructureEvents = typeof Events\nexport const EventNames = strEnum(...keys(Events))\nexport type EventName = StrEnumKeys<typeof EventNames>\n\nconst Tasks = {\n  checkOperations: () => null, // web tells sync to check for new Operations to perform\n  repairAsset: (_arg: UpdateAssetArgs) => null,\n  repairAssetFile: (_arg: UpdateAssetFileArgs) => null,\n  runTagMaintenance: () => null,\n  syncDir: (_arg: { nativePath: string }) => null\n}\n\nexport type PhotoStructureTasks = typeof Tasks\nexport const TaskNames = strEnum(...keys(Tasks))\nexport type TaskName = StrEnumKeys<typeof TaskNames>\n\nexport interface PhotoStructureEvent<E extends EventName> {\n  name: E\n  args: Args<PhotoStructureEvents[E]>\n}\n\nexport interface StoredEvent<E extends EventName>\n  extends PhotoStructureEvent<E> {\n  uid: string\n}\n\nexport function isStoredEvent(o: any): o is StoredEvent<any> {\n  return (\n    typeof o === \"object\" &&\n    isUID(o.uid) &&\n    EventNames.includes(o.name) &&\n    Array.isArray(o.args)\n  )\n}\n\nexport interface StoredTask<T extends TaskName> {\n  uid: string\n  name: T\n  args: Args<PhotoStructureTasks[T]>\n}\n\nexport function isStoredTask(o: any): o is StoredTask<any> {\n  return (\n    typeof o === \"object\" &&\n    isUID(o.uid) &&\n    TaskNames.includes(o.name) &&\n    Array.isArray(o.args)\n  )\n}\n\nexport interface TaskSuccess {\n  uid: string\n  ts: number\n  pid: string\n  result: any\n}\n\nexport interface TaskFailure {\n  uid: string\n  ts: number\n  pid: string\n  error: string\n}\n\nexport type TaskResult = TaskSuccess | TaskFailure\n\nexport function isTaskResult(o: any): o is TaskResult {\n  return (\n    (typeof o === \"object\" && isUID(o.uid) && notBlank(o.result)) ||\n    notBlank(o.error)\n  )\n}\n\nexport type PhotoStructureEmitter = TypedEventEmitter<PhotoStructureEvents>\n\nexport const EventNameToLevel: Record<EventName, LogLevel> = Object.freeze({\n  exit: LogLevels.warn,\n  updateReadyToInstall: LogLevels.warn,\n  clearCache: LogLevels.trace,\n  clearDbCache: LogLevels.trace,\n  clearToolCache: LogLevels.trace,\n  error: LogLevels.error,\n  fatal: LogLevels.fatal,\n  fileChanged: LogLevels.trace,\n  invalidFile: LogLevels.warn,\n  mountpointsChanged: LogLevels.info,\n  nonFatal: LogLevels.warn,\n  pause: LogLevels.info,\n  progress: LogLevels.info,\n  updateProgress: LogLevels.info,\n  reloadLicenses: LogLevels.info,\n  resume: LogLevels.info,\n  settingsChanged: LogLevels.info,\n  showAbout: LogLevels.info,\n  syncing: LogLevels.info,\n  taskResult: LogLevels.info,\n  timing: LogLevels.trace,\n  vacuuming: LogLevels.info,\n  volumesChanged: LogLevels.info\n})\n\nexport const TaskNameToLevel: Record<TaskName, LogLevel> = {\n  checkOperations: LogLevels.info,\n  repairAsset: LogLevels.info,\n  repairAssetFile: LogLevels.info,\n  runTagMaintenance: LogLevels.info,\n  syncDir: LogLevels.info\n}\n","import { Event } from \"@parcel/watcher\"\nimport { pidExists } from \"batch-cluster\"\nimport { Dirent } from \"fs\"\nimport { sep } from \"path\"\nimport { pid } from \"process\"\nimport { clearInterval, setInterval } from \"timers\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact, isEmpty, isNotEmpty, uniqByLast } from \"../../fe/Array\"\nimport { sortBy, sortUniqBy } from \"../../fe/ArraySort\"\nimport { isBoolean } from \"../../fe/Boolean\"\nimport { hourMs, minuteMs, secondMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { eql } from \"../../fe/Eql\"\nimport { shortStack } from \"../../fe/Error\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { parseJSON, stringify } from \"../../fe/JSON\"\nimport { deleteIf } from \"../../fe/Map\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt, isNumber } from \"../../fe/Number\"\nimport { pick } from \"../../fe/Object\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { toA } from \"../../fe/toA\"\nimport { Args } from \"../Args\"\nimport { mkLogger } from \"../Logger\"\nimport { mapGt0 } from \"../Number\"\nimport {\n  isSyncService,\n  isWebService,\n  isWorkerService,\n  processName\n} from \"../ServiceNames\"\nimport { StartTs } from \"../StartTs\"\nimport { TTLMap } from \"../TTLMap\"\nimport { TTLSet } from \"../TTLSet\"\nimport { tsFromUid, uid } from \"../UID\"\nimport { Deferred } from \"../async/Deferred\"\nimport { EndableRanks, end } from \"../async/Endable\"\nimport { EndableWrapper } from \"../async/EndableWrapper\"\nimport { oneAtATime } from \"../async/OneAtATime\"\nimport { untilTrue } from \"../async/until\"\nimport { isRecentMs } from \"../date/Date\"\nimport { errorToS } from \"../error/Error\"\nimport { InternalErrorFlag } from \"../error/ErrorFlags\"\nimport { DirWatcher } from \"../fs/DirWatcher\"\nimport { isJsonExt } from \"../fs/FileExt\"\nimport { withLock_ } from \"../fs/FsLock\"\nimport { isPsLockFileOrDir } from \"../fs/FsLockDir\"\nimport { nativePathsEqlSync } from \"../fs/NativePathsEql\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { readFileMaybe } from \"../fs/ReadFile\"\nimport { SimpleFileOrString, basename, toNativePath_ } from \"../fs/SimpleFile\"\nimport { isMtimeRecent } from \"../fs/Stat\"\nimport { isWip } from \"../fs/WIP\"\nimport { Settings } from \"../settings/Settings\"\nimport { isPaused, pause, resume } from \"../work/IsPaused\"\nimport { ee } from \"./EventEmitter\"\nimport { isSyncing, setIsSyncing } from \"./IsSyncing\"\nimport {\n  EventName,\n  PhotoStructureEvents,\n  PhotoStructureTasks,\n  StoredEvent,\n  StoredTask,\n  TaskFailure,\n  TaskName,\n  TaskResult,\n  isStoredEvent,\n  isStoredTask,\n  isTaskResult\n} from \"./PhotoStructureEvents\"\nimport { TaskProcessor, taskProcessors } from \"./TaskProcessor\"\n\nconst logger = lazy(() => mkLogger(\"event.SharedState\"))\n\n// See worker/WorkRequest\n\nexport interface SharedStateJson {\n  pid: number\n  syncing?: boolean // < only set by SyncService processes\n  paused: boolean\n  // task results are stored as events. Events are only retained for a couple minutes:\n  events: StoredEvent<any>[]\n  // tasks are retained until there is a taskResult StoredEvent for it's uid, or it expires:\n  tasks: StoredTask<any>[]\n  // only set if there wasn't any shared state.\n  default?: true\n}\n\nexport function isSharedStateJson(o: any): o is SharedStateJson {\n  return (\n    o != null &&\n    typeof o === \"object\" &&\n    isNumber(o.pid) &&\n    isBoolean(o.paused) &&\n    Array.isArray(o.events) &&\n    Array.isArray(o.tasks)\n  )\n}\n\nexport const EventTimeoutMs = minuteMs\n\nfunction isStateFile(ea: SimpleFileOrString) {\n  return isJsonExt(ea) && !isWip(ea)\n}\n\nexport function isSharedStateFileOrDir(f: SimpleFileOrString | Dirent) {\n  return isPsLockFileOrDir(f) || isJsonExt(f) || isWip(f)\n}\n\nexport function isFreshEvent(evt: StoredEvent<any>): boolean {\n  const ts = tsFromUid(evt?.uid)\n  const fresh = isStoredEvent(evt) && isRecentMs(ts, EventTimeoutMs)\n  if (fresh && evt.name === \"exit\") {\n    // exit events should be disregarded if they happened before we started:\n    return gt(ts, StartTs)\n  } else {\n    return fresh\n  }\n}\n\nexport function dedupeStoredEvents(\n  arr: Maybe<StoredEvent<any>>[]\n): StoredEvent<any>[] {\n  const sorted = sortBy(compact(arr).filter(isFreshEvent), ea => ea.uid)\n\n  return uniqByLast(sorted, ea => stringify({ name: ea.name, args: ea.args }))\n}\n\n/**\n * Handles watching and broadcasting changes in shared state.\n *\n * This class replaces v1.x's RPC stuff.\n *\n * 1. Each process writes to it's own shared state file, living in $configDir/shared-state/$pid.json (no locking!)\n * 2. Each process is in charge of removing its own broadcast events after a minute.\n * 3. If a process handles a task, it should broadcast a taskResult.\n * 4. The process that submitted the task will remove the task when it sees the taskResult event.\n */\nexport class SharedState extends EndableWrapper {\n  readonly jsonFile: PosixFile\n  #pollInterval: Maybe<NodeJS.Timeout>\n  readonly #jsoncontent2event = new TTLMap<string, StoredEvent<any>>(\n    EventTimeoutMs\n  )\n  // readonly #myTasks = new TTLMap<string, StoredTask<any>>(\n  //   Settings.sharedStateTaskTimeoutMs.valueOrDefault\n  // )\n  readonly handledEventUids = new TTLSet<string>(\n    Settings.sharedStateTaskTimeoutMs.valueOrDefault\n  )\n  readonly handledTaskUids = new TTLSet<string>(\n    Settings.sharedStateTaskTimeoutMs.valueOrDefault\n  )\n  readonly #uid2pendingTasks = new TTLMap<\n    string,\n    Deferred<TaskResult, StoredTask<any>>\n  >(Settings.sharedStateTaskTimeoutMs.valueOrDefault)\n\n  static #watchAndValidate = defer(() => {\n    Settings.libraryDir.watchLater(this.#validate)\n    Settings.cacheDir.watchLater(this.#validate)\n    Settings.sharedStateDir.watchLater(this.#validate)\n  })\n\n  static #validate = async () => {\n    const expectedDir = Settings.sharedStateDir.valueOrDefault\n    if (!nativePathsEqlSync(expectedDir, this.instance()?.dir)) {\n      logger().warn(\"SharedState has changed. Restarting...\")\n      await end(this.instance())\n      this.instance.refresh()\n    }\n  }\n\n  static readonly instance = lazy(() => {\n    if (isWorkerService()) {\n      logger().warn(\n        \"SharedState.instance() is not supported within worker services.\",\n        shortStack()\n      )\n      return\n    }\n    this.#watchAndValidate()\n    const result = map(\n      Settings.sharedStateDir.valueOrDefault,\n      ea => new SharedState(PosixFile.for(ea))\n    )\n    if (result != null) {\n      Settings.sharedStateTaskTimeoutMs.watchLater(ea => {\n        // result.#myTasks.ttlMs = ea\n        result.handledEventUids.ttlMs = ea\n        result.handledTaskUids.ttlMs = ea\n        result.#uid2pendingTasks.ttlMs = ea\n      })\n    }\n    return result\n  })\n\n  constructor(\n    readonly dir: PosixFile,\n    readonly id: string = String(pid),\n    readonly eventEmitter = ee(),\n    readonly processors: TaskProcessor[] = taskProcessors\n  ) {\n    super(\n      \"event.SharedState(\" + dir + \")#\" + id,\n      () => this.#onEnd(),\n      EndableRanks.first,\n      Settings.sharedStateTaskTimeoutMs.valueOrDefault\n    )\n    this.jsonFile = dir.join(id + \".json\")\n\n    mapGt0(\n      Settings.sharedStatePollMs.valueOrDefault,\n      ms => (this.#pollInterval = setInterval(() => this.read(), ms))\n    )\n    void this.setup()\n  }\n\n  #onDirChange(_err: Error | null, events: Event[]) {\n    const files = toA(events)\n      .filter(\n        ea =>\n          ea.type !== \"delete\" && !ea.path.endsWith(sep + this.jsonFile.base)\n      )\n      .map(ea => ea.path)\n    this.logger.debug(\"#onDirChange()\", { files, _err, events })\n    void this.read({ files })\n  }\n\n  async #onEnd() {\n    const logCurrentState = lazy(() => {\n      this.logger.warn(\"#onEnd(): current state\", this.currentState())\n    }, 10 * secondMs)\n\n    await untilTrue(\n      () => {\n        this.vacuum()\n        const done = this.#uid2pendingTasks.size === 0\n        if (!done) logCurrentState()\n        return done\n      },\n      {\n        timeoutMs: Settings.sharedStateTaskTimeoutMs.valueOrDefault,\n        intervalMs: secondMs\n      }\n    )\n\n    // WE DON'T UNLINK HERE--we want to leave the file around so our last\n    // events get picked up by our siblings.\n    map(this.#pollInterval, clearInterval)\n    this.#pollInterval = undefined\n  }\n\n  readonly setup = lazy(async () => {\n    this.#uid2pendingTasks.on(\"expire\", (k, v) => {\n      this.logger.warn(\n        \"failed to resolve task before timeout (see sharedStateTaskTimeoutMs)\",\n        {\n          task: v.payload,\n          sharedStateTaskTimeoutMs:\n            Settings.sharedStateTaskTimeoutMs.valueOrDefault\n        }\n      )\n      const err: TaskFailure = {\n        uid: k,\n        ts: Date.now(),\n        pid: processName(),\n        error: \"timeout\"\n      }\n      void v.resolve(err)\n    })\n    await this.read({ setup: true })\n    await DirWatcher.for(\n      this.dir,\n      (err, events) => this.#onDirChange(err, events),\n      EndableRanks.first\n    )\n  })\n\n  async read({\n    files,\n    setup\n  }: { files?: SimpleFileOrString[]; setup?: boolean } = {}) {\n    if (isEmpty(files)) {\n      files = toA(\n        await this.jsonFile.clearThisAndParent().siblings(ea => isStateFile(ea))\n      )\n    }\n    const arr = []\n\n    for (const file of files) {\n      if (\n        isStateFile(file) &&\n        basename(file) !== this.jsonFile.base &&\n        (await isMtimeRecent(toNativePath_(file), hourMs))\n      ) {\n        const bytes = await readFileMaybe(toNativePath_(file))\n        const json = parseJSON<SharedStateJson>(bytes)\n        if (json != null) arr.push(json)\n      }\n    }\n\n    if (setup === true) {\n      // bootstrap paused state:\n      pause(arr.some(ea => ea?.paused === true))\n    }\n\n    this.logger.debug(\"read()\", { arr })\n\n    let updated = false\n\n    // even if a shared state JSON only has 1 field, still parse it:\n    if (isEmpty(arr)) {\n      return\n    }\n\n    const events = dedupeStoredEvents(flatten(arr.map(ea => ea.events)))\n\n    this.logger.debug(\"read() events\", { arr, events })\n\n    for (const event of events) {\n      // don't re-do tasks that have been started or finished:\n      if (event.name === \"taskResult\" || event.name === \"taskStarted\")\n        this.handledTaskUids.add(event.uid)\n\n      // process the remote event:\n      updated ||= this.#handleRemoteEvent(event)\n    }\n\n    if (updated) await this.save()\n\n    const unfilteredTasks = flatten(arr.map(ea => ea.tasks))\n\n    const taskExpireTs = Date.now() - Settings.taskTimeoutMs.valueOrDefault\n    const tasks = sortUniqBy(\n      unfilteredTasks.filter(\n        ea =>\n          isStoredTask(ea) &&\n          !this.handledTaskUids.has(ea.uid) &&\n          gt(tsFromUid(ea?.uid), taskExpireTs)\n      ),\n      ea => ea.uid\n    )\n\n    if (isNotEmpty(tasks)) {\n      this.logger.info(\"read()\", { tasks })\n    }\n\n    // don't run these tasks again:\n    this.handledTaskUids.addAll(tasks.map(ea => ea.uid))\n\n    for (const task of tasks) {\n      // don't wait for each task: get each running ASAP. This may edit\n      // the JSON if we handle a task.\n\n      // these are possibly contested tasks, so we need an fs lock.\n      void this.#handleTask({\n        task,\n        sendEvents: true,\n        withFsLock: true\n      })\n    }\n\n    this.#updateSyncState(arr)\n\n    return\n  }\n\n  vacuum() {\n    deleteIf(this.#uid2pendingTasks, (_, v) => v.isSettled)\n  }\n\n  currentState(): SharedStateJson {\n    this.vacuum()\n    return {\n      pid: process.pid,\n      paused: isPaused(),\n      syncing: isSyncService() ? isSyncing() : undefined,\n      events: [...this.#jsoncontent2event.values()],\n      tasks: [...this.#uid2pendingTasks.values()].map(ea => ea.payload!)\n    }\n  }\n\n  async maybeSave() {\n    const state = this.currentState()\n    const prior = await this.jsonFile.readJson()\n    if (!eql(state, prior)) {\n      await this.save()\n    }\n  }\n\n  readonly save = oneAtATime({\n    fn: () => {\n      const state = this.currentState()\n      this.logger.info(\"save()\", { state })\n      return this.jsonFile.writeJson_(state)\n    }\n  })\n\n  async broadcast<E extends EventName>(\n    name: E,\n    ...args: Args<PhotoStructureEvents[E]>\n  ) {\n    return this.broadcastEvent_({ name, args })\n  }\n\n  async broadcastEvent_<E extends EventName>(evt: {\n    uid?: string\n    name: E\n    args: Args<PhotoStructureEvents[E]>\n  }): PromiseMaybe<StoredEvent<E>> {\n    const event = { ...evt, uid: evt.uid ?? uid() }\n    this.logger.info(\"addEvent_()\", { event })\n    const key = stringify(pick(event, \"name\", \"args\"))\n    // newer events should override prior:\n    this.#jsoncontent2event.set(key, event)\n    this.handledEventUids.add(event.uid)\n    this.eventEmitter.emit(event.name, ...event.args)\n    await this.save()\n    return event\n  }\n\n  #updateSyncState(arr: SharedStateJson[]) {\n    // only the webservice cares about sync state:\n    if (!isWebService()) return\n\n    const syncingPids = arr.filter(ea => ea.syncing).map(ea => ea.pid)\n\n    // we're only syncing if the process is still alive:\n    for (const syncingPid of syncingPids) {\n      if (pidExists(syncingPid)) {\n        this.logger.debug(\"#updateSyncState(): syncing\", { syncingPid })\n        setIsSyncing(true)\n        return\n      }\n    }\n\n    this.logger.debug(\"#updateSyncState(): no syncing states\", { syncingPids })\n\n    setIsSyncing(false)\n  }\n\n  /**\n   * @return true iff this should re-save\n   */\n  #handleRemoteEvent(event: StoredEvent<any>): boolean {\n    if (!isFreshEvent(event)) {\n      this.logger.warn(\"#handleRemoteEvent(): ignoring stale event\", { event })\n      return false\n    }\n\n    // don't double-process any events:\n    if (this.handledEventUids.has(event.uid)) return false\n    this.handledEventUids.add(event.uid)\n\n    this.logger.info(\"#handleRemoteEvent()\", event)\n    if (event.name === \"resume\") {\n      resume()\n    } else if (event.name === \"pause\") {\n      pause()\n    } else if (event.name === \"taskResult\") {\n      const taskResult: TaskResult = event.args[0] as any\n      if (!isTaskResult(taskResult)) {\n        this.logger.warn(\"Invalid task result\", { event })\n        return true // \"handled\"?\n      }\n      const d = this.#uid2pendingTasks.get(taskResult.uid)\n      if (d != null) {\n        this.logger.info(\"Received a task result for one of my tasks!\", {\n          event\n        })\n        void d.resolve(taskResult)\n      }\n      return true\n    } else {\n      this.eventEmitter.emit(event.name, ...event.args)\n    }\n    return false\n  }\n\n  canHandleTaskLocally(task: StoredTask<any>): boolean {\n    return this.processors.some(ea => ea.accept(task))\n  }\n\n  async #handleTask({\n    task,\n    sendEvents,\n    withFsLock\n  }: {\n    task: StoredTask<any>\n    sendEvents: boolean\n    withFsLock: boolean\n  }): PromiseMaybe<TaskResult> {\n    const processors = this.processors.filter(ea => ea.accept(task))\n    if (processors.length === 0) {\n      this.logger.info(\"#handleTask(): no local task processor\", { task })\n      return\n    }\n\n    if (withFsLock) {\n      return withLock_(\n        {\n          name: \"task-\" + task.name + \"-\" + task.uid,\n          file: this.dir.join(task.uid),\n          timeoutMs: Settings.sharedStateTaskTimeoutMs.valueOrDefault,\n          noopIfContested: true // < don't run a task multiple times\n        },\n        () => this.#handleTask({ task, sendEvents, withFsLock: false })\n      )\n    }\n\n    let result: TaskResult\n\n    if (processors.length > 1) {\n      this.logger.warn(\n        \"#handleTask(): multiple local task processors for \" + task.name,\n        { processors: processors.map(ea => ea.name) }\n      )\n      // first one will get a crack at it...\n    }\n\n    for (const ea of processors) {\n      try {\n        result = {\n          uid: task.uid,\n          ts: Date.now(),\n          pid: processName() + \"-\" + ea.name,\n          result: await thenOrTimeoutError(\n            ea.apply(task),\n            Settings.sharedStateTaskTimeoutMs.valueOrDefault\n          )\n        }\n        this.logger.info(\"#handleTask(): processor success\", {\n          processor: ea.name,\n          result,\n          task\n        })\n        break\n      } catch (error) {\n        this.logger.warn(\"#handleTask(): processor failed\", {\n          processor: ea.name,\n          error\n        })\n        result = {\n          uid: task.uid,\n          ts: Date.now(),\n          pid: processName() + \"-\" + ea.name,\n          error: errorToS(error)\n        }\n      }\n    }\n    if (result! == null) {\n      this.logger.warn(\"#handleTask(): null result\" + InternalErrorFlag, {\n        task\n      })\n      result = {\n        uid: task.uid,\n        ts: Date.now(),\n        pid: processName() + \"-error\",\n        error: \"null result\" + InternalErrorFlag\n      }\n    }\n\n    // resolve the task before broadcasting event to only save once:\n\n    void this.#uid2pendingTasks.get(task.uid)?.resolve(result)\n\n    if (sendEvents) {\n      this.logger.warn(\"#handleTask(): broadcasting result\", { task, result })\n      await this.broadcastEvent_({ name: \"taskResult\", args: [result] })\n    } else {\n      this.logger.warn(\"#handleTask(): NOT broadcasting result\", {\n        task,\n        result\n      })\n    }\n\n    return result\n  }\n\n  /**\n   * Process the given task, either locally, or request another process to\n   * handle it.\n   */\n  submitTask_<T extends TaskName>(\n    name: T,\n    ...args: Args<PhotoStructureTasks[T]>\n  ): Deferred<TaskResult, StoredTask<any>> {\n    this.logger.info(\"submitTask_()\", { name, args })\n\n    const task: StoredTask<any> = { uid: uid(), name, args }\n\n    // We always return a Deferred just to make the API consistent.\n    const d = new Deferred<TaskResult, StoredTask<any>>(name, {\n      payload: task\n    }).setTimeout(Settings.sharedStateTaskTimeoutMs.valueOrDefault)\n\n    // if we can handle the task locally, we don't need to do any bookkeeping--just run it and return.\n    if (this.canHandleTaskLocally(task)) {\n      return d.observe(\n        this.#handleTask({\n          task,\n          withFsLock: false, // we're the only one that's seen this task so far\n          sendEvents: false\n        }) as any\n      ) // we know it will be defined\n    }\n\n    // Dang. Hope there's someone out there that can do this!\n\n    // broadcast failure:\n    void d.catch(err => {\n      void this.broadcastEvent_({\n        name: \"taskResult\",\n        args: [\n          {\n            uid: task.uid,\n            ts: Date.now(),\n            pid: processName() + \"-error\",\n            error: \"uncaught rejection: \" + errorToS(err) + InternalErrorFlag\n          }\n        ]\n      })\n    })\n\n    this.#uid2pendingTasks.set(task.uid, d)\n\n    // this will add the task to our shared-state.json, which the other\n    // processes will see:\n    void this.save()\n    return d\n  }\n}\n\nexport function submitTask_<T extends TaskName>(\n  name: T,\n  ...args: Args<PhotoStructureTasks[T]>\n): Maybe<Deferred<TaskResult, StoredTask<any>>> {\n  return SharedState.instance()?.submitTask_(name, ...args)\n}\n\nexport async function clearSharedStates() {\n  const prior = SharedState.instance.clear()\n  await prior?.end()\n  const root =\n    prior?.dir ??\n    map(Settings.sharedStateDir.valueOrDefault, ea => PosixFile.for(ea))\n  await root?.visitDescendants(ea => {\n    return isSharedStateFileOrDir(ea)\n      ? ea.isDirectorySync()\n        ? ea.rmdir()\n        : ea.unlink()\n      : undefined\n  })\n}\n","import { isTest } from \"../NodeEnv\"\nimport { StoredTask } from \"./PhotoStructureEvents\"\n\nexport interface TaskProcessor {\n  name: string\n\n  /**\n   * Can this processor handle this task?\n   */\n  accept(task: StoredTask<any>): boolean\n\n  /**\n   * @return null if the task was not handled, and a non-blank string iff the\n   * listener \"handled\" the task\n   * @throw if the error task was attempted but failed\n   */\n  apply(task: StoredTask<any>): Promise<string>\n}\n\nexport const taskProcessors: TaskProcessor[] = []\n// outside of the instance, so it can be set up before we read shared state:\n\nexport function addTaskProcessor(processor: TaskProcessor) {\n  taskProcessors.push(processor)\n}\n\nexport function clearTaskProcessors() {\n  if (isTest) taskProcessors.length = 0\n}\n","import { later } from \"../../fe/Delay\"\nimport { ee } from \"./EventEmitter\"\n\nlet updateReadyToInstall = false\n\nlater(() =>\n  ee().on(\"updateReadyToInstall\", () => (updateReadyToInstall = true))\n)\n\nexport function isUpdateReadyToInstall() {\n  return updateReadyToInstall\n}\n","import fs from \"fs\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { selfAndAncestorG } from \"../fs/Ancestors\"\nimport { statMaybe } from \"../fs/Stat\"\nimport { isWin } from \"../platform/Platform\"\n\nconst getUid = lazy(() => process.geteuid?.())\nconst getGids = lazy(() => process.getgroups?.())\n\nexport function canAccessSync(nativePath: Maybe<string>, mode?: number) {\n  try {\n    if (blank(nativePath)) return false\n    fs.accessSync(nativePath, mode)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport function isStatRWX(\n  stat: Maybe<fs.Stats>,\n  nativePath: Maybe<string>\n): boolean {\n  return isWin\n    ? canAccessSync(nativePath, fs.constants.R_OK | fs.constants.W_OK)\n    : access({ stat, r: true, w: true, x: true })\n}\n\nexport function isStatRX(\n  stat: Maybe<fs.Stats>,\n  nativePath: Maybe<string>\n): boolean {\n  return isWin\n    ? canAccessSync(nativePath, fs.constants.R_OK)\n    : access({ stat, r: true, x: true })\n}\n\nexport async function canRWXFirstExistingAncestor(\n  nativePath: string\n): Promise<boolean> {\n  let foundNearest = false\n  // We need to be able to rX all the way up to the root:\n  for (const dir of selfAndAncestorG(nativePath)) {\n    const s = await statMaybe(dir)\n    if (s != null) {\n      if (!s.isDirectory()) {\n        return false\n      }\n      if (!foundNearest) {\n        foundNearest = true\n        if (!isStatRWX(s, nativePath)) {\n          return false\n        }\n      } else {\n        if (!isStatRX(s, nativePath)) {\n          return false\n        }\n      }\n    }\n  }\n  return true\n}\n\nexport function access({\n  stat,\n  r = false,\n  w = false,\n  x = false,\n  processUid,\n  processGid\n}: {\n  stat: Maybe<fs.Stats>\n  r?: boolean\n  w?: boolean\n  x?: boolean\n  processUid?: number\n  processGid?: number\n}): boolean {\n  if (stat == null) return false\n  const uid = processUid ?? getUid()\n  const gids = processGid != null ? [processGid] : getGids() ?? []\n\n  const isRoot = uid === 0\n  const isUser = isRoot || stat.uid === uid\n  const isGroup = isRoot || gids.includes(stat.gid)\n\n  if (r) {\n    const mask = (isUser ? 0o400 : 0) | (isGroup ? 0o040 : 0) | 0o004\n    if ((mask & stat.mode) === 0) return false\n  }\n\n  if (w) {\n    const mask = (isUser ? 0o200 : 0) | (isGroup ? 0o020 : 0) | 0o002\n    if ((mask & stat.mode) === 0) return false\n  }\n\n  // windows doesn't care about x: it happily executes files with no execute\n  // bit as long as the extension is .exe/.bat/...\n  if (x && !isWin) {\n    const mask = (isUser ? 0o100 : 0) | (isGroup ? 0o010 : 0) | 0o001\n    if ((mask & stat.mode) === 0) return false\n  }\n\n  return true\n}\n","import _path from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { equalsIgnoreCase } from \"../String\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { isLinux } from \"../platform/Platform\"\nimport { FileCache } from \"./FileCache\"\nimport { logger, parseNativePath, pathIsRoot, resolve } from \"./Path\"\nimport { readdir_ } from \"./Readdir\"\n\nexport async function actualPath(...nativePath: string[]): Promise<string> {\n  try {\n    return await actualPath_(...nativePath)\n  } catch (error) {\n    logger().warn(\"actualPath() failed, reverting to resolve()\", {\n      nativePath,\n      error\n    })\n    return resolve(...nativePath)\n  }\n}\nconst actualPathCache = lazy(\n  () => new FileCache<string>({ name: \"fs.Path.actualPathCache\" })\n)\n/**\n * `node:fs.resolve()`, `node:fs.normalize()`, and `node:fs.realpath()` don't\n * actually return the _actual_ correctly-cased filename for case-insensitive\n * filesystems on Windows and macOS.\n *\n * This method does that.\n */\n\nexport async function actualPath_(...nativePath: string[]): Promise<string> {\n  // our resolve() upcases drive letters:\n  const resolved = resolve(...nativePath)\n  // No need to check on Linux (filesystems are case-sensitive), or for root\n  // paths (which would cause an infinite loop)\n  if (isLinux || pathIsRoot(resolved)) {\n    return resolved\n  }\n\n  return actualPathCache().getOrSetAsync(resolved, async () => {\n    const p = parseNativePath(resolve(...nativePath))\n    const actualDir = await actualPath_(p.dir)\n    for (const ea of await readdir_(actualDir)) {\n      // equalsIgnoreCase does unicode normalization!\n      if (equalsIgnoreCase(ea.basename, p.base)) {\n        return _path.join(actualDir, ea.basename)\n      }\n    }\n    throw new WrappedError(resolved + \" not found\", {\n      code: \"ENOENT\",\n      path: resolved\n    })\n  })\n}\n","import { readdirSync } from \"fs\"\nimport { dirname } from \"path\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\n\n/**\n * @return nativePath to all ancestors of a given path, in order from nearest\n * to farthest.\n */\nexport function ancestors(path: string): string[] {\n  return [...ancestorG(path)]\n}\n\nexport function* ancestorG(path: string): Generator<string> {\n  while (path !== dirname(path)) {\n    path = dirname(path)\n    yield path\n  }\n  return\n}\n\nexport function* selfAndAncestorG(path: string): Generator<string> {\n  yield path\n  yield* ancestorG(path)\n}\n\nexport function childrenSync(path: string): string[] {\n  try {\n    return readdirSync(path)\n  } catch (err) {\n    return []\n  }\n}\nexport function hasChildrenSync(path: string, childNames: string[]): boolean {\n  const actual = childrenSync(path)\n  return childNames.every(ea => actual.includes(ea))\n}\n\nexport function ancestorWithChildren(\n  path: string,\n  childNames: string[]\n): Maybe<string> {\n  return ancestors(path).find(ea => hasChildrenSync(ea, childNames))\n}\n","import fs, { readFileSync, watch, WatchEventType } from \"fs\"\nimport * as _fse from \"fs-extra\"\nimport { readFile } from \"fs/promises\"\nimport _path from \"path\"\nimport process from \"process\"\nimport stream from \"stream\"\nimport { pipeline } from \"stream/promises\"\nimport util from \"util\"\nimport zlib from \"zlib\"\nimport { lazy } from \"../../core/Lazy\"\nimport {\n  compact,\n  filterInPlaceAsync,\n  includesAll,\n  isEmpty,\n  isNotEmpty\n} from \"../../fe/Array\"\nimport { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { blank } from \"../../fe/Blank\"\nimport { minuteMs, secondMs, unixtime } from \"../../fe/Date\"\nimport { eql } from \"../../fe/Eql\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { stringify } from \"../../fe/JSON\"\nimport { denull, map, map3, mapOr, orElse } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { closeTo, gt0 } from \"../../fe/Number\"\nimport { omit } from \"../../fe/Object\"\nimport { opt } from \"../../fe/Opt\"\nimport { pad2 } from \"../../fe/Pad\"\nimport { newlineRe } from \"../../fe/String\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { leastBy, leastIndex, max } from \"../Array\"\nimport { Deferred } from \"../async/Deferred\"\nimport {\n  thenDefined,\n  thenMap,\n  thenMap2Or,\n  thenMapOr,\n  thenNot\n} from \"../async/Promise\"\nimport { time, timeSync } from \"../async/PromiseTimer\"\nimport { untilTrue } from \"../async/until\"\nimport { bufferToString } from \"../Buffers\"\nimport { isRetriableError } from \"../error/ErrorTypes\"\nimport { ee } from \"../event/EventEmitter\"\nimport { parseJSON } from \"../JSON\"\nimport { LogLevel } from \"../log/LogLevel\"\nimport { mkLogger } from \"../Logger\"\nimport { min } from \"../math/Vector\"\nimport { isLinux, isWin } from \"../platform/Platform\"\nimport { Predicate } from \"../predicates/Predicates\"\nimport { SyncPredicate } from \"../predicates/SyncPredicates\"\nimport { equalsIgnoreCase, stripSuffix } from \"../String\"\nimport { diceCoeff, hamming } from \"../StringSimilarity\"\nimport { bname } from \"../tags/Bname\"\nimport { userDesc } from \"../UserInfo\"\nimport { access, isStatRWX } from \"./Access\"\nimport { actualPath } from \"./ActualPath\"\nimport { splitLines } from \"./CRLF\"\nimport { DirectoryEntry, StatDirent } from \"./DirectoryEntry\"\nimport {\n  ensureNewNativePath_,\n  ensureNewNativePathSync_,\n  EnsureNewOptions\n} from \"./EnsureNew\"\nimport { CacheableFile, FileCache } from \"./FileCache\"\nimport { fileSha_, fileShaMeta_ } from \"./Hash\"\nimport { JsonWriteOptions } from \"./JsonWriteOptions\"\nimport { LineReader } from \"./LineReader\"\nimport {\n  containedByNativePath,\n  ellipsizePath,\n  isAbsolute,\n  isHiddenBasename,\n  isUNC,\n  mkdirp_,\n  mkdirpSync_,\n  parseNativePath,\n  pathDepth,\n  pathIsRoot,\n  posixPathFrom,\n  resolve,\n  splitNativePath\n} from \"./Path\"\nimport { native2posix } from \"./PosixNative\"\nimport { ProjectPath } from \"./ProjectPath\"\nimport { readdir_ } from \"./Readdir\"\nimport { SimpleDirent } from \"./SimpleDirent\"\nimport {\n  isSimpleFile,\n  SimpleFile,\n  SimpleFileOrString,\n  toNativePath_\n} from \"./SimpleFile\"\nimport { stat_, statMaybe, statTimes } from \"./Stat\"\nimport { statSync } from \"./StatSync\"\nimport { onDataChunked } from \"./StreamChunker\"\nimport { touch_ } from \"./Touch\"\nimport { writeFile_, writeText_, writeTextSync_ } from \"./WriteFile\"\nimport { zCopyToBuffer_ } from \"./zcat\"\n\nexport function isBaseFile(object: any): object is BaseFile {\n  return isSimpleFile(object) && object instanceof BaseFile\n}\n\nexport interface FileProgress {\n  path: string\n  /**\n   * operation (like \"sha\" or \"cp\")\n   */\n  op: string\n  /**\n   * percent complete\n   */\n  pct: number\n}\nconst cache = lazy(() => new FileCache<BaseFile>({ name: \"fs.BaseFile\" }))\n\nexport type UtimesArgs = Omit<\n  Parameters<typeof touch_>[0],\n  \"file\" | \"ensureFile\"\n>\n\nexport type RefreshArgs = {\n  refresh?: boolean\n  logLevel?: LogLevel\n}\n\n/**\n * Extracted from PosixFile, this superclass is used by the FileLogger.\n *\n * It must not depend on core code that also requires a Logger.\n */\nexport class BaseFile implements SimpleFile, CacheableFile {\n  protected readonly bflog = lazy(() =>\n    mkLogger(\"fs.BaseFile(\" + this.nativePath + \")\")\n  )\n\n  protected static attrTTL = 3 * minuteMs\n  readonly posixPath: string\n  readonly nativePath: string\n\n  /** \"/home/user/dir\" of \"/home/user/dir/file.txt\" */\n  readonly dir: string\n  /** \"file.txt\" of \"/home/user/dir/file.txt\" */\n  readonly base: string\n  /** \"file\" of \"/home/user/dir/file.txt\" */\n  readonly name: string\n  /** \".txt\" of \"/home/user/dir/file.txt\" */\n  readonly ext: string\n\n  protected constructor(\n    nativePath: string,\n    private dirent?: DirectoryEntry\n  ) {\n    if (dirent != null) {\n      this.nativePath = dirent.nativePath\n      this.dir = dirent.dir\n      this.base = dirent.base\n      this.name = dirent.name\n      this.ext = dirent.ext\n    } else {\n      this.nativePath = nativePath\n      const parsed = parseNativePath(this.nativePath)\n      this.dir = parsed.dir\n      this.base = parsed.base\n      this.name = parsed.name\n      this.ext = parsed.ext\n    }\n    this.posixPath = native2posix(this.nativePath)\n  }\n\n  toJSON() {\n    return {\n      _ctor: this.constructor.name,\n      nativePath: this.nativePath\n    }\n  }\n\n  toLogJSON() {\n    return this.nativePath\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON()\n  }\n\n  static async withFastestAccess<F extends BaseFile>(\n    files: Maybe<F>[]\n  ): PromiseMaybe<F> {\n    const arr = compact(files)\n    const msArr = await Promise.all(arr.map(f => f.shaMs()))\n    return arr[leastIndex(msArr)]\n  }\n\n  static projectRoot = lazy(() => {\n    const root = ProjectPath.Root()\n    if (root == null) {\n      throw new Error(\"Cannot find project path\")\n    } else {\n      return BaseFile.for(root)\n    }\n  })\n\n  static forPosix(posixPathOrFile: string | BaseFile) {\n    return posixPathOrFile instanceof BaseFile\n      ? posixPathOrFile\n      : this.for(posixPathOrFile.split(\"/\").join(_path.sep))\n  }\n\n  static forDirectoryEntry(de: DirectoryEntry) {\n    return this.for(de.nativePath, de)\n  }\n\n  static for(nativePathOrFile: SimpleFileOrString, dirent?: DirectoryEntry) {\n    if (nativePathOrFile instanceof BaseFile) {\n      return nativePathOrFile\n    }\n\n    // resolve() is expensive! Try to avoid it...\n\n    const nativePath = isSimpleFile(nativePathOrFile)\n      ? nativePathOrFile.nativePath\n      : toS(nativePathOrFile)\n\n    if (blank(nativePath)) {\n      throw new Error(\"BaseFile.for(): empty nativePathOrFile\")\n    }\n    const prior = cache().get(nativePath)\n    if (prior != null) return prior\n\n    // no need for a mutex: we're sync!\n    const resolved = resolve(nativePath)\n    const result = new BaseFile(resolved, dirent)\n    cache().set(nativePath, result)\n    cache().set(resolved, result)\n    return result\n  }\n\n  /**\n   * Wipe the instance cache and caches of all instances.\n   *\n   * This should only be used by tests.\n   *\n   * @param fromPath if undefined, all instances will be cleared.\n   */\n  static clear(fromPath?: string) {\n    ee().emit(\"fileChanged\", fromPath)\n  }\n\n  for(path: string, dirent?: DirectoryEntry): this {\n    return BaseFile.for(path, dirent) as this\n  }\n\n  forDirectoryEntry(de: DirectoryEntry): this {\n    return BaseFile.for(de.nativePath, de) as this\n  }\n\n  forChildDirent(dirent: SimpleDirent): this {\n    return this.forDirectoryEntry(\n      DirectoryEntry.fromSimpleDirent(this.nativePath, dirent)\n    )\n  }\n\n  forSiblingDirent(dirent: SimpleDirent): this {\n    return this.forDirectoryEntry(\n      DirectoryEntry.fromSimpleDirent(this.dir, dirent)\n    )\n  }\n\n  clear({ emit }: { emit?: boolean } = {}): this {\n    if (emit === true) ee().emit(\"fileChanged\", this.nativePath)\n    this.dirent = undefined\n    this.#childDirectoryEntries.unset()\n    this.#stat = undefined\n    return this\n  }\n\n  clearThisAndParent(): this {\n    ee().emit(\"fileChanged\", this.dir)\n    // this .clear() shouldn't be necessary, but it prevents race conditions\n    // from async onFileChanged listeners.\n    return this.clear({ emit: false })\n  }\n\n  toString() {\n    return this.nativePath\n  }\n\n  valueOf() {\n    return this.pathnames\n  }\n\n  resolve() {\n    const resolved = resolve(this.nativePath)\n    return resolved === this.nativePath ? this : this.for(resolved)\n  }\n\n  eql(that: Maybe<SimpleFileOrString>): boolean {\n    if (that == null) return false\n    const thatNativePath = toNativePath_(that)\n    // These paths have already been resolve()d. We don't need to do it again\n    // here.\n    return isLinux\n      ? this.nativePath === thatNativePath\n      : // darn Windows and macOS have case-insensitive filesystems!\n        equalsIgnoreCase(this.nativePath, thatNativePath)\n  }\n\n  get isUNC() {\n    return isUNC(this.nativePath)\n  }\n\n  /**\n   * Posix path from parent\n   */\n  get baseWithParent(): string {\n    return (\n      this.isRoot\n        ? \"/\"\n        : this.parent().isRoot\n        ? \"/\" + this.base\n        : (this.parent().parent().isRoot ? \"/\" : \"\") + // <  prefixes the path with a / if grandparent is root.\n          this.parent().base +\n          \"/\" +\n          this.base\n    ).normalize() // < normalize for macOS\n  }\n\n  /**\n   * @return nativePath \"…/path/to/file.ext\" with ancestors such that the\n   * result doesn't exceed maxLength\n   */\n  ellipsize({\n    maxLength = 80\n  }: { maxLength?: number; maxDepth?: number } = {}) {\n    return ellipsizePath({ p: this, maxLength })\n  }\n\n  get baseWithParentNoExt(): string {\n    return stripSuffix(this.baseWithParent, this.ext)\n  }\n\n  /**\n   * posix path from grandparent\n   */\n  get baseWithGrandparent(): string {\n    return (\n      this.isRoot\n        ? \"/\"\n        : this.parent().isRoot\n        ? this.baseWithParent\n        : this.parent().baseWithParent + \"/\" + this.base\n    ).normalize()\n  }\n\n  posixPathFrom(from: SimpleFileOrString): string {\n    return posixPathFrom(from, this) + (this.isDirectorySync() ? \"/\" : \"\")\n  }\n\n  async directoryEntry(): PromiseMaybe<DirectoryEntry> {\n    return (this.dirent ??= await thenMap(\n      this.stat(),\n      ea => new DirectoryEntry(this.dir, new StatDirent(this.base, ea))\n    ))\n  }\n\n  directoryEntrySync(): Maybe<DirectoryEntry> {\n    return (this.dirent ??= map(\n      this.statSync(),\n      ea => new DirectoryEntry(this.dir, new StatDirent(this.base, ea))\n    ))\n  }\n\n  readonly #childDirectoryEntries = lazy(() =>\n    thenMap(this.directoryEntry(), de => de.children())\n  )\n\n  async childDirectoryEntries(f?: Predicate<DirectoryEntry>) {\n    const dirents = await this.#childDirectoryEntries()\n    if (dirents == null || f == null || isEmpty(dirents)) return dirents\n\n    // PERF: don't filterAsync here to avoid lots of Promises GC\n    const result: DirectoryEntry[] = []\n    for (const dirent of dirents) {\n      if (true === (await f(dirent))) result.push(dirent)\n    }\n    return result\n  }\n\n  _directoryEntryChild(de: DirectoryEntry) {\n    return this.for(_path.join(this.nativePath, de.base), de)\n  }\n\n  /**\n   * @return the basename of the children of `this`, locale sorted.\n   */\n  childNames(): PromiseMaybe<string[]> {\n    return thenMap(this.childDirectoryEntries(), arr => arr.map(ea => ea.base))\n  }\n\n  /**\n   * For case-insensitive filesystems, return the closest-matching existing file\n   * **with case matching whats on the filesystem**\n   */\n  async resolve_(): PromiseMaybe<this> {\n    return (\n      (await this.#resolve_()) ?? (await this.clearThisAndParent().#resolve_())\n    )\n  }\n  async #resolve_(): PromiseMaybe<this> {\n    // DON'T USE this.siblingDirectoryEntries(): that filters `this`!\n\n    // Use readdir_() directly to avoid needless DirectoryEntry creation:\n    const sibs = (await readdir_(this.dir)).filter(ea =>\n      equalsIgnoreCase(ea.basename, this.base)\n    )\n    const closest = leastBy(sibs, ea => hamming(ea.basename, this.base))\n    return this.bflog().tap({\n      msg: \"resolve()\",\n      result:\n        closest?.basename === this.base\n          ? this\n          : map(closest, ea => this.forSiblingDirent(ea)),\n      meta: { sibs }\n    })\n  }\n\n  /**\n   * @throws if `readdir` fails\n   */\n  async children_(predicate?: Predicate<SimpleDirent>): Promise<this[]> {\n    const dirents = await readdir_(this.nativePath)\n    if (predicate != null) {\n      await filterInPlaceAsync(dirents, predicate)\n    }\n    // readdir_ gives us sorted files already!\n    return dirents.map(ea => this.forChildDirent(ea))\n  }\n\n  async children(predicate?: Predicate<DirectoryEntry>): PromiseMaybe<this[]> {\n    return (await this.childDirectoryEntries(predicate))?.map(ea =>\n      this._directoryEntryChild(ea)\n    )\n  }\n\n  async childFiles(\n    predicate?: Predicate<DirectoryEntry>\n  ): PromiseMaybe<this[]> {\n    const arr = await this.childDirectoryEntries(async ea => {\n      return (\n        ea.isFile() && (predicate == null || true === (await predicate(ea)))\n      )\n    })\n    return arr == null\n      ? undefined\n      : arr.map(ea => this._directoryEntryChild(ea))\n  }\n\n  async childDirectories(\n    predicate?: Predicate<DirectoryEntry>\n  ): PromiseMaybe<this[]> {\n    const arr = await this.childDirectoryEntries(async ea => {\n      return (\n        ea.isDirectory() &&\n        (predicate == null || true === (await predicate(ea)))\n      )\n    })\n    return arr == null\n      ? undefined\n      : arr.map(ea => this._directoryEntryChild(ea))\n  }\n\n  /**\n   * ONLY FOR TESTS\n   */\n  childrenSync(): this[] {\n    return orElse(\n      this.trapSync(\"childrenSync\", () =>\n        fs.readdirSync(this.nativePath).map(ea => this.join(ea))\n      ),\n      []\n    )\n  }\n  childFilesSync(): this[] {\n    return orElse(\n      this.trapSync(\"childrenSync\", () =>\n        fs\n          .readdirSync(this.nativePath, { withFileTypes: true })\n          .filter(ea => ea.isFile())\n          .map(ea => this.join(ea.name))\n      ),\n      []\n    )\n  }\n\n  async hasChildren(childNames?: string[]) {\n    const actualChildNames = await this.childNames()\n    return isNotEmpty(childNames)\n      ? includesAll(actualChildNames, childNames)\n      : isNotEmpty(actualChildNames)\n  }\n\n  async hasNoChildren() {\n    return (await this.isFile()) || isEmpty(await this.childNames())\n  }\n\n  /**\n   * Depth-first recursion, includes child directories.\n   */\n  async visitDescendants(\n    f: (descendant: this) => any | Promise<any>\n  ): Promise<void> {\n    return thenMap(this.children(), async children => {\n      for (const child of children) {\n        await child.visitDescendants(f)\n        await f(child)\n      }\n    })\n  }\n\n  /**\n   * Breadth-first recursion\n   *\n   * @return all files (no directories) that pass the given predicate.\n   */\n  async descendants(\n    predicate: Predicate<DirectoryEntry>\n  ): PromiseMaybe<this[]> {\n    const result: this[] = []\n    result.push(...toA(await this.childFiles(predicate)))\n    const dirs = await this.childDirectories()\n    if (dirs == null) return result\n    for (const dir of dirs) {\n      result.push(...toA(await dir.descendants(predicate)))\n    }\n    return result\n  }\n\n  async someDescendant(\n    predicate: Predicate<DirectoryEntry>,\n    depth: number = 0\n  ): PromiseMaybe<this> {\n    if (!gt0(depth)) return\n    const arr = (await this.#childDirectoryEntries()) ?? []\n    for (const ea of arr) {\n      if (true === (await predicate(ea))) {\n        return this._directoryEntryChild(ea)\n      }\n    }\n    if (depth > 0) {\n      for (const ea of arr) {\n        if (ea.isDirectory()) {\n          const result = await this._directoryEntryChild(ea).someDescendant(\n            predicate,\n            depth - 1\n          )\n          if (result != null) return result\n        }\n      }\n    }\n    return\n  }\n\n  /**\n   * Lightweight breadth-first directory entry visiting\n   *\n   * @return all files (no directories) that pass the given predicate.\n   */\n  descendantsSync(predicate: SyncPredicate<DirectoryEntry>): this[] {\n    const thisDe = this.directoryEntrySync()\n    const result: this[] = []\n    thisDe?.visitDescendantsSync(ea => {\n      if (true === predicate(ea)) {\n        result.push(this.forDirectoryEntry(ea))\n      }\n    })\n    return result\n  }\n\n  async ancestorWithChildren(childNames: string[]): PromiseMaybe<this> {\n    if (await this.hasChildren(childNames)) {\n      return this\n    } else if (this.isRoot) {\n      return undefined\n    } else {\n      return this.parent().ancestorWithChildren(childNames)\n    }\n  }\n\n  async siblings(f?: Predicate<DirectoryEntry>): PromiseMaybe<this[]> {\n    const p = this.parent()\n    return (await this.siblingDirectoryEntries(f))?.map(ea =>\n      p._directoryEntryChild(ea)\n    )\n  }\n\n  async siblingDirectoryEntries(\n    f?: Predicate<DirectoryEntry>\n  ): PromiseMaybe<DirectoryEntry[]> {\n    return this.parent().childDirectoryEntries(\n      async ea => ea.base !== this.base && (f == null || true === (await f(ea)))\n    )\n  }\n\n  async selfAndSiblings() {\n    return this.parent().children()\n  }\n\n  async firstExistingSelfOrAncestor(): Promise<this> {\n    return this.isRoot || (await this.exists())\n      ? this\n      : this.parent().firstExistingSelfOrAncestor()\n  }\n\n  /**\n   * @return [\"C:\", \"Users\", \"Bob\", \"image.jpg\"] on win, [\"home\", \"bob\",\n   * \"image.jpg\"] on !win\n   */\n  get pathnames(): string[] {\n    return splitNativePath(this.nativePath)\n\n    // return this.bflog().tap({\n    //   msg: \"pathnames()\",\n    //   result: splitNativePath(this.nativePath),\n    //   meta: { nativePath: this.nativePath }\n    // })\n  }\n\n  get pathsForDateParsing(): string[] {\n    return [\n      ...(this.isRoot ? [] : this.parent().pathnamesWithoutDrive),\n      bname(this.name)\n    ]\n  }\n\n  get pathnamesWithoutDrive(): string[] {\n    return isWin ? this.pathnames.slice(1) : this.pathnames\n  }\n\n  /**\n   * @return 0 for \"/\" or \"C:\\\", 1 for \"C:\\Users\" or \"/etc\", ...\n   */\n  get depth(): number {\n    return pathDepth(this)!\n  }\n\n  get isRoot(): boolean {\n    return pathIsRoot(this)\n  }\n\n  /**\n   * @param depth The number of directories from root to include. For example,\n   * \"C:\\\" or \"/\" for 0, \"C:\\Users\" or \"/home\" for depth 1\n   */\n  root(depth: number = 0): this {\n    // \"/\".root(1) should return \"/\"\n    return this.depth <= depth ? this : this.parent().root(depth)\n  }\n\n  parent(): this {\n    // MEMLEAK: don't cache this: this.for will do that for us.\n    return this.isRoot ? this : (this.for(this.dir) as this)\n  }\n\n  isAncestorOf(\n    maybeDescendant: Maybe<string | SimpleFile>,\n    args?: { acceptSelf: boolean }\n  ): boolean {\n    return containedByNativePath({\n      ancestor: this,\n      descendant: maybeDescendant,\n      ...args\n    })\n  }\n\n  isDescendantOf(maybeAncestor: Maybe<string | SimpleFile>): boolean {\n    return containedByNativePath({ descendant: this, ancestor: maybeAncestor })\n  }\n\n  isSelfOrDescendantOf(maybeAncestor: Maybe<string | SimpleFile>): boolean {\n    return (\n      maybeAncestor != null &&\n      (this.nativePath === toNativePath_(maybeAncestor) ||\n        this.isDescendantOf(maybeAncestor))\n    )\n  }\n\n  parentsAndSelf(): this[] {\n    return [...this.parents(), this]\n  }\n\n  selfAndParents(depth: number): this[] {\n    return [\n      this,\n      ...(this.isRoot || depth <= 0\n        ? []\n        : this.parent().selfAndParents(depth - 1))\n    ]\n  }\n\n  ancestor(depth = 1): Maybe<this> {\n    // TODO: remove recursion\n    return this.isRoot && depth > 0\n      ? undefined\n      : depth === 0\n      ? this\n      : this.parent().ancestor(depth - 1)\n  }\n\n  findAncestor(predicate: (ea: this) => boolean): Maybe<this> {\n    return this.isRoot\n      ? undefined\n      : predicate(this)\n      ? this\n      : this.parent().findAncestor(predicate)\n  }\n\n  /**\n   * Root-first order of paths (so [/, /var, /var/tmp, ...]\n   */\n  parents(): this[] {\n    const p = this.parent()\n    // NOTE: ALWAYS RETURN A NEW ARRAY, because consumers may .reverse or do\n    // other nasty things to it.\n    return this.isRoot ? [] : [...p.parents(), p]\n  }\n\n  /**\n   * Paths from URIs can have differently-encoded unicode paths (which switching\n   * from macOS to linux or Windows, for example.)\n   *\n   * If `this` exists, return it.\n   *\n   * If it doesn't, walk from the root of the path and try to find elements that,\n   * when unicode-normalized, match the current filesystem.\n   *\n   * As a last-ditch effort, try a case-insensitive match.\n   */\n  async normalize(): Promise<this> {\n    // Don't need to handle UNC paths (they are always windows-only):\n    return this.isUNC ? this : this.for(await actualPath(this.nativePath))\n  }\n\n  sibling(base: string): this {\n    return this.parent().join(base)\n  }\n\n  withPrefix(prefix: string): this {\n    return this.sibling(prefix + this.base)\n  }\n\n  /**\n   * @return this.sibling(this.name + suffix + this.ext)\n   */\n  withNameSuffix(suffix: string): this {\n    return this.sibling(this.name + suffix + this.ext)\n  }\n\n  /**\n   * @return this.sibling(this.base + suffix)\n   */\n  withSuffix(suffix: string): this {\n    return this.sibling(this.base + suffix)\n  }\n\n  siblingOf(possibleSibling: BaseFile): boolean {\n    return (\n      this.nativePath !== possibleSibling.nativePath &&\n      this.dir === possibleSibling.dir\n    )\n  }\n\n  /**\n   * Allows ../... directory traversals.\n   */\n  join(...paths: string[]): this {\n    if (isEmpty(paths) || eql([\".\"], paths) || paths.every(blank)) return this\n    return isAbsolute(paths[0])\n      ? this.for(_path.join(...paths))\n      : this.for(_path.join(this.nativePath, ...paths))\n  }\n\n  joinYMD(d = new Date()): Maybe<this> {\n    return map3(\n      d?.getFullYear(),\n      d?.getMonth(),\n      d?.getDate(),\n      (year, month, day) => this.join(toS(year), pad2(month + 1), pad2(day))\n    )\n  }\n\n  /**\n   * Prevents `..` directory traversals\n   * @param paths\n   */\n  child(...paths: string[]): this {\n    if (isEmpty(paths)) return this\n    const pathElements = flatten(paths.map(ea => ea.split(_path.sep))).filter(\n      ea => ea !== \"..\"\n    )\n    // Convert to posix to prevent \"\\\\\" and \"/\" from confusing the split:\n    return this.join(...pathElements)\n  }\n\n  //  _  _    _\n  // (_)| |_ ( )___    __ _\n  // | || __||// __|  / _` |\n  // | || |_   \\__ \\ | (_| | _  _  _\n  // |_| \\__|  |___/  \\__,_|(_)(_)(_)\n  protected async trap<T>(\n    methodName: string,\n    p: () => SyncOrAsync<T>,\n    errLogLevel: LogLevel = \"warn\"\n  ): PromiseMaybe<T> {\n    try {\n      return await time(\"fs.\" + methodName, p)\n    } catch (err) {\n      this.bflog().log(errLogLevel, `trap: ${methodName}() failed: ${err}`)\n      return undefined\n    }\n  }\n\n  // Return true if p() doesn't raise an error, else return false.\n  protected async trapOr(\n    methodName: string,\n    p: () => Promise<any>,\n    errLogLevel: LogLevel = \"warn\"\n  ): Promise<boolean> {\n    try {\n      await time(\"fs.\" + methodName, p)\n      return true\n    } catch (err) {\n      this.bflog().log(errLogLevel, `trapOr: ${methodName}() failed: ${err}`)\n      return false\n    }\n  }\n\n  protected trapSync<T>(\n    methodName: string,\n    p: () => T,\n    errLogLevel: LogLevel = \"warn\"\n  ): Maybe<T> {\n    try {\n      // this.bflog().trace(`trapSync ${methodName}()`)\n      return timeSync(\"fs.\" + methodName, p)\n    } catch (err) {\n      this.bflog().log(errLogLevel, `${methodName}() failed: ${err}`)\n      return undefined\n    }\n  }\n\n  /**\n   * Never cached\n   */\n  stat_() {\n    return stat_(this.nativePath)\n  }\n\n  #stat: Maybe<fs.Stats> = undefined\n\n  async stat(opts?: RefreshArgs) {\n    if (opts?.refresh ?? false) {\n      this.#stat = undefined\n    }\n    return (this.#stat ??= await statMaybe(this.nativePath, opts?.logLevel))\n  }\n\n  statSync(opts?: RefreshArgs) {\n    if (opts?.refresh ?? false) {\n      this.#stat = undefined\n    }\n    return (this.#stat ??= statSync(this.nativePath))\n  }\n\n  async exists(opts?: RefreshArgs): Promise<boolean> {\n    if (opts?.refresh ?? false) {\n      this.dirent = undefined\n    }\n    return this.dirent != null || (await thenDefined(this.stat(opts)))\n  }\n\n  existsSync(opts?: RefreshArgs): boolean {\n    if (opts?.refresh ?? true) {\n      this.dirent = undefined\n    }\n    return this.dirent != null || this.statSync(opts) != null\n  }\n\n  async notExists(opts?: RefreshArgs): Promise<boolean> {\n    return thenNot(this.exists(opts))\n  }\n\n  async isDeleted(maxDepth = 3): PromiseMaybe<boolean> {\n    if (await this.exists({ refresh: true })) {\n      return this.bflog().tap({\n        result: false,\n        msg: \"isDeleted(): file exists\"\n      })\n    }\n\n    if (this.isRoot || maxDepth <= 0) {\n      return this.bflog().tap({\n        result: undefined,\n        msg: \"isDeleted(): isRoot() and doesn't exist (volume is just unmounted)\"\n      })\n    }\n\n    const parentIsDeleted = await this.parent().isDeleted(maxDepth - 1)\n\n    if (parentIsDeleted == null) {\n      return this.bflog().tap({\n        result: undefined,\n        msg: \"isDeleted(): parent().isDeleted was undefined\",\n        meta: { parentIsDeleted }\n      })\n    } else {\n      return this.bflog().tap({\n        result: true,\n        msg: \"isDeleted(): parent was either deleted or not deleted: either way, that means I am deleted.\",\n        meta: { parentIsDeleted }\n      })\n    }\n  }\n\n  mtime(): PromiseMaybe<Date> {\n    return thenMap(this.stat(), s => s.mtime)\n  }\n\n  mtimeMs(opts?: RefreshArgs): PromiseMaybe<number> {\n    return thenMap(this.stat(opts), s => Math.floor(s.mtimeMs))\n  }\n\n  async mtimeSec(): PromiseMaybe<number> {\n    const s = await this.stat()\n    return s == null ? undefined : unixtime(s.mtimeMs)\n  }\n\n  async lastModifiedUtc(): PromiseMaybe<string> {\n    return (await this.stat())?.mtime.toUTCString()\n  }\n\n  // The mtime, rather than the birthtime, will actually be the capture\n  // time if the file is \"copied and pasted\" via the Windows explorer\n  // (rather than using `rsync --times` or `cp --preserve=all`).\n\n  // Birthtime isn't supported by default in linux, and seems to just return\n  // the ctime.\n\n  /**\n   * @return the uniq stat times, including birthtime, mtime, and ctime.\n   */\n  async statTimes(): PromiseMaybe<number[]> {\n    const s = await this.stat()\n    return s == null ? undefined : statTimes(s)\n  }\n\n  maxStatMs(): PromiseMaybe<number> {\n    return thenMap(this.statTimes(), max)\n  }\n\n  maxStatDate(): PromiseMaybe<Date> {\n    return thenMap(this.maxStatMs(), ea => new Date(ea))\n  }\n\n  minStatMs(): PromiseMaybe<number> {\n    return thenMap(this.statTimes(), min)\n  }\n\n  minStatDate(): PromiseMaybe<Date> {\n    return thenMap(this.minStatMs(), ea => new Date(ea))\n  }\n\n  async size(opts?: RefreshArgs): PromiseMaybe<number> {\n    return thenMap(this.stat(opts), s => s.size)\n  }\n\n  /**\n   * Always uncached\n   */\n  async size_(): Promise<number> {\n    return (await this.stat_()).size\n  }\n\n  /**\n   * @return Promise<true> if the file is executable (not relevant on windows)\n   */\n  async isExecutable(): Promise<boolean> {\n    return access({ stat: await this.stat(), r: true, x: true })\n  }\n\n  async isReadable(): Promise<boolean> {\n    return access({ stat: await this.stat(), r: true })\n  }\n\n  isNotReadable(): Promise<boolean> {\n    return thenNot(this.isReadable())\n  }\n\n  async isReadWritable(): Promise<boolean> {\n    return access({ stat: await this.stat(), r: true, w: true })\n  }\n\n  isNotReadWritable(): Promise<boolean> {\n    return thenNot(this.isReadWritable())\n  }\n\n  async isReadWriteExecutable(): Promise<boolean> {\n    return isStatRWX(await this.stat(), this.nativePath)\n  }\n\n  isReadWriteExecutableSync(): boolean {\n    return isStatRWX(this.statSync(), this.nativePath)\n  }\n\n  async isReadWriteExecutable_(): Promise<boolean> {\n    return isStatRWX(await this.stat_(), this.nativePath)\n  }\n\n  async isReadWriteDirectory(): Promise<boolean> {\n    const stat = await this.stat()\n    return stat?.isDirectory() === true && isStatRWX(stat, this.nativePath)\n  }\n\n  async assertReadWriteExecutable(): Promise<void> {\n    if (!(await this.isReadWriteExecutable())) {\n      throw new Error(\n        `Please check directory permissions for ${\n          this.nativePath\n        }: it must be read/write${\n          isWin ? \"\" : \"/execute\"\n        } by ${await userDesc()}`\n      )\n    }\n  }\n\n  /**\n   * Is this a rw dir, or **is it possible** for this directory to be made rw?\n   */\n  async maybeReadWriteDirectory(): Promise<boolean> {\n    if ((await this.isFile()) === true) {\n      return false\n    } else if (await this.isDirectory()) {\n      return this.isReadWriteExecutable()\n    } else {\n      // I don't exist! ask my parent:\n      return this.parent().maybeReadWriteDirectory()\n    }\n  }\n\n  isHiddenBasename(): boolean {\n    return isHiddenBasename(this.base)\n  }\n\n  async isEmpty(bytesConsideredEmpty = 0): Promise<boolean> {\n    if (await this.isDirectory()) {\n      return isNotEmpty(await this.childNames())\n    } else {\n      const s = await this.size()\n      return s == null || s <= bytesConsideredEmpty\n    }\n  }\n\n  isNonEmpty(minSizeBytes = 1): Promise<boolean> {\n    return thenNot(this.isEmpty(minSizeBytes))\n  }\n\n  /**\n   * @return only if the file is missing or is already a file and size is less than {@link minSizeBytes}\n   */\n  async isEmptyFile(minSizeBytes = 1): Promise<boolean> {\n    const s = await this.stat({ logLevel: \"trace\" })\n    return s == null || (s.isFile() && s.size < minSizeBytes)\n  }\n\n  async isNonEmptyFile(minSizeBytes = 1): Promise<boolean> {\n    const s = await this.stat({ logLevel: \"trace\" })\n    return s != null && s.isFile() && s.size >= minSizeBytes\n  }\n\n  async modifiedGTE(mtime: Date): PromiseMaybe<boolean> {\n    return thenMap(\n      this.mtime(),\n      thisMtime =>\n        // Filesystems have only second-level resolution\n        unixtime(thisMtime) >= unixtime(mtime)\n    )\n  }\n\n  async modifiedCloseTo(\n    mtimeMs: number,\n    deltaMs: number\n  ): PromiseMaybe<boolean> {\n    return thenMap(\n      this.mtimeMs(),\n      thisMtimeMs => Math.abs(thisMtimeMs - mtimeMs) <= deltaMs\n    )\n  }\n\n  async isRecent(agoMs: number): Promise<boolean> {\n    const mtime = await this.maxStatMs()\n    return mtime != null && mtime > Date.now() - agoMs\n  }\n\n  async modifiedGT(mtime: Maybe<Date>): PromiseMaybe<boolean> {\n    if (mtime == null) return\n    return thenMap(\n      this.mtime(),\n      thisMtime =>\n        // Filesystems have only second-level resolution\n        unixtime(thisMtime) > unixtime(mtime)\n    )\n  }\n\n  isDirectory(opts?: RefreshArgs): SyncOrAsync<boolean> {\n    if (this.dirent != null) return this.dirent.isDirectory()\n    return thenMapOr(\n      this.stat(opts),\n      ea => ea.isDirectory(),\n      () => false\n    )\n  }\n\n  async isNotDirectory(): Promise<boolean> {\n    return thenNot(this.isDirectory())\n  }\n\n  isDirectorySync(opts?: RefreshArgs): boolean {\n    if (this.dirent != null) return this.dirent.isDirectory()\n    return mapOr(\n      this.statSync(opts),\n      ea => ea.isDirectory(),\n      () => false\n    )\n  }\n\n  async nearestDir(): Promise<this> {\n    return (await this.isDirectory()) ? this : this.parent()\n  }\n\n  async isFile(): Promise<boolean> {\n    if (this.dirent != null) return this.dirent.isFile()\n    const s = await this.stat()\n    return s != null ? s.isFile() : false\n  }\n\n  isFileSync(): boolean {\n    if (this.dirent != null) return this.dirent.isFile()\n    return opt(this.statSync()).filter(ea => ea.isFile()).isDefined\n  }\n\n  async rmdir(errLogLevel: LogLevel = \"warn\"): Promise<boolean> {\n    this.clear()\n    return (\n      (await this.trap(\n        \"rmdir\",\n        async () => {\n          await _fse.rmdir(this.nativePath, {\n            recursive: false,\n            maxRetries: 8,\n            retryDelay: 500\n          })\n          return true\n        },\n        errLogLevel\n      )) ?? false\n    )\n  }\n\n  rmdirSync(errLogLevel: LogLevel = \"warn\"): boolean {\n    this.clear()\n    return (\n      this.trapSync(\n        \"rmdirSync\",\n        () => {\n          _fse.rmdirSync(this.nativePath, {\n            recursive: false,\n            maxRetries: 8,\n            retryDelay: 500\n          })\n          return true\n        },\n        errLogLevel\n      ) ?? false\n    )\n  }\n\n  /**\n   * @throws on error\n   */\n  async mkdirp_(): Promise<this> {\n    try {\n      await mkdirp_(this.nativePath)\n    } catch (err: any) {\n      // EEXIST is from race conditions, and can be ignored.\n      if (err?.code !== \"EEXIST\") throw err\n    }\n    if (\n      // kernel FS lag can't be longer than a second or two\n      false ===\n      (await untilTrue(() => this.clear().isDirectory(), {\n        timeoutMs: 2 * secondMs,\n        intervalMs: 200\n      }))\n    ) {\n      throw new Error(\"Failed to mkdirp \" + this)\n    } else {\n      // this and parent because parent caches children.\n      return this.clearThisAndParent()\n    }\n  }\n\n  async mkdirp(): PromiseMaybe<this> {\n    if ((await this.clear().isDirectory()) || this.isRoot) return this\n    return this.trap(\"mkdirp\", async () => this.mkdirp_())\n  }\n\n  /**\n   * @throws on error\n   */\n  mkdirpSync_(): this {\n    mkdirpSync_(this.nativePath)\n    return this.clearThisAndParent()\n  }\n\n  mkdirpSync(): Maybe<this> {\n    if (this.isRoot) return this\n    return this.trapSync(\"mkdirpSync\", () => this.mkdirpSync_())\n  }\n\n  // no need lazy() or cache: fileSha_ already has smart caching.\n  sha_(): Promise<string> {\n    return fileSha_(this.nativePath)\n  }\n\n  /**\n   * base64 encoded SHA-512/192 (ish)\n   */\n  async sha(): PromiseMaybe<string> {\n    return this.trap(\"sha\", () => this.sha_())\n  }\n\n  /**\n   * @return ms to gather the sha for this file\n   */\n  async shaMs(): PromiseMaybe<number> {\n    // we don't care if the metadata is stale!\n    return this.trap(\n      \"shaMs\",\n      async () =>\n        (await fileShaMeta_(this, { autoInvalidate: false })).elapsedMs\n    )\n  }\n\n  async readJson_<T>(): Promise<T> {\n    return parseJSON((await _fse.readFile(this.nativePath)).toString()) as any\n  }\n\n  readJson<T>(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<T> {\n    return this.trap(\"readJson\", () => this.readJson_<T>(), errLogLevel)\n  }\n\n  readJsonSync<T>(): Maybe<T> {\n    return this.trapSync(\"readJsonSync\", () =>\n      parseJSON<T>(fs.readFileSync(this.nativePath).toString())\n    )\n  }\n\n  readFileSync_() {\n    return readFileSync(this.nativePath)\n  }\n\n  readFile_(): Promise<Buffer> {\n    return readFile(this.nativePath)\n  }\n\n  readFile(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<Buffer> {\n    return this.trap(\"readFile\", () => this.readFile_(), errLogLevel)\n  }\n\n  async readTextFile_() {\n    return bufferToString(await this.readFile_())\n  }\n\n  readTextFile(errLogLevel: LogLevel = \"warn\") {\n    return this.trap(\"readTextFile\", () => this.readTextFile_(), errLogLevel)\n  }\n\n  /**\n   * `readFile`, but on-the-fly decompression for .gz and .br\n   * @throws on error\n   */\n  async zReadFile_(options?: {\n    start?: number\n    end?: number\n  }): PromiseMaybe<Buffer> {\n    return zCopyToBuffer_(this.nativePath, options)\n  }\n\n  async zcat(options?: { start?: number; end?: number }): PromiseMaybe<string> {\n    return this.trap(\"zcat\", () => thenMap(this.zReadFile_(options), toS))\n  }\n\n  readLines(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<string[]> {\n    return thenMap(this.readTextFile(errLogLevel), splitLines)\n  }\n\n  readFileSync(): Maybe<string> {\n    try {\n      return fs.readFileSync(this.nativePath).toString()\n    } catch (error) {\n      this.bflog().warn(\"readFileSync() failed\", { error })\n      return\n    }\n  }\n\n  /**\n   * @throws on error\n   */\n  async writeText_(...txt: string[]) {\n    await writeText_(this.nativePath, ...txt)\n    return this\n  }\n\n  writeTextSync_(...txt: string[]) {\n    writeTextSync_(this.nativePath, ...txt)\n    return this\n  }\n\n  /**\n   * @throws on error\n   */\n  async writeFile_(data: string | Buffer) {\n    await writeFile_(this.nativePath, data)\n    return this\n  }\n\n  async writeJson(object: any, options?: JsonWriteOptions): PromiseMaybe<this> {\n    // outputJSON is almost the same as writeJson, except that if the directory\n    // does not exist, it's created\n    return this.trap(\"writeJsonMaybe\", () => this.writeJson_(object, options))\n  }\n\n  /**\n   * @throws on error\n   */\n  async writeJson_(object: any, options?: JsonWriteOptions): Promise<this> {\n    await mkdirp_(this.dir)\n    await _fse.writeFile(\n      this.nativePath,\n      stringify(object, options?.replacer, options?.spaces),\n      omit(options, \"replacer\", \"spaces\")\n    )\n    this.clearThisAndParent()\n    return this\n  }\n\n  async matchesContent(that: this): Promise<boolean> {\n    const stats = await Promise.all([\n      this.stat({ refresh: true }),\n      that.stat({ refresh: true })\n    ])\n    if (stats[0] == null || stats[1] == null || stats[0].size !== stats[1].size)\n      return false\n    return (await this.sha()) === (await that.sha())\n  }\n\n  async touch(args: UtimesArgs = {}): PromiseMaybe<this> {\n    return this.trap(\"touch\", () => this.touch_(args))\n  }\n\n  async touch_(args: UtimesArgs = {}): Promise<this> {\n    await touch_({\n      ...args,\n      file: this,\n      ensureFile: true\n    })\n    return this.clearThisAndParent()\n  }\n\n  async utimes(args: UtimesArgs = {}): PromiseMaybe<this> {\n    return this.trap(\"utimes\", async () => {\n      await touch_({\n        ...args,\n        file: this,\n        ensureFile: false\n      })\n      this.clearThisAndParent()\n      return this\n    })\n  }\n\n  async rm(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<this> {\n    return this.unlink(errLogLevel)\n  }\n\n  /**\n   * Deletes the current file.\n   * @return Promise<this> if unlink was successful\n   */\n  async unlink(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<this> {\n    return this.trap(\"unlink\", () => this.unlink_(), errLogLevel)\n  }\n\n  /**\n   * Deletes the current file.\n   */\n  unlinkSync(logLevel: LogLevel = \"info\") {\n    return this.trapSync(\n      \"unlinkSync\",\n      () => {\n        _fse.unlinkSync(this.nativePath)\n        this.clearThisAndParent()\n      },\n      logLevel\n    )\n  }\n\n  async unlink_(): Promise<this> {\n    await _fse.unlink(this.nativePath)\n    return this.clearThisAndParent()\n  }\n\n  /**\n   * Delete files or directories. Should only be needed by tests or applied to\n   * cache dirs.\n   *\n   * Note that the promise may be returned before the file op is actually\n   * complete due to a (bug?) in fs-extra.\n   */\n  async rmrf(logLevel: LogLevel = \"info\"): PromiseMaybe<this> {\n    return this.trap(\"rmrf\", () => this.rmrf_(), logLevel)\n  }\n\n  async rmrf_(): Promise<this> {\n    // retries may be required for windows\n    return retryOnReject(\n      async () => {\n        const s = await this.stat({ refresh: true })\n        if (s != null) {\n          await _fse.rm(this.nativePath, {\n            recursive: s.isDirectory(),\n            force: true\n          })\n        }\n        return this.clearThisAndParent()\n      },\n      {\n        maxRetries: 3,\n        timeoutMs: 0, // recursive deletions may take a while\n        retryDelay: secondMs,\n        errorIsRetriable: isRetriableError\n      }\n    )\n  }\n\n  /**\n   * Supports gzip/gunzip/brotli/whatever transform you've got:\n   *\n   * THIS FILE IS DELETED AFTER THE PIPELINE COMPLETES\n   */\n  async #pipeTo(base: string, transform: stream.Transform) {\n    return this.trap(\"pipeTo(\" + base + \")\", async () => {\n      const dest = await this.sibling(base).ensureNew_()\n      await pipeline([\n        fs.createReadStream(this.nativePath, { autoClose: true }),\n        transform,\n        fs.createWriteStream(dest.nativePath, { autoClose: true })\n      ])\n      await this.unlink()\n      return dest\n    })\n  }\n\n  async gunzip(): PromiseMaybe<this> {\n    return this.#pipeTo(stripSuffix(this.base, \".gz\"), zlib.createGunzip())\n  }\n\n  async gzip(): PromiseMaybe<this> {\n    return this.#pipeTo(this.base + \".gz\", zlib.createGzip())\n  }\n\n  async compressBrotli(): PromiseMaybe<this> {\n    return this.#pipeTo(this.base + \".br\", zlib.createBrotliCompress())\n  }\n\n  ensureFile_(): Promise<this> {\n    return _fse\n      .ensureFile(this.nativePath)\n      .then(() => this.clearThisAndParent())\n  }\n\n  ensureFile(): PromiseMaybe<this> {\n    return this.trap(\"ensureFile\", () => this.ensureFile_())\n  }\n\n  /**\n   * @throws on error\n   */\n  ensureFileSync_() {\n    _fse.ensureFileSync(this.nativePath)\n    return this.clearThisAndParent()\n  }\n\n  /**\n   * Returns a basename in this directory with this same .ext and prefixed with\n   * this.name which either doesn't exist or is zero length.\n   *\n   * If `options.emptyIsNew` is `true`, the file may exist, but must be\n   * zero-length. If `options.emptyIsNew` is `false`, the returned path will be\n   * nonexistent.\n   */\n  async ensureNewNativePath(\n    options: Omit<EnsureNewOptions, \"nativePath\">\n  ): Promise<string> {\n    return ensureNewNativePath_({ nativePath: this.nativePath, ...options })\n  }\n\n  /**\n   * @throws if errors\n   */\n  ensureNew_(opts: Partial<EnsureNewOptions> = {}): Promise<this> {\n    return this.ensureNewNativePath(opts).then(p => this.for(p))\n  }\n\n  /**\n   * @throws if errors\n   */\n  ensureNewSync_(opts: Partial<EnsureNewOptions> = {}): this {\n    return this.for(\n      ensureNewNativePathSync_({ nativePath: this.nativePath, ...opts })\n    )\n  }\n\n  /**\n   * Make sure you encode `mode` in octal! 0o644\n   */\n  async chmod_(mode: string | number): Promise<this> {\n    await _fse.chmod(this.nativePath, mode)\n    return this.clear()\n  }\n\n  async chmod(mode: string | number): PromiseMaybe<this> {\n    try {\n      await this.chmod_(mode)\n      return this\n    } catch (err) {\n      this.bflog().warn(\"failed to chmod to \" + mode.toString(8), err)\n      return\n    }\n  }\n\n  chmodSync(mode: string | number): Maybe<this> {\n    try {\n      fs.chmodSync(this.nativePath, mode)\n      return this\n    } catch (err) {\n      this.bflog().warn(\"failed to chmod to \" + mode.toString(8), err)\n      return\n    }\n  }\n\n  zreadline(): LineReader {\n    return fs\n      .createReadStream(this.nativePath)\n      .on(\"error\", (err: any) => {\n        throw new Error(\"Failed to read from \" + this + \": \" + err)\n      })\n      .pipe(zlib.createGunzip())\n      .on(\"error\", (err: any) => {\n        throw new Error(\"Failed to gunzip \" + this + \": \" + err)\n      })\n      .pipe(new LineReader())\n  }\n\n  async siblingWithSameContents(): PromiseMaybe<this> {\n    return this.parent().childWithSameContents(this)\n  }\n\n  async childWithSameContents(target: BaseFile): PromiseMaybe<this> {\n    return time(\"fs.childWithSameContents\", async () => {\n      if (!(await this.isDirectory())) return\n\n      const targetSize = await target.size()\n      if (targetSize == null) return\n\n      // Only look for a same-named file if the parent directories are different:\n      if (!this.eql(target.parent())) {\n        const withSameName = this.join(target.base)\n        // SWEET we don't have to this.readdir()!\n        if (await target.matchesContent(withSameName)) return withSameName\n      }\n\n      const sameSize = await this.children(\n        async ea =>\n          !ea.isNameHidden() &&\n          targetSize === (await ea.size()) &&\n          // Don't include target!\n          ea.nativePath !== target.nativePath\n        // (we're not normalizing or case-insensitive matching here: there shouldn't be a need to, and that will be wrong on non-ci filesystems.)\n      )\n\n      // Don't need to sha target if none are the same size:\n      if (isEmpty(sameSize)) return\n\n      const targetSha = await target.sha()\n      if (targetSha == null) return\n\n      // Assume similar names are more likely to be the same, so try those first.\n      // if we have to check _64_ files with the same exact size, something screwy is going on: give up.\n      for (const child of sameSize\n        .sort((a, b) => -diceCoeff(a.base, b.base))\n        .slice(0, 64)) {\n        if ((await child.sha()) === targetSha) {\n          return child\n        }\n      }\n      return\n    })\n  }\n\n  firstMatchingLine(re: RegExp): PromiseMaybe<RegExpMatchArray> {\n    const d = new Deferred<Maybe<RegExpMatchArray>>(\n      \"firstMatchingLine(\" + this + \")\"\n    )\n    const r = fs.createReadStream(this.nativePath, { flags: \"r\" })\n    r.on(\"error\", (err: any) => {\n      if (err.errno === -2 || err.code === \"ENOENT\") {\n        void d.maybeResolve(undefined)\n        r.close()\n      } else {\n        void d.maybeReject(err)\n      }\n    })\n    r.on(\"close\", () => d.maybeResolve(undefined))\n    void onDataChunked(r, newlineRe(), ea => {\n      const m = re.exec(ea)\n      if (m != null) {\n        void d.maybeResolve(m)\n        r.close()\n      }\n    })\n    return d.promise\n  }\n\n  contemporary(b: BaseFile, maxDiffMs: number): Promise<boolean> {\n    return thenMap2Or(\n      this.statTimes(),\n      b.statTimes(),\n      (arr1, arr2) => {\n        for (const i of arr1) {\n          for (const j of arr2) {\n            if (closeTo(i, j, maxDiffMs)) {\n              return true\n            }\n          }\n        }\n        return false\n      },\n      () => false\n    )\n  }\n\n  /**\n   * NOTE: recursive is only supported if Settings.useFsWatch is true.\n   */\n  watchUntil<T>(opts: {\n    f: (event?: WatchEventType, filename?: string) => PromiseMaybe<T>\n    timeoutMs: number\n    persistent: boolean\n    recursive: boolean\n    intervalMs?: number\n    accept?: (t: Maybe<T>) => boolean\n  }): Deferred<T> {\n    const accept = (opts.accept ??= (t: Maybe<T>) => t != null && t !== false)\n    const d = new Deferred<T>(\"watchUntil(\" + this.nativePath + \")\")\n    if (opts.timeoutMs > 0) {\n      void d.setTimeout(opts.timeoutMs, !opts.persistent)\n    }\n    if (_useFsWatch) {\n      try {\n        const watcher = watch(\n          this.nativePath,\n          {\n            persistent: opts.persistent,\n            recursive: opts.recursive,\n            encoding: \"utf8\"\n          },\n          async (event, filename) => {\n            try {\n              const result = await opts.f(event, denull(filename))\n              if (accept(result)) {\n                void d.resolve(result!)\n              }\n            } catch (error) {\n              void d.reject(error)\n            }\n          }\n        )\n        void d.finally(() => {\n          watcher.close()\n        })\n      } catch (error) {\n        opts.intervalMs ??= 500\n        this.bflog().warn(\"fs.watch failed, using polling\", { error, opts })\n      }\n    } else {\n      // Force polling:\n      opts.intervalMs ??= 500\n      this.bflog().warn(\"watchUntil(): fsWatch disabled, using polling\", {\n        opts\n      })\n    }\n\n    if (gt0(opts.intervalMs)) {\n      const interval = setInterval(async () => {\n        try {\n          const result = await opts.f()\n          if (accept(result)) {\n            void d.resolve(result!)\n          }\n        } catch (error) {\n          void d.reject(error)\n        }\n      }, opts.intervalMs)\n      if (!opts.persistent) {\n        interval.unref()\n      }\n      void d.finally(() => {\n        clearInterval(interval)\n      })\n    }\n\n    return d\n  }\n}\n\nexport function execDir(): BaseFile {\n  return BaseFile.for(process.execPath).parent()\n}\n\n// This is used to break a circular dependency between fs and Settings:\nlet _useFsWatch: boolean = true\n\n// This is set in SettingsDefaults to watch Settings.useFsWatch:\nexport function useFsWatch(b: boolean) {\n  _useFsWatch = b\n}\n","import { SyncPredicate } from \"../predicates/SyncPredicates\"\nimport { Settings } from \"../settings/Settings\"\nimport { ExtType, ExtTypes } from \"../tags/ExtType\"\nimport { isExtType } from \"../tags/FileTypes\"\nimport { toPathnames } from \"./Path\"\nimport { SimpleFile } from \"./SimpleFile\"\n\n/**\n * case-insensitive basename matching\n */\nexport function excludedPathFilter<T extends SimpleFile>(\n  excludedBasenames: string[]\n): SyncPredicate<T> {\n  const s = new Set(excludedBasenames.map(ea => ea.toLowerCase()))\n  return (file: T) =>\n    toPathnames(file.nativePath).every(ea => !s.has(ea.toLowerCase()))\n}\n\n/**\n * @param includedExtensions case-insensitive file extensions.\n * Note these must be prefixed with a '.'\n */\nexport function extFilter<T extends SimpleFile>(\n  extType: ExtType\n): SyncPredicate<T> {\n  return (file: T) =>\n    Settings.respectFileExtensions.valueOrDefault\n      ? isExtType(file?.ext, extType)\n      : null\n}\n\nexport const isBrowserExtension = extFilter(ExtTypes.SupportedByCurrentBrowser)\nexport const isVideoExtension = extFilter(ExtTypes.Video)\nexport const isAssetFileExtension = extFilter(ExtTypes.AssetFile)\n","import { compactBlanks } from \"../../fe/Array\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { newlineRe } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { isWin } from \"../platform/Platform\"\n\nexport const Newline = isWin ? \"\\r\\n\" : \"\\n\"\n\nexport function crlf(...s: string[]): string {\n  const result = s.map(toS).join(\"\\n\")\n  return isWin ? result.replace(newlineRe(), \"\\r\\n\") : result\n}\n\nexport function splitLines(...arr: Maybe<string | Buffer>[]): string[] {\n  return flatten(\n    arr.map(ea =>\n      Array.isArray(ea) ? splitLines(...ea) : toS(ea).split(newlineRe())\n    )\n  )\n}\n\nexport function joinLines(...lines: string[]): string {\n  return splitLines(...lines).join(Newline)\n}\n\nexport function splitCompactLines(...arr: Maybe<string | Buffer>[]): string[] {\n  return compactBlanks(splitLines(...arr))\n}\n","import { join } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { AppNameVersion } from \"../AppName\"\nimport { mkLogger } from \"../Logger\"\nimport { joinNativePath, mkdirp_ } from \"./Path\"\nimport { readFilePart_ } from \"./ReadFilePart\"\nimport { SimpleFileOrString, basename, toNativePath_ } from \"./SimpleFile\"\nimport { isNonEmptyFile } from \"./Stat\"\nimport { writeTextfile_ } from \"./WriteFile\"\n\n// https://bford.info/cachedir/\nexport const CACHEDIR_TAG = \"CACHEDIR.TAG\"\n\nexport const CACHEDIR_TAG_CONTENT =\n  \"Signature: 8a477f597d28d172789f06886806bc55\"\n\nconst logger = lazy(() => mkLogger(\"fs.CachedirTag\"))\n\nexport async function isCachedirTagDirectory(dir: SimpleFileOrString) {\n  return isCachedirTagFile(join(toNativePath_(dir), CACHEDIR_TAG))\n}\n\nexport async function isCachedirTagFile(\n  f: SimpleFileOrString\n): Promise<boolean> {\n  if (basename(f) !== CACHEDIR_TAG) {\n    return false\n  }\n  if (!(await isNonEmptyFile(toNativePath_(f), CACHEDIR_TAG_CONTENT.length))) {\n    return false\n  }\n  try {\n    const header = (\n      await readFilePart_({\n        nativePath: toNativePath_(f),\n        position: 0,\n        length: CACHEDIR_TAG_CONTENT.length\n      })\n    )?.buffer?.toString()\n    return header === CACHEDIR_TAG_CONTENT\n  } catch (error) {\n    logger().debug(\"isCachedirTagFile(): failed to read \" + f, error)\n    return false\n  }\n}\n\nexport async function writeCachedirTag_(dir: SimpleFileOrString) {\n  const dirPath = toNativePath_(dir)\n  await mkdirp_(dirPath)\n  await writeTextfile_(\n    joinNativePath([dirPath, CACHEDIR_TAG]),\n    CACHEDIR_TAG_CONTENT,\n    \"# This file is a cache directory tag\",\n    `# created by ${AppNameVersion()}`\n  )\n}\n","import path from \"path\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mapNotBlankOr } from \"../../fe/Blank\"\nimport { isMac, isWin } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\n\nconst DefaultMacOSPaths = Object.freeze([\n  \"/opt/homebrew/bin\",\n  \"/opt/homebrew/sbin\",\n  \"/usr/local/bin\",\n  \"/usr/local/sbin\",\n  \"/usr/bin\",\n  \"/bin\",\n  \"/usr/sbin\",\n  \"/sbin\"\n])\n\n// exported for tests:\nexport const DefaultPosixPaths = Object.freeze([\n  // From Ubuntu's /etc/environment:\n  \"/usr/local/bin\",\n  \"/usr/local/sbin\",\n  \"/usr/lib/libraw\", // where dcraw_emu lives\n  \"/opt/local/bin\", // macports\n  \"/opt/local/sbin\", // macports\n  \"/usr/sbin\",\n  \"/usr/bin\",\n  \"/sbin\",\n  \"/bin\"\n])\n\nexport const DefaultDockerPaths = Object.freeze([\n  \"/opt/photostructure/tools/bin\",\n  ...DefaultPosixPaths\n])\n\nexport const DefaultWinPaths = lazy(() => [\n  ...mapNotBlankOr(\n    process.env.SYSTEMROOT,\n    ea => [ea, path.join(ea, \"System32\"), path.join(ea, \"System32\", \"webm\")],\n    () => []\n  ),\n  \"C:\\\\cygwin64\\\\bin\"\n])\n\n// exported for tests:\nexport const DefaultPaths = Object.freeze(\n  isDocker()\n    ? DefaultDockerPaths\n    : isWin\n    ? DefaultWinPaths()\n    : isMac\n    ? DefaultMacOSPaths\n    : DefaultPosixPaths\n)\n","import {\n  AsyncSubscription,\n  Event,\n  subscribe,\n  SubscribeCallback\n} from \"@parcel/watcher\"\nimport { Stats } from \"fs\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { EndableRank, EndableRanks } from \"../async/Endable\"\nimport { EndableWrapper } from \"../async/EndableWrapper\"\nimport { filterAsync } from \"../async/Promise\"\nimport { onError } from \"../error/OnError\"\nimport { FifoCache } from \"../FifoCache\"\nimport { mkLogger } from \"../Logger\"\nimport { mkdirp_ } from \"./Path\"\nimport { SimpleFileOrString, toNativePath_ } from \"./SimpleFile\"\nimport { statEql, statMaybe } from \"./Stat\"\nimport { WipPrefix } from \"./WIP\"\n\nexport type FsEventListener = (events: Event[]) => any\n\nconst logger = lazy(() => mkLogger(\"fs.DirWatcher\"))\n\n// TODO: ADD TESTS!\n\nexport class DirWatcher extends EndableWrapper {\n  static async for(\n    dir: SimpleFileOrString,\n    cb: SubscribeCallback,\n    rank = EndableRanks.first\n  ) {\n    const nativePath = toNativePath_(dir)\n    await mkdirp_(nativePath)\n\n    const path2stat = new FifoCache<Maybe<Stats>>(1024)\n    const sub = await subscribe(nativePath, async (err, arr) => {\n      logger().trace(\"callback\", { nativePath, err, arr })\n      if (err != null) {\n        onError(\"FsWatcher error\", { cause: err, path: nativePath })\n      }\n      if (arr != null) {\n        // don't ignore delete events: FsLock wants to know!\n\n        // ignore WIPs and unchanged files:\n        arr = await filterAsync({\n          name: this.name,\n          arr,\n          f: async ea => {\n            if (ea.path.includes(WipPrefix)) return false\n            const prior = path2stat.get(ea.path)\n            const current = await statMaybe(ea.path)\n            if (true === current?.isFile() && statEql(prior, current)) {\n              // only skip _files_ that didn't change\n              return false\n            } else {\n              path2stat.set(ea.path, current)\n              return true\n            }\n          }\n        })\n      }\n      if (err != null || isNotEmpty(arr)) cb(err, arr)\n    })\n\n    return new DirWatcher(nativePath, sub, path2stat, rank)\n  }\n\n  private constructor(\n    readonly nativePath: string,\n    readonly subscription: AsyncSubscription,\n    readonly path2stat: FifoCache<Maybe<Stats>>,\n    rank?: EndableRank\n  ) {\n    super(\"fs.DirWatcher(\" + nativePath + \")\", () => this.close(), rank)\n  }\n\n  clear() {\n    this.path2stat.clear()\n  }\n\n  readonly close = lazy(() => this.subscription.unsubscribe())\n}\n","import fs from \"fs\"\nimport * as fse from \"fs-extra\"\nimport { join, parse, sep } from \"path\"\nimport { inspect } from \"util\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { MaybeSyncOrAsync, SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { toA } from \"../../fe/toA\"\nimport { mkLogger } from \"../Logger\"\nimport { stripSuffix } from \"../String\"\nimport { thenMap } from \"../async/Promise\"\nimport { ee } from \"../event/EventEmitter\"\nimport { ParsedFile, parentBasename, parseNativePath } from \"./Path\"\nimport { readdir } from \"./Readdir\"\nimport { SimpleDirent, isSimpleDirent } from \"./SimpleDirent\"\nimport { SimpleFile, isSimpleFile } from \"./SimpleFile\"\nimport { stat_ } from \"./Stat\"\n\n// DON'T REFERENCE PosixFile HERE, you'll have circular deps.\n\nexport class StatDirent implements Partial<Pick<fs.Stats, \"size\" | \"mtimeMs\">> {\n  readonly isFile: boolean\n  readonly isDirectory: boolean\n  size: Maybe<number>\n  mtimeMs: Maybe<number>\n  // Allow the Stats instance to be GC'ed by copying what I need out of it:\n  constructor(\n    readonly base: string,\n    s: fs.Stats | fs.Dirent | SimpleDirent\n  ) {\n    if (isSimpleDirent(s)) {\n      // TODO: assert that base === s.basename\n      this.isFile = s.isFile\n      this.isDirectory = s.isDirectory\n    } else {\n      this.isFile = s.isFile()\n      this.isDirectory = s.isDirectory()\n      // isSymbolicLink is always false unless you use lstat, which we never use.\n    }\n    if (s instanceof fs.Stats) {\n      this.size = s.size\n      this.mtimeMs = s.mtimeMs\n    }\n  }\n}\n\nconst logger = lazy(() => mkLogger(\"fs.DirectoryEntry\"))\n\nexport class DirectoryEntry implements ParsedFile, SimpleFile {\n  /**\n   * Full path\n   */\n  readonly nativePath: string\n\n  /**\n   * @return extension (`.jpg` for `image.jpg`)\n   */\n  readonly ext: string\n\n  /**\n   * Should only be constructed by BaseFile\n   *\n   * @param dir The full parent directory path such as `/home/user/dir` or\n   * `c:\\\\path\\\\dir` for `/home/user/dir/file.txt` or `c:\\\\path\\\\dir\\\\file.txt`\n   */\n  constructor(\n    readonly dir: string,\n    public dirent: StatDirent\n  ) {\n    this.nativePath = join(this.dir, dirent.base)\n    this.ext = parseNativePath(dirent.base).ext\n  }\n\n  static fromSimpleDirent(dir: string, dirent: SimpleDirent) {\n    return new DirectoryEntry(dir, new StatDirent(dirent.basename, dirent))\n  }\n\n  static async for(\n    nativePathOrFile: string | SimpleFile\n  ): PromiseMaybe<DirectoryEntry> {\n    try {\n      return await this.for_(nativePathOrFile)\n    } catch {\n      return\n    }\n  }\n\n  static async for_(\n    nativePathOrFile: string | SimpleFile\n  ): Promise<DirectoryEntry> {\n    const { nativePath, dir, base } = isSimpleFile(nativePathOrFile)\n      ? nativePathOrFile\n      : { nativePath: nativePathOrFile, ...parseNativePath(nativePathOrFile) }\n\n    const s = await fse.stat(nativePath)\n    return new DirectoryEntry(dir, new StatDirent(base, s))\n  }\n\n  clear() {\n    ee().emit(\"fileChanged\", this.nativePath)\n    this.dirent.size = undefined\n    this.dirent.mtimeMs = undefined\n    return this\n  }\n\n  async join(...path: string[]) {\n    return DirectoryEntry.for(join(this.nativePath, ...path))\n  }\n\n  /**\n   * @return the full basename `image.jpg`\n   */\n  get base() {\n    return this.dirent.base\n  }\n\n  /**\n   * @return basename without the ext (`image` for `image.jpg`)\n   */\n  get name() {\n    return stripSuffix(this.base, this.ext)\n  }\n\n  get pathnames(): string[] {\n    return this.nativePath.split(sep)\n  }\n\n  get parentAndBase(): string {\n    return this.pathnames.slice(-2).join(\"/\")\n  }\n\n  get parentBasename(): string {\n    return parentBasename(this.nativePath)\n  }\n\n  toJSON() {\n    return {\n      _ctor: this.constructor.name,\n      nativePath: this.nativePath\n    }\n  }\n\n  toLogJSON() {\n    return this.nativePath\n  }\n\n  [inspect.custom]() {\n    return this.toJSON()\n  }\n\n  toString() {\n    return this.nativePath\n  }\n\n  isFile() {\n    return this.dirent.isFile\n  }\n\n  isFileSync() {\n    return this.dirent.isFile\n  }\n\n  isDirectory() {\n    return this.dirent.isDirectory\n  }\n\n  isDirectorySync() {\n    return this.dirent.isDirectory\n  }\n\n  get isRoot() {\n    return this.dir === parse(this.dir).dir\n  }\n\n  isNameHidden() {\n    return this.name.startsWith(\".\")\n  }\n\n  parent(): SyncOrAsync<Maybe<this>> {\n    const p = parseNativePath(this.dir)\n    return p.dir === this.dir\n      ? this // root\n      : (new DirectoryEntry(p.dir, {\n          base: p.base,\n          isFile: false,\n          isDirectory: true,\n          mtimeMs: undefined as any,\n          size: undefined as any\n        }) as this)\n  }\n\n  async childNames() {\n    try {\n      return !this.isDirectory()\n        ? undefined\n        : (await readdir(this.nativePath))?.map(ea => ea.basename)\n    } catch (err) {\n      logger().warn(\n        \"childNames() failed to readdir(\" + this.nativePath + \")\",\n        err\n      )\n      return\n    }\n  }\n\n  async children() {\n    try {\n      if (!this.isDirectory()) return undefined\n      const arr = await readdir(this.nativePath) // readdir is already sorted\n      return arr?.map(\n        ea => DirectoryEntry.fromSimpleDirent(this.nativePath, ea) as this\n      )\n    } catch (err) {\n      logger().warn(\n        \"children() failed to readdir(\" + this.nativePath + \")\",\n        err\n      )\n      return\n    }\n  }\n\n  childrenSync() {\n    try {\n      if (!this.isDirectory()) return undefined\n      const arr = fs.readdirSync(this.nativePath, { withFileTypes: true }) // readdir is already sorted\n      return arr?.map(\n        ea => new DirectoryEntry(this.nativePath, new StatDirent(ea.name, ea))\n      )\n    } catch (err) {\n      logger().warn(\n        \"children() failed to readdir(\" + this.nativePath + \")\",\n        err\n      )\n      return\n    }\n  }\n\n  async childDirectories() {\n    return toA(await this.children()).filter(ea => ea.isDirectory())\n  }\n\n  async childFiles() {\n    return toA(await this.children()).filter(ea => ea.isFile())\n  }\n\n  /**\n   * Depth-first\n   */\n  async visitDescendants(f: (child: this) => any): Promise<void> {\n    const children = await this.children()\n    if (children == null) return\n\n    for (const dir of children.filter(ea => ea.isDirectory())) {\n      await dir.visitDescendants(f)\n    }\n\n    for (const ea of children) {\n      if (ea.isFile()) {\n        await f(ea)\n      }\n    }\n\n    for (const ea of children) {\n      if (ea.isDirectory()) {\n        await f(ea)\n      }\n    }\n\n    return\n  }\n\n  visitDescendantsSync(f: (child: DirectoryEntry) => any): void {\n    const children = this.childrenSync()\n    if (children == null) return\n    for (const ea of children) {\n      if (ea.isFile()) f(ea)\n    }\n    for (const ea of children) {\n      if (ea.isDirectory()) {\n        ea.visitDescendantsSync(f)\n        f(ea)\n      }\n    }\n  }\n\n  async visitDescendantFiles(f: (child: this) => any): Promise<void> {\n    return this.visitDescendants(ea => (ea.isFile() ? f(ea) : undefined))\n  }\n\n  async filterDescendantFiles(\n    predicate: (child: this) => SyncOrAsync<boolean>\n  ) {\n    const arr: this[] = []\n    await this.visitDescendantFiles(async ea => {\n      if (true === (await predicate(ea))) arr.push(ea)\n    })\n    return arr\n  }\n\n  async stat() {\n    try {\n      const s = await stat_(this.nativePath)\n      this.dirent = new StatDirent(this.base, s)\n      return s\n    } catch {\n      return\n    }\n  }\n\n  size(): MaybeSyncOrAsync<number> {\n    // Try to reduce the number of promises we're making:\n    return this.dirent.size ?? thenMap(this.stat(), ea => ea.size)\n  }\n\n  mtimeMs(): MaybeSyncOrAsync<number> {\n    // Try to reduce the number of promises we're making:\n    return this.dirent.mtimeMs ?? thenMap(this.stat(), ea => ea.mtimeMs)\n  }\n\n  unlink_() {\n    ee().emit(\"fileChanged\", this.nativePath)\n    return fse.unlink(this.nativePath)\n  }\n\n  rmdir_() {\n    ee().emit(\"fileChanged\", this.nativePath)\n    return fse.rmdir(this.nativePath)\n  }\n}\n","import { sep } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { andList } from \"../../fe/FmtList\"\nimport { MemoizedThunk } from \"../../fe/Lazy\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { pick } from \"../../fe/Object\"\nimport { cmpArr } from \"../../fe/Primitive\"\nimport { Timeout, thenOrTimeout } from \"../../fe/ThenOrTimeout\"\nimport { plur } from \"../../fe/Units\"\nimport { toA } from \"../../fe/toA\"\nimport { partition } from \"../Array\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { countChars } from \"../String\"\nimport { errorToS } from \"../error/Error\"\nimport { isSidecarExt } from \"../fs/FileExt\"\nimport { Settings } from \"../settings/Settings\"\nimport { isSidecarOf } from \"../tags/Sidecars\"\nimport { isPosixMountpoint } from \"../volumes/Mountpoints\"\nimport { mkFolderUrl } from \"../web/WebUrls\"\nimport { isPaused } from \"../work/IsPaused\"\nimport { DirectoryEntry } from \"./DirectoryEntry\"\nimport { DirectoryWalker } from \"./DirectoryWalker\"\nimport { whyExcludedDirectory } from \"./Excluded\"\nimport { posixPathFrom, splitNativePath } from \"./Path\"\nimport { whyRejectFileSimple } from \"./PosixFileFilters\"\nimport {\n  SyncDirStates,\n  SyncFileStates,\n  SyncProgress,\n  syncReport\n} from \"./SyncReport\"\n\nexport interface Next {\n  done: boolean\n  skipped?: boolean\n}\n\nexport const Done: Next = { done: true }\nexport const Undone: Next = { done: false }\n\nconst ScannedPreviouslyMsg = \"this was scanned in a prior incomplete sync\"\n/**\n * Recurses through the given directory, sending files that may be eligible for\n * import to a given fileHandler, and finished directories to a\n * directoryListener.\n */\nexport class DirectoryIterator {\n  readonly name: string\n  readonly start = Date.now()\n  readonly #logger: Logger\n\n  readonly #pendingChildFiles: DirectoryEntry[] = []\n  readonly #enqueuedChildFiles: DirectoryEntry[] = []\n  readonly #sidecars: DirectoryEntry[] = []\n  readonly #pendingChildDirs: DirectoryEntry[] = []\n  #childDelegate?: DirectoryIterator\n  #done = false\n\n  #childFileCount = 0\n  #totalChildFileCount = 0\n  #childDirCount = 0\n  #totalChildDirCount = 0\n  #timeoutCount = 0\n\n  constructor(\n    readonly dir: DirectoryEntry,\n    readonly ctx: DirectoryWalker,\n    readonly parent?: DirectoryIterator\n  ) {\n    syncReport().onProgress({\n      path: dir.nativePath + sep,\n      from: \"DirectoryIterator\",\n      state: SyncDirStates.scanning\n    })\n    this.name = \"dir.DirectoryIterator(\" + dir + \")\"\n    this.#logger = mkLogger(this.name)\n  }\n\n  get isRoot(): boolean {\n    return this.parent == null\n  }\n\n  readonly rootDir: MemoizedThunk<DirectoryEntry> = lazy(\n    () => this.parent?.rootDir() ?? this.dir\n  )\n\n  readonly pathFromRoot = lazy(() => {\n    return posixPathFrom({ nativePath: this.rootDir().dir }, this.dir)\n  })\n\n  isDone(): boolean {\n    return this.#done\n  }\n\n  status() {\n    return {\n      root: this.rootDir().nativePath,\n      path: this.pathFromRoot(),\n      isDone: this.isDone()\n    }\n  }\n\n  cancel(s: Partial<SyncProgress>) {\n    // console.log(this.name + \".cancel()\", s)\n    if (!this.#done) {\n      this.#done = true\n      syncReport().onProgress({\n        path: this.dir.nativePath + sep,\n        from: \"DirectoryIterator\",\n        state: SyncDirStates.canceled,\n        ...s,\n        elapsedMs: Date.now() - this.start\n      })\n    }\n    return Done\n  }\n\n  depth() {\n    return countChars(this.dir.nativePath, sep)\n  }\n\n  readonly nextTimeout = lazy(\n    () =>\n      // the closer to a root, the more patient we are, so children can clean up\n      // gracefully:\n      Settings.statTimeoutMs.valueOrDefault +\n      clamp(0, 512, (512 - this.depth()) * 10)\n  )\n\n  /**\n   * @param untilTs run until the millisecond timestamp is less than Date.now()\n   * @throws if there are problems, even after retries.\n   */\n  // Note this doesn't need a mutex because the only consumer, DirectoryWalker,\n  // already only runs one at a time.\n  async next(untilTs: number) {\n    // console.log(this.name + \".next()\", {\n    //   runMs: Date.now() - untilTs,\n    //   this_done: this._done,\n    //   pending_files: this.pendingChildFiles.map(ea => ea.parentAndBase),\n    //   delegate_child: this.childDelegate?.dir.parentAndBase,\n    //   pending_dirs: this.pendingChildDirs.map(ea => ea.parentAndBase)\n    // })\n    try {\n      this.#logger.trace(\"next() starting\", { runMs: untilTs - Date.now() })\n      const result = await thenOrTimeout(\n        this.#next(untilTs),\n        this.nextTimeout()\n      )\n      this.#logger.trace(\"next() finished\", { result })\n      if (result === Timeout) {\n        this.#timeoutCount++\n        this.#logger.warn(\".next() timed out\", {\n          statTimeoutMs: Settings.statTimeoutMs.valueOrDefault,\n          timeoutCount: this.#timeoutCount\n        })\n        if (this.#timeoutCount > 3) {\n          this.#logger.warn(\n            \".next(): too many timeouts, giving up on this directory.\"\n          )\n          return this.cancel({\n            state: SyncDirStates.timeout,\n            details: \"Failed to scan, even after 3 retries\"\n          })\n        } else {\n          return Undone\n        }\n      } else {\n        this.#timeoutCount = 0\n        return result\n      }\n    } catch (error) {\n      this.#logger.warn(\"next() failed\", { error })\n      return this.cancel({\n        state: SyncDirStates.failed,\n        details: \"Error thrown during scan: \" + errorToS(error)\n      })\n    }\n  }\n\n  async #next(untilTs: number) {\n    return (\n      (this.#done ? Done : undefined) ??\n      // Don't maybeTimeout until maybeCompleteResult, to ensure we do at least a bit of work.\n      (await this.#isExcluded()) ??\n      (await this.#setupChildren()) ??\n      (await this.#maybePopChildFile(untilTs)) ??\n      (await this.#maybePopSidecar(untilTs)) ?? // sidecars after processing children, so only valid sidecars are reported.\n      (await this.#maybeDelegateToChildDir(untilTs)) ??\n      // (await this.maybeTimeout(untilTs)) ?? DON'T RESTORE THIS. this will make very short runtimes hang on slow hardware\n      (await this.#maybeCompleteResult())\n    )\n  }\n\n  readonly #isExcluded = lazy(async () => {\n    const details =\n      (await whyExcludedDirectory(this.dir)) ??\n      // we can't just exclude all mountpoints, because that would make\n      // mountpoints un-scannable.\n      (!this.isRoot && (await isPosixMountpoint(this.dir))\n        ? \"nested mountpoint\"\n        : undefined)\n\n    if (details != null) {\n      this.#logger.info(\"skipping ignorable dir, \" + this.dir, {\n        details: details\n      })\n      this.cancel({\n        state: SyncDirStates.skipped,\n        details\n      })\n      return Done\n    }\n    return // AKA continue\n  })\n\n  #maybeTimeout(untilTs: number): Next | undefined {\n    return this.ctx.ended\n      ? this.cancel({ details: \"DirectoryWalker was ended\" })\n      : this.#done\n      ? Done\n      : isPaused() || Date.now() > untilTs\n      ? Undone\n      : undefined\n  }\n\n  #shouldSkipChild(child: DirectoryEntry): boolean {\n    return this.#logger.tap({\n      msg: \"shouldSkipChild()\",\n      result:\n        isNotEmpty(this.ctx.startAtNativePath) &&\n        cmpArr(\n          splitNativePath(child.nativePath),\n          this.ctx.startAtNativePath,\n          false // shorterIsLessThan\n        ) <= 0,\n      meta: {\n        child: child.base\n      }\n    })\n  }\n\n  readonly #setupChildren = lazy(async () => {\n    const [skipped, children] = partition(toA(await this.dir.children()), ea =>\n      this.#shouldSkipChild(ea)\n    )\n\n    for (const ea of skipped) {\n      syncReport().onProgress({\n        path: ea.nativePath,\n        from: \"DirectoryIterator\",\n        state: SyncFileStates.skipped,\n        details: ScannedPreviouslyMsg\n      })\n    }\n\n    // NOTE: We aren't doing any child filtering here, because\n\n    // 1. filtering children can take time\n\n    // 2. reporting on files and directories should be done consistently, and\n    //    directories already are reported by this.isExcluded.\n\n    // Note that this isn't just a .partition, because .isFile() !== !.isDirectory()\n\n    this.#pendingChildDirs.push(...children.filter(ea => ea.isDirectory()))\n    this.#totalChildDirCount = this.#pendingChildDirs.length\n\n    const files = children.filter(ea => ea.isFile())\n\n    // (json is considered a sidecar type)\n    const [sidecars, nonSidecars] = partition(files, isSidecarExt)\n\n    this.#pendingChildFiles.push(...nonSidecars)\n    this.#sidecars.push(...sidecars)\n    this.#totalChildFileCount = this.#pendingChildFiles.length\n  })\n\n  async #maybePopChildFile(untilTs: number): PromiseMaybe<Next> {\n    const toAdd: DirectoryEntry[] = []\n    let timeout: Maybe<Next>\n\n    while (timeout == null && isNotEmpty(this.#pendingChildFiles)) {\n      const child = this.#pendingChildFiles.shift()!\n      // Always increment\n      this.#childFileCount++\n\n      // should we \"fast-forward\" to where we were before?\n      const whyReject = await whyRejectFileSimple(child)\n\n      if (whyReject != null) {\n        this.#logger.debug(\"maybePopChildFile()\", { child, whyReject })\n        syncReport().onProgress({\n          path: child.nativePath,\n          from: \"DirectoryIterator\",\n          state: SyncFileStates.rejected,\n          details: whyReject\n        })\n      } else {\n        // The file listener (AssetFileQueue or Precheck) will handle the sync\n        // report (if we do it here, we'll get multiple enqueue events):\n        toAdd.push(child)\n      }\n      // Putting this at the bottom of the loop ensures we process at least one\n      // child file. DON'T RETURN HERE, we may have files in toAdd!\n      timeout ??= this.#maybeTimeout(untilTs)\n      if (timeout != null) {\n        this.#logger.trace(\"maybePopChildFile() timeout\", { timeout })\n      }\n    }\n\n    if (isNotEmpty(toAdd)) {\n      this.#logger.trace(\"maybePopChildFile()\", { toAdd })\n      await this.ctx.fileHandler(toAdd)\n      this.#enqueuedChildFiles.push(...toAdd)\n    }\n    return timeout\n  }\n\n  async #maybePopSidecar(untilTs: number): PromiseMaybe<Next> {\n    while (isNotEmpty(this.#sidecars)) {\n      const sidecar = this.#sidecars.shift()!\n      if (Settings.tagAlbumFilenames.values.includes(sidecar.base)) {\n        syncReport().onProgress({\n          path: sidecar.nativePath,\n          from: \"DirectoryIterator\",\n          state: SyncFileStates.note,\n          details: \"sidecar will be checked for for album metadata\"\n        })\n      } else {\n        const src = this.#enqueuedChildFiles.filter(ea =>\n          isSidecarOf(ea, sidecar)\n        )\n        if (isNotEmpty(src)) {\n          // if this sidecar is for any of the enqueued child files, we're\n          // good\n          syncReport().onProgress({\n            path: sidecar.nativePath,\n            from: \"DirectoryIterator\",\n            state: SyncFileStates.note,\n            details:\n              \"sidecar will be processed with \" +\n              andList(src.map(ea => ea.base.normalize()))\n          })\n        } else {\n          syncReport().onProgress({\n            path: sidecar.nativePath,\n            from: \"DirectoryIterator\",\n            state: SyncFileStates.rejected,\n            details:\n              \"sidecar will be ignored (no importable file was found to be relevant to this sidecar's name)\"\n          })\n        }\n      }\n      // Remember that we don't need to _actually_ enqueue it. Sidecars are\n      // handled automatically.\n\n      // Putting this at the bottom of the loop ensures we process at least\n      // one sidecar.\n      const timeout = this.#maybeTimeout(untilTs)\n      if (timeout != null) {\n        this.#logger.trace(\"handleSidecars() timeout\", { timeout })\n        return timeout\n      }\n    }\n    return\n  }\n\n  async #maybeDelegateToChildDir(untilTs: number): PromiseMaybe<Next> {\n    let timeout: Maybe<Next>\n\n    while (\n      timeout == null &&\n      (this.#childDelegate != null || isNotEmpty(this.#pendingChildDirs))\n    ) {\n      if (this.#childDelegate == null) {\n        const child = this.#pendingChildDirs.shift()\n        if (child == null) {\n          // console.log(\"wat\")\n        } else {\n          this.#logger.trace(\"delegating to child dir, \" + child)\n          this.#childDirCount++\n          this.#childDelegate = new DirectoryIterator(child, this.ctx, this)\n        }\n      }\n\n      if (this.#childDelegate != null) {\n        const result = await this.#childDelegate.next(untilTs)\n        if (result?.done ?? this.#childDelegate?.isDone() === true) {\n          this.#childDelegate = undefined\n        }\n      }\n      // Putting this at the bottom of the loop ensures we process at least one\n      // child dir:\n      timeout = this.#maybeTimeout(untilTs)\n    }\n    return timeout\n  }\n\n  /**\n   * Note that as this method is the last in the chain, it must return a\n   * response.\n   */\n  async #maybeCompleteResult(): Promise<Next> {\n    if (\n      isNotEmpty(this.#pendingChildFiles) ||\n      isNotEmpty(this.#pendingChildDirs) ||\n      this.#childDelegate != null\n    ) {\n      this.#logger.error(\n        \"maybeCompleteResult: not done (?!)\",\n        pick(\n          this as any,\n          \"result\",\n          \"pendingChildren\",\n          \"childDelegate\",\n          \"pendingChildDirs\"\n        )\n      )\n      return Undone\n    } else {\n      if (!this.#done) {\n        this.#done = true\n        const uri = await mkFolderUrl(this.dir.nativePath)\n        const noSeed = uri?.with({ query: null })\n        const url = noSeed?.toString()\n        syncReport().onProgress({\n          path: this.dir.nativePath + sep,\n          state: SyncDirStates.scanned,\n          from: \"DirectoryIterator\",\n          details: `${this.#childFileCount}/${plur(\n            this.#totalChildFileCount,\n            \"file\"\n          )} and ${this.#childDirCount}/${plur(\n            this.#totalChildDirCount,\n            \"directory\",\n            \"directories\"\n          )}`,\n          url,\n          elapsedMs: Date.now() - this.start\n        })\n        await this.ctx.directoryListener(this.dir)\n      }\n\n      return Done\n    }\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { secondMs } from \"../../fe/Date\"\nimport { clamp } from \"../../fe/Number\"\nimport { isTest } from \"../NodeEnv\"\nimport { EndableRanks } from \"../async/Endable\"\nimport { EndableInterval } from \"../async/EndableInterval\"\nimport { oneAtATime } from \"../async/OneAtATime\"\nimport { Settings } from \"../settings/Settings\"\nimport { doNotRun } from \"../work/DoNotRun\"\nimport { DirectoryEntry } from \"./DirectoryEntry\"\nimport { DirectoryIterator } from \"./DirectoryIterator\"\nimport { containedByNativePath, splitNativePath } from \"./Path\"\n\n/**\n * Facades a DirectoryIterator to run periodically for only a set time slice.\n */\nexport class DirectoryWalker extends EndableInterval {\n  // lazy so tests can muck with it:\n  static IntervalMs = lazy(() => 2 * secondMs)\n\n  runMs: number\n\n  readonly highPriority = true // the only high priority chunked worker!\n  private readonly iterator: DirectoryIterator\n  readonly startAtNativePath?: string[]\n\n  constructor(\n    readonly root: DirectoryEntry,\n    readonly fileHandler: (files: DirectoryEntry[]) => any,\n    readonly directoryListener: (dir: DirectoryEntry) => any,\n    startAtNativePath?: string,\n    runMs?: number\n  ) {\n    super({\n      name: \"dir.DirectoryWalker(\" + root.nativePath + \")\",\n      callback: () => this.runChunk(),\n      intervalMs: DirectoryWalker.IntervalMs(),\n      rank: EndableRanks.first\n    })\n    this.runMs =\n      runMs ??\n      (clamp(1, 100, Settings.cpuBusyPercent.valueOrDefault) / 100) *\n        DirectoryWalker.IntervalMs()\n    if (startAtNativePath != null) {\n      if (\n        containedByNativePath({\n          ancestor: this.root.nativePath,\n          descendant: startAtNativePath\n        })\n      ) {\n        this.startAtNativePath = splitNativePath(startAtNativePath)\n      } else {\n        this.logger.error(\"bad startAtNativePath: ignoring.\", {\n          root: this.root.nativePath,\n          startAtNativePath\n        })\n      }\n    }\n    this.iterator = new DirectoryIterator(root, this)\n    void this.runChunk()\n  }\n\n  readonly runChunk = oneAtATime({\n    runLaterIfBusy: false,\n    fn: async () => {\n      if (!isTest && doNotRun(this)) return\n      const result = await this.iterator.next(Date.now() + this.runMs)\n      this.logger.debug(\"runSlice()\", { result })\n      if (result?.done === true) {\n        this.logger.info(\"runSlice(): completed iteration\")\n        void this.end()\n      }\n    }\n  })\n}\n","import path from \"path\"\nimport { leftPad } from \"../../fe/Pad\"\nimport { mkdirpSync_, mkdirp_, parseNativePath } from \"./Path\"\nimport { isEmptyFile } from \"./Stat\"\nimport { isEmptyFileSync } from \"./StatSync\"\n\nexport interface EnsureNewOptions {\n  nativePath: string\n  emptyIsNew?: boolean\n  maxVersions?: number\n  requireNumber?: boolean\n  leftPad?: number\n  startIndex?: number\n}\n\nexport const DefaultEnsureNewOptions: Omit<\n  Required<EnsureNewOptions>,\n  \"nativePath\"\n> = Object.freeze({\n  emptyIsNew: true,\n  maxVersions: 512,\n  requireNumber: false,\n  leftPad: 1,\n  startIndex: 1\n})\n\nexport async function ensureNewNativePath_(\n  arg: EnsureNewOptions\n): Promise<string> {\n  const opts: Required<EnsureNewOptions> = {\n    ...DefaultEnsureNewOptions,\n    ...arg\n  }\n  const p = parseNativePath(opts.nativePath)\n  await mkdirp_(p.dir)\n  {\n    if (!opts.requireNumber && (await isEmptyFile(opts.nativePath, opts))) {\n      return opts.nativePath\n    }\n  }\n  for (let i = opts.startIndex; i <= opts.maxVersions; i++) {\n    const f = path.join(\n      p.dir,\n      `${p.name}-${leftPad(i, opts.leftPad, \"0\")}${p.ext}`\n    )\n    if (await isEmptyFile(f, opts)) return f\n  }\n  throw new Error(\n    \"There are already more than \" + opts.maxVersions + \" of \" + opts.nativePath\n  )\n}\n\nexport function ensureNewNativePathSync_(arg: EnsureNewOptions): string {\n  const opts: Required<EnsureNewOptions> = {\n    ...DefaultEnsureNewOptions,\n    ...arg\n  }\n  const p = parseNativePath(opts.nativePath)\n  mkdirpSync_(p.dir)\n  if (!opts.requireNumber && isEmptyFileSync(opts.nativePath, opts)) {\n    return opts.nativePath\n  }\n  for (let i = opts.startIndex; i <= opts.maxVersions; i++) {\n    const f = path.join(\n      p.dir,\n      `${p.name}-${leftPad(i, opts.leftPad, \"0\")}${p.ext}`\n    )\n    if (isEmptyFileSync(f, opts)) return f\n  }\n  throw new Error(\n    \"There are already more than \" + opts.maxVersions + \" of \" + opts.nativePath\n  )\n}\n","import picomatch from \"picomatch\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks, uniq } from \"../../fe/Array\"\nimport { sort, sortBy } from \"../../fe/ArraySort\"\nimport { blank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { ellipsize, ensureSuffix } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { partition } from \"../Array\"\nimport { CaseInsensitiveMap } from \"../CaseInsensitiveMap\"\nimport { FifoCache } from \"../FifoCache\"\nimport { mkLogger } from \"../Logger\"\nimport { pairToObject } from \"../Object\"\nimport { thenNot } from \"../async/Promise\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { homeDir } from \"../dir/HomeDir\"\nimport { inHiddenPhotoStructureDir } from \"../dir/InHiddenPhotoStructureDir\"\nimport {\n  libraryDirPosixFile,\n  libraryOriginalsDirPosixFile\n} from \"../dir/LibraryDirs\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { isLinux, isWin } from \"../platform/Platform\"\nimport { PredicateBundle, Predicates } from \"../predicates/Predicates\"\nimport {\n  SyncPredicateBundle,\n  SyncPredicates\n} from \"../predicates/SyncPredicates\"\nimport { Settings } from \"../settings/Settings\"\nimport { actualPath } from \"./ActualPath\"\nimport { BaseFile } from \"./BaseFile\"\nimport { isHidden } from \"./Hidden\"\nimport { hasNoMedia } from \"./NoMedia\"\nimport { native2posix } from \"./PosixNative\"\nimport { seemsLikeSymlinkLoop } from \"./SeemsLikeSymlinkLoop\"\nimport { SimpleFile, SimpleFileOrString, isSimpleFile } from \"./SimpleFile\"\n\n/*\n * This is a steaming bag of whack-a-mole heuristics to prevent iterating\n * \"ignorable\" directories. These are OS or application directories which\n * frequently make up the bulk of files on many drives, but never include\n * assets that users want to include in their libraries.\n *\n * It's messy down here. Scroll down at your own peril.\n *\n * Because people access volumes with different OSes, we won't assume that a\n * given drive was used by the current OS, so \"C:\\\\etc\" on windows and\n * \"/Program Files/\" on mac should be considered ignorable directories, and be\n * skipped.\n *\n * Also: people's home directory and scan paths may be in \"ignorable\"\n * directories, but if they specifically ask to scan a directory, we should\n * scan it. That means we need a list of directories that won't be\n * ignored--but subdirectories that are ignorable _should_ be ignored. As an\n * example, if someone's name is \"cache\", /home/cache should not be ignored,\n * neither should /home/cache/pictures, but /home/cache/tmp can be ignored.\n */\n\nconst logger = lazy(() => mkLogger(\"fs.ExcludeGlobs\"))\n\nconst path2formattedPathForGlobCache = new FifoCache<string>(256)\n\nconst EndWithSepRe = /[\\\\/]$/\n\nexport function formatPathForGlob(f: SimpleFileOrString): string {\n  const str = toS(f)\n  const prior = path2formattedPathForGlobCache.get(str)\n  if (prior != null) return prior\n\n  const sf = isSimpleFile(f) ? f : BaseFile.for(f)\n  const isDir = EndWithSepRe.test(str) || sf.isDirectorySync()\n  const posixPath = native2posix(sf.nativePath)\n  const result = isDir ? ensureSuffix(posixPath, \"/\") : posixPath\n\n  path2formattedPathForGlobCache.set(str, result)\n  path2formattedPathForGlobCache.set(result, result)\n  path2formattedPathForGlobCache.set(sf.nativePath, result)\n\n  return result\n}\n\nclass Glob {\n  readonly reason: string\n  readonly re: Maybe<RegExp>\n  readonly bundle: PredicateBundle<SimpleFileOrString>\n  readonly valid: boolean\n  constructor(\n    readonly pattern: string,\n    readonly desc: string,\n    readonly exclude = true\n  ) {\n    if (pattern.includes(\"\\\\\")) {\n      const given = pattern\n      pattern = native2posix(given)\n      logger().warn(\n        \"globToPredicate(): backslash in patterns aren't supported: assuming you meant forward-slash?\",\n        { given, input: pattern }\n      )\n    }\n\n    // If desc is empty: \"not **/Trash/\"\n    // If desc is not empty: \"not QNAP Trash (**/@Trash/)\"\n\n    this.reason = compactBlanks([\n      this.exclude ? \"not\" : \"\",\n      desc,\n      \"(\" + ellipsize(pattern, 48, 12) + \")\"\n    ]).join(\" \")\n\n    try {\n      this.re = picomatch.makeRe(this.pattern, {\n        nocase: Settings.globsCaseInsensitive.valueOrDefault,\n        dot: true,\n        posixSlashes: true\n      })\n      this.valid = true\n    } catch (error) {\n      this.valid = false\n      logger().warn(\"Cannot parse pattern\", { glob: this.pattern, error })\n    }\n\n    this.bundle =\n      this.valid && this.re != null\n        ? pairToObject(this.reason, this.#apply.bind(this))\n        : {}\n  }\n\n  #apply(f: SimpleFileOrString) {\n    const posixPath = formatPathForGlob(f)\n    const matched = this.re!.test(posixPath) ?? this.exclude\n    return logger().tap({\n      msg: \"apply()\",\n      level: matched ? LogLevels.debug : LogLevels.trace,\n      result: matched ? !this.exclude : this.exclude,\n      meta: {\n        desc: this.desc,\n        pattern: this.pattern,\n        exclude: this.exclude,\n        posixPath,\n        matched\n      }\n    })\n  }\n}\n\nclass GlobSet {\n  readonly #globs: Glob[] = []\n\n  push(...globs: Glob[]) {\n    for (const glob of globs) {\n      if (!glob.valid) {\n        logger().warn(\"Ignoring invalid glob\", { glob })\n        continue\n      }\n      const prior = this.#globs.find(ea => ea.pattern === glob.pattern)\n      if (prior != null) {\n        logger().debug(\"Ignoring duplicate glob\", { glob, prior })\n        continue\n      }\n      this.#globs.push(glob)\n    }\n  }\n\n  pushNativePath(nativePath: string, description: string) {\n    this.push(new Glob(native2posix(nativePath), description))\n  }\n\n  toA() {\n    return this.#globs\n  }\n}\n\nconst HiddenFileGlob = new Glob(\"**/.*\", \"hidden file\")\nconst HiddenDirGlob = new Glob(\"**/.*/\", \"hidden directory\")\n\nconst defaultExcludeGlobs = lazy(() => {\n  const result = new GlobSet()\n\n  // hidden directories and files\n  result.push(HiddenDirGlob, HiddenFileGlob)\n\n  // ignorableRootDirectories\n  for (const ea of [\n    // See http://www.linfo.org/var.html\n    // https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard\n    // http://www.pathname.com/fhs/\n\n    // bin and boot don't have many files, let them get scanned\n    // \"boot\", // Boot loader files\n    { s: \"bin\", desc: \"command binary\" }, // Essential command binaries\n    { s: \"dev\", desc: \"device file\" }, // Essential device files\n    { s: \"etc\", desc: \"system configuration file\" }, // Host-specific system-wide configuration files\n    { s: \"initrd\", desc: \"initial ramdisk\" }, // initial ramdisk\n    // lib and lost+found is handled by ignored directory patterns\n    // { s: \"lib?(32|64|x64)\", desc: \"system library\" }, // Libraries essential for the binaries in /bin and /sbin.\n    // { s: \"lost+found\", desc: \"fsck recovered file\" },\n    { s: \"proc\", desc: \"process metadata\" }, // Virtual filesystem providing process and kernel information as files.\n    { s: \"sbin\", desc: \"system binary\" }, // Essential system binaries\n    { s: \"snap\", desc: \"snap software\" }, // https://en.wikipedia.org/wiki/Snap_(software)\n    { s: \"sys\", desc: \"system metadata\" }, // Contains information about devices, drivers, and some kernel features\n    // \"var\", < Some people mounted their docker volume to /var/photos:\n    // \"root\", // Home directory for the root user (might have something?},\n\n    // DON'T IGNORE /System/Volumes/Data : that's the user's homedir!\n    // DON'T INCLUDE /Volumes here, as that causes all external drives to be\n    // rejected!\n\n    // windows\n    { s: \"Dell\", desc: \"Windows driver\" },\n    { s: \"Drivers\", desc: \"Windows driver\" },\n    { s: \"Intel\", desc: \"Windows driver\" },\n    { s: \"Microsoft\", desc: \"Windows driver\" },\n    { s: \"NVIDIA\", desc: \"Windows driver\" }, // surprisingly large driver (> 4gb!},\n    { s: \"Windows.old\", desc: \"Windows system\" }, // thanks, windows updater\n    { s: \"Windows\", desc: \"Windows system\" }\n  ]) {\n    // ignorable root directory\n    // The * prefix handles drive letters:\n    // SKIP_DRIVE_PREFIXES\n    result.push(new Glob((isWin ? \"*\" : \"\") + \"/\" + ea.s + \"/\", ea.desc))\n  }\n\n  if (isWin) {\n    for (const ea of [\n      \"ProgramFiles\",\n      \"ProgramFiles(x86)\",\n      \"ProgramW6432\",\n      \"SystemRoot\",\n      \"windir\"\n    ] as const) {\n      const dir = getEnv(ea)\n      if (!blank(dir)) {\n        result.pushNativePath(dir, `%${ea}%`)\n      }\n    }\n  }\n\n  if (isLinux) {\n    result.push(new Glob(`${homeDir()}/snap/`, \"Snap software\"))\n  }\n  /*\n   * All these directories are sufficiently nerdy that they uniquely identify\n   * a system or development directory, and don't need to be anchored to root\n   * to be sufficiently constrained.\n   */\n  // \"Download\", // these might actually have something\n  // \"Downloads\",\n\n  for (const ea of [\n    { s: \"__MACOSX\", desc: \"macOS resource fork\" },\n    { s: \"_includes\", desc: \"code\" },\n    { s: \"@eaDir\", desc: \"Synology thumbnail\" },\n    { s: \"@Recently-Snapshot\", desc: \"QNAP snapshot\" },\n    { s: \"@Recycle\", desc: \"QNAP trash\" },\n    { s: \"@SynoResource\", desc: \"Synology metadata\" },\n    { s: \"#recycle\", desc: \"Synology trash\" },\n    { s: \"#snapshot\", desc: \"Synology snapshot\" },\n    { s: \"$Recycle.Bin\", desc: \"Windows trash\" },\n    { s: \"3rdParty\", desc: \"code\" },\n    { s: \"Application Data\", desc: \"Windows application support\" },\n    { s: \"Application Support\", desc: \"Windows application support\" },\n    { s: \"Applications\", desc: \"macOS Applications directory\" }, // macOS calls directories \"folders\"\n    { s: \"arangodb\", desc: \"3rd party\" },\n    { s: \"cache\", desc: \"Cache directory\" },\n    { s: \"CacheClip\", desc: \"Movie cache directory\" },\n    { s: \"caches\", desc: \"Cache directory\" },\n    { s: \"cmake\", desc: \"code\" },\n    { s: \"com.apple.TimeMachine.localsnapshots\", desc: \"macOS\" },\n    { s: \"cpan\", desc: \"code\" },\n    { s: \"DefinitelyTyped\", desc: \"TypeScript type\" }, // roughly infinite s}bdirectories\n    { s: \"Desktop DB\", desc: \"macOS metadata\" },\n    { s: \"Desktop DF\", desc: \"macOS metadata\" },\n    { s: \"Desktop.ini\", desc: \"macOS metadata\" },\n    { s: \"DisplayDriver\", desc: \"Windows driver\" },\n    { s: \"DLLs\", desc: \"Windows library\" },\n    { s: \"dyld\", desc: \"macOS library\" },\n    { s: \"ehthumbs.db\", desc: \"Windows thumbnail\" },\n    { s: \"i18n\", desc: \"i18n code\" },\n    { s: \"iMovie Cache\", desc: \"Apple iMovie cache\" },\n    { s: \"iTunes Cache\", desc: \"Apple iTunes\" },\n    { s: \"iTunes Media\", desc: \"Apple iTunes\" }, // music videos: see https://gitlab.com/mceachen/photostructure/issues/12\n    { s: \"iTunes\", desc: \"Apple iTunes\" },\n    { s: \"lib?(32|64|x64|s)\", desc: \"program library directory\" },\n    { s: \"lost+found\", desc: \"fsck recovered directory\" },\n    { s: \"macOS Install*\", desc: \"macOS installer\" },\n    { s: \"Network Trash\", desc: \"AFP trash\" },\n    { s: \"node_modules\", desc: \"Node.js library\" },\n    { s: \"pkgconfig\", desc: \"code\" },\n    { s: \"pkgs\", desc: \"Python code\" },\n    // { s: \"private\", < NO! This will cause us to not find AVCHD streams, which typically live in PRIVATE/AVCHD/STREAM/...\n    { s: \"Program Files?( x86)\", desc: \"Windows program\" },\n    { s: \"ProgramData\", desc: \"Windows application support\" },\n    { s: \"resources/media/face\", desc: \"face thumbnail\" },\n    { s: \"rubygems-*\", desc: \"Ruby code\" },\n    { s: \"site-packages\", desc: \"Python code\" },\n    { s: \"spotifycache\", desc: \"Spotify cache\" },\n    { s: \"SteamApps\", desc: \"Game files\" },\n    { s: \"System Volume Information\", desc: \"Windows system metadata\" },\n    { s: \"System32\", desc: \"Windows system\" },\n    { s: \"temp\", desc: \"temporary file\" },\n    { s: \"Temporary Items\", desc: \"temporary file\" },\n    { s: \"test_suite\", desc: \"code\" },\n    { s: \"testutil?(s)\", desc: \"code\" },\n    { s: \"third_party\", desc: \"code\" },\n    { s: \"Thumbnail?(s)\", desc: \"thumbnail\" }, // iPhoto\n    { s: \"Thumbs.db\", desc: \"Windows thumbnail\" },\n    { s: \"tmp\", desc: \"temporary file\" },\n    { s: \"Trash\", desc: \"trash directory\" }, // xdg trash https://specifications.freedesktop.org/trash-spec/trashspec-1.0.h}ml\n    { s: \"Windows10Upgrade\", desc: \"Windows upgrade\" },\n    { s: \"Xcode.app\", desc: \"macOS code\" },\n    { s: \"*.sparsebundle/bands\", desc: \"Time Machine backup\" }, // < mac time machine backups like \".../bob's mac.sparsebundle/bands/...\"\n    { s: \"ImageMagick*\", desc: \"ImageMagick source\" },\n    { s: \"Install OS X*\", desc: \"macOS installer\" },\n    { s: \"Install macOS*\", desc: \"macOS installer\" },\n    { s: \"*.lrdata\", desc: \"LightRoom data\" }, // lightroom\n    { s: \"MinGW*\", desc: \"code\" }, // MSYS and variants\n    { s: \"msys*\", desc: \"code\" } // msys or msys64\n  ]) {\n    // ignorable directory\n    result.push(new Glob(\"**/\" + ea.s + \"/\", ea.desc))\n  }\n\n  map(configDir(), ea =>\n    result.pushNativePath(ea, \"PhotoStructure configuration\")\n  )\n\n  // Some \"ignorable\" paths need more than just a single pathname to be sure it's\n  // ignorable. For example, just ignoring all folders named \"Library\" would not\n  // be safe.\n\n  function addIgnorableSubdirs(root: string, children: string[], desc: string) {\n    if (!blank(root)) {\n      const arr = sort(\n        uniq(compactBlanks(children).map(ea => ea.toLowerCase()))\n      )\n      if (arr.length === 1) {\n        result.push(new Glob(`**/${root}/${arr[0]}/`, desc))\n      }\n      if (arr.length > 1) {\n        result.push(new Glob(`**/${root}/(${arr.join(\"|\")})/`, desc))\n      }\n    }\n  }\n\n  addIgnorableSubdirs(\"nix\", [\"store\"], \"NixOS package\")\n\n  result.push(\n    new Glob(\n      \"**/*.(photo|photos|ap)library/!(master|masters|modified|original|originals)/\",\n      \"Apple Photos/Aperture library\"\n    )\n  )\n\n  result.push(new Glob(\"**/facetile*\", \"face thumbnail\"))\n\n  const subdirs = [\n    \"bin\",\n    \"cygdrive\",\n    \"dev\",\n    \"etc\",\n    \"games\",\n    \"include\",\n    \"lib?(32|64|x64)\",\n    \"local\",\n    \"locale\",\n    \"man\",\n    \"proc\",\n    \"sbin\",\n    \"share\",\n    \"src\",\n    \"tmp\",\n    \"usr\",\n    \"var\"\n  ]\n\n  addIgnorableSubdirs(\"usr\", subdirs, \"FHS system\")\n  addIgnorableSubdirs(\"cygwin?(64)\", subdirs, \"Cygwin\")\n  addIgnorableSubdirs(\"local\", subdirs, \"FHS system\")\n\n  // These can be found in backups:\n  addIgnorableSubdirs(\n    \"Windows\",\n    [\n      \"Boot\",\n      \"Containers\",\n      \"Cursors\",\n      \"Fonts\",\n      \"Help\",\n      \"Installer\",\n      \"Logs\",\n      \"Microsoft.NET\",\n      \"Servicing\",\n      \"SoftwareDistribution\",\n      \"System?(32)\",\n      \"SysWOW64\",\n      \"Temp\"\n    ],\n    \"Windows system directory\"\n  )\n\n  addIgnorableSubdirs(\n    \"lib\",\n    [\"firmware\", \"modules\", \"systemd\", \"udev\", \"x86_64-linux-gnu\"],\n    \"Linux system package\"\n  )\n  addIgnorableSubdirs(\"opt\", [\"google\", \"x11\", ...subdirs], \"FHS package\")\n\n  // git:\n  addIgnorableSubdirs(\"lfs\", [\"incomplete\", \"objects\"], \"Git LFS object\")\n\n  // https://www.tldp.org/LDP/sag/html/var-fs.html\n  const varDirs = [\n    \"cache\",\n    \"crash\",\n    \"games\",\n    \"lib\",\n    \"local\",\n    \"lock\",\n    \"log\",\n    \"logs\",\n    \"mail\",\n    \"run\",\n    \"snap\",\n    \"spool\",\n    \"tmp\"\n  ]\n  addIgnorableSubdirs(\"var\", varDirs, \"Linux /var\")\n  addIgnorableSubdirs(\"mnt\", varDirs, \"Linux /mnt\")\n\n  // linux backups:\n  addIgnorableSubdirs(\n    \"dev\",\n    [\n      \"block\",\n      \"bsg\",\n      \"bus\",\n      \"char\",\n      \"cpu\",\n      \"disk\",\n      \"dri\",\n      \"fd\",\n      \"hugepages\",\n      \"input\",\n      \"lightnvm\",\n      \"mapper\",\n      \"mqueue\",\n      \"net\",\n      \"pts\",\n      \"shm\",\n      \"snd\",\n      \"ubuntu-vg\",\n      \"usb\",\n      \"vfio\"\n    ],\n    \"Linux /dev backup\"\n  )\n\n  addIgnorableSubdirs(\n    \"proc\",\n    [\n      \"acpi\",\n      \"asound\",\n      \"bus\",\n      \"driver\",\n      \"fs\",\n      \"ipmi\",\n      \"irq\",\n      \"net\",\n      \"scsi\",\n      \"self\",\n      \"sys\",\n      \"sysvipc\",\n      \"thread-self\",\n      \"tty\"\n    ],\n    \"Linux /proc backup\"\n  )\n\n  // Mac /Library folders: sudo du -s /Library/* | sort -nr\n  addIgnorableSubdirs(\n    \"library\",\n    [\n      \"Accessibility*\",\n      \"AccessibilityBundles\",\n      \"Accounts\",\n      \"Address Book Plug-Ins\",\n      \"Apple\",\n      \"AppleMediaServices\",\n      \"Application Support\",\n      \"AssetCache\",\n      \"Assets\",\n      \"AssetsV2\",\n      \"AssetTypeDescriptors\",\n      \"Assistant\",\n      \"Audio\",\n      \"AWD\",\n      \"BridgeSupport\",\n      \"Bundles\",\n      \"CacheDelete\",\n      \"Caches\",\n      \"CardKit\",\n      \"Classroom\",\n      \"ColorPickers\",\n      \"Colors\",\n      \"ColorSync\",\n      \"Components\",\n      \"Compositions\",\n      \"ConfigurationProfiles\",\n      \"Contextual Menu Items\",\n      \"CoreAccessories\",\n      \"CoreAnalytics\",\n      \"CoreImage\",\n      \"CoreMediaIO\",\n      \"CoreServices\",\n      \"CryptoTokenKit\",\n      \"DefaultsConfigurations\",\n      \"Desktop Pictures\",\n      \"Developer\",\n      \"Dictionaries\",\n      \"DifferentialPrivacy\",\n      \"DirectoryServices\",\n      \"Display\",\n      \"Displays\",\n      \"DistributedEvaluation\",\n      \"Documentation\",\n      \"DriverExtensions\",\n      \"DTDs\",\n      \"DuetActivityScheduler\",\n      \"Extensions\",\n      \"FDR\",\n      \"FeatureFlags\",\n      \"Filesystems\",\n      \"Filters\",\n      \"Fonts\",\n      \"Frameworks\",\n      \"GPUBundles\",\n      \"Graphics\",\n      \"HIDPlugins\",\n      \"IdentityServices\",\n      \"Image Capture\",\n      \"Input Methods\",\n      \"InstallerSandboxes\",\n      \"InternetAccounts\",\n      \"Internet Plug-Ins\",\n      \"Isp\",\n      \"iTunes\",\n      \"Java\",\n      \"KerberosPlugins\",\n      \"KernelCollections\",\n      \"Kernels\",\n      \"Keyboard Layouts\",\n      \"Keychain\",\n      \"Keychains\",\n      \"LASecureIO\",\n      \"LaunchAgents\",\n      \"LaunchDaemons\",\n      \"Lexicons\",\n      \"LinguisticData\",\n      \"LocationBundles\",\n      \"LoginPlugins\",\n      \"Logs\",\n      \"MediaStreamPlugins\",\n      \"Messages\",\n      \"MessageTracer\",\n      \"Modem Scripts\",\n      \"MonitorPanels\",\n      \"MultiversePlugins\",\n      \"NetworkServiceProxy\",\n      \"OnBoardingBundles\",\n      \"OpenDirectory\",\n      \"OpenSSL\",\n      \"OSAnalytics\",\n      \"PairedSyncServices\",\n      \"Password Server Filters\",\n      \"PDF Services\",\n      \"Perl\",\n      \"PreferenceBundles\",\n      \"PreferencePanes\",\n      \"Preferences\",\n      \"PreferencesSyncBundles\",\n      \"Printers\",\n      \"PrivateFrameworks\",\n      \"PrivilegedHelperTools\",\n      \"Python\",\n      \"QuickLook\",\n      \"QuickTime\",\n      \"Receipts\",\n      \"Recents\",\n      \"Ruby\",\n      \"RunningBoard\",\n      \"Sandbox\",\n      \"ScreenReader\",\n      \"Screen Savers\",\n      \"Script Editor Plugins\",\n      \"ScriptingAdditions\",\n      \"Scripts\",\n      \"Security\",\n      \"Services\",\n      \"Sounds\",\n      \"Speech\",\n      \"SpeechBase\",\n      \"Spotlight\",\n      \"StagedDriverExtensions\",\n      \"StagedExtensions\",\n      \"StartupItems\",\n      \"SyncServices\",\n      \"SystemConfiguration\",\n      \"SystemExtensions\",\n      \"SystemMigration\",\n      \"SystemProfiler\",\n      \"Tcl\",\n      \"Templates\",\n      \"TextEncodings\",\n      \"TextInput\",\n      \"Trial\",\n      \"Updates\",\n      \"UserEventPlugins\",\n      \"UserNotifications\",\n      \"User Pictures\",\n      \"User Template\",\n      \"Video\",\n      \"VideoProcessors\",\n      \"WebServer\",\n      \"Widgets\",\n      \"xpc\"\n    ],\n    \"macOS Library\"\n  )\n\n  // from x64 mini's /Volumes/InstallESD:\n  addIgnorableSubdirs(\"packages\", [\"*.pkg\", \"*.mpkg\"], \"macOS package\")\n\n  // src trees:\n  addIgnorableSubdirs(\n    \"src/**\",\n    [\n      \"bin\",\n      \"ci\",\n      \"dist\",\n      \"doc?(s)\",\n      \"etc\",\n      \"lib?(s)\",\n      \"main\",\n      \"spec?(s)\",\n      \"src\",\n      \"test?(s)\",\n      \"tools\",\n      \"util\"\n    ],\n    \"code\"\n  )\n\n  addIgnorableSubdirs(\n    \"docs\",\n    [\"admin\", \"content\", \"general\", \"generated\", \"sql\"],\n    \"code\"\n  ) // docs\n  addIgnorableSubdirs(\n    \"pkg\",\n    [\n      \"acceptance\",\n      \"ccl\",\n      \"cli\",\n      \"cmd\",\n      \"server\",\n      \"sql\",\n      \"storage\",\n      \"ui\",\n      \"util\",\n      \"workload\"\n    ],\n    \"code\"\n  ) // cockroach\n\n  addIgnorableSubdirs(\n    \"osv\",\n    [\n      \"apps\",\n      \"arch\",\n      \"compiler\",\n      \"external\",\n      \"include\",\n      \"java\",\n      \"modules\",\n      \"musl\",\n      \"tests\"\n    ],\n    \"code\"\n  )\n\n  // Go installation has some ignorables:\n  addIgnorableSubdirs(\n    \"go\",\n    [\"bin\", \"blog\", \"cmd\", \"doc\", \"lib\", \"misc\", \"pkg\", \"src\", \"test\", \"vt\"],\n    \"code\"\n  )\n\n  // Perl\n  addIgnorableSubdirs(\n    \"Perl?(64)\",\n    [\"bin\", \"eg\", \"etc\", \"html\", \"lib\", \"site\"],\n    \"code\"\n  )\n  addIgnorableSubdirs(\n    \"Python*\",\n    [\"dlls\", \"doc?(s)\", \"include\", \"lib?(s)\", \"scripts\", \"tools\", \"tcl\"],\n    \"code\"\n  )\n\n  addIgnorableSubdirs(\n    \"Ruby*\",\n    [\"bin\", \"include\", \"lib\", \"msys*\", \"packages\", \"share\", \"ssl\"],\n    \"code\"\n  )\n\n  addIgnorableSubdirs(\n    \"msys*\",\n    [\"clang*\", \"dev\", \"etc\", \"mingw*\", \"tmp\", \"ucrt*\", \"var\"],\n    \"code\"\n  )\n\n  // Android SDK:\n  addIgnorableSubdirs(\n    \"sdk\",\n    [\n      \"build-tools\",\n      \"emulator\",\n      \"extras\",\n      \"patcher\",\n      \"platforms\",\n      \"platform-tools\",\n      \"sources\",\n      \"tools\"\n    ],\n    \"code\"\n  )\n\n  addIgnorableSubdirs(\"test\", [\"fixtures\"], \"code\") // no one will put their precious photos in \".../test/fixtures/...\". RIGHT?\n  addIgnorableSubdirs(\"data\", [\"$of\"], \"windows backup\") // windows 7-10 backup directories\n\n  addIgnorableSubdirs(\n    \"System\",\n    [\n      \"Applications\",\n      \"Developer\",\n      \"DriverKit\",\n      \"Library\",\n      \"iOSSupport\"\n      //Volumes, < DON'T IGNORE /System/Volumes/Data/Users is the homedir!\n    ],\n    \"macOS System\"\n  )\n\n  addIgnorableSubdirs(\n    \"contents\",\n    [\"frameworks\", \"plugins\", \"resources\", \"sharedsupport\"],\n    \"macOS application\"\n  ) // mac os app\n\n  addIgnorableSubdirs(\"pg\", [\"pgsql\"], \"code\") // PostgreSQL src\n\n  // Windows application data:\n  addIgnorableSubdirs(\n    \"appdata\",\n    [\"local\", \"locallow\", \"roaming\"],\n    \"Windows default AppData\"\n  )\n\n  addIgnorableSubdirs(\n    \"ps\",\n    [\"cache\", \"config\", \"logs\", \"tmp\"],\n    \"PhotoStructure docker directory\"\n  )\n\n  return result.toA()\n})\n\nconst clearCaches = () => {\n  excludeGlobs.unset()\n  excludeBundles.unset()\n}\n\nconst clearNotExcludedDirs = () => {\n  notExcludedDirs.unset()\n}\n\nconst watchSettings = lazy(() => {\n  Settings.excludeGlobsOmitDefaults.watchLater(clearCaches)\n  Settings.excludeGlobsAdd.watchLater(clearCaches)\n  Settings.excludeGlobsOmit.watchLater(clearCaches)\n  Settings.globsCaseInsensitive.watchLater(clearCaches)\n\n  Settings.libraryDir.watchLater(clearNotExcludedDirs)\n  Settings.originalsDir.watchLater(clearNotExcludedDirs)\n  Settings.scanPaths.watchLater(clearNotExcludedDirs)\n  Settings.argvScanPaths.watchLater(clearNotExcludedDirs)\n})\n\n// exposed for tests\nexport const defaultDirPredicates = lazy<PredicateBundle<SimpleFile>>(() => [\n  {\n    notSymlinkLoop,\n    notInHiddenPhotoStructureDir,\n    notNoMedia,\n    notHidden\n    // don't hide \"ignorable\" mountpoints!\n  }\n])\n\n// exposed for tests\nexport const defaultFilePredicates = lazy(() => [\n  { notInHiddenPhotoStructureDir }\n])\n\nexport const excludeGlobs = lazy(() => {\n  watchSettings()\n\n  const result = new CaseInsensitiveMap<Glob>()\n  function addGlob(glob: Glob) {\n    if (glob != null && glob.valid) {\n      const k = glob.pattern.trim()\n      if (result.has(k)) {\n        logger().warn(\"Duplicate glob:\", { glob })\n      }\n      result.set(k, glob)\n    }\n  }\n\n  function omitGlob(glob: string) {\n    const k = glob.trim()\n    if (!result.has(k)) {\n      logger().warn(\n        \"Failed to find and remove glob specified in PS_EXCLUDE_GLOBS_OMIT\",\n        { glob }\n      )\n    } else {\n      result.delete(k)\n    }\n  }\n\n  if (!Settings.excludeGlobsOmitDefaults.valueOrDefault) {\n    for (const ea of defaultExcludeGlobs()) {\n      addGlob(ea)\n    }\n  }\n  for (const glob of Settings.excludeGlobsOmit.values) {\n    omitGlob(glob)\n  }\n  for (const ea of Settings.excludeGlobsAdd.values) {\n    addGlob(new Glob(ea, \"(from PS_EXCLUDED_GLOBS_ADD)\"))\n  }\n  const arr = sortBy(result.values(), ea =>\n    compactBlanks(ea.pattern.toLowerCase().split(\"/\"))\n  )\n  const [dir, file] = partition(arr, ea => ea.pattern.endsWith(\"/\"))\n\n  return { dir, file }\n})\n\nexport const excludeBundles = lazy(() => {\n  const g = excludeGlobs()\n  return {\n    dir: [\n      ...defaultDirPredicates(),\n      ...g.dir.map(ea => ea.bundle)\n    ] as PredicateBundle<SimpleFileOrString>,\n    file: [\n      ...defaultFilePredicates(),\n      ...g.file.map(ea => ea.bundle)\n    ] as SyncPredicateBundle<SimpleFileOrString>\n  }\n})\n\nconst ifDisabled: SyncPredicateBundle<SimpleFileOrString> = [\n  { disableAllFilters: () => true }\n]\nconst ifBlank: SyncPredicateBundle<SimpleFileOrString> = [\n  { notBlank: () => false }\n]\n\nexport function notExcludedFilePredicates(\n  file: SimpleFileOrString\n): SyncPredicateBundle<SimpleFileOrString> {\n  return Settings.disableAllFilters.valueOrDefault\n    ? ifDisabled\n    : blank(file)\n    ? ifBlank\n    : excludeBundles().file\n}\n\nexport function whyExcludedFile(f: SimpleFileOrString): Maybe<string> {\n  return SyncPredicates.whyRejected(f, ...notExcludedFilePredicates(f))\n}\n\nexport function isExcludedFile(f: SimpleFileOrString): boolean {\n  return null != whyExcludedFile(f)\n}\n\nexport function notExcludedDirPredicates(\n  dir: SimpleFileOrString\n): PredicateBundle<SimpleFileOrString> {\n  return Settings.disableAllFilters.valueOrDefault\n    ? ifDisabled\n    : blank(dir)\n    ? ifBlank\n    : excludeBundles().dir\n}\n\nexport async function whyExcludedDirectory(\n  dir: SimpleFileOrString\n): PromiseMaybe<string> {\n  return Predicates.whyRejected(dir, ...notExcludedDirPredicates(dir))\n}\n\nexport async function isExcludedDirectory(\n  f: SimpleFileOrString\n): Promise<boolean> {\n  return null != (await whyExcludedDirectory(f))\n}\n\nexport const notExcludedDirs = lazy<Promise<string[]>>(async () => {\n  // yes we're uniq'ing twice here but it means we can hit actualPath in\n  // parallel and not waste time.\n  const arr = uniq(\n    compactBlanks([\n      libraryDirPosixFile(),\n      libraryOriginalsDirPosixFile(),\n      Settings.argvScanPaths.values,\n      Settings.scanPaths.values\n    ])\n  )\n  // Include both the resolved() path and the actualPath() for this list, just\n  // to make sure our bases are covered.\n  return logger().tap({\n    msg: \"notExcludedDirs() (these directories will never be excluded)\",\n    level: \"info\",\n    result: uniq([\n      ...arr,\n      ...(await Promise.all(arr.map(ea => actualPath(ea))))\n    ])\n  })\n})\n\nexport async function whyExcludedDirectoryRecursive(\n  dir: SimpleFile\n): PromiseMaybe<string> {\n  // We don't want to exclude the library directory or scanned paths for any\n  // reason--they might put it in some directory that we normally exclude, and\n  // we don't want to just prune out those patterns, as they should normally\n  // apply, so if we're in the library dir (or scanned directory), don't\n  // descend past that.\n  const doNotPassDirs = await notExcludedDirs()\n\n  for (\n    let ea: Maybe<SimpleFile> = dir;\n    ea != null && !ea.isRoot;\n    ea = await ea?.parent()\n  ) {\n    if (doNotPassDirs.includes(ea?.nativePath)) {\n      // Return now: don't check the directory, nor check ancestor directories.\n      return\n    }\n    const why = await whyExcludedDirectory(ea)\n    if (why != null) {\n      return why\n    }\n  }\n  return\n}\n\nfunction notSymlinkLoop(dir: SimpleFileOrString): boolean {\n  return !seemsLikeSymlinkLoop(dir)\n}\n\nfunction notNoMedia(dir: SimpleFileOrString) {\n  return thenNot(hasNoMedia(dir))\n}\n\nfunction notHidden(dir: SimpleFileOrString) {\n  return thenNot(isHidden(dir))\n}\n\nexport function notInHiddenPhotoStructureDir(dir: SimpleFileOrString) {\n  return !inHiddenPhotoStructureDir(dir)\n}\n","import { isNotEmpty } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { later } from \"../../fe/Delay\"\nimport { keys } from \"../../fe/Object\"\nimport { EndableRanks } from \"../async/Endable\"\nimport { EndableWrapper } from \"../async/EndableWrapper\"\nimport { ee } from \"../event/EventEmitter\"\nimport { FifoCacheAsync, FifoCacheAsyncOpts } from \"../FifoCacheAsync\"\nimport { mkLogger } from \"../Logger\"\nimport { mapEntries } from \"../Object\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\n\n// DEPLOOP DANGER: DON'T REFERENCE BASEFILE!\n\nexport const InstanceCacheMaxSize = 256\n\nexport interface CacheableFile {\n  clear(args?: { emit?: boolean }): this\n}\n\nexport function isCacheableFile(o: any): o is CacheableFile {\n  return typeof o === \"object\" && typeof o.clear === \"function\"\n}\n\nexport class FileCache<T> extends FifoCacheAsync<T> {\n  constructor(\n    opts: Partial<FifoCacheAsyncOpts> & Pick<FifoCacheAsyncOpts, \"name\">\n  ) {\n    super({\n      maxSize: InstanceCacheMaxSize,\n      timeoutMs: ShortCommandTimeoutMs,\n      ...opts\n    })\n\n    // break circular deps:\n    later(() => {\n      ee().on(\"fileChanged\", path => this.#clearFromPath(path))\n      ee().on(\"clearCache\", () => this.clear())\n\n      new EndableWrapper(\n        opts.name + \" stats\",\n        () => {\n          const s = mapEntries(this.stats(), (_, v) => (v > 0 ? v : undefined))\n          if (isNotEmpty(keys(s))) {\n            mkLogger(opts.name).info(\"stats\", s)\n          }\n        },\n        EndableRanks.stats\n      )\n    })\n  }\n\n  async #clearFromPath(fromPath?: string) {\n    if (blank(fromPath)) {\n      // full wipe: the singleton expectation can't/shouldn't be expected.\n      this.clear()\n    } else {\n      for (const k of this.cache.keys()) {\n        if (k.startsWith(fromPath)) {\n          const v = await this.cache.get(k) // values may be promises\n          if (isCacheableFile(v)) {\n            // NOTE: BaseFile and PosixFile instances are expected to be\n            // singletons for a given path, so if we remove the instance from\n            // here, they won't be singletons anymore: we just want to remove\n            // any cached state they currently have.\n            v.clear({ emit: false })\n          } else {\n            this.cache.delete(k)\n          }\n        }\n      }\n    }\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { dayMs, minuteMs } from \"../../fe/Date\"\nimport { clamp } from \"../../fe/Number\"\nimport { gt } from \"../../fe/Primitive\"\nimport { MaybeSyncOrAsync, SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { rateLimited } from \"../RateLimited\"\nimport { EndableRanks, ending } from \"../async/Endable\"\nimport { EndableInterval } from \"../async/EndableInterval\"\nimport { fmtFullDuration } from \"../date/DurationFormat\"\nimport { ee } from \"../event/EventEmitter\"\nimport { DirectoryEntry } from \"./DirectoryEntry\"\nimport { isNoMediaName } from \"./NoMedia\"\nimport { SimpleFile } from \"./SimpleFile\"\n\nexport class FileCleanup {\n  readonly #logger: Logger\n\n  constructor(\n    readonly name: string,\n    readonly rootNativePath: () => MaybeSyncOrAsync<string | SimpleFile>,\n    readonly staleMs: number,\n    readonly isPrunable?: (file: DirectoryEntry) => SyncOrAsync<boolean>\n  ) {\n    this.#logger = mkLogger(\"fs.FileCleanup(\" + name + \")\")\n  }\n\n  readonly intervalMs = lazy(() =>\n    clamp(isTest ? 0 : 5 * minuteMs, dayMs, this.staleMs / 2)\n  )\n\n  readonly scheduleInterval = lazy(\n    () =>\n      new EndableInterval({\n        name: this.name,\n        callback: () => this.cleanup(),\n        intervalMs: this.intervalMs(),\n        rank: EndableRanks.first\n      })\n  )\n\n  // We're using DirectoryEntries here, as we don't want anything that's cached,\n  // we want to minimize memory/object creation, and don't want to blow out the\n  // PosixFile caches:\n  readonly cleanup = rateLimited({\n    name: this.name,\n    minCallDelayMs: this.intervalMs() / 4,\n    f: async () => {\n      if (ending()) return\n      const r = await this.rootNativePath()\n      if (r == null) return []\n      const root = await DirectoryEntry.for(r)\n      if (root == null) {\n        // this.logger.debug(\"_cleanup(): no-op, root is null\", r)\n        return []\n      }\n\n      this.#logger.info(\"cleanup(): starting\", {\n        root,\n        staleMs: fmtFullDuration(this.staleMs, \" \")\n      })\n\n      const minFreshTs = Date.now() - this.staleMs\n      const victimDirs = new Set()\n      const prunedFiles: string[] = []\n      const prunedDirs: string[] = []\n      // this.logger.debug(\"_cleanup(): starting\", { root, maxTs })\n      await root.clear().visitDescendants(async f => {\n        // Don't delete the root .nomedia dir:\n        if (f.dir === root.nativePath && isNoMediaName(f.base)) return\n\n        // If we're a victim dir, ignore the mtime: we should still try to delete it.\n        const notVictimDir = !victimDirs.has(f.nativePath)\n        if (notVictimDir && gt(await f.mtimeMs(), minFreshTs)) {\n          return\n        }\n\n        if (f.isDirectory()) {\n          try {\n            // Rather than running readdir, just try unlinking:\n            await f.rmdir_()\n            prunedDirs.push(f.nativePath)\n            victimDirs.add(f.dir)\n            // this.logger.debug(\"_cleanup(): deleted \" + f)\n          } catch (err: any) {\n            if (err.code === \"ENOENT\") {\n              this.#logger.warn(\"cleanup(): ENOENT \" + f, err)\n              ee().emit(\"clearCache\")\n            }\n            if (err.code !== \"ENOTEMPTY\") {\n              this.#logger.warn(\"cleanup(): failed to rmdir \" + f, err)\n            }\n          }\n        } else if (this.isPrunable == null || (await this.isPrunable(f))) {\n          try {\n            await f.unlink_()\n            prunedFiles.push(f.nativePath)\n            victimDirs.add(f.dir)\n            // this.logger.debug(\"_cleanup(): unlinked \" + f)\n          } catch (err) {\n            this.#logger.warn(\"cleanup(): failed to clean up tmpfile \" + f, err)\n          }\n        } else {\n          // this.logger.debug(\"_cleanup(): not prunable: \" + f)\n        }\n      })\n      const result = [...prunedFiles, ...prunedDirs]\n      if (isNotEmpty(result)) {\n        root.clear()\n      }\n      this.#logger.info(\"cleanup(): done\", {\n        root,\n        pruned_file_count: prunedFiles.length,\n        pruned_dir_count: prunedDirs.length\n      })\n      return result\n    }\n  })\n}\n","import { Dirent } from \"fs\"\nimport { lazy } from \"../../core/Lazy\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { values } from \"../../fe/Object\"\nimport { toS } from \"../../fe/toS\"\nimport { MaybeFileish } from \"../fs/MaybeFileish\"\nimport { JpegExts } from \"./JpegExts\"\nimport { isSimpleFile } from \"./SimpleFile\"\n\nconst ShortExtRe = /(?:^\\.?|.\\.)([a-z\\d]{2,4})$/i\n\n/**\n * @return the file extension, in lower case, without a \".\" prefix. File\n * extensions longer than 4 characters are not supported.\n */\nexport function normalizeExt(ext: MaybeFileish): Maybe<string> {\n  ext = isSimpleFile(ext) ? ext.ext : ext instanceof Dirent ? ext.name : ext\n  const result = map(ShortExtRe.exec(toS(ext)), m => m[1])?.toLowerCase()\n  // hack to normalize all JPEG to \"jpg\"\n  return JpegExts.includes(result as any) ? \"jpg\" : result\n}\n\nexport function isExt(ext: MaybeFileish, ...exts: string[]): boolean {\n  ext = normalizeExt(ext)\n  return exts.some(ea => normalizeExt(ea) === ext)\n}\n\nexport function isJpegExt(ext: MaybeFileish): boolean {\n  return isExt(ext, ...JpegExts)\n}\nexport function isJsonExt(ext: MaybeFileish): boolean {\n  return isExt(ext, \"json\")\n}\nexport function isCsvExt(ext: MaybeFileish): boolean {\n  return isExt(ext, \"csv\")\n}\n\nexport const SidecarFiletypes = {\n  \"application/rdf+xml\": [\"xmp\"],\n  \"application/json\": [\"json\"],\n  \"application/x-mie\": [\"mie\"],\n  \"application/x-exif\": [\"exif\"],\n  \"application/vnd.apple.photos\": [\"aae\"],\n  \"image/x-exv\": [\"exv\"] // BOO it's not an image!\n} as const\n\nexport const SidecarExts = flatten(\n  values(SidecarFiletypes)\n) as unknown as string[]\n\n/**\n * Note that JSON is considered a sidecar type\n */\nexport function isSidecarExt(ext: MaybeFileish): boolean {\n  return isExt(ext, ...SidecarExts)\n}\n\nexport const extAliases = lazy(() => {\n  const result = new Map<string, string[]>()\n  for (const arr of [\n    JpegExts,\n    [\"tif\", \"tiff\"],\n    [\"heif\", \"heic\"],\n    [\"html\", \"htm\"],\n    [\"jp2\", \"jp2k\"]\n  ] as string[][]) {\n    for (const ea of arr) {\n      result.set(ea, arr)\n    }\n  }\n  return result\n})\n\nconst regexCache = new Map<string, RegExp>()\n\n/**\n * NOTE: Assumes exts doesn't need normalization, and comes directly from getExtInfo!\n */\nexport function mkExtsRegExp(exts: string[]): RegExp {\n  return getOrSet(\n    regexCache,\n    exts.join(\",\"),\n    () => new RegExp(\"\\\\.(?:\" + exts.join(\"|\") + \")$\", \"im\")\n  )\n}\n","import fs from \"fs\"\nimport { stat } from \"fs/promises\"\nimport { pick } from \"../../fe/Object\"\nimport { SimpleFileOrString, toNativePath_ } from \"./SimpleFile\"\n\nexport type FileStats = Pick<fs.Stats, \"size\" | \"mtimeMs\">\n\nexport async function fileStats_(f: SimpleFileOrString): Promise<FileStats> {\n  return pick((await stat(toNativePath_(f)))!, \"size\", \"mtimeMs\")\n}\n","import { FileTypeResult, fromBuffer } from \"file-type\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank, mapNotBlank } from \"../../fe/Blank\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { mkLogger } from \"../Logger\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { normalizeExt } from \"../fs/FileExt\"\nimport { readRawField } from \"../tags/ExifTool\"\nimport { mimetypeExt } from \"../tags/FileTypes\"\nimport { normalizeMimetype } from \"../tags/MimeTypes\"\nimport { PosixFile } from \"./PosixFile\"\nimport { readFilePart_ } from \"./ReadFilePart\"\nimport { exists } from \"./Stat\"\n\nconst logger = lazy(() => mkLogger(\"fs.FileType\"))\n\n// file-type doesn't handle these correctly:\nconst BadMimes = [\"image/tiff\", \"audio/mpeg\"]\n\n/**\n * You probably want readMimeType(), which tries to use existing ExifTool\n * caches first before falling back to calling this function.\n */\nexport async function readFileType_(\n  nativePath: string\n): PromiseMaybe<FileTypeResult> {\n  try {\n    // PERF: don't stat then read. Just hit it.\n    // We need to fetch at least 197 bytes to work with AVCHD properly:\n    const { buffer } = await readFilePart_({\n      nativePath,\n      position: 0,\n      length: 256\n    })\n    const result = await fromBuffer(buffer)\n    if (result != null && !BadMimes.includes(result.mime)) {\n      return {\n        ext: normalizeExt(result.ext) ?? result.ext,\n        mime: normalizeMimetype(result.mime)\n      } as FileTypeResult\n    }\n\n    // Don't bother exiftool if the file doesn't exist:\n    if (!(await exists(nativePath))) return\n\n    const mime = mapNotBlank(\n      await readRawField(nativePath, \"MIMEType\"),\n      normalizeMimetype\n    )\n    const ext = normalizeExt(PosixFile.for(nativePath)) ?? mimetypeExt(mime)\n    return blank(mime) || blank(ext)\n      ? undefined\n      : ({ ext, mime } as FileTypeResult)\n  } catch (cause: any) {\n    if (cause?.code === \"EISDIR\") {\n      return undefined\n    } else {\n      logger().warn(\"readFileType() failed for \" + nativePath, cause)\n      throw new WrappedError(\"Failed to read mimetype for \" + nativePath, {\n        cause,\n        ignorable: true,\n        retriable: false,\n        fatal: false,\n        path: nativePath\n      })\n    }\n  }\n}\n","import { map } from \"../../fe/Maybe\"\nimport { thenOrTimeout } from \"../../fe/ThenOrTimeout\"\nimport { sortIgnoreCase } from \"../String\"\nimport { shortFsStringSha } from \"../StringHash\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { FsLock } from \"./FsLock\"\nimport { PosixFile } from \"./PosixFile\"\n\nexport function defaultFsAdvisoryLockDir() {\n  return map(configDir(), ea => PosixFile.for(ea).join(\"advisory-locks\"))\n}\n\nexport async function withFsAdvisoryLocks_<T>({\n  name,\n  lockNames,\n  f,\n  timeoutMs,\n  lockDir = defaultFsAdvisoryLockDir()\n}: {\n  name: string\n  lockNames: string[]\n  f: () => Promise<T>\n  timeoutMs: number\n  lockDir?: PosixFile\n}): Promise<T> {\n  if (lockDir == null) return f()\n  await lockDir.mkdirp_()\n  const fsSafeLockNames = sortIgnoreCase(lockNames)\n  const locks = fsSafeLockNames.map(lockName =>\n    FsLock.for({\n      name: lockName,\n      file: lockDir.join(shortFsStringSha(lockName)),\n      timeoutMs\n    })\n  )\n  try {\n    for (const lock of locks) {\n      if (true !== (await thenOrTimeout(lock.acquire_(), timeoutMs))) {\n        throw new Error(\n          \"Failed to acquire lock for \" +\n            name +\n            \": \" +\n            lock.opts.name +\n            \" was busy\"\n        )\n      }\n    }\n    return await f()\n  } finally {\n    for (const lock of locks) {\n      lock.release()\n    }\n  }\n}\n","import { pidExists } from \"batch-cluster\"\nimport { Dirent } from \"fs\"\nimport fse from \"fs-extra\"\nimport { clearTimeout } from \"timers\"\nimport { compactBlanks, filterInPlace } from \"../../fe/Array\"\nimport { at } from \"../../fe/At\"\nimport { secondMs } from \"../../fe/Date\"\nimport { eql } from \"../../fe/Eql\"\nimport { fmtDuration } from \"../../fe/FmtDuration\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0, round, toInt } from \"../../fe/Number\"\nimport { randomFloat } from \"../../fe/Random\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { toS } from \"../../fe/toS\"\nimport { isTest } from \"../NodeEnv\"\nimport { escapeRegExp } from \"../RegExp\"\nimport { serviceName } from \"../ServiceNames\"\nimport { EndableRank, EndableRanks, ending } from \"../async/Endable\"\nimport { EndableWrapper } from \"../async/EndableWrapper\"\nimport { oneAtATime } from \"../async/OneAtATime\"\nimport { InternalErrorFlag } from \"../error/ErrorFlags\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { TokenRadix } from \"../math/Radix\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { BaseFile } from \"./BaseFile\"\nimport {\n  PsLockExt,\n  fsLockDir,\n  fsLockFileBasename,\n  isPsLockFileOrDir\n} from \"./FsLockDir\"\nimport { SimpleFileOrString, basename } from \"./SimpleFile\"\n\nexport interface FsLockOptions {\n  name?: string\n  file: BaseFile\n  /**\n   * If 0, no timeout\n   */\n  timeoutMs: number\n  noopIfContested?: boolean\n  /**\n   * If true, ignore fslock\n   */\n  skipFsLock?: boolean\n\n  endableRank?: EndableRank\n\n  /**\n   * If this is lock in a cache directory, don't bother running rmdir'ing the\n   * lock dir on release.\n   */\n  dirty?: boolean\n}\n\ntype VacuumArg = { vacuum: boolean }\n\nconst LastNumberRe = new RegExp(\"-(?<pid>\\\\d+)\" + escapeRegExp(PsLockExt) + \"$\")\n\n/**\n * FsLock is a filesystem-based advisory lock for a given file, where:\n *  - lock contention is expected both inter and intra processes\n *  - fair lock acquisition (first in, first served)\n *  - locks are only held temporarily\n *  - locks are held per given instance, not per process\n *\n * The instance that holds the lock is the instance whose filename is\n * alphabetically first in the lock dir.\n */\nexport class FsLock extends EndableWrapper {\n  static #lastUidTime: number = 0\n  static internalErrors = 0\n  static #instanceCount = 0\n\n  static newUid(pid = process.pid) {\n    // Make sure lastUidTime is always increasing:\n    this.#lastUidTime = Math.max(Date.now(), this.#lastUidTime + 1)\n    // The time uid MUST BE FIRST in the UID to ensure locks are acquired in\n    // temporal order:\n    return compactBlanks([\n      TokenRadix.encode(this.#lastUidTime), // filename-safe radix\n      serviceName.prior(),\n      toS(pid)\n    ]).join(\"-\")\n  }\n\n  static pidFromLockfile(lockfile: SimpleFileOrString | Dirent): Maybe<number> {\n    return FsLock.pidFromBasename(basename(lockfile))\n  }\n\n  static pidFromBasename(base: string): Maybe<number> {\n    return toInt(LastNumberRe.exec(toS(base))?.groups?.pid)\n  }\n\n  static #instances: FsLock[] = []\n\n  /**\n   * Use `FsLock.for()` instead of the constructor to ensure the same fslock\n   * instance is used for the same file\n   */\n  static for(opts: FsLockOptions): FsLock {\n    return (\n      this.#instances.find(ea => ea.opts.file === opts.file) ?? new FsLock(opts)\n    )\n  }\n\n  readonly #instanceId = ++FsLock.#instanceCount\n  readonly lockdir: BaseFile\n  #acquired = false\n  /** only set when acquisition is requested */\n  lockfile: Maybe<BaseFile>\n  #refreshTimer: Maybe<NodeJS.Timeout>\n  #rmLockdirLater: Maybe<NodeJS.Timeout>\n  #lastVacuumTs = Date.now()\n  readonly staleMs: number\n\n  constructor(readonly opts: FsLockOptions) {\n    super(\n      opts.name ?? \"FsLock\",\n      () => this.release(),\n      opts.endableRank ?? EndableRanks.postdb,\n      commandTimeoutMs()\n    )\n    this.lockdir = fsLockDir(this.opts.file)\n\n    if (opts.name == null) {\n      this.name =\n        \"fs.FsLock(\" + opts.file.baseWithGrandparent + \")#\" + this.#instanceId\n    }\n\n    // files should be checked for being stale at least once during the\n    // timeoutMs period. We make this a random period less than timeoutMs to\n    // avoid a thundering herd of processes all trying to vacuum at the same\n    // time.\n    this.staleMs = round(this.opts.timeoutMs / randomFloat(2, 4))\n    FsLock.#instances.push(this)\n  }\n\n  get acquired() {\n    return this.#acquired\n  }\n\n  toLogJSON() {\n    return {\n      name: this.name,\n      acquired: this.acquired\n    }\n  }\n\n  async #maybeVacuum(arg?: VacuumArg) {\n    const why =\n      true === arg?.vacuum\n        ? \"arg.vacuum\"\n        : gt0(this.staleMs) && Date.now() > this.#lastVacuumTs + this.staleMs\n        ? \"lastVacuumTs was too long ago\"\n        : undefined\n\n    return this.logger.tap({\n      msg: \"#maybeVacuum()\",\n      level: why == null ? \"trace\" : \"debug\",\n      result: why == null ? undefined : await this.#vacuum(),\n      meta: { why }\n    })\n  }\n\n  async #vacuum() {\n    this.#lastVacuumTs = Date.now()\n    const survivors: string[] = []\n\n    // NOTE: we don't no-op this whole section if #staleMs is 0, because we\n    // can still determine lockfiles are stale if their pid is gone.\n\n    const names = await this.#selfAndSiblingNames_()\n\n    for (const ea of names) {\n      const child = this.lockdir.join(ea)\n      if (gt0(this.staleMs)) {\n        const staleAt =\n          Math.round((Date.now() - (this.staleMs + secondMs)) / 1000) * 1000\n        const childMtimeMs = await child.mtimeMs({ refresh: true })\n        if (childMtimeMs != null && childMtimeMs < staleAt) {\n          this.logger.warn(\n            \"#vacuum(): child \" +\n              child.base +\n              \" is stale by \" +\n              fmtDuration(staleAt - childMtimeMs),\n            { staleMs: this.staleMs, childMtimeMs, staleAt }\n          )\n          await child.unlink()\n          continue\n        }\n      }\n      const pid = FsLock.pidFromLockfile(child)\n      if (pid == null) {\n        this.logger.error(\n          \"#vacuum(): Lockfile \" +\n            child.base +\n            \" has no pid.\" +\n            InternalErrorFlag\n        )\n        FsLock.internalErrors++\n        await child.unlink()\n        continue\n      }\n      if (!pidExists(pid)) {\n        this.logger.warn(\n          \"#vacuum(): Lockfile \" + child.base + \"'s pid is gone.\",\n          { pid }\n        )\n        await child.unlink()\n        continue\n      }\n      this.logger.debug(\n        \"#vacuum(): Lockfile \" + child.base + \" is still valid.\",\n        { pid }\n      )\n      survivors.push(ea)\n    }\n    return survivors\n  }\n\n  async #selfAndSiblingNames_() {\n    const arr = await fse.readdir(this.lockdir.nativePath, {\n      withFileTypes: true\n    })\n    return arr\n      .filter(ea => ea.isFile() && isPsLockFileOrDir(ea))\n      .map(ea => ea.name)\n  }\n\n  async selfAndSiblingNames_(arg?: VacuumArg): Promise<string[]> {\n    return (await this.#maybeVacuum(arg)) ?? this.#selfAndSiblingNames_()\n  }\n\n  async siblingNames(arg?: VacuumArg): Promise<string[]> {\n    return (await this.selfAndSiblingNames_(arg)).filter(\n      ea => ea !== this.lockfile?.base\n    )\n  }\n\n  async #iAmNext_(arg?: VacuumArg): Promise<boolean> {\n    if (this.lockfile == null) {\n      this.release()\n      return false\n    }\n    const children = await this.selfAndSiblingNames_(arg)\n    // someone can sneak into .release() while I was checking sibling names:\n    if (this.lockfile == null) {\n      this.release()\n      return false\n    }\n    if (!children.includes(this.lockfile.base)) {\n      if (isTest) {\n        FsLock.internalErrors++\n        this.logger.throw(\n          \"#iAmNext_(): missing lockfile, \" + this.lockfile + InternalErrorFlag,\n          { children, lockfile: this.lockfile }\n        )\n      } else {\n        this.release()\n        return false\n      }\n    }\n\n    const result = children[0] === this.lockfile.base\n    if (result) {\n      this.#acquired = true\n    } else {\n      // If the current owner is dead, vacuum.\n      if (arg?.vacuum !== true) {\n        const ownerPid = FsLock.pidFromBasename(children[0])\n        if (gt0(ownerPid) && !pidExists(ownerPid)) {\n          this.logger.info(\"#iAmNext_(): auto-vacuuming, owner pid is gone.\")\n          return this.#iAmNext_({ vacuum: true })\n        }\n      }\n    }\n    return this.logger.tap({\n      msg: \"#iAmNext_()\",\n      result,\n      meta: {\n        lockfiles: children\n      }\n    })\n  }\n\n  async iAmLast_(arg?: VacuumArg): Promise<boolean> {\n    return (\n      this.lockfile != null &&\n      at(await this.selfAndSiblingNames_(arg), -1) === this.lockfile.base\n    )\n  }\n\n  async iAmOnly_(arg?: VacuumArg): Promise<boolean> {\n    return (\n      this.lockfile != null &&\n      eql(await this.selfAndSiblingNames_(arg), [this.lockfile.base]) === true\n    )\n  }\n\n  readonly tryAcquire_ = oneAtATime<boolean>({\n    runLaterIfBusy: false,\n    undefinedIfBusy: true,\n    fn: async () => {\n      if (this.#acquired) return true\n      await (this.lockfile ??= this.lockdir.join(\n        fsLockFileBasename(FsLock.newUid())\n      )).touch_()\n      this.startRefreshTimer_()\n      try {\n        // something may have raced us to release() before we could check if\n        // we were next:\n        if (this.lockfile == null) return false\n        if (await this.#iAmNext_()) {\n          this.logger.debug(\"tryAcquire(): acquired\")\n          return true\n        }\n        return false\n      } catch (error) {\n        this.release()\n        this.logger.error(\"tryAcquire() failed\", error)\n        return false\n      }\n    }\n  })\n\n  startRefreshTimer_() {\n    if (this.#refreshTimer == null) {\n      if (this.staleMs > 0) {\n        const lockfileRefreshMs = Math.max(\n          // Make sure we refresh more frequently than the staleMs:\n          this.staleMs / 2,\n          // But not more than once a second:\n          isTest ? 10 : secondMs\n        )\n        this.#refreshTimer = setInterval(\n          () => this.#refreshLockfile_(),\n          lockfileRefreshMs\n        )\n      }\n    }\n  }\n\n  stopRefreshTimer() {\n    if (this.#refreshTimer != null) {\n      clearInterval(this.#refreshTimer)\n      this.#refreshTimer = undefined\n    }\n  }\n\n  async #refreshLockfile_() {\n    if (\n      this.lockfile == null ||\n      (await this.lockfile.notExists({ refresh: true }))\n    ) {\n      // This _shouldn't_ happen...\n      this.logger.warn(\"#refreshLockfile_(): null or missing lockfile\", {\n        lockfile: this.lockfile,\n        notExists: await this.lockfile?.notExists()\n      })\n      // But if it does, do the bookkeeping to make sure our state is in sync\n      // with the filesystem:\n      this.release()\n    } else {\n      try {\n        await this.lockfile.touch_()\n        this.logger.debug(\"#refreshLockfile_(): Touched lockfile\", {\n          lockfile: this.lockfile,\n          selfAndSiblings: await this.#selfAndSiblingNames_()\n        })\n      } catch (err) {\n        this.logger.warn(\"#refreshLockfile_(): failed, force-releasing.\", err)\n        this.release()\n        throw err\n      }\n    }\n  }\n\n  async acquire_({\n    releaseOnFailure = true,\n    timeoutMs = this.opts.timeoutMs\n  }: {\n    releaseOnFailure?: boolean\n    timeoutMs?: number\n  } = {}): Promise<boolean> {\n    if (this.#acquired) {\n      return true\n    }\n\n    try {\n      // Feeling lucky? (if this works, we can skip the fswatch!)\n      if (await this.tryAcquire_()) return true\n\n      await this.lockdir.watchUntil({\n        f: () => this.tryAcquire_(),\n        persistent: false,\n        recursive: false,\n        timeoutMs,\n        intervalMs: Math.round(Math.min(this.staleMs, timeoutMs) / 5)\n      })\n\n      if (!this.acquired && releaseOnFailure) {\n        this.release()\n      }\n      return this.acquired\n    } catch (error) {\n      if (releaseOnFailure) this.release()\n      this.logger.warn(\"acquire_() failed\", { error })\n      throw error\n    }\n  }\n\n  #rmLockDir() {\n    this.logger.debug(\"#rmLockDir() attempting lockdir rmdir...\", {\n      // This will fail if there is other contents (we're not calling .rmrf!)\n      success: this.lockdir.rmdirSync(\"trace\")\n    })\n  }\n\n  // sync to avoid concurrent state changes:\n  release(): boolean {\n    if (this.ended) {\n      filterInPlace(\n        FsLock.#instances,\n        ea => ea.#instanceId !== this.#instanceId\n      )\n    }\n    this.stopRefreshTimer()\n\n    // we set our state first, before we change the filesystem to make sure\n    // the lockfile refresher doesn't re-touch the lockfile:\n    this.#acquired = false\n\n    map(this.#rmLockdirLater, ea => clearTimeout(ea))\n\n    try {\n      // release is sync to avoid concurrent state changes:\n      this.lockfile?.unlinkSync(LogLevels.trace)\n      this.lockfile = undefined\n      this.logger.debug(\"#release() success\")\n      return true\n    } catch (err) {\n      this.logger.warn(\"#release() failed to delete lockfile\", err)\n      return false\n    } finally {\n      if (this.opts.dirty === true) {\n        // no need to do anything else.\n      } else if (ending() || this.ended) {\n        // Don't wait, just try now (which might fail, but who cares)\n        void this.#rmLockDir()\n      } else {\n        // Try to clean up the lockdir but only after a bit, to make sure there's\n        // no subsequent lock contention:\n        this.logger.debug(\"#release() scheduling lockdir cleanup\", {\n          ms: this.staleMs * 2\n        })\n        // unref'ed timer--it doesn't need to keep the process alive:\n        this.#rmLockdirLater = setTimeout(\n          () => this.#rmLockDir(),\n          this.staleMs * 2\n        )\n        this.#rmLockdirLater.unref()\n      }\n    }\n  }\n\n  /**\n   * @return undefined if the lock couldn't be acquired, or the result of f()\n   * @throws if f() throws\n   */\n  async withLock_<T>(f: (lock: FsLock) => T | Promise<T>): Promise<Maybe<T>> {\n    if (this.opts.skipFsLock === true) {\n      this.logger.debug(\"withLock(): skipLock is true, running f()\")\n      return f(this)\n    }\n    if (this.#acquired) {\n      // nested locks (!)\n      this.logger.debug(\"withLock() already acquired\")\n      return f(this)\n    }\n    try {\n      const acquired = await (this.opts.noopIfContested === true\n        ? this.tryAcquire_()\n        : this.acquire_())\n      this.logger.debug(\"withLock()\", { acquired })\n      if (acquired) {\n        return await thenOrTimeoutError(f(this), this.opts.timeoutMs, false)\n      } else {\n        return undefined\n      }\n    } catch (err) {\n      this.logger.warn(\"withLock_() rejected\", err)\n      throw err\n    } finally {\n      this.release()\n    }\n  }\n}\n\n/**\n * Two-phase lock. Try to make the .fslock dir, then write my id into the\n * lockdir. I only have the lock once I am the least-valued UID. Once I am\n * done with the lock, I remove my id file. If I am the last one in, I delete\n * the lockdir.\n *\n * Note that this lock is unique per call, per process--if the lock is already\n * acquired by a previous stackframe, this will deadlock.\n */\nexport async function withLock_<T>(\n  opts: FsLockOptions,\n  f: (lock?: FsLock) => T | Promise<T>\n): PromiseMaybe<T> {\n  if (opts.skipFsLock === true) return f()\n  const l = new FsLock(opts)\n  try {\n    return await l.withLock_(f)\n  } finally {\n    void l.end()\n  }\n}\n","import { Dirent } from \"fs\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { ensurePrefixSuffix } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { BaseFile } from \"./BaseFile\"\nimport { SimpleFileOrString, basename } from \"./SimpleFile\"\n\nexport const PsLockExt = \".pslock\"\n\nexport function fsLockDir(f: BaseFile): BaseFile {\n  return f.sibling(\n    ensurePrefixSuffix(f.base, { prefix: \".\", suffix: PsLockExt })\n  )\n}\n\nexport function fsLockFileBasename(id: string): string {\n  // The lockfiles don't need to be hidden, but it makes isPsLockFileOrDir()\n  // much simpler.\n  return ensurePrefixSuffix(id, { prefix: \".\", suffix: PsLockExt })\n}\n\nexport function uidFromFsLockfile(\n  f: Maybe<SimpleFileOrString | Dirent>\n): Maybe<string> {\n  if (f == null || blank(toS(f))) return\n  const name = basename(f)\n  return basenameIsPsLockFileOrDir(name)\n    ? name.substring(1, name.length - PsLockExt.length)\n    : undefined\n}\n\nexport function isPsLockFileOrDir(f: SimpleFileOrString | Dirent): boolean {\n  return blank(f) ? false : basenameIsPsLockFileOrDir(basename(f))\n}\n\nfunction basenameIsPsLockFileOrDir(name: string): boolean {\n  return notBlank(name) && name.startsWith(\".\") && name.endsWith(PsLockExt)\n}\n","import fs from \"fs\"\nimport fse from \"fs-extra\"\nimport { lazy } from \"../../core/Lazy\"\nimport { or } from \"../../fe/Boolean\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { eql } from \"../../fe/Eql\"\nimport { MemoizedThunk } from \"../../fe/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { pick } from \"../../fe/Object\"\nimport { thenOrTimeout, Timeout } from \"../../fe/ThenOrTimeout\"\nimport { debounce } from \"../async/Debounce\"\nimport { EndableRanks } from \"../async/Endable\"\nimport { EndableInterval } from \"../async/EndableInterval\"\nimport { oneAtATime } from \"../async/OneAtATime\"\nimport { ee } from \"../event/EventEmitter\"\nimport { diff } from \"../Set\"\nimport { Settings } from \"../settings/Settings\"\nimport { sortIgnoreCase } from \"../String\"\nimport { uid } from \"../UID\"\nimport { fileSha_ } from \"./Hash\"\nimport { PosixFile } from \"./PosixFile\"\nimport { SimpleFile, toNativePath_ } from \"./SimpleFile\"\nimport { statMaybe } from \"./Stat\"\nimport { statSync } from \"./StatSync\"\n\nexport const DefaultWatchedStatFields: (keyof fs.Stats)[] = [\n  \"ino\",\n  \"size\",\n  \"mtimeMs\",\n  \"birthtimeMs\"\n]\n\nclass WatchMgr extends EndableInterval {\n  static readonly instance = new WatchMgr()\n  readonly path2watcher = new Map<string, fs.FSWatcher>()\n  readonly id2watchers = new Map<string, FsWatcher>()\n\n  private constructor() {\n    super({\n      name: \"fs.WatchMgr\",\n      callback: () => this.vacuum(),\n      intervalMs: minuteMs,\n      unref: true\n    })\n    this.onEnds.push(() => {\n      for (const [k, v] of this.path2watcher) {\n        try {\n          v.close()\n        } catch (err) {\n          this.logger.warn(\"failed to close FsWatcher for \" + k, err)\n        }\n      }\n    })\n  }\n\n  vacuumEnded() {\n    for (const [id, w] of this.id2watchers) {\n      if (w.ended) this.id2watchers.delete(id)\n    }\n  }\n\n  registeredPaths() {\n    return new Set(\n      [...this.id2watchers.values()].map(ea => ea.target.nativePath)\n    )\n  }\n\n  watchedPaths() {\n    return [...this.path2watcher.keys()]\n  }\n\n  vacuum() {\n    this.vacuumEnded()\n    const oldPaths = diff(this.watchedPaths(), this.registeredPaths())\n    // remove any now-unwatched paths:\n    for (const k of oldPaths) {\n      try {\n        this.logger.warn(\"closing orphaned FsWatcher for \" + k)\n        this.path2watcher.get(k)?.close()\n        this.path2watcher.delete(k)\n      } catch (err) {\n        this.logger.warn(\"failed to close FsWatcher for \" + k, err)\n      }\n    }\n    const unwatchedPaths = diff(this.registeredPaths(), this.watchedPaths())\n    // Are there any paths we can watch now?\n    for (const np of unwatchedPaths) {\n      this.maybeWatch(np)\n    }\n\n    this.logger.debug(\"vacuum() complete\", {\n      watchedPaths: [...this.watchedPaths()],\n      registeredPaths: [...this.registeredPaths()],\n      oldPaths: [...oldPaths],\n      unwatchedPaths: [...unwatchedPaths]\n    })\n  }\n\n  maybeWatch(nativePath: string) {\n    if (this.watchersForPath(nativePath).length === 0) {\n      throw new Error(\"no registered watchers for \" + nativePath)\n    }\n    if (this.path2watcher.get(nativePath) != null) return\n\n    // only add a FSWatcher if the file or dir exists\n    if (fs.existsSync(nativePath)) {\n      const arr = this.watchersForPath(nativePath)\n      const persistent = or(arr.map(ea => ea.args.persistent))\n      this.logger.info(\"Setting up fs.watch for \" + nativePath)\n      const fsw = fs.watch(nativePath, { persistent }, () =>\n        this.onChange(nativePath)\n      )\n      this.path2watcher.set(nativePath, fsw)\n      fsw.on(\"close\", () => {\n        this.path2watcher.delete(nativePath)\n      })\n      fsw.on(\"error\", error => {\n        this.path2watcher.delete(nativePath)\n        this.logger.warn(\"fs.watch failed\", {\n          error,\n          watchers: this.watchersForPath(nativePath)\n            ?.filter(ea => !ea.ended)\n            .map(ea => ea.name)\n        })\n      })\n    }\n  }\n\n  registerWatcher(w: FsWatcher) {\n    this.id2watchers.set(w.id, w)\n    this.maybeWatch(w.target.nativePath)\n  }\n\n  watchersForPath(nativePath: string) {\n    const result: FsWatcher[] = []\n    for (const ea of this.id2watchers.values()) {\n      if (ea.target.eql(nativePath)) {\n        result.push(ea)\n      }\n    }\n    return result\n  }\n\n  onChange(nativePath: string) {\n    for (const ea of this.id2watchers.values()) {\n      if (ea.target.eql(nativePath)) {\n        ea.debouncedCheck()\n      }\n    }\n  }\n}\n\n// TODO: use https://www.npmjs.com/package/@parcel/watcher ?\n\nexport type FsWatcherArgs = ConstructorParameters<typeof FsWatcher>[0]\n\nexport class FsWatcher extends EndableInterval {\n  readonly id = uid()\n  readonly target: PosixFile\n  #partialStatPrior: Maybe<Partial<fs.Stats>>\n  #shaPrior: Maybe<string>\n  #childrenPrior: Maybe<string[]>\n\n  constructor(\n    readonly args: {\n      target: string | SimpleFile\n      onChange: () => void\n      maxPollIntervalMs: number\n      initialDelayMs?: number\n      sha?: boolean\n      watchDebounceMs?: number\n      applyOnChangeAtSetupIfExists?: boolean\n      applyOnChangeIfTargetMissing?: boolean\n      persistent?: boolean\n    }\n  ) {\n    super({\n      name: `fs.FileWatcher(${toNativePath_(args.target)})`,\n      callback: () => this.debouncedCheck(),\n      intervalMs: args.maxPollIntervalMs,\n      rank: EndableRanks.first,\n      initialDelayMs: args.initialDelayMs\n    })\n    this.target = PosixFile.for(args.target)\n\n    const watchDebounceMs =\n      args.watchDebounceMs ?? Settings.watchDebounceMs.valueOrDefault\n    const maxPollIntervalMs = args.maxPollIntervalMs\n    if (gt0(maxPollIntervalMs) && maxPollIntervalMs <= watchDebounceMs) {\n      args.maxPollIntervalMs = watchDebounceMs + 100\n      this.setIntervalMs(args.maxPollIntervalMs)\n      this.logger.error(\n        \"Bad configuration: watchDebounceMs must be less than maxPollIntervalMs. Increasing maxPollIntervalMs.\",\n        {\n          watchDebounceMs,\n          maxPollIntervalMs,\n          newMaxPollIntervalMs: args.maxPollIntervalMs\n        }\n      )\n    }\n    this.onEnds.push(() => {\n      this.reset()\n      later(() => WatchMgr.instance.vacuum())\n    })\n    this.logger.debug(\"new FsWatcher()\", {\n      watchDebounceMs,\n      maxPollIntervalMs: args.maxPollIntervalMs\n    })\n    void this.setup()\n    WatchMgr.instance.registerWatcher(this)\n  }\n\n  get nativePath() {\n    return this.target.nativePath\n  }\n\n  readonly setup: MemoizedThunk<Promise<FsWatcher>> = lazy(async () => {\n    const s = statSync(this.nativePath)\n    this.#partialStatPrior =\n      s == null ? undefined : pick(s, ...DefaultWatchedStatFields)\n    if (true === s?.isDirectory()) await this.#checkDirChanged()\n    if (true === s?.isFile()) await this.#checkFileChanged()\n    this.logger.info(\"setup()\", {\n      stat: this.#partialStatPrior,\n      sha: this.#shaPrior,\n      children: this.#childrenPrior\n    })\n    if (s != null && true === this.args.applyOnChangeAtSetupIfExists) {\n      this.args.onChange()\n    }\n    return this\n  })\n\n  // exposed for tests\n  get partialStatPrior() {\n    return this.#partialStatPrior\n  }\n\n  get debounceMs(): number {\n    return this.debouncedCheck.timeoutMs()\n  }\n\n  readonly debouncedCheck = debounce(\n    () => this.check(),\n    this.args.watchDebounceMs ?? Settings.watchDebounceMs.valueOrDefault\n  )\n\n  forcedCheck() {\n    this.debouncedCheck.reset()\n    return this.check.force()\n  }\n\n  async #checkDirChanged() {\n    const children = await thenOrTimeout(\n      fse.readdir(this.nativePath),\n      Settings.statTimeoutMs.valueOrDefault\n    )\n    if (children === Timeout) {\n      this.logger.warn(\"Failed to read directory: timeout\", {\n        timeoutMs: Settings.statTimeoutMs.valueOrDefault\n      })\n      this.#childrenPrior = undefined\n      return false\n    }\n    const now = sortIgnoreCase(children)\n    if (!eql(this.#childrenPrior, now)) {\n      this.logger.debug(\"checkDirChanged(): children changed\", {\n        now,\n        prior: this.#childrenPrior\n      })\n      this.#childrenPrior = now\n      return true\n    } else {\n      return false\n    }\n  }\n\n  async #checkFileChanged() {\n    if (true !== this.args.sha) return true\n    const sha = await fileSha_(this.nativePath).catch(() => undefined)\n    if (sha != null && sha === this.#shaPrior) {\n      return false\n    } else {\n      this.#shaPrior = sha\n      return true\n    }\n  }\n\n  // exposed for tests\n  readonly check = oneAtATime({\n    fn: async () => {\n      if (this.ended) return\n\n      this.logger.debug(\"check(): starting\", {\n        prior: this.#partialStatPrior\n      })\n\n      const partialStatPrior = this.#partialStatPrior\n      const statNow = await statMaybe(this.nativePath)\n\n      if (statNow == null) {\n        if (\n          this.#partialStatPrior != null &&\n          true === this.args.applyOnChangeIfTargetMissing\n        ) {\n          this.target.clear()\n          this.args.onChange()\n        }\n        this.logger.debug(\"check(): missing stat, closing file watcher\")\n        this.reset()\n        // file or directory onChange shouldn't care when target is deleted\n        return\n      }\n\n      later(() => WatchMgr.instance.registerWatcher(this))\n\n      const partialStatNow = pick(statNow!, ...DefaultWatchedStatFields)\n      const statEql = eql(partialStatPrior, partialStatNow)\n\n      // .stat() on directories may not change when children are added or deleted, so we always have to check:\n      const changed = statNow.isDirectory()\n        ? await this.#checkDirChanged()\n        : statEql\n        ? false\n        : statNow.isFile()\n        ? await this.#checkFileChanged()\n        : false\n\n      // this.logger.log(result ? LogLevels.debug : LogLevels.trace, \".check()\", {\n      this.logger.debug(\".check()\", {\n        changed,\n        partialStatNow,\n        partialStatPrior,\n        isDir: statNow.isDirectory(),\n        isFile: statNow.isFile()\n      })\n      if (changed) {\n        ee().emit(\"fileChanged\", this.nativePath)\n        this.#partialStatPrior = partialStatNow\n        this.args.onChange()\n      }\n    }\n  })\n\n  reset() {\n    // no infinite loops (where w.close() calls this.close()):\n    this.#partialStatPrior = undefined\n    this.#shaPrior = undefined\n    this.#childrenPrior = undefined\n  }\n}\n","import { blank, toNotBlank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { isString, stripPrefix } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { extractInt } from \"../Number\"\nimport { ParsedFile, parsePosixPath } from \"./Path\"\nimport { SimpleFile } from \"./SimpleFile\"\n\nconst CopiesRe = [\n  // macOS, when you copy-paste-paste, you get\n  // img.jpg\n  // img copy.jpg\n  // img copy 2.jpg\n  // img copy 3.jpg\n\n  // Windows, when you copy-paste-paste, you get\n  // img.jpg\n  // img - Copy.jpg\n  // img - Copy 2.jpg\n  // img - Copy 3.jpg\n  /\\s*(?:-\\s*)?copy(?:\\s*\\d{1,3}\\s*)?$/i,\n\n  // img - Copy (2).jpg\n  // img - Copy (3).jpg\n  // img - Copy (101).jpg\n  /\\s*(?:-\\s*)?copy\\s*\\(\\s*\\d{1,3}\\s*\\)$/i,\n\n  // Ubuntu when you copy-paste-paste-paste, you get\n  // img.jpg\n  // img (copy).jpg\n  // img (another copy).jpg // <-- srsly wth\n  // img (3rd copy).jpg\n  // img (4th copy).jpg\n  /\\s*\\((?:another|\\d+[a-z]{2})?\\s*copy\\)$/i,\n\n  // foobar(1).jpg\n  // foobar (1).jpg\n  // foobar ( 32 ).jpg\n  // foobar-(1).jpg\n  // foobar-( 32 ).jpg\n  /\\s*-?\\(\\s*\\d{1,4}\\s*\\)$/,\n\n  // frakkin google sidecars chop the right bit off the UUID.\n  // https://forum.photostructure.com/t/574/7\n\n  // The \"38\" means we leave a - on the end of UUIDs. That dash should make all\n  // other patterns not match, so this regex will be the only one applied.\n  /(?<=[\\da-f-]{37}-)[\\da-f-]+$/i,\n\n  // Variations added by EnsureNew.\n  // P432781234-1.jpg\n  // P432781234-01.jpg\n  // P432781234-001.jpg\n\n  /\\s*-\\s*\\d{1,3}$/\n]\n\nconst Copies2Re = [\n  ...CopiesRe,\n  // // img edit.jpg\n  // // img-edit.jpg\n  // // img edited.jpg\n  // // img-edited.jpg\n  /\\s*-?edit(?:ed)?$/i\n]\n\nexport const ymdIsoRE = /^(?:\\d\\d){1,2}-\\d\\d-\\d\\d$/\n\nexport function ciStablePosixPath(posixPath: string): string {\n  const path = posixPath.split(\"/\")\n  const basename = path.pop()\n  if (blank(basename)) return posixPath\n  const parsed = parsePosixPath(basename)\n  const strippedName = stripCopySuffixFromName(parsed, { aggressive: false })\n  return [...path, strippedName + parsed.ext].join(\"/\").normalize()\n}\n\n/**\n * @return the file's name, stripped of any suffixes due to copies. DOES NOT LOWER CASE OR NORMALIZE.\n */\nexport function stripCopySuffixFromName(\n  f: SimpleFile | ParsedFile | string,\n  opts: { aggressive: boolean } = { aggressive: true }\n): string {\n  return _stripCopySuffixFromName(\n    toNotBlank((f as any).name) ?? toS(f),\n    opts\n  ).normalize()\n}\n\nfunction _stripCopySuffixFromName(\n  initialName: string,\n  opts: { aggressive: boolean }\n): string {\n  // Don't touch yyyy-mm-dd:\n  if (ymdIsoRE.test(initialName)) return initialName\n  let name = initialName\n  for (const re of opts.aggressive ? Copies2Re : CopiesRe) {\n    const m = name.match(re)\n    if (gt0(m?.index)) {\n      const s = name.slice(0, m!.index).trim()\n      if (s.length > 0) name = s\n    }\n  }\n  // If you make a copy of a copy, you'll get \"image - Copy 2 - copy\". We\n  // don't want to hit the exported function, because then the file ext may be\n  // stripped multiple times.\n  return initialName === name\n    ? initialName\n    : _stripCopySuffixFromName(name, opts)\n}\n\nexport function copySuffixCountFromName(\n  f: string | SimpleFile | ParsedFile\n): Maybe<number> {\n  const name = (isString(f) ? f : f.name).toLowerCase().normalize()\n  const strip = stripCopySuffixFromName(name)\n  const stripped = stripPrefix(name.toLowerCase().normalize(), strip)\n  return map(extractInt(stripped), Math.abs)\n}\n\nconst burstRe = /burst\\s*([\\w-]{8,})\\s*$/i\n\nconst coverRe = /(?<=.{6})_cover$/i\n\n// https://en.wikipedia.org/wiki/Design_rule_for_Camera_File_system\n// IMG_E0001.JPG is an edited version of IMG_0001.JPG\nconst dscPrefixRe =\n  /^(?:dsc|dscf|img|gpfr|gopro?|gf|gh|gp|mov|mvi|mvimg|p|vid)[-_ ]{0,2}e?(\\d.+)$/i\nexport function stripDSC(f: SimpleFile | string): string {\n  let name = (isString(f) ? f : f.name).trim().replace(coverRe, \"\").trim()\n  map(burstRe.exec(name), m => (name = m[1].trim()))\n  map(dscPrefixRe.exec(name), m => (name = m[1].trim()))\n  return name\n}\n","import fs from \"fs\"\nimport { Transform, TransformCallback } from \"stream\"\nimport { pipeline } from \"stream/promises\"\nimport { toS } from \"../../fe/toS\"\nimport { LineReader } from \"./LineReader\"\nimport { SimpleFile, toNativePath_ } from \"./SimpleFile\"\nimport { WritableToBuffer } from \"./WritableToBuffer\"\n\nexport class GrepReader extends Transform {\n  constructor(\n    readonly pattern: RegExp,\n    readonly sep = \"\\n\"\n  ) {\n    super({ objectMode: false, autoDestroy: true })\n  }\n\n  _transform(chunk: any, _encoding: BufferEncoding, done: TransformCallback) {\n    const str = toS(chunk)\n    const m = str.match(this.pattern)\n    if (m != null) {\n      this.push(m[1] ?? m[0] + this.sep)\n    }\n    done()\n  }\n}\n\nexport async function fileGrep_(file: SimpleFile | string, pattern: RegExp) {\n  const output = new WritableToBuffer()\n  await pipeline([\n    fs.createReadStream(toNativePath_(file)),\n    new LineReader(),\n    new GrepReader(pattern),\n    output\n  ])\n  return (await output.buffer).toString()\n}\n","import _fs from \"fs\"\nimport _fse from \"fs-extra\"\nimport { pipeline } from \"stream/promises\"\nimport _zlib from \"zlib\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { escapeRegExp } from \"../RegExp\"\n\nexport async function gzip_(nativePath: string): Promise<string> {\n  if (nativePath.endsWith(\".gz\")) return nativePath\n  const out = nativePath + \".gz\"\n  await pipeline(\n    _fs.createReadStream(nativePath, { autoClose: true }),\n    _zlib.createGzip(),\n    _fs.createWriteStream(out, { autoClose: true })\n  )\n  await _fse.unlink(nativePath)\n  return out\n}\n\nexport function isExtOrCompressedExt(\n  actualExt: string,\n  expectedExt: string\n): boolean {\n  return matcherForExtOrCompressedExt(expectedExt)(actualExt)\n}\n\nconst extMatchers = new Map<string, (actualExt: string) => boolean>()\n\nexport function matcherForExtOrCompressedExt(\n  ext: string\n): (actualExt: string) => boolean {\n  return getOrSet(extMatchers, ext, () => {\n    const re = new RegExp(\"^\" + escapeRegExp(ext) + \"(?:\\\\.(gz|br))?$\", \"i\")\n    return (actualExt: string) => re.exec(actualExt) != null\n  })\n}\n","import crypto from \"crypto\"\nimport fs from \"fs\"\nimport { pipeline } from \"stream/promises\"\nimport { lazy } from \"../../core/Lazy\"\nimport { eql } from \"../../fe/Eql\"\nimport { stringify } from \"../../fe/JSON\"\nimport { pick } from \"../../fe/Object\"\nimport { FifoCacheAsync } from \"../FifoCacheAsync\"\nimport { HashBits } from \"../HashBits\"\nimport { mkLogger } from \"../Logger\"\nimport { shim1 } from \"../Shim1\"\nimport { stringShaToBuffer } from \"../StringHash\"\nimport { FileStats, fileStats_ } from \"./FileStats\"\nimport { SimpleFileOrString, toNativePath_ } from \"./SimpleFile\"\nimport { stat_ } from \"./Stat\"\n\nconst logger = lazy(() => mkLogger(\"fs.Hash\"))\n\nexport interface ShaMeta {\n  sha: string\n  stats: FileStats\n  elapsedMs: number\n}\n\nconst cache = lazy(\n  () =>\n    // we're not using a FileCache here, because SHAs are so expensive we want\n    // to manage cache invalidation ourselves.\n    new FifoCacheAsync<ShaMeta>({\n      name: \"fs.fileSha\",\n      maxSize: 512,\n      timeoutMs: 0, // TODO: we should be able to read any file in under a minute? What about videos?\n      clearEveryMs: 0 // no periodic clearing--no need, we're bounded to 512\n    })\n)\n\n/**\n * Consumers should not directly call this: use {@link fileSha_()} instead.\n * @return a Buffer with the first 192 bits of a SHA512 digest.\n * @throws on read error\n */\nexport const shimmedFileSha_ = shim1({\n  name: \"fs.Hash\",\n  cache,\n  impl: uncachedFileSha_\n})\n\n/**\n * Automatically invalidates SHAs whose stats have changed.\n */\nexport async function fileShaMeta_(\n  f: SimpleFileOrString,\n  { autoInvalidate = true }: { autoInvalidate?: boolean } = {}\n): Promise<ShaMeta> {\n  const nativePath = toNativePath_(f)\n  if (autoInvalidate) {\n    const prior = cache().get(nativePath)\n    if (prior != null) {\n      if (eql(prior.stats, await fileStats_(f))) {\n        logger().debug(\"fileSha_() cache matches current Stats\", {\n          nativePath,\n          prior\n        })\n        return prior\n      } else {\n        logger().debug(\"fileSha_() prior cache is invalid, re-reading SHA\", {\n          nativePath,\n          prior\n        })\n        cache().delete(nativePath) // prior sha is invalid!\n      }\n    }\n  }\n  return shimmedFileSha_(f)\n}\n\n/**\n * Automatically invalidates SHAs whose stats have changed.\n */\nexport async function fileSha_(f: SimpleFileOrString): Promise<string> {\n  return (await fileShaMeta_(f)).sha\n}\n\n/**\n * Uncached file SHA. Throws on error.\n */\nexport async function uncachedFileSha_(f: SimpleFileOrString) {\n  const start = Date.now()\n  const nativePath = toNativePath_(f)\n  return {\n    sha: await streamSha_(fs.createReadStream(nativePath)),\n    stats: pick(await stat_(nativePath), \"size\", \"mtimeMs\"),\n    elapsedMs: Date.now() - start\n  }\n}\n\nexport async function streamSha_(\n  source: NodeJS.ReadableStream,\n  transforms: NodeJS.ReadWriteStream[] = [],\n  hashAlgorithm: string = \"sha512\"\n): Promise<string> {\n  const hash = crypto.createHash(hashAlgorithm)\n  await pipeline([source, ...transforms, hash])\n  return hash\n    .digest()\n    .subarray(0, HashBits / 8)\n    .toString(\"base64\")\n}\n\n// /**\n//  * Take the SHA of a readable\n//  */\n// export async function readableShaB64(reader: Readable): Promise<string> {\n//   const hash = crypto.createHash(\"sha512\")\n//   await  pipelinePromise([reader, hash])\n//   return sliced(hash.digest()).toString(\"base64\")\n// }\n\nexport function numericSha(obj: any, msbits = 48): number {\n  return parseInt(stringShaToBuffer(stringify(obj), msbits).toString(\"hex\"), 16)\n}\n\nexport function randomSha() {\n  return crypto.randomBytes(HashBits / 8).toString(\"base64\")\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { secondMs } from \"../../fe/Date\"\nimport { mapOr } from \"../../fe/Maybe\"\nimport { toInt } from \"../../fe/Number\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { ee } from \"../event/EventEmitter\"\nimport { isLinux, isMac, isWin } from \"../platform/Platform\"\nimport { PowerShell, pwshQuote } from \"../pwsh/PowerShell\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { BaseFile } from \"./BaseFile\"\nimport { FileCache } from \"./FileCache\"\nimport {\n  SimpleFile,\n  SimpleFileOrString,\n  isSimpleFile,\n  toNativePath_\n} from \"./SimpleFile\"\nimport { exists } from \"./Stat\"\n\nexport async function hide_(file: SimpleFile | string) {\n  if (!isWin && !isMac) return\n  const nativePath = toNativePath_(file)\n  if (!(await exists(nativePath))) return\n  if (isWin) {\n    await PowerShell.instance().execute(\n      `(Get-Item ${pwshQuote(nativePath)}).Attributes += 'Hidden'`,\n      () => undefined\n    )\n  } else if (isMac) {\n    await stdout_(\"chflags\", [\"hidden\", nativePath], {\n      timeoutMs: 10 * secondMs\n    })\n  }\n  ee().emit(\"fileChanged\", nativePath)\n  return\n}\n\nasync function isHiddenWin(file: SimpleFile) {\n  if (file.isRoot) return false // C:\\ reports to be hidden! WHY?\n  const json = await PowerShell.instance().executeJsonToA(\n    [\n      \"Get-Item -Force -LiteralPath\",\n      pwshQuote(file.nativePath),\n      \"-ErrorAction SilentlyContinue\",\n      \"| Select-Object -Property Name, Mode\"\n    ].join(\" \")\n  )\n  // See https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-childitem?view=powershell-5.1#examples\n  return mapOr(\n    json?.[0]?.Mode,\n    mode => [\"s\", \"h\"].some(ea => mode.includes(ea)),\n    () => false\n  )\n}\n\nasync function isHiddenMac(file: SimpleFile) {\n  try {\n    const out = await stdout_(\"stat\", [\"-f\", \"%f\", file.nativePath], {\n      timeoutMs: 10 * secondMs\n    })\n    const flags = toInt(out)\n    if (flags != null) {\n      return (flags & 0x8000) > 0 // from /usr/include/sys/stat.h\n    } else {\n      return false\n    }\n  } catch (err) {\n    return false\n  }\n}\n\nconst cache = lazy(\n  () =>\n    new FileCache<boolean>({\n      name: \"fs.hidden\",\n      maxSize: 512,\n      timeoutMs: commandTimeoutMs()\n    })\n)\n\n/**\n * Doesn't match posix-hidden (\".\"-prefixed) files--only looks for windows or\n * mac hidden metadata flags.\n */\nexport function isHidden(f: SimpleFileOrString): SyncOrAsync<boolean> {\n  // Don't check for posixHidden here-that's handled by a glob (that the user\n  // can omit!)\n  if (isLinux) return false // no way to hide on linux except with \".\"\n  const sf = isSimpleFile(f) ? f : BaseFile.for(f)\n  return sf.isRoot // assume no mountpoint will ever be hidden (because why?)\n    ? false\n    : isWin\n    ? cache().getOrSetAsync(sf.nativePath, () => isHiddenWin(sf))\n    : isMac\n    ? cache().getOrSetAsync(sf.nativePath, () => isHiddenMac(sf))\n    : false\n}\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { isTest } from \"../NodeEnv\"\nimport { isMac } from \"../platform/Platform\"\nimport { isExcludedMountpoint } from \"../volumes/PosixVolumes\"\n\nconst DevMounts = /^\\/dev(?:\\/|$)/i\n\n// Mojave mounts to /private/var/vm.\n// BigSur mounts to /System/Volumes/VM, /System/Volumes/Preboot, /System/Volumes/xarts, ...\n\n// mrm@mini ~ % mount | sed -e \"s/map auto/map_auto/\" | cut -d\\  -f3\n// /\n// /dev\n// /System/Volumes/Data\n// /private/var/vm\n// /Volumes/Mojave\n// /System/Volumes/Data/home\n// /System/Volumes/Hardware\n// /Volumes/Update\n// /Volumes/Install\n// /Volumes/SSD\n// /Volumes/Big\n// /Volumes/Update\n// /Volumes/Mojave\n// /Volumes/Recovery\n// mrm@mini ~ % uname -a\n// Darwin mini 19.6.0 Darwin Kernel Version 19.6.0: Sun Nov 14 19:58:51 PST 2021; root:xnu-6153.141.50~1/RELEASE_X86_64 x86_64\n\nconst MacSystemVolumes =\n  isMac || isTest\n    ? [\n        \"/dev\",\n        \"/System/Volumes/Hardware\",\n        \"/System/Volumes/iSCPreboot\",\n        \"/System/Volumes/Preboot\",\n        \"/System/Volumes/Update\",\n        \"/System/Volumes/VM\",\n        \"/System/Volumes/xarts\",\n        \"/Volumes/Install\",\n        \"/Volumes/Recovery\"\n      ].map(ea => ea.toLowerCase())\n    : undefined\n\nconst MacPrivate = isMac || isTest ? /^\\/private\\//i : undefined\n\n// macOS installation media\nconst MacOsInstall =\n  isMac || isTest ? /^\\/Volumes\\/install macos\\b/i : undefined\n\nconst MacNotDmg =\n  isMac || isTest // support \"v1.2\", \"v1.2.3\", \"v1.2.3-beta.4\", \"v1.2.3-beta.4-pre\", ...\n    ? /^\\/Volumes\\/PhotoStructure v?[\\d.]{3,}/i\n    : undefined\n\nexport function isPhotoStructureDmg(mountpoint: string): boolean {\n  return MacNotDmg?.exec(toS(mountpoint)) != null\n}\n\nexport function isIgnorableMountpoint(mountpoint: string): boolean {\n  return whyIgnorableMountpoint(mountpoint) != null\n}\n\nexport function whyIgnorableMountpoint(mountpoint: string): Maybe<string> {\n  return blank(mountpoint)\n    ? \"blank\"\n    : isExcludedMountpoint(mountpoint)\n    ? \"excluded\"\n    : DevMounts.test(mountpoint)\n    ? \"/dev\"\n    : MacSystemVolumes?.includes(mountpoint.toLowerCase()) === true\n    ? \"macOS system volume\"\n    : MacOsInstall?.test(mountpoint) === true\n    ? \"macOS installer volume\"\n    : MacPrivate?.test(mountpoint) === true\n    ? \"macOS private volume\"\n    : isPhotoStructureDmg(mountpoint)\n    ? \"PhotoStructure dmg\"\n    : undefined\n}\n","export const JpegExts = [\"jpg\", \"jpeg\", \"jpe\"] as const\n","import { lazy } from \"../../core/Lazy\"\nimport { map } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { MaybeSyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { mkLogger } from \"../Logger\"\nimport { PosixFile } from \"./PosixFile\"\n\nexport interface CreatedAt {\n  createdAt: number\n}\n\nexport class JsonFileStore<T extends CreatedAt> {\n  constructor(\n    readonly file: PosixFile,\n    readonly mkObject: () => MaybeSyncOrAsync<T>,\n    readonly onWrite?: (pf: PosixFile, object: T) => any\n  ) {}\n\n  private readonly prior = lazy(() => this.file.readJson<T>(\"debug\"))\n\n  async read_(): PromiseMaybe<T> {\n    return (\n      (await this.prior()) ?? map(await this.mkObject(), t => this.write_(t))\n    )\n  }\n\n  async write_(t: T): Promise<T> {\n    try {\n      await this.file.writeJson_(t, { spaces: 2 })\n      this.prior.set(Promise.resolve(t))\n      mkLogger(\"fs.JsonFileStore\").info(\"wrote to \" + this.file, t)\n      if (this.onWrite != null) {\n        await this.onWrite(this.file, t)\n      }\n      return t\n    } catch (err) {\n      throw new WrappedError(\"Failed to write to \" + this.file, {\n        cause: err,\n        path: this.file.nativePath\n      })\n    }\n  }\n}\n","import { Transform, TransformCallback } from \"stream\"\nimport { newlineRe } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\n\nexport class LineReader extends Transform {\n  private _prior: string = \"\"\n\n  constructor() {\n    super({ objectMode: false, autoDestroy: true })\n  }\n\n  _transform(chunk: any, _encoding: BufferEncoding, done: TransformCallback) {\n    const lines = (this._prior + toS(chunk)).split(newlineRe())\n    const last = lines.pop()\n    // if the last line is \"\", we ended with a newline, and we don't have a prior.\n    this._prior = last ?? \"\"\n    let delay = false\n    for (const ea of lines) {\n      // .push returns true if additional chunks of data may continue to be pushed; false otherwise\n      delay ||= !this.push(ea)\n    }\n    if (delay) setTimeout(done, 1)\n    else done()\n  }\n\n  _flush(done: TransformCallback): void {\n    if (this._prior !== \"\") this.push(this._prior)\n    this._prior = \"\"\n    done()\n  }\n}\n","import _path from \"path\"\nimport { SimpleFile, toNativePath_ } from \"./SimpleFile\"\nimport { writeTextfile_ } from \"./WriteFile\"\n\nexport function mkNoMedia_(dir: SimpleFile | string) {\n  return writeTextfile_(\n    _path.join(toNativePath_(dir), \".NoMedia\"),\n    `This directory's contents are excluded from PhotoStructure libraries.`,\n    ``,\n    `See https://photostructure.com/nomedia/ for details.`\n  )\n}\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { actualPath_ } from \"./ActualPath\"\nimport { SimpleFileOrString, toNativePath_ } from \"./SimpleFile\"\n\nexport function nativePathsEqlSync(\n  a: Maybe<SimpleFileOrString>,\n  b: Maybe<SimpleFileOrString>\n): boolean {\n  if (a == null || b == null) return false\n  if (a === b) return true\n  try {\n    // toNativePath does a resolve() for us, we don't need to!\n    const ap = toNativePath_(a)\n    const bp = toNativePath_(b)\n    return ap != null && bp != null && ap === bp\n  } catch {\n    return false\n  }\n}\n\nexport async function nativePathsEql(\n  a: Maybe<SimpleFileOrString>,\n  b: Maybe<SimpleFileOrString>\n): Promise<boolean> {\n  try {\n    // toNativePath does a resolve() for us, we don't need to!\n    return (\n      a != null &&\n      b != null &&\n      (await actualPath_(toNativePath_(a))) ===\n        (await actualPath_(toNativePath_(b)))\n    )\n  } catch {\n    return false\n  }\n}\n","import _path, { join } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { Halt } from \"../Halt\"\nimport { mkLogger } from \"../Logger\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { BaseFile } from \"./BaseFile\"\nimport {\n  CACHEDIR_TAG,\n  isCachedirTagDirectory,\n  isCachedirTagFile\n} from \"./CachedirTag\"\nimport { FileCache } from \"./FileCache\"\nimport { readdir, readdirCached } from \"./Readdir\"\nimport { SimpleDirent } from \"./SimpleDirent\"\nimport {\n  SimpleFileOrString,\n  isSimpleFile,\n  someSelfOrAncestor\n} from \"./SimpleFile\"\nimport { exists } from \"./Stat\"\n\nconst logger = lazy(() => mkLogger(\"fs.hasNoMedia()\"))\n\n// We're making the dot optional (although that isn't part of the spec)\nconst nomediaRe = /^\\.?NoMedia$/i\n\nconst NoMedia = \"NoMedia\"\n\nfunction variants(s: string) {\n  return [s, s.toLowerCase(), s.toUpperCase()]\n}\n\nconst NoMediaNames = Object.freeze([\n  ...variants(\".\" + NoMedia),\n  ...variants(NoMedia)\n])\n\nexport function isNoMediaName(basename: string): boolean {\n  return nomediaRe.exec(basename) != null\n}\n\nconst noMediaDirsCache = lazy(\n  () => new FileCache<boolean>({ name: \"fs.noMediaDirsCache\" })\n)\n\nexport async function hasNoMediaRecursive(\n  f: Maybe<SimpleFileOrString>\n): PromiseMaybe<boolean> {\n  if (f == null) return false\n  const sf = isSimpleFile(f) ? f : BaseFile.for(f)\n  return someSelfOrAncestor(sf, hasNoMedia)\n}\n\nexport async function isNoMedia(f: SimpleFileOrString): Promise<boolean> {\n  if (f == null) return false\n  const sf = isSimpleFile(f) ? f : BaseFile.for(f)\n  return isNoMediaName(sf.base) || (await isCachedirTagFile(sf))\n}\n\nexport async function hasNoMedia(f: SimpleFileOrString): Promise<boolean> {\n  if (f == null) return false\n  const sf = isSimpleFile(f) ? f : BaseFile.for(f)\n\n  if (sf.base === CACHEDIR_TAG) {\n    return logger().tap({\n      msg: sf.nativePath + \" is a CACHEDIR.TAG file\",\n      // return FALSE if the header doesn't exist?\n      result: await isCachedirTagFile(sf)\n    })\n  }\n\n  // Are we an actual NoMedia file?\n\n  if (isNoMediaName(sf.base)) {\n    // this doesn't need to be cached, it's almost a no-op:\n    return logger().tap({ msg: sf + \" basename is NoMedia\", result: true })\n  }\n\n  if (await sf.isDirectory()) {\n    return noMediaDirsCache().getOrSetAsync(sf.nativePath, () =>\n      dirHasNoMediaChild(sf.nativePath)\n    )\n  } else {\n    return false\n  }\n}\n\nasync function dirHasNoMediaChild(nativePath: string): Promise<boolean> {\n  const halt = new Halt()\n\n  // If we can only hit the readdir cache, that'd be great:\n  const cached: Maybe<SimpleDirent[]> = readdirCached(nativePath)\n  if (cached != null) {\n    return someIsNoMedia(nativePath, cached, halt)\n  }\n\n  // Otherwise, race:\n  const result: boolean = await Promise.race([\n    _dirHasNoMediaChild(nativePath, halt),\n    _readdirHasNoMediaChild(nativePath, halt)\n  ])\n  halt.halt() // < stop the loser\n  return result\n}\n\nasync function _dirHasNoMediaChild(\n  nativePath: string,\n  halt?: Halt\n): Promise<boolean> {\n  for (const ea of NoMediaNames) {\n    if (halt?.halted === true) {\n      return null as any\n    }\n    if (await exists(_path.join(nativePath, ea), LogLevels.trace)) {\n      return logger().tap({\n        msg: nativePath + \" is a directory and has a noMedia child, \" + ea,\n        result: true\n      })\n    }\n  }\n  if (halt?.halted === true) return null as any\n  return isCachedirTagDirectory(nativePath)\n}\n\nasync function someIsNoMedia(\n  dir: string,\n  arr: SimpleDirent[],\n  halt?: Halt\n): Promise<boolean> {\n  for (const ea of arr) {\n    if (halt?.halted === true) return null as any\n    if (isNoMediaName(ea.basename)) {\n      return logger().tap({\n        msg: dir + \" has a noMedia child, \" + ea.basename,\n        result: true\n      })\n    }\n    if (ea.basename === CACHEDIR_TAG) {\n      if (await isCachedirTagFile(join(dir, ea.basename))) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nasync function _readdirHasNoMediaChild(\n  nativePath: string,\n  halt?: Halt\n): Promise<boolean> {\n  const arr = await readdir(nativePath)\n  return arr == null ? false : someIsNoMedia(nativePath, arr, halt)\n}\n","import _fse from \"fs-extra\"\nimport _path from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { ensurePrefix, splitLast } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { greatestBy } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport {\n  ensureSuffix,\n  equalsIgnoreCase,\n  spliceCapture,\n  stripPrefix\n} from \"../String\"\nimport { isRetriableError } from \"../error/ErrorTypes\"\nimport { isPosix, isWin } from \"../platform/Platform\"\nimport { native2posix, posix2native } from \"./PosixNative\"\nimport {\n  SimpleFile,\n  SimpleFileOrString,\n  isSimpleFile,\n  toNativePath_\n} from \"./SimpleFile\"\nimport { isReadableDirectory } from \"./Stat\"\nimport { isReadWriteableDirectorySync } from \"./StatSync\"\n\nexport const logger = lazy(() => mkLogger(\"fs.Path\"))\n\nexport function isHiddenBasename(f: SimpleFileOrString): boolean {\n  const base = isSimpleFile(f) ? f.base : _path.basename(_path.resolve(f))\n  return base.startsWith(\".\")\n}\n\nexport function containsHiddenPathname(f: SimpleFileOrString): boolean {\n  return toPathnames(f).some(isHiddenBasename)\n}\n\nexport function isNotHiddenPosixPath(f: SimpleFileOrString): boolean {\n  return toPathnames(f).every(ea => !isHiddenBasename(ea))\n}\n\nconst driveRe = /^(?<drive>[A-Z]:)(?<path>[\\\\/].*)?$/i\n\nfunction upcaseDriveLetters(nativePath: string): string {\n  const g = driveRe.exec(nativePath)?.groups\n  return g == null\n    ? nativePath\n    : g.drive.toUpperCase() + toS(g.path ?? _path.sep)\n}\n\nexport function resolveSimpleFile(f: SimpleFileOrString) {\n  return isSimpleFile(f) ? f.nativePath : resolve(f.toString())\n}\n\nexport function resolve(...paths: string[]): string {\n  if (blank(paths.join(\"\"))) {\n    throw new Error(\"resolve(): empty paths\")\n  }\n  return _path.resolve(upcaseDriveLetters(paths[0]), ...paths.slice(1))\n}\n\n/**\n * Reject if any of the paths are blank\n */\nexport function resolveMaybe(...paths: Maybe<string>[]): Maybe<string> {\n  return paths.some(blank) ? undefined : resolve(...(paths as string[]))\n}\n\nexport interface ParsedFile {\n  /** \"/home/user/dir\" of \"/home/user/dir/file.txt\" */\n  readonly dir: string\n  /** \"file.txt\" of \"/home/user/dir/file.txt\" */\n  readonly base: string\n  /** \"file\" of \"/home/user/dir/file.txt\" */\n  readonly name: string\n  /** \".txt\" or \".log.gz\" of \"/home/user/dir/file.txt\" */\n  readonly ext: string\n}\n\nexport function parsePosixPath(posixPath: string): ParsedFile {\n  return parseNativePath(posix2native(posixPath))\n}\n\n/** @return \".txt\" or \".log.gz\" of \"/home/user/dir/file.txt\" */\nexport function extname(nativePath: string): string {\n  return parseNativePath(nativePath).ext\n}\n\n/**\n * @return parent directory of `fileish`\n */\nexport function dirname(fileish: SimpleFileOrString): string {\n  return _path.dirname(toNativePath_(fileish))\n}\n\nexport function extMatches(pathlike1: Maybe<string>, pathlike2: Maybe<string>) {\n  if (blank(pathlike1) || blank(pathlike2)) return false\n  return equalsIgnoreCase(\n    _path.parse(pathlike1).ext,\n    _path.parse(pathlike2).ext\n  )\n}\n\nconst CompressedExtRE = /(\\.(?:gz|z|7z|xz|bz2))$/i\n\n/**\n * Supports hidden files and extracting \".log.gz\" as the `ext` for \"file.log.gz\"\n */\nexport function parseNativePath(nativePath: string): ParsedFile {\n  const r = spliceCapture(nativePath, CompressedExtRE)\n  const p = _path.parse(r?.uncaptured ?? nativePath)\n  return {\n    ...p,\n    ...(r == null\n      ? {}\n      : {\n          ext: p.ext + r.captured,\n          base: p.base + r.captured\n        })\n  }\n}\n\n// BEWARE!\n\n// > require(\"path\").parse(\"C:\")\n// { root: 'C:', dir: 'C:', base: '', ext: '', name: '' }\n\n/**\n * Return the name (NOT the path!) of the parent directory\n */\nexport function parentBasename(nativePath: SimpleFileOrString) {\n  const p = _path.parse(toNativePath_(nativePath))\n  return p.root === p.dir ? p.root : splitLast(p.dir, _path.sep)\n}\n\nexport function grandParentBasename(nativePath: SimpleFileOrString) {\n  return parentBasename(_path.parse(toNativePath_(nativePath)).dir)\n}\n\nexport function containedByNativePath(args: {\n  ancestor: Maybe<SimpleFileOrString>\n  descendant: Maybe<SimpleFileOrString>\n  acceptSelf?: boolean // false\n}): boolean {\n  try {\n    if (args.descendant == null || args.ancestor == null) return false\n    const ancestor = toNativePath_(args.ancestor)\n    const descendant = toNativePath_(args.descendant)\n    if (blank(ancestor) || blank(descendant)) return false\n    const acceptSelf = args.acceptSelf ?? false\n    if (ancestor === descendant) return acceptSelf\n    return descendant.startsWith(ensureSuffix(ancestor, _path.sep))\n  } catch (error) {\n    logger().warn(\"containedByNativePath() failed (returning false)\", {\n      args,\n      error\n    })\n    return false\n  }\n}\n\nexport function toPathnames(nativePath: SimpleFileOrString): string[] {\n  return isSimpleFile(nativePath)\n    ? nativePath.pathnames\n    : nativePath.split(_path.sep).filter(ea => ea != null && ea !== \"\")\n}\n\nexport function pathIsRoot(f: Maybe<SimpleFileOrString>): boolean {\n  return notBlank(f) && toPathnames(f).length === (isWin ? 1 : 0)\n}\n\nexport function pathDepth(f: Maybe<SimpleFileOrString>): Maybe<number> {\n  return blank(f) ? undefined : toPathnames(f).length - (isWin ? 1 : 0)\n}\n\nexport type NativePathed = Pick<SimpleFile, \"nativePath\">\n\nexport function posixPathFrom(\n  parent: string | NativePathed,\n  child: string | NativePathed\n): string {\n  const p = toNativePath_(parent)\n  const c = toNativePath_(child)\n  if (blank(p) || blank(c))\n    throw new Error(\"posixPathFrom empty args \" + stringify({ parent, child }))\n\n  return p === c\n    ? \"\"\n    : // The ensureSuffix handles windows drive letters properly:\n      stripPrefix(\n        native2posix(c).normalize(),\n        ensureSuffix(native2posix(p), \"/\").normalize()\n      ).normalize() // < macOS requires us to normalize\n}\n\n/**\n * @return the native path of `p`. If the full path is longer than\n * `maxLength`, only include the root and parent directory names until the\n * path is at most `maxLength` characters long.\n */\nexport function ellipsizePath({\n  p,\n  maxLength\n}: {\n  p: SimpleFileOrString\n  maxLength: number\n}) {\n  const np = toNativePath_(p)\n  if (np.length <= maxLength) return np\n  const pathnames = toPathnames(p)\n  const base = pathnames.pop()!\n  const lhs = []\n  const rhs = [base]\n  while (pathnames.length > 0) {\n    if (lhs.length < rhs.length) {\n      // pop off something for lhs:\n      lhs.push(pathnames.shift()!)\n      if (joinNativePath([...lhs, ...rhs]).length >= maxLength) {\n        pathnames.unshift(lhs.pop()!)\n        break\n      }\n    } else {\n      rhs.unshift(pathnames.pop()!)\n      if (joinNativePath([...lhs, ...rhs]).length >= maxLength) {\n        pathnames.push(rhs.shift()!)\n        break\n      }\n    }\n  }\n\n  if (pathnames.length > 0) {\n    lhs.push(\"…\")\n  }\n  return joinNativePath([...lhs, ...rhs])\n}\n\nexport function posixPathFromParent(nativePath: string): string {\n  return toPathnames(nativePath).slice(-2).join(\"/\")\n}\n\nexport function posixPathFromGrandparent(nativePath: string): string {\n  return toPathnames(nativePath).slice(-3).join(\"/\")\n}\n\nexport function addNameSuffix(basename_: string, suffix: string): string {\n  const p = parseNativePath(basename_)\n  return `${p.base}${suffix}${p.ext}`\n}\n\nexport function isUNC(nativePath: string) {\n  return nativePath.startsWith(\"\\\\\\\\\")\n}\n\nexport function isAbsolute(nativePath: string) {\n  return (\n    (isPosix && nativePath.startsWith(\"/\")) ||\n    (isWin && (isUNC(nativePath) || nativePath.match(driveRe) != null))\n  )\n}\n\nexport async function mkdirp_(nativePath: string) {\n  try {\n    // Don't try to make the mountpoint (or, say, \"c:\")\n    if (await isReadableDirectory(nativePath)) return\n    await _fse.mkdirp(nativePath)\n  } catch (err) {\n    // concurrent mkdirp() calls spuriously throw EACCES or EEXIST\n    if (await isReadableDirectory(nativePath)) return\n    else throw err\n  }\n}\n\nexport function mkdirpSync_(\n  nativePath: string,\n  options?: _fse.EnsureDirOptions\n) {\n  try {\n    // Don't try to make the mountpoint (or, say, \"c:\")\n    if (isReadWriteableDirectorySync(nativePath)) return\n    _fse.mkdirpSync(nativePath, options)\n  } catch (err) {\n    // concurrent mkdirp() calls spuriously throw EACCES\n    if (isReadWriteableDirectorySync(nativePath)) return\n    else throw err\n  }\n}\n\nexport async function move_(srcNativePath: string, destNativePath: string) {\n  return retryOnReject(\n    () => _fse.move(srcNativePath, destNativePath, { overwrite: true }),\n    {\n      errorIsRetriable: isRetriableError,\n      maxRetries: 5, // windows may throw EBUSY\n      retryDelay: 250\n    }\n  )\n}\n\nexport function splitNativePath(nativePath: SimpleFileOrString): string[] {\n  const result = toNativePath_(nativePath)\n  // DON'T USE compactBlanks: (correct) tests will fail, because a path can\n  // validly be \" \"\n  return result.split(_path.sep).filter(ea => ea != null && ea !== \"\")\n}\n\nexport function joinNativePath(filePaths: string[]): string {\n  return ensurePrefix(\n    compactBlanks(filePaths).join(_path.sep),\n    isWin ? \"\" : _path.sep\n  )\n}\n\nexport function joinNativePathMaybe(...paths: Maybe<string>[]): Maybe<string> {\n  return paths.some(blank) ? undefined : joinNativePath(paths as string[])\n}\n\nexport function bestMountpointForDir(\n  dir: SimpleFileOrString,\n  mountpoints: SimpleFileOrString[]\n): Maybe<SimpleFileOrString> {\n  return greatestBy(mountpoints, ea =>\n    // containedByNativePath handles blank and null properly:\n    containedByNativePath({\n      ancestor: ea,\n      descendant: dir,\n      acceptSelf: true\n    })\n      ? [toNativePath_(ea).length]\n      : undefined\n  )\n}\n\nexport function posixPathIncludesPathElement(\n  posixPath: string,\n  name: string\n): boolean {\n  return posixPath.split(\"/\").includes(name)\n}\n","import _path from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks, uniq } from \"../../fe/Array\"\nimport { toNotBlank } from \"../../fe/Blank\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gte } from \"../../fe/Number\"\nimport { ensureSuffix } from \"../../fe/String\"\nimport { KiB } from \"../../fe/Units\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { env } from \"../env/Env\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { isLinux, isWin } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { isStatRX } from \"./Access\"\nimport { actualPath } from \"./ActualPath\"\nimport { BaseFile } from \"./BaseFile\"\nimport { statMaybe } from \"./Stat\"\n\nconst logger = lazy(() => mkLogger(\"fs.PathTo\"))\n\n// This file is instead of depending on the \"which\" npm package, which doesn't\n// have fallbacks, nor min filesize, nor access validation\n\n// dcraw_emu.exe is the smallest binary, and it's 26K.\nconst MinBinarySize = KiB\n\nexport async function isRXFile(\n  nativePath: string,\n  minSize = MinBinarySize\n): Promise<boolean> {\n  const stat = await statMaybe(nativePath, \"trace\")\n  return (\n    stat != null &&\n    stat.isFile() &&\n    gte(stat.size, minSize) &&\n    isStatRX(stat, nativePath)\n  )\n}\n\nfunction fallbackPathDirectories() {\n  if (isWin) {\n    const systemRoot = toNotBlank(getEnv(\"SystemRoot\")) ?? \"C:\\\\Windows\"\n    const systemDrive = toNotBlank(getEnv(\"SystemDrive\")) ?? \"C:\"\n    return [\n      systemRoot,\n      _path.join(systemRoot, \"System32\"),\n      _path.join(systemRoot, \"System32\", \"Wbem\"), // < wmic is hiding in Wbem\n      _path.join(systemDrive, \"cygwin64\", \"bin\")\n    ]\n  } else {\n    return [\n      ...(isDocker()\n        ? [\"/opt/photostructure/bin\", \"/opt/photostructure/tools/bin\"]\n        : []),\n      \"/usr/local/bin\",\n      \"/usr/bin\",\n      \"/bin\",\n      \"/usr/sbin\",\n      \"/sbin\"\n    ]\n  }\n}\n\nfunction pathDirectories() {\n  const paths = toS(env().PATH).split(_path.delimiter)\n  return uniq(compactBlanks([...paths, ...fallbackPathDirectories()]))\n}\n\nexport async function pathTo({\n  tool,\n  alternativePath,\n  paths\n}: {\n  tool: string\n  alternativePath?: string\n  paths?: string[]\n}): PromiseMaybe<string> {\n  const dirs = uniq(compactBlanks([...pathDirectories(), ...toA(paths)]))\n  for (const ea of uniq(compactBlanks([tool, alternativePath]))) {\n    const base = isWin ? ensureSuffix(ea, \".exe\") : ea\n\n    for (const dir of dirs) {\n      const nativePath = _path.join(dir, base)\n      if (await isRXFile(nativePath)) {\n        // only run actualPath for case-insensitive OSes:\n        return isLinux ? nativePath : actualPath(nativePath)\n      }\n    }\n  }\n  logger().warn(\"Failed to find tool\", { tool, dirs })\n  return\n}\n\nexport async function pathIfExists(f: Maybe<BaseFile>) {\n  if (f == null) return\n  const s = await f.stat({ logLevel: \"debug\" })\n  return s != null &&\n    s.isFile() &&\n    s.size > MinBinarySize &&\n    isStatRX(s, f.nativePath)\n    ? f.nativePath\n    : undefined\n}\n\nexport const wmic = () => \"wmic\"\nexport const fsutil = () => \"fsutil\"\nexport const nslookupWin = () => \"nslookup\"\nexport const pingWin = () => \"ping\"\nexport const arpWin = () => \"arp\"\n\n// export const wmic = lazy(() => pathTo(\"wmic\", [\"OS\", \"GET\", \"localdatetime\"], [\"System32\", \"wbem\"]) )\n// export const fsutil = lazy(() => pathTo(\"fsutil\", []))\n// export const nslookupWin = lazy(() => pathTo(\"nslookup\", [\"127.0.0.1\"]))\n// export const pingWin = lazy(() => pathTo(\"ping\", [\"-n\", \"1\", \"localhost\"]))\n// export const arpWin = lazy(() => pathTo(\"arp\", [\"-a\"]))\n","import fs from \"fs\"\nimport * as _fse from \"fs-extra\"\nimport fsp from \"fs/promises\"\nimport _path from \"path\"\nimport stream from \"stream\"\nimport { pipeline } from \"stream/promises\"\nimport util from \"util\"\nimport { MemoizedThunk, lazy } from \"../../core/Lazy\"\nimport { compact } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { blank, notBlank, notBlankOr } from \"../../fe/Blank\"\nimport { fmtYMDHMS, minuteMs, secondMs } from \"../../fe/Date\"\nimport { errorCode } from \"../../fe/Error\"\nimport { fmtDuration } from \"../../fe/FmtDuration\"\nimport { map, mapOr } from \"../../fe/Maybe\"\nimport { Maybe, MaybePromiseMaybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { approximates, clamp, gte } from \"../../fe/Number\"\nimport { StringValued, omit } from \"../../fe/Object\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport {\n  PS_LIBRARY_SCHEME,\n  PS_LOCAL_FILE_SCHEME,\n  PS_NETWORK_FILESYSTEM_SCHEME\n} from \"../../fe/URI\"\nimport { MiB } from \"../../fe/Units\"\nimport { toS } from \"../../fe/toS\"\nimport { contextFilter, max } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport {\n  countChars,\n  ensurePrefix,\n  equalsIgnoreCase,\n  isString,\n  stripPrefix\n} from \"../String\"\nimport { thenMap, thenMapOr } from \"../async/Promise\"\nimport { time } from \"../async/PromiseTimer\"\nimport { untilTrue } from \"../async/until\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { libraryDir, originalsDir } from \"../dir/LibraryDir\"\nimport { DoNotSendErrorFlag, NonRetriableErrorFlag } from \"../error/ErrorFlags\"\nimport { isNonRetriableError } from \"../error/ErrorTypes\"\nimport { LogLevel, LogLevels } from \"../log/LogLevel\"\nimport { Radix58 } from \"../math/Radix\"\nimport { isMac, isWin } from \"../platform/Platform\"\nimport { PullProgressObserver } from \"../progress/PullProgressObserver\"\nimport { PowerShell, pwshQuote } from \"../pwsh/PowerShell\"\nimport { Settings } from \"../settings/Settings\"\nimport { defaultSidecarExt, existingSidecars } from \"../tags/Sidecars\"\nimport { nativePath2uri, uri2nativePath } from \"../uri/FileURI\"\nimport { URI, toURI } from \"../uri/URI\"\nimport { uriIsEquivalent } from \"../uri/UriNormalization\"\nimport { mountpoints } from \"../volumes/Mountpoints\"\nimport { MinIoRate, commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { bestMountpoint } from \"../volumes/Volumes\"\nimport { BaseFile, RefreshArgs } from \"./BaseFile\"\nimport { DirectoryEntry } from \"./DirectoryEntry\"\nimport { FileCache } from \"./FileCache\"\nimport { isJsonExt, isSidecarExt } from \"./FileExt\"\nimport { withLock_ } from \"./FsLock\"\nimport { hide_, isHidden } from \"./Hidden\"\nimport { mkNoMedia_ } from \"./MkNoMedia\"\nimport { hasNoMedia, hasNoMediaRecursive } from \"./NoMedia\"\nimport { containedByNativePath, move_ } from \"./Path\"\nimport { SimpleFile, SimpleFileOrString, toNativePath_ } from \"./SimpleFile\"\nimport { ByteCounter } from \"./Streams\"\nimport { touch_ } from \"./Touch\"\nimport { WipPrefix, WipTimeoutMs } from \"./WIP\"\nimport { WriteOptions } from \"./WriteOptions\"\nimport { zpipe_ } from \"./zcat\"\n\nconst cache = lazy(() => new FileCache<PosixFile>({ name: \"fs.PosixFile\" }))\n\nfunction sortFiles(paths: PosixFile[]) {\n  return sortBy(paths, ea => ea.nativePath)\n}\n\nexport function uniquePrefixes(paths: PosixFile[]) {\n  return contextFilter(\n    sortFiles(paths),\n    // This also does a uniq():\n    (ea, _idx, last) => last == null || !ea.isDescendantOf(last)\n  )\n}\n\nexport const NoOp = Symbol(\"no-op\")\n\n/**\n * Ensures a given path is only \"posix-ized\" once, and holds promises for more\n * expensive information about the file, like inode stats, SHA1, and EXIF tags.\n */\nexport class PosixFile extends BaseFile implements SimpleFile {\n  protected readonly pflog = lazy(() =>\n    mkLogger(\"fs.PosixFile(\" + this.nativePath + \")\")\n  )\n\n  protected constructor(\n    readonly nativePath: string,\n    dirent?: DirectoryEntry\n  ) {\n    super(nativePath, dirent)\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON()\n  }\n\n  static forDirectoryEntry(de: DirectoryEntry) {\n    return PosixFile.for(de.nativePath, de)\n  }\n\n  static forMaybe(nativePathOrFile: Maybe<SimpleFileOrString>) {\n    return notBlank(nativePathOrFile)\n      ? PosixFile.for(nativePathOrFile)\n      : undefined\n  }\n\n  static for(\n    nativePathOrFile: SimpleFileOrString,\n    dirent?: DirectoryEntry\n  ): PosixFile {\n    if (nativePathOrFile instanceof PosixFile) {\n      return nativePathOrFile\n    }\n\n    if (blank(nativePathOrFile)) {\n      throw new Error(\"PosixFile.for(): empty nativePathOrFile\")\n    }\n\n    if (isString(nativePathOrFile)) {\n      // avoid expensive resolve() call:\n      const prior = cache().get(nativePathOrFile)\n      if (prior != null) return prior\n    }\n    const resolved = toNativePath_(nativePathOrFile)\n    const result = new PosixFile(resolved, dirent)\n    if (isString(nativePathOrFile)) {\n      cache().set(nativePathOrFile, result)\n    }\n    cache().set(resolved, result)\n    return result\n  }\n\n  static forPosix(posixPath: string): PosixFile {\n    return PosixFile.for(posixPath.replace(/\\//g, _path.sep))\n  }\n\n  static forUri(uri: string, mountpoint?: string): PromiseMaybe<PosixFile> {\n    return thenMap(uri2nativePath(uri, mountpoint), nativePath =>\n      PosixFile.for(nativePath)\n    )\n  }\n\n  for(nativePath: string, dirent?: DirectoryEntry): this {\n    return PosixFile.for(nativePath, dirent) as this\n  }\n\n  forDirectoryEntry(de: DirectoryEntry): this {\n    return PosixFile.for(de.nativePath, de) as this\n  }\n\n  clear({ emit } = { emit: true }): this {\n    super.clear({ emit })\n    this.uriObject_.unset()\n    this.uri_.unset()\n    this.normalizedPathUri_.unset()\n    this.fileuri.unset()\n    this.etag.unset()\n    this.existingSidecars.unset()\n    this.unlock.unset()\n    return this\n  }\n\n  readonly uriObject_ = lazy(() => nativePath2uri(this.nativePath))\n  readonly uri_ = lazy(async () => (await this.uriObject_()).toString())\n  uri(): PromiseMaybe<string> {\n    return this.trap(\"uri\", () => this.uri_())\n  }\n  readonly fileuri = lazy(() => URI.file(this.nativePath).toString())\n\n  readonly normalizedPathUri_: MemoizedThunk<PromiseMaybe<string>> = lazy(\n    async () => (await this.normalize()).uri_()\n  )\n\n  async mountpoint(): PromiseMaybe<PosixFile> {\n    if (\n      containedByNativePath({\n        // HEY FUTURE ME: referencing libraryDirPosixFile creates a deploop _don't do that_\n        ancestor: libraryDir(),\n        descendant: this,\n        acceptSelf: true\n      }) ||\n      containedByNativePath({\n        ancestor: originalsDir(),\n        descendant: this,\n        acceptSelf: true\n      })\n    ) {\n      return\n    }\n    if (isWin && this.nativePath.startsWith(\"\\\\\\\\\")) {\n      return PosixFile.for(this.nativePath.split(\"\\\\\").slice(0, 4).join(\"\\\\\"))\n    }\n    return map(bestMountpoint(this.nativePath, await mountpoints()), ea =>\n      PosixFile.for(ea)\n    )\n  }\n\n  /**\n   * @return true iff this file or directory doesn't exist, and the mountpoint\n   * is currently mounted, or some parent directory exists.\n   */\n  async isDeletedUri(_uri?: URI | string): PromiseMaybe<boolean> {\n    if (await this.exists({ refresh: true })) return false // NOT deleted\n\n    if (this.isUNC) {\n      return this.pflog().tap({\n        result: await this.isDeleted(),\n        msg: \"isDeletedUri(): is UNC, delegating to isDeleted()\"\n      })\n    }\n\n    const uri = map(\n      notBlankOr(_uri, () => this.uri_() as any),\n      toURI\n    )\n\n    if (uri == null) {\n      return this.pflog().tap({\n        result: await this.isDeleted(),\n        level: \"warn\",\n        msg: \"isDeletedUri(): missing URI, delegating to isDeleted()\"\n      })\n    }\n\n    if (uri.isRootPath()) {\n      // don't descend any farther, we're at (least a prior) mountpoint\n      return this.pflog().tap({\n        result: await this.notExists(),\n        msg: \"isDeletedUri(): uri isRootPath\",\n        meta: { uri }\n      })\n    }\n\n    // Is the uri relevant to this path?\n\n    if (toS(uri.pathBase).normalize() !== this.base.normalize()) {\n      return this.pflog().tap({\n        level: \"warn\",\n        result: await this.notExists(),\n        msg: \"isDeleted(): uri isn't correct, returning notExists()\",\n        meta: { uri, expectedBase: this.base, uriBase: uri.pathBase }\n      })\n    }\n\n    // C:\\goo\\bar\\file.jpg\n    // /opt/library/file.jpg\n\n    // NOTE: we're counting slashes in the _URI_, not the native path, because\n    // that goes to the mountpoint.\n\n    // pslib:/dir/file.jpg\n    // psfile:/UUID/dir/file.jpg\n    // psnet:/server/share/dir/file.jpg\n\n    const schemeDiscount =\n      uri.scheme === PS_LIBRARY_SCHEME\n        ? 1\n        : uri.scheme === PS_LOCAL_FILE_SCHEME\n        ? 2\n        : uri.scheme === PS_NETWORK_FILESYSTEM_SCHEME\n        ? 3\n        : 1\n\n    const maxDepth = countChars(uri.path, \"/\") - schemeDiscount\n\n    // we don't need to log.tap this result: BaseFile will already log it.\n    return this.isDeleted(maxDepth)\n  }\n\n  readonly etag = lazy(() =>\n    thenMap(this.stat(), s =>\n      [s.size, s.mtime.getTime()].map(n => Radix58.encode(n)).join(\"-\")\n    )\n  )\n\n  async httpHeaders(): Promise<StringValued> {\n    return {\n      ETag: await this.etag(),\n      \"Last-Modified\": await this.lastModifiedUtc()\n    }\n  }\n\n  hide(): MaybePromiseMaybe<this> {\n    if (!isWin && !isMac) return\n    return this.trap(\"hide\", async () => {\n      await hide_(this)\n      return this\n    })\n  }\n\n  /**\n   * @throws on error\n   */\n  async mkNoMedia_() {\n    return mkNoMedia_(this)\n  }\n\n  /**\n   * @return this, not the .NoMedia file, so the method can be chained.\n   */\n\n  async mkNoMedia(): PromiseMaybe<this> {\n    try {\n      await this.mkNoMedia_()\n      return this\n    } catch (err) {\n      this.pflog().warn(\"Could not add .NoMedia file to \" + this, err)\n      return undefined\n    }\n  }\n\n  hasNoMedia(): PromiseMaybe<boolean> {\n    return hasNoMedia(this)\n  }\n\n  hasNoMediaRecursive(): PromiseMaybe<boolean> {\n    return hasNoMediaRecursive(this)\n  }\n\n  async hidden() {\n    return isHidden(this)\n  }\n\n  readonly isMountpoint = lazy(\n    async () =>\n      (await this.isDirectory()) &&\n      (await thenMapOr(\n        mountpoints(),\n        arr => arr.includes(this.nativePath),\n        () => false\n      ))\n  )\n\n  isSidecar() {\n    return isSidecarExt(this.ext)\n  }\n\n  /**\n   * @return all JSON and non-JSON sidecars\n   */\n  readonly existingSidecars = lazy(() => existingSidecars(this))\n\n  /**\n   * Returns non-JSON sidecars that ExifTool can read (.xmp, .mie, ...)\n   *\n   * @return oldest sidecars first (so newest sidecar metadata wins, as they are\n   * layered on top of eachother)\n   */\n  async existingExifSidecars() {\n    return (await this.existingSidecars()).filter(ea => !isJsonExt(ea))\n  }\n\n  /**\n   * Should only be used for writes\n   */\n  async sidecar() {\n    const existing = await this.existingExifSidecars()\n    return (\n      existing.find(ea => equalsIgnoreCase(ea.ext, defaultSidecarExt())) ??\n      this.defaultSidecar()\n    )\n  }\n\n  defaultSidecar() {\n    return this.sibling(this.base + defaultSidecarExt())\n  }\n\n  async jsonSidecars() {\n    return (await this.existingSidecars()).filter(ea => isJsonExt(ea))\n  }\n\n  async sidecareStats(opts?: RefreshArgs): Promise<fs.Stats[]> {\n    const refresh = opts?.refresh ?? false\n    if (refresh) this.existingSidecars.unset()\n    return compact(\n      await Promise.all(\n        [this, ...(await this.existingSidecars())].map(ea => ea.stat(opts))\n      )\n    )\n  }\n\n  async thisOrSidecareMaxMtimeMs(opts?: RefreshArgs) {\n    const ss = await this.sidecareStats(opts)\n    return max(ss.map(ea => ea.mtimeMs))\n  }\n\n  /**\n   * @throws so when readables encounter errors in the midst of reading, they\n   * can propagate the error to the caller\n   */\n  async writeStream_(\n    readable: stream.Readable,\n    options?: WriteOptions & { onProgress?: (bytes: number) => any }\n  ): PromiseMaybe<this> {\n    await pipeline(\n      compact([\n        readable,\n        map(options?.onProgress, f => new ByteCounter(f)),\n        _fse.createWriteStream(this.nativePath, {\n          autoClose: true,\n          ...omit(options, \"onProgress\")\n        })\n      ])\n    )\n    readable.destroy()\n    return this.clearThisAndParent()\n  }\n\n  /**\n   * @param f_ must throw an error on failure, or we'll wait for a minute for\n   * the command to finish (!!)\n   */\n  async applyIfEmpty_({\n    fn_,\n    minSizeBytes = 0,\n    returnUndefinedIfNotEmpty = false,\n    timeoutMs,\n    skipWip = false,\n    skipFsLock = false,\n    retries = 2,\n    dirty = false\n  }: {\n    fn_: (destination: PosixFile) => Promise<any>\n    minSizeBytes?: number\n    returnUndefinedIfNotEmpty?: boolean\n    timeoutMs: number\n    skipWip?: boolean\n    skipFsLock?: boolean\n    retries?: number\n    dirty?: boolean\n  }): PromiseMaybe<this> {\n    return retryOnReject(\n      async () => {\n        const initiallyNotEmpty =\n          await this.clear().isNonEmptyFile(minSizeBytes)\n\n        if (!initiallyNotEmpty) {\n          if (skipWip && skipFsLock) {\n            return fn_(this)\n          } else {\n            await this.applyWip_({\n              fn_: async dest => {\n                if (await this.clear().isNonEmptyFile(minSizeBytes)) {\n                  // someone got a file lock before us and did the work!\n                  return NoOp\n                } else {\n                  return fn_(dest)\n                }\n              },\n              skipFsLock,\n              minSizeBytes,\n              timeoutMs,\n              dirty\n            })\n          }\n        }\n\n        return initiallyNotEmpty && returnUndefinedIfNotEmpty\n          ? undefined\n          : this.utimes()\n      },\n      {\n        maxRetries: retries,\n        timeoutMs: timeoutMs * 2,\n        retryDelay: 3 * secondMs,\n        errorIsRetriable: e => errorCode(e) === \"EBUSY\"\n      }\n    )\n  }\n\n  /**\n   * @returns a hidden file .wip file\n   */\n  wip(): this {\n    return this.sibling(ensurePrefix(this.base, WipPrefix))\n  }\n\n  isWip(): boolean {\n    return this.name.startsWith(WipPrefix)\n  }\n\n  async wipIsRecent(staleMs = WipTimeoutMs): Promise<boolean> {\n    return (\n      (await this.wip().isFile()) &&\n      gte(await this.wip().clear().maxStatMs(), Date.now() - staleMs)\n    )\n  }\n\n  unwipBase() {\n    return stripPrefix(this.base, WipPrefix)\n  }\n\n  /**\n   * If this is a WIP, rename to the \"source\" file (by removing the WipToken\n   * (\".WIP-\") prefix\n   */\n  unwip_(): Promise<this> {\n    return this.mv_(this.sibling(this.unwipBase()))\n  }\n\n  async applyWip_<T>({\n    fn_,\n    minSizeBytes = 0,\n    skipFsLock = false,\n    timeoutMs,\n    dirty = false\n  }: {\n    fn_: (destination: PosixFile) => Promise<T>\n    timeoutMs: number\n    skipFsLock: boolean\n    minSizeBytes?: number\n    dirty?: boolean\n  }): PromiseMaybe<T> {\n    await this.parent().mkdirp_()\n    return withLock_(\n      {\n        file: this,\n        skipFsLock,\n        timeoutMs,\n        dirty\n      },\n      async () => {\n        const wip = this.wip()\n        try {\n          // NOTE: don't touch() WIP file, ExifTool's no-clobber policy will be\n          // grumpy!\n          await wip.unlink(\"trace\") // < should be a no-op\n\n          const result = await thenOrTimeoutError(fn_(wip), timeoutMs)\n\n          if ((result as any) === NoOp) return result\n\n          const isNonEmpty = await untilTrue(\n            () => wip.clear().isNonEmptyFile(minSizeBytes),\n            {\n              timeoutMs: ShortCommandTimeoutMs,\n              intervalMs: 250 // short interval because it's just a stat()\n            }\n          )\n\n          if (isNonEmpty) {\n            await wip.mv_(this) // throws errors if issues\n            return result\n          } else {\n            throw new Error(\n              this +\n                \"applyWip(): still empty after waiting \" +\n                fmtDuration(ShortCommandTimeoutMs)\n            )\n          }\n        } catch (err) {\n          this.pflog().warn(\"applyWip() threw error\", err)\n          await wip.unlink(\"trace\")\n          await this.unlink(\"trace\")\n          throw err\n        }\n      }\n    )\n  }\n\n  /**\n   * Atomically overwrite `destOrDestDir.join(paths)` with the contents of\n   * `this`. Use `.ensureNew` on destOrDestDir if you want to prevent\n   * overwriting.\n   *\n   * If the result of joining `destOrDestDir` and `paths` results in an\n   * extensionless name, the path will be assumed to be a containing directory,\n   * and this name will be appended to the result.\n   *\n   * @throws if there are any errors\n   */\n  copyFile_(destFileOrDir: this): Promise<this> {\n    return time(\"fs.copyFile\", async () => {\n      const dest = this.dest(destFileOrDir)\n      if (this.nativePath === dest.nativePath) {\n        return this\n      }\n\n      if (Settings.onlyNativeFileCopy.valueOrDefault !== true)\n        try {\n          return await this.#copyFile_(dest)\n        } catch (error) {\n          if (isNonRetriableError(error) === true) {\n            return this.pflog().throw(\n              \"_copyFile failed, but error wasn't retriable\",\n              {\n                error,\n                dest: dest.nativePath,\n                src: this.nativePath\n              }\n            )\n          }\n\n          this.pflog().warn(\"_copyFile failed, trying _nativeCopyFile\", {\n            dest: dest.nativePath,\n            src: this.nativePath,\n            error\n          })\n        }\n\n      return await this.#nativeCopyFile_(dest)\n    })\n  }\n\n  async maybeVerifySameOrThrow_(dest: this) {\n    const start = Date.now()\n    if (Settings.verifyFileCopies.valueOrDefault) {\n      // we don't need to refresh this.sha().\n      if (\n        await untilTrue(() => this.matchesContent(dest), {\n          timeoutMs: commandTimeoutMs(),\n          intervalMs: secondMs\n        })\n      ) {\n        // YAY COPY WORKED\n      } else {\n        this.pflog().throw(\n          \"copyFile_() failed (contents did not match after copy)\",\n          { dest, elapsedMs: Date.now() - start }\n        )\n      }\n    }\n  }\n\n  async #copyFile_(dest: this): Promise<this> {\n    let obs: Maybe<PullProgressObserver>\n    let result = dest\n    const copyDest = dest.wip()\n    try {\n      const s = await this.stat_()\n      if (s == null) {\n        return this.pflog().throw(\n          \"Can't copy missing files\" + NonRetriableErrorFlag\n        )\n      }\n      if (s.size > 0) {\n        // skip copy for empty files\n        if (Settings.verifyFileCopies.valueOrDefault) {\n          if ((await this.sha()) == null) {\n            return this.pflog().throw(\n              \"Can't copy file without SHA\" + NonRetriableErrorFlag\n            )\n          }\n        }\n        const mkdir = await copyDest.parent().mkdirp()\n        if (mkdir == null)\n          return this.pflog().throw(\"Cannot mkdirp \" + dest.dir)\n\n        await fsp.copyFile(\n          this.nativePath,\n          copyDest.nativePath,\n          // COPYFILE_FICLONE: copy operation will attempt to create a\n          // copy-on-write reflink. If the underlying platform does not\n          // support copy-on-write, then a fallback copy mechanism is used.\n          fs.constants.COPYFILE_FICLONE\n        )\n        if (s.size > 5 * MiB) {\n          obs = new PullProgressObserver(\n            {\n              op: \"Copying\",\n              path: this.nativePath,\n              dest: dest.nativePath\n            } as any,\n            s.size,\n            () => copyDest.size({ refresh: true })\n          )\n        }\n        const sizeMatches = await untilTrue(\n          async () =>\n            approximates(s.size, await copyDest.size({ refresh: true })),\n          // it was already supposed to be done, so waiting a minute is really\n          // just to wait for sync (which might take ages!):\n          { intervalMs: secondMs, timeoutMs: minuteMs }\n        )\n        if (!sizeMatches) {\n          return this.pflog().throw(\"copyFile_() failed\", {\n            expectedSize: s.size,\n            actualSize: await copyDest.size({ refresh: true })\n          })\n        }\n\n        await this.maybeVerifySameOrThrow_(copyDest)\n\n        result = dest.eql(copyDest)\n          ? dest\n          : await copyDest.mv_(dest, LogLevels.trace)\n      }\n      try {\n        // this doesn't need to fail the whole operation:\n        await touch_({\n          file: result,\n          btimeMs: s.birthtimeMs,\n          mtimeMs: s.mtimeMs,\n          ensureFile: false\n        })\n      } catch (err) {\n        this.pflog().warn(\n          `copyFile_(${result.nativePath}): couldn't set utimes to match source: ${err}`\n        )\n      }\n      try {\n        // this doesn't need to fail the whole operation:\n        await _fse.chmod(result.nativePath, s.mode)\n      } catch (err) {\n        this.pflog().warn(\n          `copyFile_(${result.nativePath}): couldn't chmod to ${s.mode}: ${err}`\n        )\n      }\n      this.pflog().debug(`copyFile_(${result.nativePath}): success`)\n      return result\n    } catch (err) {\n      this.pflog().warn(`copyFile_(${copyDest?.nativePath}) failed: ${err}`)\n      await copyDest.unlink()\n      if (!copyDest.eql(dest)) {\n        await dest.unlink()\n      }\n      throw err\n    } finally {\n      result?.clearThisAndParent()\n      void map(obs, ea => ea.end())\n    }\n  }\n\n  async zCopyFile_(dest: this, options?: { start?: number; end?: number }) {\n    await dest.parent().mkdirp_()\n    await zpipe_(\n      this.nativePath,\n      fs.createWriteStream(dest.nativePath, { autoClose: true }),\n      options\n    )\n    return dest.clear()\n  }\n\n  async copyTimeoutMs(): Promise<number> {\n    return clamp(\n      ShortCommandTimeoutMs, // don't go shorter than this!\n      10 * minuteMs,\n      ((await this.size()) ?? 0) * MinIoRate\n    )\n  }\n\n  async #nativeCopyFile_(dest: this): Promise<this> {\n    let obs: Maybe<PullProgressObserver>\n    const wipDest = dest.wip()\n\n    try {\n      if (null == (await dest.parent().mkdirp())) {\n        return this.pflog().throw(\"Can't mkdir destination directory\", {\n          src: this.nativePath,\n          dest: dest.nativePath\n        })\n      }\n      const s = await this.stat_()\n      const size = s?.size\n      if (s == null || size == null) {\n        return this.pflog().throw(\"Can't copy missing files\")\n      }\n      if (size > 5 * MiB) {\n        obs = new PullProgressObserver(\n          {\n            op: \"Copying\",\n            path: this.nativePath,\n            dest: wipDest.nativePath\n          } as any,\n          size,\n          () => dest.clear().size()\n        )\n      }\n\n      if (isWin) {\n        await PowerShell.instance().execute(\n          `Copy-Item -LiteralPath ${pwshQuote(\n            this.nativePath\n          )} -Destination ${pwshQuote(wipDest.nativePath)}`,\n          ea => ea\n        )\n      } else if (isMac) {\n        await stdout_(\"ditto\", [this.nativePath, wipDest.nativePath], {\n          timeoutMs: await this.copyTimeoutMs()\n        })\n      } else {\n        // -a means archive, or -pPR on macOS or -dR --preserve=all on debian\n        // -f means force. If existing dest cannot be opened, remove it and try again.\n        await stdout_(\"cp\", [\"-a\", \"-f\", this.nativePath, wipDest.nativePath], {\n          timeoutMs: await this.copyTimeoutMs()\n        })\n      }\n      await this.maybeVerifySameOrThrow_(wipDest)\n      await wipDest.mv_(dest, LogLevels.trace)\n      await touch_({ file: dest, reference: this, ensureFile: false })\n      return dest.clearThisAndParent()\n    } catch (error) {\n      await wipDest.unlink()\n      return this.pflog().throw(\n        \"_nativeCopyFile(\" + dest + \") failed\" + DoNotSendErrorFlag,\n        { error }\n      )\n    } finally {\n      void map(obs, ea => ea.end())\n    }\n  }\n\n  dest(destOrDestDir: this): this {\n    const destOrDir = destOrDestDir.clear() // < bust cache\n    return (notBlank(this.ext) && blank(destOrDir.ext)) ||\n      destOrDir.isDirectorySync()\n      ? destOrDir.join(this.base)\n      : destOrDir\n  }\n\n  /**\n   * @throws if errors\n   */\n  async renameYMDHMS_(\n    args: { subdir?: string; ts?: number } = {}\n  ): Promise<this> {\n    if (await this.clear().notExists()) {\n      throw new Error(\"Cannot rename: \" + this + \" doesn't exist.\")\n    }\n    const ts = fmtYMDHMS(args.ts ?? (await this.mtime()) ?? Date.now())\n    const destDir = mapOr(\n      args.subdir,\n      ea => this.parent().join(ea),\n      () => this.parent()\n    )\n    return this.mv_(destDir.join(this.name + \"-\" + ts + this.ext))\n  }\n\n  /**\n   * @throws on error\n   */\n  async renameWithNameSuffix_(nameSuffix: string): PromiseMaybe<this> {\n    return thenMap(\n      this.withNameSuffix(nameSuffix).ensureNew_({ emptyIsNew: true }),\n      dest => dest.unlink(\"debug\").then(() => this.mv_(dest))\n    )\n  }\n\n  /**\n   * If `this` exists and has new contents for this current directory, rename it\n   * to a new file with the given base (and possibly a count, to ensure new\n   * overwriting).\n   *\n   * If `this` is empty, or already has the same contents as another file in\n   * this directory, return that file and unlink this file.\n   */\n  async saveIfNewOrDelete(base: string): PromiseMaybe<this> {\n    if (await this.clear().isEmpty()) {\n      // don't complain about removing a missing file:\n      await this.unlink(\"trace\")\n      return\n    }\n    const prior = await this.siblingWithSameContents()\n    if (prior != null) {\n      await this.unlink()\n      return prior\n    }\n    const dest = await this.sibling(base).ensureNew_()\n    return this.mv_(dest)\n  }\n\n  /**\n   * SITS: Mac sometimes locks files when they've been copied. No, I couldn't\n   * find out why, but if I own the file, I can chflags the file back to being\n   * unlocked.\n   *\n   * This should only be applied to newly-copied files, and not for files that\n   * PhotoStructure didn't create.\n   */\n  readonly unlock = lazy(() =>\n    !isMac\n      ? undefined\n      : stdout_(\"chflags\", [\"nouchg\", this.nativePath], {\n          quiet: true,\n          timeoutMs: ShortCommandTimeoutMs\n        })\n  )\n\n  /**\n   * Move this to `destFileOrDir`. If dest exists, it will be overwritten.\n   *\n   * @return the file that was copied into\n   * @throws error if there are issues\n   */\n  async mv_(\n    destFileOrDir: this | string,\n    level: LogLevel = LogLevels.debug\n  ): Promise<this> {\n    const dest = isString(destFileOrDir)\n      ? this.parent().join(destFileOrDir)\n      : this.dest(destFileOrDir)\n    if (this.nativePath === dest.nativePath) {\n      this.pflog().warn(\"mv(): no-op\", new Error(\"internal error\"))\n      return this\n    }\n    if (this.dir !== dest.dir) {\n      await dest.parent().mkdirp_()\n    }\n    this.pflog().log(level, \"mv_()\", { dest })\n    try {\n      // windows can throw EBUSY:\n      await move_(this.nativePath, dest.nativePath)\n    } catch (err) {\n      this.pflog().warn(\"mv() failed. Calling unlock() and retrying...\", err)\n      await Promise.all([this.unlock(), dest.unlock()])\n      await move_(this.nativePath, dest.nativePath)\n    }\n    if (this.dir !== dest.dir) this.clearThisAndParent()\n    return dest.clearThisAndParent()\n  }\n\n  /**\n   * @return true if the provided URI is equivalent to this\n   */\n  async equalsUri_(uri: string | URI): Promise<boolean> {\n    return uriIsEquivalent(await this.uriObject_(), uri)\n  }\n}\n","import { Tags } from \"exiftool-vendored\"\nimport { includes } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0, gte, lte, toInt } from \"../../fe/Number\"\nimport { toS } from \"../../fe/toS\"\nimport { allNotBlank } from \"../Array\"\nimport { thenMapOr } from \"../async/Promise\"\nimport {\n  Predicate,\n  PredicateBundle,\n  Predicates\n} from \"../predicates/Predicates\"\nimport { Settings } from \"../settings/Settings\"\nimport { extractDurationSec } from \"../tags/Duration\"\nimport { readRawTags, readTags } from \"../tags/ExifTool\"\nimport { rawTagKeywords } from \"../tags/KeywordTags\"\nimport { isAssetFileMimeType, isVideoMimeType } from \"../tags/MimeTypes\"\nimport { readMimeType } from \"../tags/ReadMimeType\"\nimport { extractSizeInfoFromFile } from \"../tags/SizeInfo\"\nimport { leafIsExcluded } from \"../tags/TagPaths\"\nimport { isBaseFile } from \"./BaseFile\"\nimport { isAssetFileExtension } from \"./BaseFilePredicates\"\nimport {\n  isExcludedDirectory,\n  notExcludedFilePredicates,\n  whyExcludedDirectoryRecursive\n} from \"./Excluded\"\nimport { PosixFile } from \"./PosixFile\"\nimport { SimpleFile } from \"./SimpleFile\"\nimport { exists } from \"./Stat\"\n\nfunction mkTagFilter(f: (tags: Tags) => boolean): Predicate<PosixFile> {\n  return async (file: PosixFile) =>\n    thenMapOr(readRawTags(file, false), f, () => false)\n}\n\nexport function requiredTagsFilter(\n  requiredExifTags: (keyof Tags)[]\n): Predicate<PosixFile> {\n  return mkTagFilter((t: Tags) =>\n    allNotBlank(...requiredExifTags.map(ea => t[ea]))\n  )\n}\n\nexport async function notDimensionsTooSmall(f: PosixFile) {\n  if (\n    !gt0(Settings.minVideoDimension.valueOrDefault) &&\n    !gt0(Settings.minImageDimension.valueOrDefault)\n  ) {\n    return\n  }\n  const m = await readMimeType(f)\n  if (m == null || (!m.startsWith(\"image/\") && !m.startsWith(\"video/\")))\n    return false\n  const min = m.startsWith(\"video/\")\n    ? Settings.minVideoDimension.valueOrDefault\n    : Settings.minImageDimension.valueOrDefault\n  if (!gt0(min)) return\n  return thenMapOr(\n    extractSizeInfoFromFile(f),\n    dim => gte(dim.ImageWidth, min) && gte(dim.ImageHeight, min),\n    () => false\n  )\n}\n\nasync function notVideoTooShort(f: PosixFile) {\n  if (!gt0(Settings.minVideoDurationSec.valueOrDefault)) return\n  const m = await readMimeType(f)\n  if (m == null) return false\n  if (!isVideoMimeType(m)) return\n  const t = await readRawTags(f, false)\n  if (t == null) return false\n  return gte(extractDurationSec(t), Settings.minVideoDurationSec.valueOrDefault)\n}\n\nasync function notVideoTooLong(f: PosixFile) {\n  if (!gt0(Settings.maxVideoDurationSec.valueOrDefault)) return\n  const m = await readMimeType(f)\n  if (m == null) return false\n  if (!isVideoMimeType(m)) return\n  const t = await readRawTags(f, false)\n  if (t == null) return false\n  return lte(extractDurationSec(t), Settings.maxVideoDurationSec.valueOrDefault)\n}\n\nasync function notMissingMimeType(f: PosixFile): Promise<boolean> {\n  return !blank(await readMimeType(f))\n}\n\n// A rating of -1 is considered \"rejected\"\nasync function notRejectedRating(f: PosixFile): Promise<boolean | undefined> {\n  if (Settings.rejectRatingsLessThan.valueOrDefault === -100) return undefined\n  const t = await readTags(f)\n  const rating = toInt(t?.Rating)\n  return (\n    rating == null || rating >= Settings.rejectRatingsLessThan.valueOrDefault\n  )\n}\n\n// Any keywords matching excludedKeywords?\nasync function notExcludedKeyword(f: PosixFile): Promise<boolean | undefined> {\n  if (Settings.keywordBlocklist.values.length === 0) return undefined\n  const tagPaths = rawTagKeywords(await readTags(f))\n  return tagPaths.every(\n    ea => leafIsExcluded(ea, Settings.keywordBlocklist.values) !== true\n  )\n}\n\nexport const hasBrowserImgMimeType = mkTagFilter((t: Tags) =>\n  includes([\"image/jpeg\", \"image/png\"], toS(t.MIMEType))\n)\n\nasync function notMissingMakeAndModelTags(f: PosixFile) {\n  const skip = !Settings.requireMakeModel.valueOrDefault\n  if (skip) return\n  const t = await readRawTags(f)\n  if (t == null || blank(t.MIMEType)) return\n  if (t.MIMEType.startsWith(\"image/\")) {\n    return t != null && notBlank(t.Make) && notBlank(t.Model)\n  } else {\n    return // not applicable\n  }\n}\n\nexport async function notFileMissing(file: SimpleFile) {\n  return isBaseFile(file) ? file.exists() : exists(file.nativePath)\n}\n\n// Skip over files that are < 50kb or > 1 gb, assuming that > 1 gb files are\n// downloaded movies. (1 gb is 10-20 minutes of FHD video, or > 5 minutes of\n// UHD video). kb = 1e3, mb = 1e6, gb = 1e9\n\n// If we're copying a file from a NAS to an external drive, we might be looking\n// at ~5-10mb/s. Transferring 1.5gb @ 5 mb/s is 5 minutes.\n\n// TODO: if we make asset import timeouts based on filesize, we can make this\n// limit much larger.\n\n// (Note that a 1600x1200 JPEG at 50% quality is ~150k, so 50k should be very\n// conservative.)\nexport async function notFileTooSmall(\n  file: SimpleFile\n): Promise<boolean | null> {\n  const min = Settings.minAssetFileSizeBytes.valueOrDefault\n  if (min <= 0) return null // disabled\n  const size = await file.size()\n  return gte(size, min)\n}\n\nexport async function notFileTooBig(file: SimpleFile): Promise<boolean | null> {\n  const max = Settings.maxAssetFileSizeBytes.valueOrDefault\n  if (max <= 0) return null\n  const size = await file.size()\n  return lte(size, max)\n}\n\nexport function simpleFileFiltersFor(\n  file: SimpleFile\n): PredicateBundle<SimpleFile> {\n  return [\n    { isSupportedFileExtension: isAssetFileExtension },\n    ...notExcludedFilePredicates(file),\n    { notFileMissing },\n    { notFileTooSmall, notFileTooBig }\n  ] as PredicateBundle<SimpleFile>\n}\n\nexport function whyRejectFileSimple(file: SimpleFile): PromiseMaybe<string> {\n  return Predicates.whyRejected(file, ...simpleFileFiltersFor(file))\n}\n\nexport function acceptFileSimple(file: SimpleFile): Promise<boolean> {\n  return Predicates.accepted(file, ...simpleFileFiltersFor(file))\n}\n\nexport async function acceptParentAndFileAndSimple(\n  file: SimpleFile\n): Promise<boolean> {\n  const parent = await file.parent()\n  return (\n    parent != null &&\n    !(await isExcludedDirectory(parent)) &&\n    (await Predicates.accepted(file, ...simpleFileFiltersFor(file)))\n  )\n}\n\n// NOTE 1: These are named to make PredicateNames.negateFilterName simple (so,\n// \"notMissingMimeType\" becomes \"missing mime type\")\n\nexport function expensiveFileFiltersFor(\n  file: PosixFile\n): PredicateBundle<PosixFile> {\n  return [\n    ...simpleFileFiltersFor(file),\n    { notMissingMimeType },\n    { supportedMimeType: isAssetFileMimeType },\n    { notMissingMakeAndModelTags },\n    { notDimensionsTooSmall },\n    { notVideoTooShort },\n    { notVideoTooLong },\n    { notRejectedRating },\n    { notExcludedKeyword }\n  ] as PredicateBundle<PosixFile> // SITS TYPING (why is the as cast necessary?)\n}\n\nexport async function whyRejectFile(\n  file: PosixFile,\n  bundle?: PredicateBundle<PosixFile>\n): PromiseMaybe<string> {\n  return (\n    // file predicate first as it may be the most specific rejection reason\n    (await Predicates.whyRejected(\n      file,\n      ...(bundle ?? expensiveFileFiltersFor(file))\n    )) ?? (await whyExcludedDirectoryRecursive(file.parent()))\n  )\n}\n\nexport async function acceptFile(file: PosixFile): Promise<boolean> {\n  return null == (await whyRejectFile(file))\n}\n","import _path from \"path\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { equalsIgnoreCase } from \"../String\"\n\nexport function posix2native(posixPath: string, hostname?: string): string {\n  if (blank(posixPath)) return posixPath\n  if (_path.sep === _path.posix.sep) return posixPath\n  const prefix = notBlank(hostname)\n    ? _path.sep + _path.sep + hostname + _path.sep\n    : \"\"\n  const split = posixPath.split(_path.posix.sep)\n  if (equalsIgnoreCase(split[0], hostname)) split.unshift()\n  return prefix + split.join(_path.sep)\n}\n\nexport function native2posix(nativePath: string): string {\n  if (blank(nativePath)) return nativePath\n  if (_path.sep === _path.posix.sep) return nativePath\n  return _path.posix.sep === _path.sep\n    ? nativePath\n    : nativePath.split(_path.sep).join(_path.posix.sep)\n}\n","import _path from \"path\"\nimport process from \"process\"\nimport { lazy, MemoizedThunk } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { uniqInPlace } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { isElectron, isMac } from \"../platform/Platform\"\nimport { ancestors, hasChildrenSync } from \"./Ancestors\"\nimport { isPhotoStructureDmg } from \"./IgnorableMountpoint\"\n\nexport const execDir = lazy(() => _path.dirname(process.execPath))\n\nfunction pathTo(...child: string[]): MemoizedThunk<string> {\n  return lazy<string>(() => _path.join(ProjectPath.Root() as string, ...child))\n}\n\nexport const ProjectPath = {\n  Root: lazy(() => {\n    const projectDirs = [\"data\", \"public\", \"views\"]\n    const dirs: string[] = []\n    if (isDocker()) {\n      dirs.push(\"/opt/photostructure\")\n    }\n    if (isElectron) {\n      dirs.push(\n        _path.join(execDir(), \"resources\"), // win electron\n        _path.join(execDir(), \"..\", \"Resources\") // mac electron\n      )\n    }\n    dirs.push(...compactBlanks([execDir(), process.cwd(), __dirname]))\n    uniqInPlace(dirs)\n    for (const dir of dirs) {\n      if (hasChildrenSync(dir, projectDirs)) return dir\n      // don't go too far up:\n      for (const parent of ancestors(dir).slice(0, 4)) {\n        if (hasChildrenSync(parent, projectDirs)) return parent\n        const npx = _path.join(dir, \"node_modules\", \"photostructure\")\n        if (hasChildrenSync(npx, projectDirs)) return npx\n      }\n    }\n    return mkLogger(\"fs.ProjectPath\").throw(\n      \"Failed to find project root. Looked in \" + dirs\n    )\n  }),\n  Bin: pathTo(\"bin\"), // only present in docker and node\n  Data: pathTo(\"data\"),\n  ICC: pathTo(\"data\", \"icc\"),\n  Migrations: pathTo(\"data\", \"migrations\"),\n  Public: pathTo(\"public\"),\n  Tools: pathTo(\"tools\"),\n  Views: pathTo(\"views\"),\n  isInDMG: function (projectPathRoot?: string) {\n    if (!isMac) return false\n\n    // If PhotoStructure.app has a sibling called .background with a\n    // nobg-background.tiff, we're still in the DMG, but that will break if we\n    // change the DMG background. We could also check to see that we live in an\n    // Applications directory, but that's also not guaranteed.\n    return isPhotoStructureDmg(projectPathRoot ?? ProjectPath.Root())\n  }\n}\n","import * as fs from \"fs\"\nimport { readFile } from \"fs-extra\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toInt } from \"../../fe/Number\"\nimport { mkLogger } from \"../Logger\"\nimport { LogLevel, LogLevels } from \"../log/LogLevel\"\n\nconst logger = lazy(() => mkLogger(\"fs.ReadFile\"))\n\nexport async function readFileMaybe(\n  nativePath: string,\n  errLogLevel: LogLevel = LogLevels.info\n): PromiseMaybe<Buffer> {\n  try {\n    return await readFile(nativePath)\n  } catch (err) {\n    logger().log(errLogLevel, \".readFileMaybe(\" + nativePath + \")\", err)\n    return\n  }\n}\n\nexport function readFileSync(nativePath: string): Maybe<Buffer> {\n  try {\n    return fs.readFileSync(nativePath)\n  } catch {\n    //\n  }\n  return\n}\n\nexport function intFromFileSync(nativePath: string): Maybe<number> {\n  return logger().tap({\n    msg: \"intFromFileSync()\",\n    result: toInt(readFileSync(nativePath)?.toString(), {\n      defaultValue: undefined\n    }),\n    meta: { nativePath }\n  })\n}\n","import { close, open, read, stat } from \"fs-extra\"\nimport { mapGte0 } from \"../Number\"\n\n/**\n * @param position where to begin reading from in the file\n * @param length the number of bytes to read\n * @throws if fs.open or fs.read throws\n */\nexport async function readFilePart_({\n  nativePath,\n  position = 0,\n  length\n}: {\n  nativePath: string\n  position?: number\n  length?: number\n}) {\n  let fd = -1\n  try {\n    // only stat() if the length is not provided:\n    const bufLen = length ?? (await stat(nativePath)).size - position\n    const b = Buffer.alloc(bufLen)\n    fd = await open(nativePath, \"r\")\n    return await read(fd, b, 0, bufLen, position)\n  } finally {\n    mapGte0(fd, close)\n  }\n}\n","import { readFile } from \"fs-extra\"\nimport { splitCompactLines } from \"./CRLF\"\n\nexport async function readLines_(nativePath: string): Promise<string[]> {\n  return splitCompactLines(await readFile(nativePath))\n}\n","import { Readable } from \"stream\"\n\nexport class ReadableBuffer extends Readable {\n  constructor(buffer: Buffer | string) {\n    super()\n    this.push(buffer)\n    this.push(null)\n  }\n}\n","import fsp from \"fs/promises\"\nimport { join } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0, toGt0 } from \"../../fe/Number\"\nimport {\n  Timeout,\n  thenOrTimeout,\n  thenOrTimeoutAt,\n  toNotTimeout\n} from \"../../fe/ThenOrTimeout\"\nimport { FifoSet } from \"../FifoSet\"\nimport { mkLogger } from \"../Logger\"\nimport { onTimeout } from \"../async/TimeoutHandler\"\nimport { ee } from \"../event/EventEmitter\"\nimport { Settings } from \"../settings/Settings\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { FileCache } from \"./FileCache\"\nimport { SimpleDirent } from \"./SimpleDirent\"\nimport { statTimeoutMs } from \"./StatTimeout\"\n\nexport interface CachedReaddir {\n  ts: number\n  path: string\n  result: SimpleDirent[]\n}\n\nexport const ReadDirCacheName = \"readdircache\"\n\nexport const readdirCacheDir = lazy(() =>\n  join(Settings.cacheDir.valueOrDefault, ReadDirCacheName)\n)\n\nconst logger = lazy(() => mkLogger(\"fs.Readdir\"))\n\nexport async function clearReaddirCaches() {\n  try {\n    await fsp.rm(readdirCacheDir(), { force: true, recursive: true })\n  } catch (error) {\n    logger().warn(\"clearReaddirCaches(): failed\", { error })\n  }\n}\n\nconst path2cache = lazy(\n  () =>\n    new FileCache<SimpleDirent[]>({\n      name: \"fs.readdir\",\n      maxSize: 256,\n      timeoutMs: commandTimeoutMs(),\n      clearEveryMs: minuteMs\n    })\n)\n\nexport function clearCachedReaddir(nativePath: string) {\n  if (!blank(nativePath)) {\n    path2cache.prior()?.delete(nativePath)\n  }\n}\n\nlater(() => {\n  Settings.cacheDir.watchLater(() => {\n    readdirCacheDir.clear()\n    void path2cache.prior()?.clear()\n    slowDirs.prior()?.clear()\n  })\n  ee().on(\"clearCache\", () => {\n    slowDirs.prior()?.clear()\n    // path2cache is a FileCache--they're already watching for \"clearCache\" and fileChanged.\n    return clearReaddirCaches()\n  })\n  ee().on(\"fileChanged\", nativePath =>\n    blank(nativePath) ? clearReaddirCaches() : clearCachedReaddir(nativePath)\n  )\n})\n\n// Only exposed for tests\nexport const slowDirs = lazy(() => new FifoSet<string>(256))\n\nexport async function isSlowDir(nativePath: string) {\n  if (blank(nativePath)) return false\n  if (slowDirs().has(nativePath)) return true\n  if (path2cache().has(nativePath)) {\n    slowDirs().add(nativePath)\n    return true\n  }\n  return false\n}\n\nexport function setSlowDir(nativePath: string) {\n  clearCachedReaddir(nativePath)\n  slowDirs().add(nativePath)\n}\n\nexport async function isCachedDir(nativePath: string) {\n  return path2cache().get(nativePath) != null\n}\n\nexport async function childDirectories_(nativePath: string): Promise<string[]> {\n  return (await readdir_(nativePath))\n    .filter(ea => ea.isDirectory)\n    .map(ea => join(nativePath, ea.basename))\n}\n\nexport async function readdir(\n  nativePath: string\n): PromiseMaybe<SimpleDirent[]> {\n  try {\n    return await (gt0(Settings.readdirCacheMs.valueOrDefault)\n      ? readdir_(nativePath)\n      : readdirUncached_(nativePath))\n  } catch (err) {\n    logger().warn(\"readdir() failed for \" + nativePath, err)\n    return\n  }\n}\n\n/**\n * @throws if readdir() fails.\n */\nexport async function readdir_(nativePath: string): Promise<SimpleDirent[]> {\n  return logger().tap({\n    level: \"trace\",\n    msg: \"readdir_(\" + nativePath + \")\",\n    result: await path2cache().getOrSetAsync(nativePath, () =>\n      _readdir_(nativePath)\n    )\n  })\n}\n\nexport function readdirCached(nativePath: string): Maybe<SimpleDirent[]> {\n  return path2cache().get(nativePath)\n}\n\nasync function _readdir_(nativePath: string): Promise<SimpleDirent[]> {\n  const ts = Date.now()\n  const timeoutAt = ts + statTimeoutMs() * 2\n\n  const p = readdirUncached_(nativePath)\n\n  // If readdir() completes quickly, don't bother with .json caching (which is\n  // expensive and generates a bunch of GC)\n\n  const quickResult = await thenOrTimeout(\n    p,\n    toGt0(Settings.fsCacheSlowMs.valueOrDefault) ?? statTimeoutMs()\n  )\n\n  if (quickResult === Timeout) {\n    onTimeout({ soft: false })\n  }\n\n  if (\n    quickResult !== Timeout &&\n    quickResult.length < Settings.readdirSizeCacheThresh.valueOrDefault\n  ) {\n    return quickResult\n  }\n\n  // Dang, we're dealing with a slow or very large directory.\n  logger().info(\"readdir(): slow or large dir\", { nativePath })\n  slowDirs().add(nativePath)\n\n  const result =\n    toNotTimeout(quickResult) ?? (await thenOrTimeoutAt(p, timeoutAt))\n\n  if (result === Timeout) {\n    return logger().throw(\"readdir() timeout\", { nativePath, doNotSend: true })\n  }\n\n  return result\n}\n\n/**\n * NOTE: CALLER SHOULD WRAP WITH A TIMEOUT!\n */\nexport async function readdirUncached_(\n  nativePath: string\n): Promise<SimpleDirent[]> {\n  const r = await fsp.readdir(nativePath, { withFileTypes: true })\n  return sortBy(\n    // this strips off the node 20 added \"path\" field:\n    r.map(ea => ({\n      basename: ea.name,\n      isFile: ea.isFile(),\n      isDirectory: ea.isDirectory()\n    })),\n    ea => [\n      ea.isFile, // < order files last\n      ea.basename.toLowerCase(), // < case insensitive sort (ish, but good enough here)\n      ea.basename // < for determinism with colliding FILE.txt and file.txt\n    ]\n  )\n}\n","import { CountingSet } from \"../CountingSet\"\nimport { Settings } from \"../settings/Settings\"\nimport { toPathnames } from \"./Path\"\nimport { SimpleFileOrString } from \"./SimpleFile\"\n\n/**\n * naïve detection of symlink loops\n */\nexport function seemsLikeSymlinkLoop(s: SimpleFileOrString): boolean {\n  const cs = new CountingSet()\n  for (const ea of toPathnames(s)) {\n    cs.incr(ea.toLowerCase().normalize())\n  }\n  return cs.max() > Settings.maxDuplicatePathElements.valueOrDefault\n}\n","import { notBlank } from \"../../fe/Blank\"\nimport { isBoolean } from \"../../fe/Boolean\"\n\nexport interface SimpleDirent {\n  /**  isFile */\n  isFile: boolean\n  /**  isDirectory */\n  isDirectory: boolean\n  /** full base name */\n  basename: string\n}\nexport function isSimpleDirent(d: any): d is SimpleDirent {\n  return (\n    d != null &&\n    notBlank(d.basename) &&\n    isBoolean(d.isFile) &&\n    isBoolean(d.isDirectory)\n  )\n}\n","import _fs from \"fs\"\nimport _path from \"path\"\nimport { blank } from \"../../fe/Blank\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe, MaybePromiseMaybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { equalsIgnoreCase, isString, stripPrefix } from \"../String\"\nimport { isWin } from \"../platform/Platform\"\nimport { NativePathed, resolve } from \"./Path\"\nimport { isSimpleDirent } from \"./SimpleDirent\"\n\n// BEST TYPE NAME EVAR\nexport type SimpleFileOrString = SimpleFile | string\n\nexport interface SimpleFile {\n  /**\n   * Absolute path\n   */\n  readonly nativePath: string\n  /**\n   * Absolute path elements\n   */\n  readonly pathnames: string[]\n  /**\n   * The file name including extension (if any) such as 'index.html'\n   */\n  readonly base: string\n  /**\n   * The file extension (if any) such as '.html'\n   */\n  readonly ext: string\n  /**\n   * The file name without extension (if any) such as 'index'\n   */\n  readonly name: string\n  /**\n   * The nativePath of the parent directory\n   */\n  readonly dir: string\n\n  /**\n   * True iff this directory has no parent\n   */\n  readonly isRoot: boolean\n\n  isFile(): SyncOrAsync<boolean>\n  isDirectory(): SyncOrAsync<boolean>\n  isFileSync(): boolean\n  isDirectorySync(): boolean\n\n  // No isSymbolicLink, as this method is only valid when using fs.lstat():\n  // https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_stats_issymboliclink\n\n  children(): MaybePromiseMaybe<this[]>\n  childNames(): MaybePromiseMaybe<string[]>\n  parent(): SyncOrAsync<Maybe<this>>\n\n  size(): SyncOrAsync<Maybe<number>>\n  mtimeMs(): SyncOrAsync<Maybe<number>>\n}\n\nexport function isSimpleFile(object: any): object is SimpleFile {\n  return (\n    object != null &&\n    // HEY FUTURE ME! Don't `instanceof DirectoryEntry` or BaseFile here: that\n    // causes a deploop\n    typeof object === \"object\" &&\n    !Array.isArray(object) &&\n    typeof object.nativePath === \"string\" &&\n    typeof object.base === \"string\" &&\n    typeof object.ext === \"string\" &&\n    typeof object.base === \"string\" &&\n    typeof object.dir === \"string\" &&\n    typeof object.isFile === \"function\"\n  ) // meh good enough\n}\n\nexport function toNativePath_(s: string | NativePathed): string {\n  if (s == null) {\n    throw new Error(\"toNativePath(null)\")\n  }\n  if (blank(s)) {\n    throw new Error(\"toNativePath(blank)\")\n  }\n  if (isString(s)) {\n    // only resolve strings--if it has a nativePath, it's already resolved:\n    return resolve(s)\n  }\n  if (blank(s.nativePath)) {\n    throw new Error(`toNativePath(${stringify(s)})`)\n  }\n  return s.nativePath\n}\n\nexport function basename(s: SimpleFileOrString | _fs.Dirent) {\n  return s instanceof _fs.Dirent\n    ? s.name\n    : isSimpleFile(s)\n    ? s.base\n    : _path.basename(toNativePath_(s))\n}\n\nexport function dirname(s: SimpleFileOrString) {\n  return isSimpleFile(s) ? s.dir : _path.dirname(toNativePath_(s))\n}\n\nconst winDriveRE = /^[a-z]:$/i\n\nexport function rootDir(s: SimpleFileOrString): Maybe<string> {\n  // TODO: handle UNC paths\n  if (isSimpleFile(s)) {\n    const arr = s.pathnames\n    return isWin && arr[0].match(winDriveRE) != null ? arr[1] : arr[0]\n  } else {\n    const str = stripPrefix(s, \"/\") // ignore the initial \"/\"\n    const i = str.indexOf(_path.sep)\n    return i > 0 ? str.slice(1, i) : undefined\n  }\n}\n\nexport function findFileIndex(\n  needle: SimpleFile,\n  haystack: SimpleFile[]\n): number {\n  for (let i = 0; i < haystack.length; i++) {\n    if (haystack[i].nativePath === needle.nativePath) return i\n  }\n  for (let i = 0; i < haystack.length; i++) {\n    if (equalsIgnoreCase(haystack[i].nativePath, needle.nativePath)) return i\n  }\n  return -1\n}\n\nexport function isFileSync(s: SimpleFileOrString) {\n  if (blank(s)) return false\n\n  if (s instanceof _fs.Dirent) return s.isFile()\n\n  for (const ea of [s, (s as any)[\"dirent\"]]) {\n    if (isSimpleDirent(ea)) return ea.isFile // < not a method.\n  }\n\n  try {\n    const stat = _fs.statSync(toNativePath_(s))\n    return stat.isFile()\n  } catch {\n    return false\n  }\n}\n\nexport async function someSelfOrAncestor<T extends SimpleFile>(\n  sf: Maybe<T>,\n  predicate: (t: T) => SyncOrAsync<boolean>\n): Promise<boolean> {\n  if (sf == null) return false\n  const result = await predicate(sf)\n  return result === true || sf.isRoot\n    ? result\n    : someSelfOrAncestor(await sf.parent(), predicate)\n}\n\nexport async function firstSelfOrAncestor<T extends SimpleFile, R>(\n  sf: Maybe<T>,\n  predicate: (t: T) => SyncOrAsync<R>\n): PromiseMaybe<R> {\n  if (sf == null) return\n  const result = await predicate(sf)\n  return result != null || sf.isRoot\n    ? result\n    : firstSelfOrAncestor(await sf.parent(), predicate)\n}\n","import { Stats } from \"fs\"\nimport _fse from \"fs-extra\"\nimport { lazy } from \"../../core/Lazy\"\nimport { uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { isDate, unixtime } from \"../../fe/Date\"\nimport { Maybe, MaybePromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { diff, isNumber } from \"../../fe/Number\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { mkLogger } from \"../Logger\"\nimport { onTimeout } from \"../async/TimeoutHandler\"\nimport { isRecentMs } from \"../date/Date\"\nimport { LogLevel, LogLevels } from \"../log/LogLevel\"\nimport { access, isStatRWX } from \"./Access\"\nimport { isEmptyStats } from \"./StatSync\"\nimport { statTimeoutMs } from \"./StatTimeout\"\n\nconst logger = lazy(() => mkLogger(\"fs.Stat\"))\n\nexport async function stat_(nativePath: Maybe<string>): Promise<Stats> {\n  if (blank(nativePath)) {\n    return logger().throw(\"stat_() for blank path\", {\n      nativePath,\n      retriable: false,\n      fatal: false\n    })\n  }\n  const start = Date.now()\n  try {\n    return await thenOrTimeoutError(\n      _fse.stat(nativePath), // < no throwIfNoEntry option for async stat()\n      statTimeoutMs(),\n      true\n    )\n  } finally {\n    const elapsedMs = Date.now() - start\n    if (elapsedMs > statTimeoutMs() / 2) {\n      logger().warn(\"soft timeout for \" + nativePath, { elapsedMs })\n      onTimeout({ soft: true })\n    }\n  }\n}\n\nexport function statMaybe(\n  nativePath: Maybe<string>,\n  logLevel: LogLevel = LogLevels.debug\n): MaybePromiseMaybe<Stats> {\n  return blank(nativePath)\n    ? undefined\n    : stat_(nativePath).catch(error => {\n        logger().log(logLevel, \"stat() failed\", { error, nativePath })\n        return undefined\n      })\n}\n\nexport function statToType(a: Stats) {\n  return a.isDirectory() ? \"directory\" : a.isFile() ? \"file\" : \"special\"\n}\n\nfunction statFieldToComparable(ea: Maybe<number | Date>): Maybe<number> {\n  return isDate(ea) ? unixtime(ea) : isNumber(ea) ? ea : undefined\n}\n\n/**\n * Given `Stats` objects from the same path, is it likely that the file has\n * changed?\n */\nexport function whyStatNotEql(a: Maybe<Stats>, b: Maybe<Stats>) {\n  if (a == null || b == null) {\n    return (\n      \"both must be defined: \" +\n      (a == null ? \"null\" : \"stat\") +\n      \" ≠ \" +\n      (b == null ? \"null\" : \"stat\")\n    )\n  }\n  const aType = statToType(a)\n  const bType = statToType(b)\n  if (aType !== bType) {\n    return \"inconsistent file type: \" + aType + \" ≠ \" + bType\n  }\n  // no atime, and birthtime isn't settable on linux--we're assuming we're\n  // comparing the same path.\n  for (const field of [\"size\", \"mtime\"] as const) {\n    const aVal = a[field]\n    const bVal = b[field]\n    const delta = diff(statFieldToComparable(aVal), statFieldToComparable(bVal))\n    // mtime and birthtime may be fractional milliseconds off.\n    if (delta == null || delta > 1) {\n      return \"unmatched \" + field + \": \" + aVal + \" ≠ \" + bVal\n    }\n  }\n  return\n}\n\nexport function statEql(a: Maybe<Stats>, b: Maybe<Stats>) {\n  return whyStatNotEql(a, b) == null\n}\n\nexport async function exists(\n  nativePath: string,\n  logLevel: LogLevel = LogLevels.info\n) {\n  return null != (await statMaybe(nativePath, logLevel))\n}\n\n/**\n * @return if the file is missing or empty\n */\nexport async function isEmptyFile(\n  nativePath: string,\n  opts?: { emptyIsNew?: boolean; logLevel?: LogLevel }\n) {\n  const s = await statMaybe(nativePath, opts?.logLevel ?? LogLevels.trace)\n  return s == null || (opts?.emptyIsNew ?? true) ? isEmptyStats(s) : false\n}\n\nexport async function isNonEmptyFile(nativePath: string, minFileSize = 0) {\n  const s = await statMaybe(nativePath)\n  return s != null && s.isFile() && s.size >= minFileSize\n}\n\nexport async function nativePathIsFile(\n  nativePath: Maybe<string>,\n  logLevel = LogLevels.info\n): Promise<boolean> {\n  return true === (await statMaybe(nativePath, logLevel))?.isFile()\n}\n\nexport async function isDirectory(nativePath: Maybe<string>): Promise<boolean> {\n  return true === (await statMaybe(nativePath))?.isDirectory()\n}\n\nexport async function isReadableDirectory(\n  nativePath: Maybe<string>,\n  logLevel: LogLevel = LogLevels.trace\n): Promise<boolean> {\n  const stat = await statMaybe(nativePath, logLevel)\n  return (\n    stat != null && stat.isDirectory() && access({ stat, r: true, x: true })\n  )\n}\n\nexport async function isReadWriteableDirectory(\n  nativePath: Maybe<string>,\n  logLevel: LogLevel = LogLevels.trace\n): Promise<boolean> {\n  const stat = await statMaybe(nativePath, logLevel)\n  return stat != null && stat.isDirectory() && isStatRWX(stat, nativePath)\n}\n\nexport async function isMtimeRecent(\n  nativePath: Maybe<string>,\n  staleMs: number\n): Promise<boolean> {\n  return isRecentMs((await statMaybe(nativePath))?.mtimeMs, staleMs)\n}\n\n/**\n * @return the uniq stat times, including birthtime and mtime (not atime or\n * ctime!)\n */\nexport function statTimes(s: Stats): number[] {\n  return uniq(\n    // birthtimeMs will be 0 on OSes that don't support it. remember that\n    // ctime is last-status-change-time, (directory-change-time), _not_\n    // create-time. We don't want ctime!\n    [s.birthtimeMs, s.mtimeMs].filter(ea => ea != null && ea !== 0)\n  )\n}\n","import fs from \"fs\"\nimport { resolve } from \"path\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isRecentMs } from \"../date/Date\"\nimport { access } from \"./Access\"\nimport { posix2native } from \"./PosixNative\"\n\nexport function statSync(nativePath: Maybe<string>) {\n  if (blank(nativePath)) return\n  try {\n    return fs.statSync(nativePath, { throwIfNoEntry: false })\n  } catch {\n    // only will throw on older node.js versions:\n    return\n  }\n}\n\nexport function nativePathExistsSync(nativePath: Maybe<string>) {\n  if (blank(nativePath)) return false\n  try {\n    return fs.existsSync(nativePath)\n  } catch {\n    return false\n  }\n}\n\nexport function nativePathSizeSync(nativePath: Maybe<string>): Maybe<number> {\n  return statSync(nativePath)?.size\n}\n\nexport function isFileSync(nativePath: string, minSize = 0): boolean {\n  const s = statSync(nativePath)\n  return s != null && s.isFile() && s.size >= minSize\n}\n\nexport function isEmptyFileSync(\n  nativePath: string,\n  opts: { emptyIsNew: boolean } = { emptyIsNew: true }\n) {\n  const s = statSync(nativePath)\n  return opts.emptyIsNew ? s == null : isEmptyStats(s)\n}\n\nexport function isMtimeRecentSync(\n  nativePath: Maybe<string>,\n  staleMs: number\n): boolean {\n  return isRecentMs(statSync(nativePath)?.mtimeMs, staleMs)\n}\n\nexport function isEmptyStats(s: Maybe<fs.Stats>) {\n  return s == null || (s.isFile() && s.size === 0)\n}\n\nexport function isDirectorySync(nativePath: Maybe<string>): boolean {\n  return statSync(nativePath)?.isDirectory() === true\n}\n\nexport function isReadableDirectorySync(nativePath: Maybe<string>): boolean {\n  const stat = statSync(nativePath)\n  return (\n    stat != null && stat.isDirectory() && access({ stat, r: true, x: true })\n  )\n}\n\nexport function isReadWriteableDirectorySync(\n  nativePath: Maybe<string>\n): boolean {\n  if (blank(nativePath)) return false\n  const stat = statSync(nativePath)\n  return (\n    stat != null &&\n    stat.isDirectory() &&\n    access({ stat, r: true, w: true, x: true })\n  )\n}\n\nexport function firstExistingDirectory(paths: Maybe<string>[]): Maybe<string> {\n  for (const ea of paths) {\n    if (notBlank(ea)) {\n      const d = resolve(ea)\n      if (isDirectorySync(d)) return d\n    }\n  }\n  return undefined\n}\n\nexport function posixPathExistsSync(posixPath: Maybe<string>) {\n  return blank(posixPath)\n    ? false\n    : nativePathExistsSync(posix2native(posixPath))\n}\n","import { Settings } from \"../settings/Settings\"\n\nexport function statTimeoutMs() {\n  return Settings.statTimeoutMs.valueOrDefault\n}\n","import { notBlank } from \"../../fe/Blank\"\nimport { Latch } from \"../../fe/Latch\"\n\nexport function onDataChunked(\n  r: NodeJS.ReadableStream,\n  sep: string | RegExp,\n  onData: (data: string) => any\n): Latch {\n  const c = new Chunker(sep, onData, true)\n  c.read(r)\n  return c.done\n}\n\n/**\n * Handles data streams that may come in with disjoint chunks (like `[\"hel\",\n * \"lo\\n\"]`)\n */\nexport class Chunker {\n  private incompleteChunk = \"\"\n  readonly done = new Latch()\n\n  constructor(\n    readonly sep: string | RegExp,\n    readonly onData: (data: string) => any,\n    readonly filterBlanks = true\n  ) {}\n\n  onChunk(chunk: string | Buffer) {\n    if (chunk == null) return\n    const s = this.incompleteChunk + chunk.toString()\n    const split = s.split(this.sep)\n    // If s is not terminated by a separator, the last element in the array will\n    // be non-blank. If the string ends in a separator, an empty string will be\n    // the last element of the array, and this \"clears out\" incompleteChunk (as\n    // we'd want), so both cases are handled appropriately here:\n    this.incompleteChunk = split.pop()!\n    split.forEach(ea => {\n      if (!this.filterBlanks || notBlank(ea)) {\n        this.onData(ea)\n      }\n    })\n  }\n\n  clear() {\n    this.onChunk(\"\")\n    if (notBlank(this.incompleteChunk)) this.onData(this.incompleteChunk)\n    this.incompleteChunk = \"\"\n  }\n\n  read(r: NodeJS.ReadableStream) {\n    r.on(\"data\", ea => this.onChunk(ea))\n    r.on(\"end\", () => {\n      this.clear()\n      void this.done.resolve()\n    })\n    return this\n  }\n}\n","import { WriteStream } from \"tty\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\n\nexport function streamEnded(s: Maybe<WriteStream>): boolean {\n  return (\n    s == null ||\n    !s.writable ||\n    s.destroyed ||\n    s.writableEnded ||\n    s.writableFinished\n  )\n}\n","import { ChildProcess } from \"child_process\"\nimport _n from \"net\"\nimport _s from \"stream\"\nimport { delay } from \"../../fe/Delay\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, MaybeNull } from \"../../fe/MaybeTypes\"\nimport { maybeCall } from \"../../fe/Object\"\nimport { NoOp } from \"../../fe/Thunk\"\nimport { Try } from \"../Object\"\nimport { ending } from \"../async/Endable\"\nimport { isIgnorableError } from \"../error/ErrorTypes\"\n\nexport class PassthroughStream extends _s.Duplex {\n  _write(chunk: any, encoding: BufferEncoding) {\n    this.push(chunk, encoding)\n  }\n}\n\n/**\n * Handles backpressure by optionally waiting for the drain event\n */\nexport async function writeAsync(\n  stream: _s.Writable,\n  data: string | Buffer\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    if (\n      false ===\n      stream.write(data, err => {\n        if (err) reject(err)\n      })\n    ) {\n      stream.once(\"drain\", resolve)\n    } else {\n      resolve()\n    }\n  })\n}\n\n// I don't want to just Pick<Writable, \"end\"> because I don't want to require\n// all the overloaded signatures as well.\nexport interface EndableStream {\n  end(chunk: any, cb?: () => void): void\n}\n\nexport async function endStream(\n  endable: MaybeNull<EndableStream>\n): Promise<void> {\n  if (endable == null) return\n  // Make sure we don't hang waiting for this stream:\n  Try(() => maybeCall(endable, \"unref\"))\n  if (ending()) {\n    // no need to wait for the end callback:\n    endable.end(null)\n  } else {\n    // Half-closes the socket (!!)\n    await new Promise<void>(resolve => endable.end(null, resolve))\n  }\n  await delay(50)\n\n  // Ensures that no more I/O activity happens on this socket\n  Try(() => maybeCall(endable, \"destroy\"))\n  return\n}\n\nexport interface ClosableStream {\n  close(callback: () => void): void\n}\n\nexport async function closeStream(\n  closable: Maybe<ClosableStream>\n): Promise<void> {\n  if (closable == null) return\n  Try(() => maybeCall(closable, \"unref\"))\n  if (ending()) {\n    closable.close(NoOp)\n  } else {\n    await new Promise<void>(resolve => closable.close(resolve))\n  }\n  // I don't think this is necessary (and caused errors with electron last year):\n  // await delay(50)\n  // Try(() => maybeCall(closable, \"destroy\"))\n  return\n}\n\nexport function onChildError(\n  cp: ChildProcess,\n  f: (src: \"cp\" | \"stdin\" | \"stdout\" | \"stderr\", err: Error) => void\n): void {\n  ;[\n    { name: \"cp\", ea: cp },\n    { name: \"stdin\", ea: cp.stdin },\n    { name: \"stdout\", ea: cp.stdout },\n    { name: \"stderr\", ea: cp.stderr }\n  ].forEach(({ name, ea }) =>\n    map(ea, ea2 =>\n      ea2.on(\"error\", err => {\n        if (isIgnorableError(err) === false) f(name as any, err)\n      })\n    )\n  )\n}\n\nexport function closeStreams(cp: ChildProcess) {\n  for (const ea of [cp?.stdin, cp?.stdout, cp?.stderr]) {\n    try {\n      ea?.destroy()\n    } catch {\n      //\n    }\n  }\n}\n\nexport type Pipeline = [\n  NodeJS.ReadableStream,\n  ...(NodeJS.ReadWriteStream | NodeJS.WritableStream)[]\n]\n\nexport function remoteDesc(s: _n.Socket): string {\n  return s.destroyed\n    ? \"destroyed\"\n    : `${s.remoteFamily}:${s.remoteAddress}:${s.remotePort}`\n}\n\nexport class ByteCounter extends _s.Transform {\n  private bytes = 0\n  constructor(readonly onProgress: (bytes: number) => any) {\n    super({\n      transform: (\n        chunk: any,\n        _encoding: BufferEncoding,\n        callback: _s.TransformCallback\n      ) => {\n        this.onProgress((this.bytes += chunk.length))\n        callback(chunk)\n      }\n    })\n  }\n}\n","import { createWriteStream } from \"fs\"\nimport { DateTime } from \"luxon\"\nimport { unparse } from \"papaparse\"\nimport { Writable } from \"stream\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { dayMs } from \"../../fe/Date\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gte } from \"../../fe/Number\"\nimport { entries, keys } from \"../../fe/Object\"\nimport { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\nimport { wrap } from \"../../fe/String\"\nimport { TimeoutError } from \"../../fe/TimeoutError\"\nimport { toS } from \"../../fe/toS\"\nimport { BoundedList } from \"../BoundedList\"\nimport { isTest } from \"../NodeEnv\"\nimport { diff } from \"../Set\"\nimport { stdoutWrite } from \"../StdoutWrite\"\nimport { EndableRanks } from \"../async/Endable\"\nimport { EndableWrapper } from \"../async/EndableWrapper\"\nimport { filestamp } from \"../date/Filestamp\"\nimport { librarySyncReportsDir } from \"../dir/LibraryDirs\"\nimport { logDir } from \"../dir/LogDir\"\nimport { errorToS } from \"../error/Error\"\nimport { InternalErrorFlag } from \"../error/ErrorFlags\"\nimport { stack } from \"../error/stack\"\nimport { isCsvExt } from \"../fs/FileExt\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { endStream } from \"../fs/Streams\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { Settings } from \"../settings/Settings\"\nimport { Newline } from \"./CRLF\"\nimport { writeTextfile_ } from \"./WriteFile\"\n\nexport const AssetFileSyncStates = strEnum(\n  \"noop\",\n  \"deleted\",\n  \"skipped\",\n  \"synced\",\n  \"unknown\"\n)\nexport type AssetFileSyncState = StrEnumKeys<typeof AssetFileSyncStates>\n\nexport const SyncFileStates = strEnum(\n  ...AssetFileSyncStates.values,\n  \"rejected\",\n  \"failed\",\n  \"timeout\",\n  \"enqueued\",\n  \"started\",\n  \"copied\",\n  \"note\"\n)\nexport type SyncFileState = StrEnumKeys<typeof SyncFileStates>\n\nexport const FileDoneStates = diff<SyncFileState>(SyncFileStates.values, [\n  \"enqueued\",\n  \"started\",\n  \"note\"\n])\n\nexport const SyncDirStates = strEnum(\n  \"scanning\",\n  \"canceled\",\n  \"failed\",\n  \"timeout\",\n  \"skipped\",\n  \"scanned\"\n)\nexport type SyncDirState = StrEnumKeys<typeof SyncDirStates>\n\nexport type SyncReportState = SyncDirState | SyncFileState\n\nexport function isRejectedState(state: Maybe<SyncReportState>): boolean {\n  return (\n    state == null ||\n    [\n      \"canceled\",\n      \"deleted\",\n      \"failed\",\n      \"rejected\",\n      \"timeout\",\n      \"unknown\"\n    ].includes(state)\n  )\n}\n\nconst FileStateDescriptions: Record<SyncFileState, string> = {\n  enqueued:\n    \"the file looks promising, and will be attempted to be imported soon.\",\n  rejected:\n    \"the file did not pass all import filters. The details column will explain why.\",\n  started:\n    \"the file was dequeued from the work queue, and is now going to be processed.\",\n  noop: `the current file metadata already matches your library database, so no operation was needed to sync this file.`,\n  deleted:\n    \"the file was determined to be deleted (the prior mountpoint exists, but the file doesn't exist anymore)\",\n  skipped: \"the file lives on a volume that isn't currently mounted.\",\n  synced: \"the file was imported.\",\n  failed: \"something went wrong. The details column will explain why.\",\n  timeout: \"the file wasn't processed in a reasonable amount of time.\",\n  copied: `\"automatic organization\" is enabled (copyAssetsToLibrary=true), and the photo or video was copied into your library originals directory. The details column will contain the source file path.`,\n  note: \"sidecars will be referenced here. The details column will specify which source file(s) it will be associated with.\",\n  unknown: \"an internal error occurred during processing.\"\n}\n\nconst DirStateDescriptions: Record<SyncDirState, string> = {\n  scanning: \"the directory contents are about to be read.\",\n  scanned: \"the directory contents were completely processed.\",\n  skipped: \"the directory was excluded. The details column will explain why.\",\n\n  canceled: \"PhotoStructure was shut down before the directory was processed.\",\n  failed: \"reading the directory contents failed.\",\n  timeout: \"reading the directory contents took too long.\"\n}\n\nfunction recordToBullets(obj: Record<string, string>): string {\n  return entries(obj)\n    .map(([k, v]) => `  - \"${k}\": ${v}`)\n    .join(\"\\n\")\n}\n\nconst WarnStates = new Set<string>([\n  AssetFileSyncStates.deleted,\n  SyncFileStates.failed,\n  SyncFileStates.timeout,\n  SyncDirStates.canceled\n])\n\n// only used for typing, and so we can get a non-runtime-erased set of keys for\n// the header:\nclass SyncReportClass {\n  constructor(\n    readonly ts: number,\n    readonly at: string,\n    readonly path: string,\n    readonly state: SyncReportState,\n    readonly from: string,\n    readonly elapsedMs?: number,\n    readonly details?: string,\n    readonly url?: string\n  ) {}\n}\n\nexport const SyncReportHeaders = strEnum(\n  ...keys(\n    new SyncReportClass(\n      Date.now(), // ts\n      \"\", // at\n      \"\", // path\n      \"\" as any, //state\n      \"\", // from\n      0, // elapsedMs\n      \"\", // details\n      \"\" // url\n    )\n  )\n)\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface SyncReportRow extends SyncReportClass {}\nexport type SyncProgress = Omit<SyncReportClass, \"ts\" | \"at\">\nexport type WrapSyncProgress = Partial<Omit<SyncProgress, \"state\">> &\n  Pick<SyncProgress, \"state\"> & { error?: string }\n\nexport function syncReportDir() {\n  // in production we shouldn't need a sync report unless we have a library, but\n  // when testing within core, we won't always have a library set up.\n  return librarySyncReportsDir() ?? PosixFile.for(logDir()).join(\"sync-reports\")\n}\n\nexport function syncReportReadme(): PosixFile {\n  return syncReportDir().join(\"README.txt\")\n}\n\nexport const ensureSyncReportReadme = lazy(() =>\n  writeTextfile_(\n    syncReportReadme().nativePath,\n    wrap(\n      `\n\nHowdy from PhotoStructure!\n\nThis directory contains your recent \"sync reports\". \n\nThese files are written as your scan paths are examined for photos and videos.\n\nPhotoStructure creates a new file when it restarts and when it completes importing a given scan path directory.\n\nThese CSV files can be opened with most spreadsheet applications, like LibreOffice.\n\n\nColumn descriptions\n===================\n\nThe \"ts\" column is the timestamp for the row, in millis from 1970-01-01. Most spreadsheet applications don’t know how to parse these values, though, so we also add the at column.\n\nThe \"at\" column is ts in ISO format with only second resolution, and should be parsable by most spreadsheet software.\n\nThe \"path\" column is the native path of the directory or file.\n\nThe \"state\" column explains why that row was added.\n\nThe \"from\" column specifies which codepath added the sync report row.\n\nThe \"elapsedMs\" column is only added to rows completing a given path, and records how long that process took.\n\nThe \"details\" column will include information about the path, like why a given file or folder were rejected.\n\nThe \"url\" column is only added to rows when a file or directory is imported. You may need to adjust the domain name of the URL to make it work correctly (it defaults to localhost).\n\n\nDirectory state values\n======================\n\nThe \"state\" column for directories will be\n\n${recordToBullets(DirStateDescriptions)}\n\n\nFile state values\n=================\n\nThe \"state\" column for files will be\n\n${recordToBullets(FileStateDescriptions)}\n\n\nSee https://photostructure.com/go/sync-reports\n\n`,\n      { maxLineLen: 80 }\n    ).join(\"\\n\")\n  )\n)\n\nfunction mkSyncReportPath() {\n  const dt = DateTime.now()\n  return syncReportDir().join(\n    dt.toFormat(\"y-MM-dd\"),\n    filestamp() + \"-sync-report.csv\"\n  )\n}\n\nexport async function recentSyncReports(agoMs = dayMs) {\n  const min_mtime = Date.now() - agoMs\n  return syncReportDir().descendants(\n    async ea => isCsvExt(ea) && gte(await ea.mtimeMs(), min_mtime)\n  )\n}\n\nexport const syncReport = lazy(() => new SyncReport())\n\nexport class SyncReport extends EndableWrapper {\n  #outputFile: Maybe<PosixFile>\n  #output: Maybe<Writable>\n  #rowCount = 0\n  readonly outputFiles = new BoundedList<string>(64)\n\n  constructor() {\n    super(\n      `fs.SyncReport()`,\n      () => {\n        return this.close()\n      },\n      EndableRanks.service\n    )\n    void ensureSyncReportReadme()\n  }\n\n  get outputNativePath() {\n    return this.#outputFile?.nativePath\n  }\n\n  get rowCount() {\n    return this.#rowCount\n  }\n\n  onProgress(s: SyncProgress) {\n    if (s == null || blank(s.path) || blank(s.state)) {\n      return this.logger.error(\".onProgress(): invalid input\", {\n        s,\n        from: stack()\n      })\n    } else {\n      this.logger.log(\n        WarnStates.has(s.state) ? LogLevels.warn : LogLevels.info,\n        \"onProgress()\",\n        s\n      )\n      const ts = Date.now()\n      const rowObj: SyncReportRow = {\n        ts,\n        at: new Date(ts).toISOString(),\n        path: s.path,\n        state: s.state,\n        from: s.from,\n        details: toS(s.details).trim().replace(/\\r?\\n/g, \"; \"),\n        url: s.url, // OpenOffice doesn't auto-link angle-bracket-wrapped urls SAD\n        elapsedMs: s.elapsedMs\n      }\n      const row = unparse([rowObj], {\n        header: false,\n        columns: SyncReportHeaders.values\n      })\n      this.output.write(row + Newline, err => {\n        if (err != null) {\n          this.logger.error(\"Failed to write\", err)\n        }\n      })\n      if (++this.#rowCount > Settings.syncReportMaxRows.valueOrDefault) {\n        void this.close()\n      }\n    }\n  }\n\n  /**\n   * Run the given function `fn_`, ensuring both start and finish rows are\n   * written\n   *\n   * @throws any error thrown by `fn_` after writing an error report row\n   */\n  async wrap_<T extends WrapSyncProgress>({\n    path,\n    from,\n    fn_\n  }: {\n    path: string\n    from: string\n    fn_: () => Promise<T>\n  }): Promise<T> {\n    const start = Date.now()\n    this.onProgress({\n      path,\n      from,\n      state: SyncFileStates.started\n    })\n    try {\n      const result = await fn_()\n      const state =\n        result.state ??\n        (result.error != null ? SyncFileStates.failed : SyncFileStates.unknown)\n      if (state === SyncFileStates.unknown) {\n        this.logger.error(\n          from + \" returned result with no state!\" + InternalErrorFlag,\n          { path, result }\n        )\n      }\n      syncReport().onProgress({\n        path,\n        from,\n        elapsedMs: Date.now() - start,\n        ...result,\n        state\n      })\n      return result\n    } catch (error: any) {\n      this.logger.warn(\"wrap_() caught error\", { error, stack: error.stack })\n      this.onProgress({\n        path,\n        from,\n        state:\n          error instanceof TimeoutError\n            ? SyncFileStates.timeout\n            : SyncFileStates.failed,\n        details: errorToS(error),\n        elapsedMs: Date.now() - start\n      })\n\n      throw error\n    }\n  }\n\n  get output() {\n    return this.#output ?? this.#setupOutput()\n  }\n\n  // must be sync\n  #setupOutput(): Writable {\n    this.#outputFile = mkSyncReportPath().ensureNewSync_({ emptyIsNew: false })\n    this.outputFiles.push(this.#outputFile.nativePath)\n    this.logger.info(\"Opening new report: \" + this.#outputFile)\n    if (isTest) stdoutWrite({ syncReport: this.#outputFile.nativePath }, false)\n    this.#output = createWriteStream(this.#outputFile.nativePath)\n    this.#output.write(\n      unparse([SyncReportHeaders.values], {\n        header: false\n      }) + Newline\n    )\n    return this.#output\n  }\n\n  /**\n   * Close the current sync report. The next onProgress() will create a new\n   * report.\n   */\n  async close(): PromiseMaybe<PosixFile> {\n    const output = this.#output\n    this.#output = undefined\n    this.#rowCount = 0\n    await endStream(output)\n    return output == null ? undefined : this.#outputFile\n  }\n}\n","import { createReadStream } from \"fs\"\nimport { NODE_STREAM_INPUT, parse, ParseConfig, ParseResult } from \"papaparse\"\nimport { Transform } from \"stream\"\nimport { pipeline } from \"stream/promises\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { sortIgnoreCase } from \"../String\"\nimport { Newline } from \"./CRLF\"\nimport { readLines_ } from \"./ReadLines\"\nimport { SimpleFileOrString, toNativePath_ } from \"./SimpleFile\"\nimport {\n  FileDoneStates,\n  SyncFileStates,\n  SyncReportRow,\n  SyncReportState\n} from \"./SyncReport\"\n\nconst DefaultOptions = {\n  header: true,\n  skipEmptyLines: \"greedy\"\n} as ParseConfig\n\nexport async function readSyncReport_(\n  nativePath: string\n): Promise<ParseResult<SyncReportRow>> {\n  const content = (await readLines_(nativePath)).join(Newline)\n  return parse<SyncReportRow>(content, DefaultOptions)\n}\n\nclass EnqueueStream extends Transform {\n  constructor(\n    readonly enqueued = new Set<string>(),\n    readonly settled = new Set<string>(),\n    readonly accept: (nativePath: string) => boolean,\n    readonly fileDoneStates: Set<SyncReportState>\n  ) {\n    super({ objectMode: true })\n  }\n\n  _write(chunk: any, _encoding: BufferEncoding, next: () => void) {\n    if (\n      chunk != null &&\n      SyncFileStates.includes(chunk.state) &&\n      notBlank(chunk.path) &&\n      this.accept(chunk.path)\n    ) {\n      const row = chunk as SyncReportRow\n      if (row.state === \"enqueued\") {\n        this.enqueued.add(row.path)\n      } else if (this.fileDoneStates.has(row.state as any)) {\n        this.settled.add(row.path)\n      }\n    }\n    next()\n  }\n}\n\nexport async function unprocessedPaths_({\n  syncReportJsons,\n  acceptPath = () => true,\n  fileDoneStates = FileDoneStates\n}: {\n  syncReportJsons: SimpleFileOrString[]\n  acceptPath?: (nativePath: string) => boolean\n  fileDoneStates?: Set<SyncReportState>\n}): Promise<string[]> {\n  const enqueued = new Set<string>()\n  const settled = new Set<string>()\n  for (const json of syncReportJsons) {\n    await pipeline(\n      createReadStream(toNativePath_(json)),\n      parse(NODE_STREAM_INPUT, DefaultOptions),\n      new EnqueueStream(enqueued, settled, acceptPath, fileDoneStates)\n    )\n  }\n  const result = [...enqueued].filter(ea => !settled.has(ea))\n  return sortIgnoreCase(result)\n}\n","import _os from \"os\"\nimport { lazy } from \"../../core/Lazy\"\nimport { map } from \"../../fe/Maybe\"\nimport { firstDefinedLater } from \"../async/Later\"\nimport { FatalErrorFlag } from \"../error/ErrorFlags\"\nimport { isWin, platformName } from \"../platform/Platform\"\nimport { BaseFile } from \"./BaseFile\"\nimport { pathIfExists, pathTo } from \"./PathTo\"\nimport { ProjectPath } from \"./ProjectPath\"\n\nconst toolsDir = lazy(() => map(ProjectPath.Tools(), ea => BaseFile.for(ea)))\n\n/**\n * @param tool \".exe\" is appended if the local platform is windows.\n * @throws if tool is not found\n */\nexport async function pathToTool_(tool: string): Promise<string> {\n  if (true !== (await toolsDir()?.isDirectory())) {\n    // Electron builds always have a tools dir:\n    throw new Error(\"Cannot find project path for /tools/\" + FatalErrorFlag)\n  }\n\n  return firstDefinedLater<string>(\n    // See https://github.com/photostructure/base-tools/blob/main/Dockerfile\n    () => pathIfExists(toolsDir()?.join(\"bin\", tool)),\n\n    () => devPathToTool(tool),\n    // system-installed tool:\n    () => systemPathToTool(tool)\n  ) as any\n}\n\nfunction devPathToTool(tool: string) {\n  return pathIfExists(\n    toolsDir()?.join(\n      platformName + \"-\" + _os.arch(),\n      tool + (isWin ? \".exe\" : \"\")\n    )\n  )\n}\n\nasync function systemPathToTool(tool: string): Promise<string> {\n  return firstDefinedLater<string>(\n    // system-installed tool:\n    () => pathTo({ tool }),\n    () => {\n      throw new Error(\"Cannot find path for \" + tool)\n    }\n  ) as any\n}\n\nexport const dcrawEmuNativePath_ = lazy(() => {\n  return pathToTool_(\"dcraw_emu\")\n})\nexport const rawIdentifyNativePath_ = lazy(() => {\n  return pathToTool_(\"raw-identify\")\n})\nexport const jpegtranNativePath_ = lazy(() => {\n  return pathToTool_(\"jpegtran\")\n})\nexport const sqliteNativePath_ = lazy(() => {\n  return pathToTool_(\"sqlite3\")\n})\n","import fse from \"fs-extra\"\nimport { utimes } from \"utimes\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { isDate } from \"../../fe/Date\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { compactValues, keys } from \"../../fe/Object\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { Settings } from \"../settings/Settings\"\nimport { mkdirp_ } from \"./Path\"\nimport {\n  SimpleFile,\n  SimpleFileOrString,\n  dirname,\n  toNativePath_\n} from \"./SimpleFile\"\nimport { statMaybe } from \"./Stat\"\nimport { statTimeoutMs } from \"./StatTimeout\"\n\n// const logger = lazy(() => mkLogger(\"fs.Touch\"))\n\nfunction toMs(d: number | Date | undefined): Maybe<number> {\n  return d == null\n    ? undefined\n    : isDate(d)\n    ? d.getTime()\n    : gt0(d)\n    ? d\n    : undefined\n}\n\nexport async function touch_(args: {\n  file: SimpleFileOrString\n  ensureFile?: boolean\n  atimeMs?: number | Date\n  mtimeMs?: number | Date\n  btimeMs?: number | Date\n  reference?: SimpleFile\n}): Promise<void> {\n  const ensureFile = args.ensureFile ?? true\n  if (args.file == null || blank(args.file))\n    throw new Error(\"can't touch blank path\")\n  const nativePath = toNativePath_(args.file)\n  if (ensureFile) {\n    await mkdirp_(dirname(args.file))\n  }\n  const rStat = lazy(() => statMaybe(args.reference?.nativePath))\n  const mtimeMs = Math.round(\n    toMs(args.mtimeMs) ?? (await rStat())?.mtimeMs ?? Date.now()\n  )\n  const atimeMs = Math.round(\n    toMs(args.atimeMs) ?? (await rStat())?.atimeMs ?? mtimeMs\n  )\n  const btimeMs = map(toMs(args.btimeMs) ?? (await rStat())?.birthtimeMs, ea =>\n    Math.round(ea)\n  )\n  // logger().debug(\"touch_(): utime()\", { args, mtimeMs, atimeMs, btimeMs })\n  try {\n    await thenOrTimeoutError(\n      btimeMs != null && Settings.retainFileBirthtimes.valueOrDefault\n        ? utimes(\n            nativePath,\n            compactValues({\n              atime: atimeMs,\n              mtime: mtimeMs,\n              btime: btimeMs\n            })\n          )\n        : fse.utimes(nativePath, new Date(atimeMs), new Date(mtimeMs)),\n      statTimeoutMs()\n    )\n  } catch (error: any) {\n    if (ensureFile && error.code === \"ENOENT\") {\n      // fsp.ensureFile() has issues: the file may not exist when the returned\n      // promise is resolved.\n      await thenOrTimeoutError(fse.ensureFile(nativePath), statTimeoutMs())\n      if (keys(args).length > 1) {\n        // args has more than just \"file\":\n        await touch_({ ...args, ensureFile: false })\n      }\n    } else {\n      throw error\n    }\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { later } from \"../../fe/Delay\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { safeRandomUid } from \"../Random\"\nimport { version } from \"../Version\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { ee } from \"../event/EventEmitter\"\nimport { TokenRadix } from \"../math/Radix\"\nimport { Settings } from \"../settings/Settings\"\nimport { CreatedAt, JsonFileStore } from \"./JsonFileStore\"\nimport { PosixFile } from \"./PosixFile\"\nimport { SimpleFileOrString } from \"./SimpleFile\"\n\nexport interface UidFile extends CreatedAt {\n  uid: string\n  version: string\n  type: \"library\" | \"system\"\n}\n\nexport function mkuid() {\n  return safeRandomUid({ radix: TokenRadix, chars: 24, splitEveryN: 4 })\n}\n\nexport class UIDStore extends JsonFileStore<UidFile> {\n  constructor(\n    readonly rootDir: PosixFile,\n    readonly type: UidFile[\"type\"]\n  ) {\n    // we hide it, because why not:\n    super(\n      // system-uid.json and library-uid.json\n      rootDir.join(\".\" + type + \"-uid.json\"),\n      () => ({\n        uid: mkuid(),\n        version,\n        type: this.type,\n        createdAt: Date.now()\n      }),\n      f => f.hide()\n    )\n  }\n\n  /**\n   * @return just the UUID, not the UidFile struct\n   */\n  readonly readUid_ = lazy(async () => (await this.read_())?.uid)\n}\n\n// /**\n//  * We store this so the system UID stays consistent even if the local hostname\n//  * changes\n//  */\nexport const SystemUIDStore = lazy(() =>\n  map(configDir(), ea => new UIDStore(PosixFile.for(ea), \"system\"))\n)\n\nexport const LibraryUIDStore = lazy(libraryUidStore)\n\nexport function libraryUidStore(\n  libraryDir: Maybe<SimpleFileOrString> = Settings.libraryDir.valueOrDefault\n) {\n  return map(PosixFile.forMaybe(libraryDir), ea => new UIDStore(ea, \"library\"))\n}\n\nlater(() => {\n  ee().on(\"clearCache\", () => {\n    SystemUIDStore.unset()\n    LibraryUIDStore.unset()\n  })\n  Settings.libraryDir.watchLater(() => LibraryUIDStore.unset())\n})\n","import * as fsp from \"node:fs/promises\"\nimport trash from \"trash\"\nimport { lazy } from \"../../core/Lazy\"\nimport { uniqBy } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { OneOrMore, toA } from \"../../fe/toA\"\nimport { mkLogger } from \"../Logger\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { mapAsyncSerial, thenNot } from \"../async/Promise\"\nimport { untilTrue } from \"../async/until\"\nimport { ee } from \"../event/EventEmitter\"\nimport { Settings } from \"../settings/Settings\"\nimport { uri2nativePath } from \"../uri/FileURI\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { SimpleFileOrString, toNativePath_ } from \"./SimpleFile\"\nimport { nativePathIsFile } from \"./Stat\"\n\nconst logger = lazy(() => mkLogger(\"fs.Unlink\"))\n\nexport interface TrashOrUnlinkResult {\n  nativePath: Maybe<string>\n  unlinked: boolean\n}\n\nexport async function unlink(arr: OneOrMore<SimpleFileOrString>) {\n  for (const ea of toA(arr)) {\n    try {\n      if (ea != null) await fsp.unlink(toNativePath_(ea))\n    } catch (error) {\n      logger().warn(\"Failed to unlink \" + ea, { error })\n    }\n  }\n}\n\nexport async function trashOrUnlinkFileUris_(\n  arr: { uri: string; mountpoint?: Maybe<string> }[]\n) {\n  // macOS soft-deletions are _not great_. Only do one at a time to work\n  // around https://github.com/sindresorhus/trash/issues/24\n\n  return mapAsyncSerial({\n    name: \"trashOrUnlinkFileUris_\",\n    arr: uniqBy(arr, ea => ea.uri),\n    f: async ({ uri, mountpoint }) => {\n      const nativePath = await uri2nativePath(uri, mountpoint)\n      if (blank(nativePath)) {\n        return logger().tap({\n          msg: \"trashOrUnlink: Failed to resolve URI to delete\",\n          result: undefined,\n          meta: { uri, mountpoint }\n        })\n      }\n\n      try {\n        return logger().tap({\n          msg: \"trashOrUnlink\",\n          result: await trashOrUnlinkNativePath_(nativePath),\n          meta: { nativePath, uri, mountpoint }\n        })\n      } catch (error) {\n        logger().error(\"Failed to unlink()\", {\n          nativePath,\n          uri,\n          mountpoint,\n          error\n        })\n      }\n      return\n    },\n    timeoutMs: commandTimeoutMs()\n  })\n}\n\n/**\n * @return true if the file was unlinked, false if the file was missing\n * @throws error on file permission error\n */\nexport async function trashOrUnlinkFileUri_(\n  uri: string,\n  mountpoint?: Maybe<string>\n): Promise<TrashOrUnlinkResult> {\n  const nativePath = await uri2nativePath(uri, mountpoint)\n  if (blank(nativePath)) {\n    return logger().tap({\n      msg: \"trashOrUnlinkFileUri_: null nativePath\",\n      result: { nativePath, unlinked: false },\n      meta: { uri, mountpoint }\n    })\n  } else {\n    return logger().tap({\n      msg: \"trashOrUnlinkFileUri_()\",\n      result: await trashOrUnlinkNativePath_(nativePath),\n      meta: {\n        uri,\n        mountpoint\n      }\n    })\n  }\n}\n\nexport async function trashOrUnlinkNativePath_(\n  nativePath: string\n): Promise<TrashOrUnlinkResult> {\n  if (!(await nativePathIsFile(nativePath))) {\n    return logger().tap({\n      level: \"warn\",\n      msg: \"trashOrUnlinkFileUri_: path is not a file, refusing to unlink.\",\n      result: { nativePath, unlinked: false }\n    })\n  }\n\n  if (Settings.trySoftDeletes.valueOrDefault) {\n    try {\n      await trash(nativePath, { glob: false })\n      if (\n        await untilTrue(() => thenNot(nativePathIsFile(nativePath)), {\n          timeoutMs: ShortCommandTimeoutMs\n        })\n      ) {\n        logger().info(\"soft-delete(\" + nativePath + \") successful\")\n        return { nativePath, unlinked: true }\n      } else {\n        logger().warn(\n          \"soft-delete(\" +\n            nativePath +\n            \") didn't seem to work: the file is still there?\"\n        )\n      }\n    } catch (error) {\n      logger().warn(\n        \"Tried to soft-delete, but that failed. We'll try to hard-delete.\",\n        { error }\n      )\n    }\n  }\n\n  await unlink(nativePath)\n  ee().emit(\"fileChanged\", nativePath)\n  logger().info(\"unlink(\" + nativePath + \") successful\")\n  return { nativePath, unlinked: true }\n}\n","import { Dirent } from \"fs\"\nimport { blank } from \"../../fe/Blank\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { basename, SimpleFile } from \"./SimpleFile\"\n\nexport const WipTimeoutMs = ShortCommandTimeoutMs\nexport const WipPrefix = \".WIP-\"\n\nexport function isWip(p: SimpleFile | string | Dirent): boolean {\n  return !blank(p) && basename(p).startsWith(WipPrefix)\n}\n","import { Writable, WritableOptions } from \"stream\"\nimport { Deferred } from \"../async/Deferred\"\n\n/**\n * Concats the result of a stream's data into a `Buffer`\n */\nexport class WritableToBuffer extends Writable {\n  private readonly deferred = new Deferred<Buffer>(\"WritableToBuffer\")\n  private readonly _buf: Buffer[] = []\n\n  constructor(opts?: WritableOptions) {\n    super(opts)\n    this.on(\"finish\", () => {\n      void this.deferred.resolve(this.data)\n    })\n    this.on(\"error\", err => {\n      void this.deferred.reject(err)\n    })\n  }\n\n  get data(): Buffer {\n    return Buffer.concat(this._buf)\n  }\n\n  /**\n   * Final result. Will only be resolved on finish.\n   */\n  get buffer(): Promise<Buffer> {\n    return this.deferred.promise\n  }\n\n  _write(chunk: any, encoding: BufferEncoding, next: () => void) {\n    this._buf.push(\n      Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding)\n    )\n    next()\n  }\n}\n","import _fse from \"fs-extra\"\nimport _path from \"path\"\nimport { ensureSuffix, wrap } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { ee } from \"../event/EventEmitter\"\nimport { crlf } from \"./CRLF\"\nimport { mkdirpSync_, mkdirp_ } from \"./Path\"\n\nexport async function writeFile_(nativePath: string, data: string | Buffer) {\n  const dir = _path.dirname(nativePath)\n  await mkdirp_(dir)\n  await _fse.writeFile(nativePath, data)\n  ee().emit(\"fileChanged\", dir) // because the parent directory has a new child!\n}\n\nexport async function writeText_(nativePath: string, ...txt: string[]) {\n  return writeFile_(\n    nativePath,\n    crlf(ensureSuffix(txt.map(toS).join(\"\\n\"), \"\\n\"))\n  )\n}\n\nexport async function writeTextfile_(nativePath: string, ...txt: string[]) {\n  const data = crlf(...wrap(txt))\n  await writeFile_(nativePath, data)\n}\n\nexport function writeFileSync_(nativePath: string, data: string | Buffer) {\n  const dir = _path.dirname(nativePath)\n  mkdirpSync_(dir)\n  _fse.writeFileSync(nativePath, data)\n  ee().emit(\"fileChanged\", dir) // because the parent directory has a new child!\n}\n\nexport function writeTextSync_(nativePath: string, ...txt: string[]) {\n  return writeFileSync_(\n    nativePath,\n    crlf(ensureSuffix(txt.map(toS).join(\"\\n\"), \"\\n\"))\n  )\n}\n","import _fs from \"fs\"\nimport { parse } from \"path\"\nimport _s from \"stream\"\nimport { pipeline } from \"stream/promises\"\nimport { createBrotliDecompress, createGunzip, createGzip } from \"zlib\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { parseJSON } from \"../JSON\"\nimport { mkLogger } from \"../Logger\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { mkdirp_ } from \"../fs/Path\"\nimport { LogLevel, LogLevels } from \"../log/LogLevel\"\nimport { ReadableBuffer } from \"./ReadableBuffer\"\nimport { Pipeline } from \"./Streams\"\nimport { WritableToBuffer } from \"./WritableToBuffer\"\n\nconst logger = lazy(() => mkLogger(\"fs.zcat\"))\n\n/**\n * @throw if the file is missing or unreadable\n */\nexport async function zcat_(\n  nativePath: string,\n  options?: { start?: number; end?: number }\n): Promise<string> {\n  return (await zCopyToBuffer_(nativePath, options)).toString()\n}\n\nexport async function zcat(\n  nativePath: string,\n  options?: { start?: number; end?: number }\n): PromiseMaybe<string> {\n  try {\n    return zcat_(nativePath, options)\n  } catch (err) {\n    logger().warn(\"zcat failed to read \" + nativePath, err)\n    return undefined\n  }\n}\n\nexport async function zpipe_(\n  nativePath: string,\n  outputStream: _s.Writable,\n  options?: { start?: number; end?: number }\n) {\n  const causes: Error[] = []\n  const p: Pipeline = [\n    _fs\n      .createReadStream(nativePath, { autoClose: true, ...options })\n      .on(\"error\", err => causes.push(err))\n  ]\n  if (nativePath.toLowerCase().endsWith(\".gz\")) {\n    p.push(createGunzip().on(\"error\", err => causes.push(err)))\n  } else if (nativePath.toLowerCase().endsWith(\".br\")) {\n    p.push(createBrotliDecompress().on(\"error\", err => causes.push(err)))\n  }\n  p.push(outputStream)\n  await pipeline(p)\n  if (isNotEmpty(causes)) {\n    throw new WrappedError(\"zPipe(\" + nativePath + \") failed\", {\n      causes,\n      path: nativePath\n    })\n  }\n}\n\n/**\n * `readFile`, but on-the-fly decompression for .gz and .br\n * @throws on error\n */\nexport async function zCopyToBuffer_(\n  nativePath: string,\n  options?: { start?: number; end?: number }\n): Promise<Buffer> {\n  const w = new WritableToBuffer()\n  await zpipe_(nativePath, w, options)\n  return await w.buffer\n}\n\nexport async function readJsonGz_<T = any>(nativePath: string) {\n  return parseJSON(await zCopyToBuffer_(nativePath)) as Maybe<T>\n}\n\nexport async function readJsonGz<T = any>(\n  nativePath: string,\n  level: LogLevel = LogLevels.warn\n) {\n  try {\n    return await readJsonGz_<T>(nativePath)\n  } catch (err) {\n    logger().log(level, \"readJsonGz(\" + nativePath + \"): failed\", err)\n    return\n  }\n}\n\nexport async function outputJsonGz_<T = any>(nativePath: string, obj: T) {\n  const json = stringify(obj)\n  await mkdirp_(parse(nativePath).dir)\n  await pipeline(\n    new ReadableBuffer(json),\n    createGzip(),\n    _fs.createWriteStream(nativePath, { autoClose: true })\n  )\n}\n\nexport async function outputJsonGz<T = any>(\n  nativePath: string,\n  obj: T,\n  level: LogLevel = LogLevels.warn\n) {\n  try {\n    await outputJsonGz_(nativePath, obj)\n  } catch (err) {\n    logger().log(level, \"outputJsonGz(\" + nativePath + \"): failed\", err)\n  }\n}\n","import { tt } from \"../../fe/BabyMarkdown\"\nimport { defer } from \"../../fe/Defer\"\nimport { errorToS } from \"../error/Error\"\nimport { exiftool, exiftoolVersion_ } from \"../tags/ExifTool\"\nimport { ver } from \"../version/Ver\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const exiftoolHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"Tools\",\n    id: \"tools-exiftool\",\n    pendingMsg: \"Checking ExifTool…\",\n    settings: [],\n    later: async () => {\n      try {\n        const ev = await exiftoolVersion_()\n        return {\n          level: \"ok\",\n          msg: [\n            \"ExifTool is OK\",\n            \"ExifTool \" + ver(ev),\n            tt(exiftool().options.exiftoolPath)\n          ],\n          meta: { exiftoolVersion: ev }\n        }\n      } catch (error) {\n        return {\n          level: \"error\", // < bad enough to not run!\n          msg: \"Something's amiss with ExifTool: \" + errorToS(error as any)\n        }\n      }\n    }\n  })\n)\n","import { readdir } from \"fs/promises\"\nimport * as pf from \"platform-folders\"\nimport { uniq } from \"../../fe/Array\"\nimport { li, tt } from \"../../fe/BabyMarkdown\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { defer } from \"../../fe/Defer\"\nimport { MultiMap } from \"../../fe/MultiMap\"\nimport { sortByCaseInsensitive } from \"../String\"\nimport { defaultApplePhotosLibrary } from \"../dir/DefaultApplePhotosLibrary\"\nimport { homeDir } from \"../dir/HomeDir\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const externalDirsHealthCheck = defer(() =>\n  isDocker()\n    ? undefined\n    : HealthCheck.for({\n        section: \"System\",\n        id: \"media-directories\",\n        pendingMsg: \"Checking default photo directories…\",\n        settings: [],\n        rejectIsWarn: true,\n        later: async () => {\n          const arr = uniq([\n            homeDir(),\n            pf.getHomeFolder(),\n            pf.getPicturesFolder(),\n            pf.getVideosFolder(),\n            pf.getDesktopFolder(),\n            await defaultApplePhotosLibrary()\n          ]).sort()\n\n          const errs = new MultiMap<string, string>()\n          const dirs = uniq(arr.filter(notBlank)).sort()\n          for (const dir of dirs) {\n            try {\n              await readdir(dir, { withFileTypes: true })\n            } catch (err: any) {\n              if (notBlank(err?.code)) {\n                errs.add(err.code, dir)\n              }\n            }\n          }\n          errs.delete(\"ENOTDIR\") // don't care\n          errs.delete(\"ENOENT\") // don't care\n\n          if (errs.valueCount() > 0) {\n            return {\n              level: \"warn\",\n              msg: [\n                \"Problem trying to read the following directories:\",\n                li(\n                  sortByCaseInsensitive(errs.tuples(), ([, v]) => v).map(\n                    ([k, v]) => `${tt(v)}: ${k}`\n                  )\n                )\n              ]\n            }\n          } else {\n            return {\n              level: \"ok\",\n              msg: [\n                \"Default media directories are readable\\nChecked the following directories:\",\n                li(dirs.map(tt))\n              ]\n            }\n          }\n        }\n      })\n)\n","import { lazy } from \"../../core/Lazy\"\nimport {\n  compact,\n  filterInPlace,\n  isEmpty,\n  isNotEmpty,\n  uniq,\n  uniqBy\n} from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { tt } from \"../../fe/BabyMarkdown\"\nimport { fmtDateShort, secondMs } from \"../../fe/Date\"\nimport { delay } from \"../../fe/Delay\"\nimport { shortStack } from \"../../fe/Error\"\nimport { flatten } from \"../../fe/Flatten\"\nimport {\n  BaseHealthCheckSummary,\n  HealthCheckLevel,\n  HealthCheckLevels,\n  HealthCheckResult,\n  HealthCheckSection,\n  HealthCheckSections,\n  HealthCheckSummary,\n  Link,\n  levelIsNotOK\n} from \"../../fe/HealthChecks\"\nimport { Later } from \"../../fe/Later\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { Comparable } from \"../../fe/Primitive\"\nimport { randomInt } from \"../../fe/Random\"\nimport { RunStateEnum, RunStates } from \"../../fe/RunStateEnum\"\nimport { isString, stripSuffix } from \"../../fe/String\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { thenOrTimeoutAs, thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { tot } from \"../../fe/Thunk\"\nimport { plur } from \"../../fe/Units\"\nimport { UnreachableCaseError } from \"../../fe/UnreachableCaseError\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { leastBy, partition } from \"../Array\"\nimport { BoundedList } from \"../BoundedList\"\nimport { CountingSet } from \"../CountingSet\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { isWebService } from \"../ServiceNames\"\nimport { debounce } from \"../async/Debounce\"\nimport { Deferred } from \"../async/Deferred\"\nimport { ending } from \"../async/Endable\"\nimport { MemoizedDeferred, lazyAsync } from \"../async/LazyAsync\"\nimport { Promises } from \"../async/Promises\"\nimport { libraryDirPosixFile } from \"../dir/LibraryDirs\"\nimport { getDevEnvFlag } from \"../env/DevEnvFlags\"\nimport { errorToS } from \"../error/Error\"\nimport { isFatalError } from \"../error/ErrorTypes\"\nimport { LogLevel } from \"../log/LogLevel\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { Settings } from \"../settings/Settings\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { HealthCheckId, HealthCheckIds } from \"./HealthCheckIds\"\nimport {\n  DockerVolumeLink,\n  WhatIsALibraryLink,\n  restartResetOrShutdownButtons\n} from \"./LibraryAdminLinks\"\n\nexport interface HealthCheckTest\n  extends Partial<Pick<HealthCheckResult, \"level\" | \"links\">> {\n  // no buttons!\n  msg: string | Maybe<string>[]\n}\n\nexport const HealthCheckLevelToLogLevel: Record<HealthCheckLevel, LogLevel> = {\n  error: \"error\",\n  \"no-library\": \"info\",\n  pending: \"debug\",\n  \"stop-sync\": \"info\",\n  warn: \"warn\",\n  ok: \"info\",\n  disabled: \"debug\"\n}\n\nconst HealthCheckLevelOrder = [\n  \"error\",\n  \"no-library\",\n  \"pending\",\n  \"stop-sync\",\n  \"warn\"\n] as const satisfies ReadonlyArray<HealthCheckLevel>\n\nfunction summaryForLevel(\n  level: (typeof HealthCheckLevelOrder)[number]\n): Pick<HealthCheckSummary, \"level\" | \"state\" | \"msg\" | \"links\" | \"buttons\"> {\n  switch (level) {\n    case \"error\":\n      return {\n        level,\n        state: \"failed\",\n        msg: [\n          \"Some health checks failed\",\n          \"Your library won't be synced until these issues are addressed.\"\n        ],\n        buttons: restartResetOrShutdownButtons()\n      }\n    case \"no-library\":\n      if (\n        isDocker() &&\n        true !== libraryDirPosixFile()?.isReadWriteExecutableSync()\n      ) {\n        return {\n          level,\n          state: \"failed\",\n          msg: [\n            \"Your docker container is missing a bind mount for \" +\n              tt(Settings.libraryDir.valueOrDefault)\n          ],\n          links: [DockerVolumeLink],\n          buttons: [\n            {\n              text:\n                \"Shut down and add a bind mount for \" +\n                Settings.libraryDir.valueOrDefault,\n              type: \"button\",\n              method: \"POST\",\n              url: \"/admin/shutdown\",\n              icon: \"power\"\n            }\n          ]\n        }\n      } else {\n        return {\n          level,\n          state: \"welcome\",\n          msg: [\"No PhotoStructure library is open\"],\n          links: [WhatIsALibraryLink],\n          buttons: [\n            {\n              text: \"Set up your library\",\n              type: \"button\",\n              method: \"GET\",\n              url: \"/welcome\",\n              icon: \"rocket_launch\"\n            }\n          ]\n        }\n      }\n\n    case \"pending\":\n      return {\n        level,\n        state: \"loading\",\n        msg: [\"Some health checks are still pending\"]\n      }\n    case \"stop-sync\":\n      return {\n        level,\n        state: \"ready\",\n        msg: [\n          \"Some health checks are preventing your library from being synced.\",\n          \"You should still be able to view your library, however.\"\n        ]\n      }\n    case \"warn\":\n      return {\n        level,\n        state: \"ready\",\n        msg: [\n          \"Some health checks are not OK\",\n          \"Your library will still be synced, but you may want to address these issues.\"\n        ]\n      }\n    default:\n      throw new UnreachableCaseError(level)\n  }\n}\n\nconst logger = lazy(() => mkLogger(\"health.HealthCheck\"))\n\nexport interface RepairTask extends Pick<HealthCheckResult, \"id\" | \"section\"> {\n  (): Promise<void>\n}\n\nexport type EnabledHealthCheckLevel = Exclude<HealthCheckLevel, \"disabled\">\n\nexport interface HealthCheckWatcher {\n  (result: {\n    hcr: HealthCheckResult\n    hc: HealthCheck\n    priorLevel: HealthCheckLevel\n  }): void\n}\n\nexport class HealthCheck {\n  /**\n   * Deferred that need to resolve or reject before #isLoading can be set to false\n   */\n  static #pending: Deferred<any>[] = []\n\n  static #p = new Promises(\"HealthCheck\")\n\n  static #vacuumPending() {\n    filterInPlace(this.#pending, ea => !ea.isPending)\n    return this.#pending\n  }\n\n  static traceLater_<T>(\n    desc: string,\n    fn: SyncOrAsync<T> | (() => SyncOrAsync<T>)\n  ): Deferred<T> | Promise<T> {\n    const d = new Deferred<T>(desc)\n    void d.catch(error => {\n      this.#errors.push(desc + \": failed: \" + errorToS(error))\n      this.onResultChange()\n    })\n    this.#vacuumPending().push(d)\n    try {\n      return d.observe(tot(fn))\n    } catch (error) {\n      void d.reject(error)\n      throw error\n    }\n  }\n\n  static #errors = new BoundedList<string>(10)\n  static #priorUniqSummaryStates = new BoundedList<{\n    state: RunStateEnum\n    ts: number\n  }>(10)\n\n  static priorRunStates() {\n    return this.#priorUniqSummaryStates.toA()\n  }\n\n  static #loadingMsgs = new BoundedList<{ at: number; msg: string }>(100)\n  static #shownMsgs = new CountingSet<string>()\n  static #instances: HealthCheck[] = []\n\n  static readonly all = lazy<readonly HealthCheck[]>(() =>\n    Object.freeze(sortBy(this.#instances, ea => ea.sortBy))\n  )\n\n  static allCritical(): HealthCheck[] {\n    return this.all().filter(ea => ea.rejectIsWarn !== true)\n  }\n\n  static addError(error: Error | string | any) {\n    this.#errors.push(isString(error) ? error : errorToS(error))\n    this.onResultChange()\n  }\n\n  static addLoadingMsg(msg: string) {\n    this.#loadingMsgs.push({ at: Date.now(), msg })\n  }\n\n  static normalizeMsg(msg: string | Maybe<string>[]) {\n    return compact(toA(msg))\n      .map(toS)\n      .join(\"\\n\")\n      .replace(/\\n{3,}/g, \"\\n\\n\") // no more than 2 blank lines\n      .replace(/\\n{2,} {2}- /g, \"\\n  - \") // no blank lines before or between bullets\n      .trim() // no blank lines at start or end\n      .split(\"\\n\")\n  }\n\n  static unseenOrOldestPendingTrace() {\n    const pending = this.all()\n      .map(ea => ea.result())\n      .filter(ea => ea.isPending)\n    pending.push(...this.#vacuumPending())\n    logger().info(\"unseenOrOldestPendingTrace\", {\n      pending: pending.map(ea => ({ name: ea.name, id: ea.id })),\n      shownCounts: this.#shownMsgs.entriesByCountDesc()\n    })\n\n    // Show oldest unshown message first:\n    // If there's a message I haven't shown yet, that's great, show that.\n    return map(\n      leastBy(pending, ea => [this.#shownMsgs.get(ea.name), ea.startedAt]),\n      ea => ({\n        msg: this.findById(ea.name)?.pendingMsg ?? ea.name,\n        at: ea.startedAt\n      })\n    )\n  }\n\n  static loadingMsg() {\n    const result =\n      this.#loadingMsgs.shift() ?? this.unseenOrOldestPendingTrace()\n    map(result, ea => this.#shownMsgs.incr(ea.msg))\n    return logger().tap({\n      msg: \"loadingMsg\",\n      level: \"info\",\n      result: result?.msg,\n      meta: {\n        runState: this.summary().state\n      }\n    })\n  }\n\n  static enableAll() {\n    return this.disableAll(false)\n  }\n\n  static disableAll(b = true) {\n    // AKA skipAllHealthChecks\n    const skipHealthCheckIds = b ? HealthCheckIds.values : []\n    Settings.skipHealthCheckIds.envValue = skipHealthCheckIds\n    return HealthCheck.reset()\n  }\n\n  static findById(id: string) {\n    return this.#instances.find(ea => ea.id === id)\n  }\n\n  static testResults(): Deferred<HealthCheckResult>[] {\n    return this.all().map(ea => ea.result())\n  }\n\n  static testResultsCritical(): Deferred<HealthCheckResult>[] {\n    return this.allCritical().map(ea => ea.result())\n  }\n\n  static async errorResults(): Promise<HealthCheckResult[]> {\n    return (await Promise.all(this.testResults())).filter(\n      ea => ea.level === \"error\"\n    )\n  }\n\n  static async notOkResults(): Promise<HealthCheckResult[]> {\n    return (await Promise.all(this.testResults())).filter(ea =>\n      levelIsNotOK(ea.level)\n    )\n  }\n\n  static runState() {\n    return this.summary().state\n  }\n\n  static readonly summary = lazy(() => {\n    return this.#summary()\n  })\n\n  static summaryFromResults(results: HealthCheckResult[]) {\n    const result = this.#summary(results)\n    this.summary.set(result)\n    return result\n  }\n\n  static #summary(results?: HealthCheckResult[]): HealthCheckSummary {\n    const result = logger().tap({\n      level: \"info\",\n      msg: \"#summary()\",\n      result: this.#_summary(results)\n    })\n    if (result.state !== this.#priorUniqSummaryStates.last?.state) {\n      this.#priorUniqSummaryStates.push({ state: result.state, ts: Date.now() })\n    }\n    return result\n  }\n\n  /** DO NOT USE. See #summary() or summary() */\n  static #_summary(results?: HealthCheckResult[]): HealthCheckSummary {\n    results ??= (\n      isWebService() ? this.allCritical() : (this.all() as HealthCheck[])\n    ).map(ea => ea.toResultSync())\n\n    const pendingIds = results\n      .filter(ea => ea.level === \"pending\")\n      .map(ea => ea.id)\n    const pendingCount = pendingIds.length\n    const settledCount = results.length - pendingCount\n    const settled = pendingCount === 0\n\n    if (this.#errors.length > 0) {\n      return {\n        ...BaseHealthCheckSummary,\n        level: HealthCheckLevels.error,\n        settled,\n        pendingIds,\n        pendingCount,\n        settledCount,\n        ts: Date.now(),\n        state: RunStates.failed,\n        msg: [\n          \"Errors encountered during setup:\",\n          uniq(this.#errors.map(ea => errorToS(ea))).join(\"\\n---\\n\")\n        ],\n        buttons: restartResetOrShutdownButtons()\n      }\n    }\n\n    for (const level of HealthCheckLevelOrder) {\n      const hcWithLevel = results.filter(ea => ea.level === level)\n      if (isNotEmpty(hcWithLevel)) {\n        // Any other messages we should show?\n        const hcNotOK = results.filter(\n          ea => !hcWithLevel.includes(ea) && levelIsNotOK(ea.level)\n        )\n        const args = summaryForLevel(level)\n\n        return logger().tap({\n          msg:\n            \"summary() found \" +\n            hcWithLevel.length +\n            \" \" +\n            args.level +\n            \" checks\",\n          level: HealthCheckLevelToLogLevel[args.level],\n          result: {\n            ...BaseHealthCheckSummary,\n            level: args.level,\n            state: args.state,\n            links: args.links,\n            buttons: args.buttons,\n            settled,\n            pendingIds,\n            pendingCount,\n            settledCount,\n            linkIds: hcWithLevel.map(ea => ea.id),\n            ts: Date.now(),\n            msg: uniq([\n              ...args.msg,\n              ...(args.level === HealthCheckLevels.pending\n                ? []\n                : flatten([...hcWithLevel, ...hcNotOK].map(ea => ea.msg[0])))\n            ])\n          },\n          meta: { checks: hcWithLevel.map(ea => ea.id) }\n        })\n      }\n    }\n\n    return logger().tap({\n      msg: \"summary(): all are passing\",\n      result: {\n        ...BaseHealthCheckSummary,\n        level: HealthCheckLevels.ok,\n        state: RunStates.ready,\n        settled,\n        pendingIds,\n        pendingCount,\n        settledCount,\n        ts: Date.now(),\n        msg: [\n          \"All health checks pass\",\n          plur(results.length, \"health check\") + \" were run\",\n          \"Last updated: \" + fmtDateShort(Date.now())\n        ]\n      }\n    })\n  }\n\n  static allResults(): AsyncGenerator<HealthCheckResult> {\n    return Deferred.toAsyncIterable(this.all().map(ea => ea.result()))\n  }\n\n  static async awaitSettled(): Promise<HealthCheckSummary> {\n    const expectedChecks = (isWebService() ? this.allCritical() : this.all())\n      .length\n    let result = HealthCheck.summary()\n    if (result.settledCount < expectedChecks || !result.settled) {\n      const results = await Promise.all(\n        isWebService()\n          ? HealthCheck.testResultsCritical()\n          : HealthCheck.testResults()\n      )\n      result = HealthCheck.summaryFromResults(results)\n      logger().info(\"awaitSettled(): summary result\", {\n        summary: result,\n        results\n      })\n    }\n    return logger().tap({\n      msg: \"awaitSettled(): done\",\n      level: \"info\",\n      result\n    })\n  }\n\n  static rerunSetup() {\n    this.reset()\n    return this.awaitSettled()\n  }\n\n  static onResultChange() {\n    HealthCheck.summary.unset()\n  }\n\n  static resetDebounced = debounce(() => HealthCheck.reset(), 50)\n\n  static reset() {\n    if (ending()) {\n      logger().warn(\"Rejecting reset() when ending()\", shortStack())\n      return\n    }\n    this.onResultChange()\n    this.#errors.clear()\n    this.#loadingMsgs.clear()\n    this.#shownMsgs.clear()\n    this.#pending.length = 0\n    for (const ea of this.all()) {\n      ea.reset()\n    }\n  }\n\n  static for(args: {\n    section: HealthCheckSection\n    id: HealthCheckId\n    pendingMsg: string\n    settings: (keyof typeof Settings)[]\n    later: Later<HealthCheckTest>\n    ordinal?: number\n    links?: Link[]\n    okLinks?: Link[]\n    warnLinks?: Link[]\n    noLibraryLinks?: Link[]\n    errorLinks?: Link[]\n    onReset?: () => void\n    ttlMs?: number\n    timeoutMs?: number\n    rejectIsWarn?: boolean\n  }) {\n    const prior = this.findById(args.id)\n    if (prior != null) {\n      throw new Error(\n        `Health check with id ${args.id} already exists in section ${prior.section}`\n      )\n    }\n    const result = new HealthCheck(\n      args.section,\n      args.id,\n      args.pendingMsg,\n      args.settings,\n      args.later,\n      args.ordinal,\n      args.links,\n      args.okLinks,\n      args.warnLinks,\n      args.noLibraryLinks,\n      args.errorLinks,\n      args.onReset,\n      args.ttlMs,\n      args.timeoutMs,\n      args.rejectIsWarn\n    )\n    this.#instances.push(result)\n    this.all.unset()\n    return result\n  }\n\n  readonly logger: Logger\n  readonly sortBy: Comparable[]\n  readonly result: MemoizedDeferred<HealthCheckResult>\n\n  private constructor(\n    readonly section: HealthCheckSection,\n    readonly id: HealthCheckId,\n    readonly pendingMsg: string,\n    readonly settings: (keyof typeof Settings)[],\n    later: Later<HealthCheckTest>,\n    readonly ordinal?: number,\n    private readonly links?: Link[],\n    private readonly okLinks?: Link[],\n    private readonly warnLinks?: Link[],\n    private readonly noLibraryLinks?: Link[],\n    private readonly errorLinks?: Link[],\n    readonly onReset?: () => void,\n    readonly ttlMs?: number,\n    readonly timeoutMs: number = commandTimeoutMs(),\n    readonly rejectIsWarn = false\n  ) {\n    this.sortBy = [\n      HealthCheckSections.ordinal(this.section),\n      ordinal ?? 999,\n      // id is included for determinism and as a backstop for lazy health\n      // checks that don't have an ordinal:\n      this.id\n    ]\n    this.logger = mkLogger(\"health.HealthCheck.\" + this.id)\n    this.result = lazyAsync({\n      desc: this.pendingMsg,\n      later: () =>\n        HealthCheck.#p.enqueue({\n          name: this.id,\n          l: () => this.#wrapLater(later)\n        }),\n      ttlMs,\n      timeoutMs\n    })\n    for (const ea of this.settings) {\n      Settings[ea].watchLater(() => this.reset())\n    }\n    this.result.watchLater({\n      onChange: () => HealthCheck.onResultChange(),\n      onError: () => HealthCheck.onResultChange()\n    })\n  }\n\n  isPending() {\n    return this.toResultSyncMaybe() == null\n  }\n\n  settledAtLeastOnce() {\n    return this.result.settledCount()\n  }\n\n  /**\n   * Clear the prior test result so that it will be re-evaluated on next\n   * access.\n   *\n   * NOTE: this forces this HealthCheck back to the pending state!\n   */\n  reset() {\n    this.result.unset()\n    this.onReset?.()\n  }\n\n  /**\n   * Rerun the test now\n   */\n  refresh() {\n    return this.result.refresh()\n  }\n\n  isSkipped() {\n    return Settings.skipHealthCheckIds.values.includes(this.id)\n  }\n\n  async #wrapLater(later: Later<HealthCheckTest>): Promise<HealthCheckResult> {\n    logger().debug(\"#wrapLater() starting\", { id: this.id })\n    try {\n      if (this.isSkipped()) {\n        return this.#toResult({\n          level: \"disabled\",\n          msg: [\"Disabled by \" + Settings.skipHealthCheckIds.key]\n        })\n      }\n      const timeoutMs = this.timeoutMs ?? commandTimeoutMs()\n      const result = await thenOrTimeoutError(\n        getDevEnvFlag(\"PS_SLOMO\")\n          ? // make .8 to avoid timeout, or 1.5 to exercise timeout error handling:\n            delay(randomInt(secondMs, timeoutMs * 0.3)).then(later)\n          : later(),\n        timeoutMs / 2\n      )\n      return this.#toResult(result)\n    } catch (err) {\n      return this.#toErrorResult(err)\n    }\n  }\n\n  // All results go through this method\n  #toResult(test: HealthCheckTest, src = \"#toResult\"): HealthCheckResult {\n    // normalize lines:\n    const msg = HealthCheck.normalizeMsg(test.msg)\n    const level =\n      test.level ??\n      (toS(msg).toLowerCase().includes(\"error\")\n        ? \"error\"\n        : toS(msg).toLowerCase().includes(\"warn\")\n        ? \"warn\"\n        : \"ok\")\n    const links = compact([\n      ...(test?.links ??\n        (level === \"ok\" || level === \"pending\"\n          ? this.okLinks\n          : level === \"warn\"\n          ? this.warnLinks\n          : level === \"no-library\"\n          ? this.noLibraryLinks\n          : level === \"error\"\n          ? this.errorLinks\n          : []) ??\n        []),\n      ...(this.links ?? [])\n    ])\n    const result: HealthCheckResult = {\n      section: this.section,\n      id: this.id,\n      ts: Date.now(),\n      level,\n      elapsedMs: this.result.elapsedMs(),\n      msg,\n      ...partitionLinks(links)\n    }\n    // don't bother to log if we're ending\n    return ending()\n      ? result\n      : this.logger.tap({\n          level: HealthCheckLevelToLogLevel[level],\n          msg: src,\n          result\n        })\n  }\n\n  #toErrorResult(error: any, level?: HealthCheckLevel): HealthCheckResult {\n    this.logger.warn(\"#toErrorResult\", { error, level })\n    const msg =\n      stripSuffix(this.pendingMsg, \"…\") +\n      \" failed:\\n\" +\n      (map(error, errorToS) ?? \"Unknown error\")\n    level ??=\n      this.rejectIsWarn ||\n      (!isFatalError(error) && msg.toLowerCase().includes(\"warn\"))\n        ? \"warn\"\n        : \"error\"\n    return this.#toResult({ msg, level }, \"#toErrorResult\")\n  }\n\n  toLevelSync() {\n    return this.result.prior()?.value?.level ?? \"pending\"\n  }\n\n  toResultSyncMaybe(): HealthCheckResult | undefined {\n    return this.result()?.value ?? this.result.lastValue()\n  }\n\n  toResultSync(): HealthCheckResult {\n    return (\n      this.toResultSyncMaybe() ?? {\n        section: this.section,\n        id: this.id,\n        ts: Date.now(),\n        level: \"pending\",\n        msg: [this.pendingMsg]\n      }\n    )\n  }\n\n  async resultOrTimeout(timeoutMs: number): Promise<HealthCheckResult> {\n    return (\n      (await thenOrTimeoutAs({ f: this.result(), timeoutMs, as: undefined })) ??\n      this.#toErrorResult(\"Timeout\", \"warn\")\n    )\n  }\n}\n\nfunction partitionLinks(\n  arr: Maybe<Link[]>\n): Pick<HealthCheckResult, \"links\" | \"buttons\"> {\n  if (isEmpty(arr)) return {}\n  const [buttons, links] = partition(\n    arr,\n    ea => ea.type === \"button\" || ea.method === \"POST\"\n  )\n  const result = {} as Pick<HealthCheckResult, \"links\" | \"buttons\">\n  if (isNotEmpty(links)) result.links = uniqBy(links)\n  if (isNotEmpty(buttons)) result.buttons = uniqBy(buttons)\n  return result\n}\n","import { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\n\nexport const HealthCheckIds = strEnum(\n  \"library-db\",\n  \"library-directories\",\n  \"library-free-space\",\n  \"library-nothing-to-sync\",\n  \"ps-version\",\n  \"media-directories\",\n  \"nodejs-version\",\n  \"proc-memory-use\",\n  \"proc-not-in-dmg\",\n  \"proc-not-superuser\",\n  \"settings-env\",\n  \"settings-library\",\n  \"settings-system\",\n  \"sync-paused\",\n  \"system-load\",\n  \"system-version\",\n  \"system-volumes\",\n  \"tools-exiftool\",\n  \"tools-heif\",\n  \"tools-powershell\",\n  \"tools-sqlite-version\",\n  \"tools-video\",\n  \"volume-uuids\"\n)\nexport type HealthCheckId =\n  | StrEnumKeys<typeof HealthCheckIds>\n  | \"summary\"\n  | \"test-health-check\"\n","import { lazy } from \"../../core/Lazy\"\nimport { b, li, tt } from \"../../fe/BabyMarkdown\"\nimport { defer } from \"../../fe/Defer\"\nimport { HealthCheckLevels } from \"../../fe/HealthChecks\"\nimport { mkLogger } from \"../Logger\"\nimport { isProd } from \"../NodeEnv\"\nimport { env } from \"../env/Env\"\nimport { ee } from \"../event/EventEmitter\"\nimport { libraryHasSettings } from \"../settings/SettingsIO\"\nimport { exiftoolHealthCheck } from \"./ExiftoolHealthCheck\"\nimport { externalDirsHealthCheck } from \"./ExternalDirsHealthCheck\"\nimport { HealthCheck } from \"./HealthCheck\"\nimport { heifHealthCheck } from \"./HeifHealthCheck\"\nimport { libraryDirectoriesCheck } from \"./LibraryDirectoriesCheck\"\nimport { libraryFreeSpaceCheck } from \"./LibraryFreeSpaceCheck\"\nimport { memoryHealthCheck } from \"./MemoryHealthCheck\"\nimport { nodejsHealthCheck } from \"./NodeHealthCheck\"\nimport { notInDMGHealthCheck } from \"./NotInDMGHealthCheck\"\nimport { osHealthCheck } from \"./OSHealthCheck\"\nimport { powershellHealthCheck } from \"./PowerShellHealthCheck\"\nimport { sqliteHealthCheck } from \"./SQLiteVersionHealthCheck\"\nimport { securityHealthCheck } from \"./SecurityHealthCheck\"\nimport { settingsEnvHealthCheck } from \"./SettingsEnvHealthCheck\"\nimport { settingsLibraryHealthCheck } from \"./SettingsLibraryHealthCheck\"\nimport { settingsSystemHealthCheck } from \"./SettingsSystemHealthCheck\"\nimport { systemLoadHealthCheck } from \"./SystemLoadHealthCheck\"\nimport { versionHealthCheck } from \"./VersionHealthCheck\"\nimport { videoHealthCheck } from \"./VideoHealthCheck\"\nimport { volumeHealthCheck } from \"./VolumeHealthCheck\"\n\nconst logger = defer(() => mkLogger(\"health.HealthCheckSetup\"))\n\nexport const testHealthCheck = defer(() => {\n  return HealthCheck.for({\n    section: \"System\",\n    id: \"test-health-check\",\n    ordinal: 0,\n    settings: [],\n    pendingMsg: \"Test check…\",\n    later: async () => {\n      const level = HealthCheckLevels.validOrElse(\n        env().PS_TEST_HEALTH_CHECK_LEVEL,\n        HealthCheckLevels.ok\n      )\n      return {\n        level,\n        msg: [\n          `Test health check: ${level.toUpperCase()}`,\n          `These are ${b(\"details\")}:`,\n          li(\"alpha\", tt(\"bravo\"), \"charlie\")\n        ]\n      }\n    }\n  })\n})\n\nexport const healthCheckSetup = lazy(() => {\n  exiftoolHealthCheck()\n  heifHealthCheck()\n  libraryDirectoriesCheck()\n  libraryFreeSpaceCheck()\n  settingsEnvHealthCheck()\n  settingsSystemHealthCheck()\n  settingsLibraryHealthCheck()\n  externalDirsHealthCheck()\n  memoryHealthCheck()\n  nodejsHealthCheck()\n  notInDMGHealthCheck()\n  osHealthCheck()\n  powershellHealthCheck()\n  securityHealthCheck()\n  sqliteHealthCheck()\n  systemLoadHealthCheck()\n  videoHealthCheck()\n  volumeHealthCheck()\n  versionHealthCheck()\n\n  if (!isProd) {\n    testHealthCheck()\n  }\n\n  let lastLibraryHasSettings = libraryHasSettings()\n\n  libraryHasSettings.watchLater(newValue => {\n    if (newValue != null && lastLibraryHasSettings !== newValue) {\n      logger().info(\"libraryHasSettings changed. Resetting health checks.\", {\n        newValue\n      })\n      lastLibraryHasSettings = newValue\n      HealthCheck.resetDebounced()\n    }\n  })\n  for (const ea of [\"volumesChanged\", \"mountpointsChanged\", \"error\"] as const) {\n    ee().on(ea, () => {\n      logger().debug(\"Clearing health check cache\", { event: ea })\n      HealthCheck.resetDebounced()\n    })\n  }\n\n  ee().on(\"fatal\", err => HealthCheck.addError(err))\n})\n","import { tt } from \"../../fe/BabyMarkdown\"\nimport { defer } from \"../../fe/Defer\"\nimport { later } from \"../../fe/Delay\"\nimport { map } from \"../../fe/Maybe\"\nimport { ee } from \"../event/EventEmitter\"\nimport { getHeifSupportDetails } from \"../img/Heif\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { ver } from \"../version/Ver\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const heifHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"Tools\",\n    id: \"tools-heif\",\n    pendingMsg: \"Checking HEIF/HEIC tooling…\",\n    settings: [\"heifConvertPath\"],\n    links: [\n      {\n        text: \"Read how to set up HEIF support with PhotoStructure\",\n        url: \"https://photostructure.com/getting-started/heif-support/\",\n        icon: \"docs\"\n      }\n    ],\n    warnLinks: isDocker()\n      ? [] // can't fix docker!\n      : [\n          {\n            text: \"Re-check for HEIF tooling\",\n            icon: \"refresh\",\n            method: \"POST\",\n            type: \"button\",\n            url: \"/admin/recheck-tools\"\n          }\n        ],\n    // if the HEIF tooling is not installed or explodes when checking, we\n    // don't want to block the server from starting:\n    rejectIsWarn: true,\n\n    later: async () => {\n      const td = await getHeifSupportDetails()\n      return td != null && false !== td.isSupportedVersion\n        ? {\n            level: \"ok\",\n            msg: [\n              \"HEIF images will be imported\",\n              map(td.version, ver),\n              map(td.path, tt)\n            ]\n          }\n        : {\n            level: \"warn\",\n            msg: [\n              \"HEIF images will not be imported\",\n              \"No HEIF tooling was found.\"\n            ]\n          }\n    }\n  })\n)\n\nlater(() => {\n  ee().on(\"clearToolCache\", () => heifHealthCheck.prior()?.reset())\n})\n","import { compact } from \"../../fe/Array\"\nimport { Link } from \"../../fe/HealthChecks\"\nimport { libraryHasSettings } from \"../settings/SettingsIO\"\n\nexport const DockerVolumeLink: Link = {\n  type: \"link\",\n  text: \"Read about PhotoStructure docker volumes\",\n  url: \"https://photostructure.com/go/docker-volumes/\",\n  icon: \"docs\"\n}\n\nexport const WhatIsALibraryLink: Link = {\n  type: \"link\",\n  text: `What's a \"PhotoStructure library?\"`,\n  url: \"https://photostructure.com/faq/library/\",\n  icon: \"docs\"\n}\n\nexport function restartResetOrShutdownButtons(): Link[] {\n  return compact([\n    libraryHasSettings()\n      ? {\n          text: \"Try again\",\n          title: \"Restart the current library\",\n          type: \"button\",\n          method: \"POST\",\n          url: \"/admin/restart\",\n          icon: \"refresh\"\n        }\n      : undefined,\n    {\n      text: \"Change PhotoStructure library\",\n      title: \"Create a new library or switch to an existing library\",\n      type: \"button\",\n      method: \"POST\",\n      url: \"/admin/clear-library\",\n      icon: \"switch_folder\"\n    },\n    {\n      text: \"Exit PhotoStructure\",\n      title:\n        \"Shut down PhotoStructure. Your library will no longer be accessible until you re-launch PhotoStructure.\",\n      type: \"button\",\n      method: \"POST\",\n      url: \"/admin/shutdown\",\n      icon: \"power\"\n    }\n  ])\n}\n","import { li, tt } from \"../../fe/BabyMarkdown\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { Link } from \"../../fe/HealthChecks\"\nimport { userDesc } from \"../UserInfo\"\nimport { libraryDirPosixFile, setupLibraryDirs_ } from \"../dir/LibraryDirs\"\nimport { errorToS } from \"../error/Error\"\nimport { isWin } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { Settings } from \"../settings/Settings\"\nimport { libraryHasSettings } from \"../settings/SettingsIO\"\nimport { HealthCheck, HealthCheckTest } from \"./HealthCheck\"\nimport { DockerVolumeLink } from \"./LibraryAdminLinks\"\n\nexport const libraryDirectoriesCheck = defer(() =>\n  HealthCheck.for({\n    section: \"Library\",\n    id: \"library-directories\",\n    ordinal: 0,\n    pendingMsg: \"Checking library directories…\",\n    settings: [\"libraryDir\", \"originalsDir\", \"previewsDir\", \"cacheDir\"],\n    ttlMs: minuteMs,\n    links: [\n      {\n        text: `What's a \"PhotoStructure library?\"`,\n        icon: \"docs\",\n        url: \"https://photostructure.com/faq/library/\"\n      },\n      ...(isDocker()\n        ? [\n            {\n              text: `Read how to setup up Docker`,\n              icon: \"docs\",\n              url: \"https://photostructure.com/server/photostructure-for-docker/\"\n            }\n          ]\n        : [])\n    ] as Link[],\n\n    okLinks: [\n      {\n        type: \"button\",\n        text: \"Run library maintenance jobs\",\n        url: \"/admin/run-maintenance\",\n        method: \"POST\",\n        icon: \"handyman\"\n      }\n    ],\n    later: isDocker() ? testDockerLibraryDir : testLibraryDir\n  })\n)\n\nasync function verifyLibraryDirs_(): Promise<HealthCheckTest> {\n  const dirs = await setupLibraryDirs_()\n  if (libraryHasSettings()) {\n    return {\n      level: \"ok\",\n      msg: [\n        \"Library directories are OK\",\n        `Verified directory permissions for the following directories:`,\n        li(...dirs.map(d => tt(d)))\n      ]\n    }\n  } else {\n    return {\n      level: \"no-library\",\n      msg: [\"Your PhotoStructure library hasn't been set up yet\"]\n    }\n  }\n}\n\nasync function testDockerLibraryDir(): Promise<HealthCheckTest> {\n  const libraryDir = libraryDirPosixFile()\n  if (libraryDir == null) {\n    return {\n      level: \"error\", // < we can't recover from this. They didn't set up the bind mount correctly.\n      msg: [\n        `Something's amiss: ${tt(\"PS_LIBRARY_DIR\")} is blank`,\n        `The default is ${tt(\n          Settings.libraryDir.toEnvLine(Settings.libraryDir.defaultValue)\n        )}`\n      ]\n    }\n  }\n\n  // We can't just mkdir the library dir--it has to be a bind mount.\n  try {\n    if (!(await libraryDir.isReadWriteExecutable_())) {\n      return {\n        level: \"error\",\n        msg: [\n          `Your library directory, ${tt(libraryDir)}, is not read/write${\n            isWin ? \"\" : \"/execute\"\n          } by ${await userDesc()}`,\n          \"Please fix the permissions for this bind mount and restart the container.\"\n        ],\n        links: [DockerVolumeLink]\n      }\n    }\n    return await verifyLibraryDirs_()\n  } catch (error: any) {\n    return {\n      level: \"error\",\n      msg: [\n        `Your library directory, ${tt(\n          libraryDir\n        )}, can't be set up for ${await userDesc()}.`,\n        errorToS(error, { maxLen: 80 }),\n        \"Please fix the permissions for this bind mount and restart the container.\"\n      ],\n      links: [DockerVolumeLink]\n    }\n  }\n}\n\nasync function testLibraryDir(): Promise<HealthCheckTest> {\n  const libraryDir = libraryDirPosixFile()\n  if (libraryDir == null) {\n    return {\n      level: \"no-library\",\n      msg: \"No PhotoStructure library is open\"\n    }\n  }\n\n  // if we got to here, the directory is either missing or is read/write.\n  // If we have settings, we're all good:\n  if (!libraryHasSettings()) {\n    return {\n      level: \"no-library\",\n      msg: [\n        \"No PhotoStructure library is open\",\n        Settings.libraryDir.hasValue()\n          ? tt(Settings.libraryDir.toEnvLine())\n          : undefined\n      ]\n    }\n  }\n  try {\n    if (!(await libraryDir.isReadWriteExecutable_())) {\n      return {\n        level: \"no-library\",\n        msg: [\n          `Your library directory, ${tt(libraryDir)}, is not read/write${\n            isWin ? \"\" : \"/execute\"\n          } by ${await userDesc()}`,\n          \"Please fix the permissions or pick a new library directory.\"\n        ]\n      }\n    }\n    return await verifyLibraryDirs_()\n  } catch (error: any) {\n    return {\n      level: \"no-library\",\n      msg: [\n        `Your library directory, ${tt(\n          libraryDir\n        )}, can't be set up for ${await userDesc()}`,\n        errorToS(error, { maxLen: 80 }),\n        \"Please fix the permissions for this bind mount and restart the container.\"\n      ]\n    }\n  }\n}\n","import { uniq } from \"../../fe/Array\"\nimport { b, li, tt } from \"../../fe/BabyMarkdown\"\nimport { dayMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { gt0 } from \"../../fe/Number\"\nimport { tap } from \"../../fe/Object\"\nimport { GB, fmtBytes } from \"../../fe/Units\"\nimport { libraryDirPosixFile, setupLibraryDirs_ } from \"../dir/LibraryDirs\"\nimport { getDevEnvFlag } from \"../env/DevEnvFlags\"\nimport { Settings } from \"../settings/Settings\"\nimport { Volume } from \"../volumes/Volume\"\nimport { bestVolumeForPath } from \"../volumes/Volumes\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const libraryFreeSpaceCheck = defer(() =>\n  tap(\n    HealthCheck.for({\n      section: \"Library\",\n      id: \"library-free-space\",\n      settings: [\n        \"libraryDir\",\n        \"minDiskFreeGb\",\n        \"originalsDir\",\n        \"previewsDir\",\n        \"cacheDir\"\n      ],\n      pendingMsg: \"Checking free space on library volume(s)…\",\n      rejectIsWarn: true,\n      ttlMs: dayMs,\n      later: async () => {\n        if (!gt0(Settings.minDiskFreeGb.valueOrDefault)) {\n          return {\n            level: \"disabled\",\n            msg: `Library disk free test disabled: ${tt(\n              Settings.minDiskFreeGb.key + \"=0\"\n            )}`\n          }\n        }\n\n        const libraryDir = libraryDirPosixFile()\n        if (libraryDir == null) {\n          return {\n            level: \"disabled\",\n            msg: `Library disk free test disabled: no library is open`\n          }\n        }\n        if (true !== (await libraryDir.isDirectory())) {\n          return {\n            level: \"disabled\",\n            msg: `Library disk free test disabled: ${tt(\n              libraryDir\n            )} is not a directory`\n          }\n        }\n\n        const toCheck: {\n          vol: Volume\n          paths: string[]\n        }[] = []\n\n        for (const pf of await setupLibraryDirs_()) {\n          const vol = await bestVolumeForPath(pf)\n          if (vol == null) {\n            return {\n              level: \"warn\",\n              msg: `Could not check for minimum disk free: no volume found for library path ${tt(\n                pf\n              )}`\n            }\n          }\n          let o = toCheck.find(ea => ea.vol.mountpoint === vol.mountpoint)\n          if (o == null) {\n            o = {\n              vol,\n              paths: []\n            }\n            toCheck.push(o)\n          }\n          o.paths.push(pf.nativePath)\n        }\n\n        const minFreeBytes = Settings.minDiskFreeGb.valueOrDefault * GB\n        const descriptions: string[] = []\n\n        for (const { vol, paths } of toCheck) {\n          const desc =\n            b(\n              `Volume ${tt(vol.mountpoint)} has ${fmtBytes(\n                vol.available\n              )} free.`\n            ) +\n            `\\nThis volume is used for these PhotoStructure directories:\\n${li(\n              uniq(paths).sort().map(tt)\n            )}`\n\n          if (\n            vol.available < minFreeBytes ||\n            getDevEnvFlag(\"PS_FORCE_FULLDISK\")\n          ) {\n            return {\n              level: \"stop-sync\",\n              msg:\n                \"Library volume is almost full\\n\" +\n                tt(Settings.minDiskFreeGb.key) +\n                \" is set to \" +\n                fmtBytes(minFreeBytes) +\n                \".\\n\" +\n                desc +\n                \"\\nPhotoStructure sync is automatically paused until you free up at least \" +\n                fmtBytes(minFreeBytes - vol.available) +\n                \" on \" +\n                vol.mountpoint\n            }\n          } else {\n            descriptions.push(desc)\n          }\n\n          if (vol.available < minFreeBytes * 0.75) {\n            return {\n              level: \"warn\",\n              msg: \"Library volume is almost full\" + desc\n            }\n          }\n        }\n        return {\n          level: \"ok\",\n          msg: [\n            \"Library free disk space is OK\",\n            ...descriptions,\n            \"\",\n            \"PhotoStructure sync will pause if free space drops below \" +\n              tt(Settings.minDiskFreeGb.key) +\n              \", set to \" +\n              fmtBytes(minFreeBytes) +\n              \".\"\n          ]\n        }\n      }\n    }),\n    ea => {\n      for (const setting of [\n        \"minDiskFreeGb\",\n        \"libraryDir\",\n        \"originalsDir\",\n        \"configDir\"\n      ] as const) {\n        Settings[setting].watchLater(() => ea.reset())\n      }\n    }\n  )\n)\n","import os from \"os\"\nimport { lazy } from \"../../core/Lazy\"\nimport { li } from \"../../fe/BabyMarkdown\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { HealthCheckLevel } from \"../../fe/HealthChecks\"\nimport { gt0 } from \"../../fe/Number\"\nimport { GB, MB, fmtBytes } from \"../../fe/Units\"\nimport { memoryUsageBytes, memoryUsageMb } from \"../Memory\"\nimport { serviceName } from \"../ServiceNames\"\nimport { Settings } from \"../settings/Settings\"\nimport { HealthCheck, HealthCheckTest } from \"./HealthCheck\"\n\nfunction asTest({\n  desc,\n  bytes,\n  level,\n  thresholdBytes\n}: {\n  desc: string\n  bytes: number\n  level: HealthCheckLevel\n  thresholdBytes: number\n}): HealthCheckTest {\n  return {\n    level,\n    msg: [\n      desc +\n        \" from \" +\n        serviceName() +\n        \" is \" +\n        (level === \"ok\" ? \"OK\" : \"high\"),\n      li([\n        \"Current: \" + fmtBytes(bytes, 2),\n        \"Threshold: \" + fmtBytes(thresholdBytes, 2)\n      ])\n    ]\n  }\n}\n\nfunction memoryUsageTest(): HealthCheckTest {\n  if (os.totalmem() < GB) {\n    return {\n      level: \"warn\",\n      msg: \"PhotoStructure may need more than a GB of RAM to run, especially if your library is large.\"\n    }\n  } else if (\n    gt0(Settings.maxMemoryMb.valueOrDefault) &&\n    memoryUsageMb() > Settings.maxMemoryMb.valueOrDefault\n  ) {\n    return asTest({\n      level: \"error\",\n      desc: \"Used memory\",\n      bytes: memoryUsageBytes(),\n      thresholdBytes: Settings.maxMemoryMb.valueOrDefault * MB\n    })\n  } else if (\n    gt0(Settings.maxMemoryMb.valueOrDefault) &&\n    memoryUsageMb() > Settings.maxMemoryMb.valueOrDefault * 0.75\n  ) {\n    return asTest({\n      level: \"warn\",\n      desc: \"Used memory\",\n      bytes: memoryUsageBytes(),\n      thresholdBytes: Settings.maxMemoryMb.valueOrDefault * MB\n    })\n  } else {\n    return asTest({\n      level: \"ok\",\n      desc: \"Used memory\",\n      bytes: memoryUsageBytes(),\n      thresholdBytes: Settings.maxMemoryMb.valueOrDefault * MB\n    })\n  }\n}\n\nexport const memoryUsageIsHigh = lazy(\n  () => memoryUsageTest().level !== \"ok\",\n  secondMs\n)\n\nexport const memoryHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"System\",\n    id: \"proc-memory-use\",\n    pendingMsg: \"Checking memory usage…\",\n    settings: [\"maxMemoryMb\"],\n    errorLinks: [\n      {\n        text: \"Restart web service\",\n        type: \"button\",\n        method: \"POST\",\n        url: \"/admin/bounce\",\n        icon: \"refresh\"\n      }\n    ],\n    ttlMs: minuteMs,\n    later: async () => memoryUsageTest()\n  })\n)\n","import p from \"process\"\nimport { tt } from \"../../fe/BabyMarkdown\"\nimport { defer } from \"../../fe/Defer\"\nimport { isSupportedNode, requiredNodeRange } from \"../NodeVersion\"\nimport { ver } from \"../version/Ver\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const nodejsHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"Tools\",\n    id: \"nodejs-version\",\n    pendingMsg: \"Checking Node.js…\",\n    settings: [],\n    // no ttlMs: this won't change at runtime\n    links: [\n      // this should only apply for PhotoStructure for Node users:\n      {\n        text: \"Read about PhotoStructure NodeJS support\",\n        icon: \"docs\",\n        url: \"https://photostructure.com/server/photostructure-for-node/#prerequisites\"\n      }\n    ],\n    later: async () => {\n      const msg =\n        \"You're running Node.js \" +\n        ver(p.versions.node) +\n        \".\\nPhotoStructure requires \" +\n        tt(requiredNodeRange()) +\n        \".\"\n      return isSupportedNode()\n        ? {\n            level: \"ok\",\n            msg: [\"Node.js is OK\", msg]\n          }\n        : {\n            level: \"warn\",\n            msg: [\"Node.js is not a supported version\", msg]\n          }\n    }\n  })\n)\n","import { defer } from \"../../fe/Defer\"\nimport { ProjectPath } from \"../fs/ProjectPath\"\nimport { isElectron, isMac } from \"../platform/Platform\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const notInDMGHealthCheck = defer(() =>\n  isMac && isElectron\n    ? HealthCheck.for({\n        section: \"System\",\n        id: \"proc-not-in-dmg\",\n        pendingMsg: \"Checking PhotoStructure installation directory…\",\n        settings: [],\n        later: async () => {\n          if (ProjectPath.isInDMG()) {\n            return {\n              level: \"error\",\n              msg: \"PhotoStructure cannot run directly from a DMG disk image. Please drag and drop the PhotoStructure icon onto your Applications folder to install.\",\n              checkboxLabel:\n                \"Open https://photostructure.com/getting-started/installation/ in your browser\"\n            }\n          } else {\n            return {\n              level: \"ok\",\n              msg: \"PhotoStructure isn't running directly from a DMG disk image\"\n            }\n          }\n        }\n      })\n    : undefined\n)\n","import { defer } from \"../../fe/Defer\"\nimport { osFullName, whyOsNotSupported } from \"../OperatingSystem\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const osHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"System\",\n    id: \"system-version\",\n    pendingMsg: \"Checking operating system…\",\n    settings: [],\n    // no ttlMs: this won't change at runtime\n    links: [\n      {\n        text: \"What do I need to run PhotoStructure?\",\n        icon: \"docs\",\n        url: \"https://forum.photostructure.com/t/what-do-i-need-to-run-photostructure/44\"\n      }\n    ],\n    later: async () => {\n      const why = whyOsNotSupported()\n      return why == null\n        ? {\n            level: \"ok\",\n            msg: [\n              \"Operating system is OK\",\n              \"PhotoStructure supports \" + osFullName()\n            ]\n          }\n        : {\n            level: \"warn\",\n            msg: [\n              \"Operating system is not supported\",\n              osFullName() + \" was detected, but only \" + why + \".\"\n            ]\n          }\n    }\n  })\n)\n","import { minuteMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { errorToS } from \"../error/Error\"\nimport { isWin } from \"../platform/Platform\"\nimport { checkPowerShell_ } from \"../pwsh/PowerShell\"\nimport { ver } from \"../version/Ver\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const powershellHealthCheck = defer(() =>\n  isWin\n    ? HealthCheck.for({\n        section: \"Tools\",\n        id: \"tools-powershell\",\n        pendingMsg: \"Checking PowerShell…\",\n        settings: [\"powerShellArgs\"],\n        ttlMs: minuteMs,\n        links: [\n          {\n            text: \"How to fix PowerShell issues\",\n            url: \"https://photostructure.com/fix-pwsh/\"\n          }\n        ],\n\n        later: async () => {\n          try {\n            const version = await checkPowerShell_()\n            return {\n              level: \"ok\",\n              msg: [\"PowerShell is OK\", ver(version)],\n              meta: {\n                version\n              }\n            }\n          } catch (error) {\n            return {\n              level: \"error\",\n              msg: \"PowerShell failed: \" + errorToS(error as any)\n            }\n          }\n        }\n      })\n    : undefined\n)\n","import { li, tt } from \"../../fe/BabyMarkdown\"\nimport { defer } from \"../../fe/Defer\"\nimport { sqliteVersion_ } from \"../db/SQLiteVersion\"\nimport { errorToS } from \"../error/Error\"\nimport { ver } from \"../version/Ver\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const sqliteHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"Tools\",\n    id: \"tools-sqlite-version\",\n    ordinal: 0,\n    pendingMsg: \"Checking SQLite…\",\n    settings: [],\n    // ttlMs: minuteMs, // it's either or not at startup, no need to recheck.\n    links: [\n      {\n        text: \"Read about PhotoStructure SQLite support\",\n        url: \"https://forum.photostructure.com/t/whats-ps-force-local-db-replica/837\",\n        icon: \"docs\"\n      }\n    ],\n    async later() {\n      try {\n        const v = await sqliteVersion_.refresh()\n        if (v == null)\n          return {\n            level: \"error\",\n            msg: \"SQLite version could not be found\"\n          }\n\n        return {\n          level: \"ok\",\n          msg: [\n            \"SQLite is OK\",\n            li([\n              \"embedded: \" + ver(v.libraryVersion),\n              tt(v.sqliteNativePath) + \": \" + ver(v.toolVersion)\n            ])\n          ]\n        }\n      } catch (error) {\n        return {\n          level: \"error\",\n          msg: \"Something's amiss with SQLite: \" + errorToS(error as any)\n        }\n      }\n    }\n  })\n)\n","import { b, tt } from \"../../fe/BabyMarkdown\"\nimport { defer } from \"../../fe/Defer\"\nimport { groupid, isRootUser, userid, username } from \"../UserInfo\"\nimport { getDevEnvFlag } from \"../env/DevEnvFlags\"\nimport { env } from \"../env/Env\"\nimport { DevEnvFlags } from \"../env/EnvKeys\"\nimport { isWin } from \"../platform/Platform\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const securityHealthCheck = defer(() => {\n  const desc = isWin ? \"an administrator\" : \"root\"\n\n  return HealthCheck.for({\n    section: \"System\",\n    id: \"proc-not-superuser\",\n    pendingMsg: \"Checking user permission level…\",\n    settings: [],\n    rejectIsWarn: true,\n    // no need to ever expire!\n    later: async () => {\n      if (env().PUID === \"0\") {\n        return {\n          level: \"disabled\",\n          msg: `Admin health check is disabled (${tt(\"PUID=0\")}).`\n        }\n      }\n      const msg = [\n        \"Current user id: \" + b(tt(userid())),\n        \"Current group id: \" + b(tt(groupid())),\n        \"Current user name: \" + b(tt((await username()) ?? \"(unknown)\"))\n      ]\n\n      if (\n        true === (await isRootUser()) ||\n        getDevEnvFlag(DevEnvFlags.PS_FAIL_SECURITY_HEALTH_CHECK)\n      ) {\n        return {\n          level: \"warn\",\n          msg: [\"PhotoStructure should not be run as \" + desc, ...msg],\n          links: [\n            {\n              text: \"Read why PhotoStructure should not be run as \" + desc,\n              url: \"https://photostructure.com/server/photostructure-for-docker/#why-not-run-as-root\"\n            }\n          ]\n        }\n      } else {\n        return {\n          msg: [\"PhotoStructure is not running as \" + desc, ...msg],\n          level: \"ok\"\n        }\n      }\n    }\n  })\n})\n","import { li, tt } from \"../../fe/BabyMarkdown\"\nimport { defer } from \"../../fe/Defer\"\nimport { plur } from \"../../fe/Units\"\nimport { allSettings } from \"../settings/Settings\"\nimport { verifyPsEnvSettings } from \"../settings/VerifyPsEnvSettings\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const settingsEnvHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"Library\",\n    id: \"settings-env\",\n    pendingMsg: \"Checking environment settings…\",\n    settings: [],\n    rejectIsWarn: true,\n    links: [\n      {\n        text: \"Read about PhotoStructure environment settings\",\n        url: \"https://photostructure.com/faq/environment-variables/\",\n        icon: \"docs\"\n      }\n    ],\n\n    later: async () => {\n      const overrides: string[] = []\n      for (const ea of allSettings()) {\n        if (ea.hasValue() && ea._envValue() != null) {\n          const v =\n            ea.opts.sensitive === true\n              ? \"********\"\n              : ea.toEnvValue(ea._envValue())\n          if (v != null) overrides.push(tt(ea.key + \"=\" + v))\n        }\n      }\n      const msg = [plur(overrides.length, \"environment setting\"), li(overrides)]\n      const warnings = verifyPsEnvSettings()\n      if (warnings.length > 0) {\n        return {\n          level: \"warn\",\n          msg: [\n            \"Some environment settings may be misconfigured:\",\n            li(warnings.map(ea => tt(ea.envKey) + \": \" + ea.msg)),\n            \"---\",\n            ...msg\n          ]\n        }\n      }\n      return {\n        level: \"ok\",\n        msg\n      }\n    }\n  })\n)\n","import { defer } from \"../../fe/Defer\"\nimport { librarySettingsFile } from \"../settings/SettingsIO\"\nimport { HealthCheck } from \"./HealthCheck\"\nimport { validateSettingsToml } from \"./SettingsSystemHealthCheck\"\n\nexport const settingsLibraryHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"Library\",\n    id: \"settings-library\",\n    pendingMsg: \"Checking library settings…\",\n    settings: [\"libraryDir\"],\n    rejectIsWarn: true,\n    links: [\n      {\n        text: \"Read about PhotoStructure library settings\",\n        url: \"https://photostructure.com/getting-started/advanced-settings/#library-settings\",\n        icon: \"docs\"\n      }\n    ],\n\n    later: () => validateSettingsToml(librarySettingsFile(), \"library\")\n  })\n)\n","import { isNotEmpty } from \"../../fe/Array\"\nimport { b, li, tt } from \"../../fe/BabyMarkdown\"\nimport { defer } from \"../../fe/Defer\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { plur } from \"../../fe/Units\"\nimport { capitalize } from \"../String\"\nimport { errorToS } from \"../error/Error\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { importFileSettings_ } from \"../settings/SettingsIO\"\nimport { systemSettingsFile } from \"../settings/SystemSettings\"\nimport { HealthCheck, HealthCheckTest } from \"./HealthCheck\"\n\nexport async function validateSettingsToml(\n  file: Maybe<PosixFile>,\n  flavor: \"system\" | \"library\"\n): Promise<HealthCheckTest> {\n  try {\n    if (file == null) {\n      return {\n        level: \"disabled\",\n        msg: \"No \" + flavor + \" settings is set.\"\n      }\n    }\n    if (await file.notExists()) {\n      return {\n        level: \"disabled\",\n        msg:\n          capitalize(flavor) + \" settings file \" + tt(file) + \" does not exist.\"\n      }\n    }\n    const result = await importFileSettings_(file)\n    if (isNotEmpty(result.warnings)) {\n      return {\n        level: \"warn\",\n        msg: tt(file) + \": \" + result.warnings.join(\", \")\n      }\n    } else {\n      return {\n        level: \"ok\",\n        msg: [\n          plur(result.settings.length, flavor + \" setting override\"),\n          b(\"Source:\"),\n          tt(file),\n          b(\"Settings:\"),\n          li(result.settings.map(s => tt(s.key + \"=\" + s.toEnvValue(s.value))))\n        ]\n      }\n    }\n  } catch (error) {\n    return {\n      level: \"error\",\n      msg: \"Failed to parse \" + file + \":\\n\" + errorToS(error)\n    }\n  }\n}\n\nexport const settingsSystemHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"Library\",\n    id: \"settings-system\",\n    pendingMsg: \"Checking system settings…\",\n    settings: [],\n    rejectIsWarn: true,\n    links: [\n      {\n        text: \"Read about PhotoStructure system settings\",\n        url: \"https://photostructure.com/getting-started/advanced-settings/#system-settings\",\n        icon: \"docs\"\n      }\n    ],\n\n    later: () =>\n      validateSettingsToml(PosixFile.forMaybe(systemSettingsFile()), \"system\")\n  })\n)\n","import { tt } from \"../../fe/BabyMarkdown\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { fmtPct } from \"../../fe/Number\"\nimport { EndableInterval } from \"../async/EndableInterval\"\nimport { Settings } from \"../settings/Settings\"\nimport { CpuUsage, isTooBusy } from \"../work/CpuUsage\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const systemLoadHealthCheck = defer(() => {\n  const interval = new EndableInterval({\n    name: \"systemLoadHealthCheck\",\n    intervalMs: minuteMs,\n    callback: async () => systemLoadHealthCheck().refresh()\n  })\n  return HealthCheck.for({\n    section: \"System\",\n    id: \"system-load\",\n    pendingMsg: \"Checking system load…\",\n    settings: [\"cpuBusyPercent\"],\n    rejectIsWarn: true,\n    later: async () => {\n      const busyPct = CpuUsage.instance().busyPct()\n      const tooBusy = isTooBusy()\n      interval.setIntervalMs((tooBusy ? 6 : 60) * secondMs)\n      const level = tooBusy ? \"stop-sync\" : \"ok\"\n      const msg =\n        \"CPU utilization is \" +\n        fmtPct(busyPct, 200) +\n        \"\\n\" +\n        (tooBusy\n          ? \"PhotoStructure sync is paused until CPU utilization drops below\"\n          : \"PhotoStructure sync will pause if CPU utilization exceeds\") +\n        \" \" +\n        tt(Settings.cpuBusyPercent.key) +\n        \": \" +\n        fmtPct(Settings.cpuBusyPercent.valueOrDefault, 200)\n      return { level, msg }\n    }\n  })\n})\n","import { hourMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { checkVersion_ } from \"../version/VersionCheck\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const versionHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"System\",\n    id: \"ps-version\",\n    pendingMsg: \"Checking PhotoStructure version…\",\n    settings: [\"autoUpdateCheck\", \"configDir\", \"libraryDir\", \"optOut\"],\n    ttlMs: hourMs,\n    rejectIsWarn: true,\n    links: [\n      {\n        text: \"Change auto-update setting\",\n        icon: \"settings\",\n        url: \"/settings#update-check-section\"\n      },\n      {\n        text: \"What's new?\",\n        icon: \"docs\",\n        url: \"https://photostructure.com/whats-new/\"\n      },\n      // {\n      //   text: \"Release notes\",\n      //   icon: \"docs\",\n      //   url: \"https://photostructure.com/release-notes/\"\n      // },\n      {\n        text: \"Update checking & privacy\",\n        icon: \"docs\",\n        url: \"https://forum.photostructure.com/t/new-in-v2023-10-automated-photostructure-version-checking/1956\"\n      }\n    ],\n    later: checkVersion_\n  })\n)\n","import { tt } from \"../../fe/BabyMarkdown\"\nimport { defer } from \"../../fe/Defer\"\nimport { later } from \"../../fe/Delay\"\nimport { map } from \"../../fe/Maybe\"\nimport { ee } from \"../event/EventEmitter\"\nimport { getVideoToolDetails_ } from \"../img/Video\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { ver } from \"../version/Ver\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const videoHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"Tools\",\n    id: \"tools-video\",\n    pendingMsg: \"Checking video tooling…\",\n    settings: [\"ffmpegPath\"],\n    links: [\n      {\n        text: \"Read how to set up video support with PhotoStructure\",\n        url: \"https://photostructure.com/getting-started/video-support/\",\n        icon: \"docs\"\n      }\n    ],\n    warnLinks: isDocker()\n      ? [] // can't fix docker!\n      : [\n          {\n            text: \"Re-check for video tooling\",\n            icon: \"refresh\",\n            method: \"POST\",\n            type: \"button\",\n            url: \"/admin/recheck-tools\"\n          }\n        ],\n    // if the video tooling is not installed, we don't want to block the server from starting:\n    rejectIsWarn: true,\n    later: async () => {\n      const td = await getVideoToolDetails_()\n      return td != null && false !== td.isSupportedVersion\n        ? {\n            level: \"ok\",\n            msg: [\n              \"Videos will be imported\",\n              map(td.version, ver),\n              map(td.path, tt)\n            ]\n          }\n        : {\n            level: \"warn\",\n            msg: [\"Videos will not be imported\", \"No video tooling was found.\"]\n          }\n    }\n  })\n)\n\nlater(() => {\n  ee().on(\"clearToolCache\", () => videoHealthCheck.prior()?.reset())\n})\n","import { isNotEmpty } from \"../../fe/Array\"\nimport { li } from \"../../fe/BabyMarkdown\"\nimport { fmtAgo, minuteMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { Timeout, thenOrTimeout } from \"../../fe/ThenOrTimeout\"\nimport { plur } from \"../../fe/Units\"\nimport { partition } from \"../Array\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { isWin } from \"../platform/Platform\"\nimport { dfPosixRawLocal_ } from \"../volumes/DfPosixRaw\"\nimport { getLocalVolumesWin_ } from \"../volumes/DfWin\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { volumes } from \"../volumes/Volumes\"\nimport { HealthCheck } from \"./HealthCheck\"\n\nexport const volumeHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"System\",\n    id: \"system-volumes\",\n    ordinal: 0,\n    pendingMsg: \"Checking volumes…\",\n    settings: [],\n    rejectIsWarn: true,\n    // ttlMs: we're relying on mountpointsChanged to trigger a recheck\n    links: [\n      {\n        text: `What's a “volume”?`,\n        url: \"https://photostructure.com/faq/what-is-a-volume/\",\n        icon: \"docs\"\n      }\n    ],\n    warnLinks: isWin\n      ? [\n          {\n            text: \"Check this page for troubleshooting tips\",\n            url: \"https://photostructure.com/faq/windows-troubleshooting/#unhealthy-network-shares\"\n          }\n        ]\n      : undefined,\n    later: async () => {\n      const start = Date.now()\n      const vols = await thenOrTimeout(volumes(), commandTimeoutMs())\n      if (vols === Timeout) {\n        // are local volumes ok?\n        const localVolumes = await thenOrTimeout<any>(\n          isWin ? getLocalVolumesWin_() : dfPosixRawLocal_(),\n          ShortCommandTimeoutMs\n        )\n        // try again after 5 minutes?\n        volumeHealthCheck().logger.warn(\"volumes() timed out, retrying in 5m\")\n        setTimeout(() => volumeHealthCheck().refresh(), 5 * minuteMs)\n        return {\n          level: \"warn\",\n\n          msg: [\n            localVolumes === Timeout\n              ? \"Something seems wrong with your computer's volumes\"\n              : \"Something seems wrong with one or more remote filesystem mounts\",\n            \"Gathering volume metadata took longer than \" +\n              fmtAgo(start, \"\") +\n              \".\"\n          ]\n        }\n      }\n\n      const notOk = vols.filter(ea => ea.ok === false)\n      if (isNotEmpty(notOk)) {\n        return {\n          level: \"warn\",\n          msg: [\n            \"One or more volumes are not healthy\",\n            \"Check the following mountpoints:\",\n            li(notOk.map(ea => ea.mountpoint))\n          ]\n        }\n      }\n\n      const [remote, local] = partition(vols, ea => ea.remote === true)\n      return {\n        level: \"ok\",\n        msg: [\n          \"Volumes seem OK\",\n          plur(local.length, \"local volume\") +\n            \" and \" +\n            plur(remote.length, \"remote volume\") +\n            \" checked.\"\n        ]\n      }\n    }\n  })\n)\n","import _sharp from \"sharp\"\nimport { inspect } from \"util\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact, diff, isNotEmpty } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { Dimensions, dmegapixels, fmtDim } from \"../../fe/Dimensions\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { pick } from \"../../fe/Object\"\nimport { leastBy } from \"../Array\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { shim1 } from \"../Shim1\"\nimport {\n  SortableAssetFile,\n  sortAssetFiles\n} from \"../asset-file/AssetFileSorter\"\nimport { getAssetFileNativePath } from \"../asset-file/IAssetFile\"\nimport { InternalError } from \"../error/InternalError\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { isBaseFile } from \"../fs/BaseFile\"\nimport { FileCache } from \"../fs/FileCache\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { whyRejectFile } from \"../fs/PosixFileFilters\"\nimport { unlink } from \"../fs/Unlink\"\nimport { PushProgressObserver } from \"../progress/PushProgressObserver\"\nimport {\n  ForceContext,\n  RequiredForceContext,\n  forceContextOrSetting\n} from \"../settings/ForceContext\"\nimport { Settings } from \"../settings/Settings\"\nimport { readTags } from \"../tags/ExifTool\"\nimport { AssetPreviewInfo, AssetPreviews } from \"./AssetPreviews\"\nimport { equivalentFitSizes, fitSizes } from \"./FitSizes\"\nimport { isHeifMimeType } from \"./HeifFilter\"\nimport { ImageSize } from \"./ImageSize\"\nimport { includePreviewTags_ } from \"./IncludePreviewTags\"\nimport { Fit } from \"./Reducers\"\nimport { sharpReadable_, toSharp } from \"./SharpReadable\"\nimport { throwIfInvalidFile_ } from \"./ValidFile\"\n\nexport interface PreviewAssetFile extends SortableAssetFile {\n  id?: number\n  assetId?: number\n  rotation?: number\n}\n\nexport async function mkPreviewAssetFile_(\n  f: PosixFile\n): Promise<PreviewAssetFile> {\n  const t = (await readTags(f))!\n  return {\n    nativePath: f.nativePath,\n    fileSize: (await f.size())!,\n    mtime: (await f.thisOrSidecareMaxMtimeMs())!,\n    uri: (await f.uri_())!,\n    mountpoint: (await f.mountpoint())?.nativePath,\n    mimetype: t.mimetype,\n    rotation: t.rotation,\n    ...t.dimensions,\n    sha: await f.sha_()\n  }\n}\n\nconst badShaCache = lazy(\n  () =>\n    new FileCache<boolean>({\n      name: \"img.badShaCache\",\n      maxSize: 256,\n      timeoutMs: minuteMs\n    })\n)\n\n// PERF: minimize GC\nconst fp = Promise.resolve(false)\nconst impl = (_sha: string) => fp\n\nexport const isBadSha = shim1({\n  name: \"isBadSha\",\n  impl,\n  cache: badShaCache\n})\n\nexport class AssetPreviewBuilder {\n  private readonly logger: Logger\n  private readonly ctx: RequiredForceContext\n  constructor(\n    readonly ap: AssetPreviews,\n    readonly assetFiles: PreviewAssetFile[],\n    ctx: ForceContext\n  ) {\n    this.logger = mkLogger(\"AssetPreviewBuilder(\" + ap.assetId + \")\")\n    this.ctx = forceContextOrSetting(ctx)\n    this.assetFiles = sortAssetFiles(this.assetFiles)\n  }\n\n  [inspect.custom]() {\n    return {\n      ctor: \"AssetPreviewBuilder\",\n      assetId: this.ap.assetId,\n      assetFiles: this.assetFiles\n    }\n  }\n\n  /**\n   * The caller is assumed to have a per-asset advisory lock to prevent\n   * concurrent runs for the same asset.\n   */\n  async build_(): Promise<AssetPreviewInfo> {\n    this.logger.info(\n      \"build_(): asset file candidates:\",\n      this.assetFiles.map(ea => pick(ea, \"id\", \"uri\"))\n    )\n    const causes: any[] = []\n    for (const af of this.assetFiles) {\n      const pf = PosixFile.forMaybe(await getAssetFileNativePath(af))\n      if (pf == null) {\n        this.logger.info(\"skipping: failed to get PosixFile\", { af })\n        causes.push(\n          new Error(\n            \"Cannot get path from URI \" +\n              stringify(pick(af, \"uri\", \"mountpoint\", \"nativePath\"))\n          )\n        )\n        continue\n      }\n      {\n        const whyRejected = await whyRejectFile(pf)\n        if (!blank(whyRejected)) {\n          this.logger.info(\"skipping: rejected\", { pf, whyRejected })\n        }\n      }\n      const sha = af.sha ?? (await pf.sha())\n      if (sha == null) {\n        this.logger.info(\"skipping: cannot read SHA\", pf)\n        causes.push(new Error(\"Cannot read \" + pf.nativePath))\n        continue\n      }\n      if (true === (await isBadSha(sha))) {\n        this.logger.info(\"skipping: bad SHA\", pf)\n        continue\n      }\n      try {\n        return await this._build(pf, af)\n      } catch (error) {\n        causes.push(error)\n        badShaCache().set(sha, true)\n        this.logger.warn(\"Failed to set shown file to \", { best: af, error })\n      } finally {\n        // Make sure we don't have a stale view of the parent contents:\n        this.ap.parent.clear()\n      }\n    }\n    return this.logger.throw(\n      \"Cannot build previews: none of the files are valid\",\n      {\n        doNotSend: true, // < don't send this to Sentry\n        retriable: false,\n        files: this.assetFiles.map(ea => ea.nativePath ?? ea.uri),\n        causes\n      }\n    )\n  }\n\n  private async infoForBest_(\n    pf: PosixFile,\n    best: PreviewAssetFile\n  ): Promise<AssetPreviewInfo> {\n    await throwIfInvalidFile_(pf)\n    const filesize = await pf.size()\n    const mtime = await pf.thisOrSidecareMaxMtimeMs()\n    this.logger.debug(\"_build\", { filesize, mtime, best: best.uri })\n    if (filesize == null || mtime == null) {\n      return this.logger.throw(\"build(): missing stat info for best file\", {\n        ignorable: true,\n        best\n      })\n    }\n\n    const { uri, width, height, sha, mimetype } = best\n\n    if (\n      uri == null ||\n      width == null ||\n      height == null ||\n      mimetype == null ||\n      sha == null\n    ) {\n      return this.logger.throw(\n        \"build(): internal error: missing fields for best file \" + pf,\n        { ignorable: true, best }\n      )\n    }\n\n    const fits = fitSizes(best as Dimensions, best.mimetype)\n\n    return {\n      assetId: best.assetId!,\n      assetFileId: best.id!,\n      uri,\n      uris: this.assetFiles.map(ea => ea.uri),\n      path: pf.nativePath,\n      mtime,\n      filesize,\n      width,\n      height,\n      sha,\n      mimetype,\n      fitSizes: fits.map(([, ea]) => ea.name).join(\",\"),\n      sqWidths: compact(ImageSize.sq().map(ea => ea.outputSize(best)?.width)),\n      fitWidths: fits.map(([ea]) => ea.width)\n    }\n  }\n\n  private async priorIfValid_(\n    best: PreviewAssetFile,\n    info: AssetPreviewInfo\n  ): PromiseMaybe<AssetPreviewInfo> {\n    if (this.ctx.forceSync || this.ctx.forceRebuildPreviews) return\n    // Make sure we fetch the latest json with .refresh():\n    const priorInfo = await this.ap.readInfo.refresh()\n    if (priorInfo != null) {\n      if (priorInfo.assetId !== info.assetId) {\n        throw new InternalError(\n          \"priorIfValid_(): mismatched asset IDs for \" +\n            best +\n            \": \" +\n            stringify({ priorInfo, info })\n        )\n      }\n      const priorFits = priorInfo.fitSizes.split(\",\")\n      const currFits = info.fitSizes.split(\",\")\n\n      if (\n        priorInfo.sha != null &&\n        priorInfo.sha === info.sha &&\n        priorInfo.rotation === info.rotation &&\n        equivalentFitSizes(priorFits, currFits)\n      ) {\n        // This is a no-op as far as the previews are concerned, but in order to\n        // be deterministic, we should change the metadata to make it point to\n        // (possibly) the library version.\n\n        const fits = fitSizes(best as Dimensions, best.mimetype)\n\n        // Are there previews that were orphaned?\n        const leftovers = diff(priorFits, currFits)\n        if (isNotEmpty(leftovers)) {\n          this.logger.info(\n            \"priorIfValid_(): removing previews that aren't required anymore.\",\n            { leftovers }\n          )\n          for (const fitname of leftovers) {\n            const fitsize = fits.find(([, ea]) => ea.name === fitname)\n            if (fitsize == null) {\n              this.logger.warn(\n                \"priorIfValid_(): Failed to clean up: missing fit size\",\n                { fitsize, fits }\n              )\n            } else {\n              const victim = this.ap.fileForWidth(\n                fitsize[1].reducer.name,\n                fitsize[0].width\n              )\n              this.logger.debug(\n                \"priorIfValid_(): unlinking unwanted preview \" + victim,\n                { fitsize }\n              )\n              await victim.unlink(\"warn\")\n            }\n          }\n        }\n\n        this.logger.debug(\n          \"priorIfValid_(): SHA and rotation match, and previews exist.\",\n          {\n            info,\n            priorInfo\n          }\n        )\n        await this.ap.writeInfo(info)\n        return info\n      }\n    }\n    return\n  }\n\n  private async _build(\n    srcFile: PosixFile,\n    best: PreviewAssetFile\n  ): Promise<AssetPreviewInfo> {\n    this.logger.info(\"_build(\" + srcFile + \")\", { uri: best.uri })\n\n    const info = await this.infoForBest_(srcFile, best)\n\n    // Is the prior preview sufficient?\n    const prior = await this.priorIfValid_(best, info)\n    if (prior != null) return prior\n\n    // By rebuilding all sizes we ensure all the previews are from the same\n    // source (especially noticeable with assets are rotated!)\n\n    const pe = new PushProgressObserver(\n      { path: srcFile.nativePath, op: \"Building previews\" },\n      ImageSize.sq().length + ImageSize.fit().length\n    )\n\n    this.logger.debug(\"Rebuilding all previews from \" + best.uri, {\n      assetId: best.assetId,\n      info\n    })\n\n    if (null == (await this.ap.parent.mkdirp())) {\n      throw new Error(\n        \"build(): Failed to create previews directory, \" +\n          this.ap.parent +\n          \" for \" +\n          best\n      )\n    }\n\n    // It'd be easier to remove these files now, but it means there aren't\n    // previews available while we rebuild them, and that makes the UI 404.\n    // We'll delete them after we finish rebuilding the previews.\n    const priorExistingFiles = await this.ap.existingFiles()\n\n    const origSharpReadable = await sharpReadable_({\n      src: srcFile,\n      minDim: ImageSize.largestFit().max\n    })\n    if (origSharpReadable == null) {\n      throw new WrappedError(\n        \"AssetPreviewBuilder.build(): \" +\n          best.uri +\n          \", \" +\n          srcFile.nativePath +\n          \", is not readable by sharp.\",\n        {\n          retriable: false\n        }\n      )\n    }\n\n    const origSharp = toSharp(origSharpReadable)\n    // TODO: should I restore this? DID IT WORK?\n    // const origSharp = await maybeApplyColorspace(pf, toSharp(origSharpReadable))\n\n    // videos are auto-rotated by Video.extractVideoFrame\n    if (\n      best.mimetype.startsWith(\"image/\") &&\n      !isHeifMimeType(best.mimetype) &&\n      best.rotation != null &&\n      best.rotation !== 0\n    ) {\n      origSharp.rotate(best.rotation) // we don't use auto-rotate.\n      this.logger.debug(\"build(): rotating \" + best.rotation + \"°\")\n    }\n\n    if (\n      isBaseFile(origSharpReadable) &&\n      origSharpReadable.desc.toLowerCase().includes(\"thumbnail\")\n    ) {\n      // JPEG thumbnails are regularly \"letterboxed\". Delete that:\n      try {\n        origSharp.trim(1)\n      } catch {\n        // don't care\n      }\n    }\n\n    const fits = fitSizes(best as Dimensions, best.mimetype)\n    // These are the thumbnail/preview images we're generating:\n    const files: PosixFile[] = []\n    // This is a subset of files, which should be tagged:\n    const previewTagFiles: PosixFile[] = []\n    let sqDim: Maybe<Dimensions> // = origDim\n    let sqSharp: Maybe<_sharp.Sharp> // = origSharp\n\n    // Pick the smallest fit size that's larger than the largest square:\n    const lsq = ImageSize.largestSq()\n    const bestFitNameForSq = leastBy(fits, ([outputSize, fit]) =>\n      map(lsq.outputSize(outputSize), () => fit.megapixels())\n    )?.[1].name\n\n    const origDim = pick(best, \"width\", \"height\") as Dimensions\n    {\n      let fitSharp = origSharp.clone()\n      let fitDim = origDim\n\n      for (const [outputSize, fit] of fits) {\n        const start = Date.now()\n        const inputDim = fitDim\n        const dest = this.ap\n          .fileForWidth(fit.reducer.name, outputSize.width)\n          .wip()\n        fitSharp = fit.resize(outputSize, fitSharp)\n        fitDim = outputSize\n\n        if (fit.name === bestFitNameForSq) {\n          sqSharp = fitSharp.clone()\n          sqDim = outputSize\n        }\n\n        if (\n          dmegapixels(outputSize) >= 1 &&\n          fit.reducer === Fit &&\n          Settings.includePreviewTags.valueOrDefault\n        ) {\n          previewTagFiles.push(dest)\n        }\n\n        await fit.toJpeg({\n          path: dest.nativePath,\n          sh: fitSharp,\n          outputSize\n        })\n        pe.onProgress()\n\n        this.logger.debug(\n          \"resize(\" +\n            fit.name +\n            \") \" +\n            fmtDim(inputDim) +\n            \" -> \" +\n            fmtDim(outputSize) +\n            \" in \" +\n            (Date.now() - start) +\n            \" ms\"\n        )\n        files.push(dest)\n      }\n    }\n\n    // sq\n    {\n      if (sqSharp == null) {\n        this.logger.debug(\"square resize(): resorting to \", {\n          origDim,\n          bestFitNameForSq\n        })\n        sqSharp = origSharp\n        sqDim = origDim\n      } else {\n        this.logger.debug(\"square resize(): using to \", {\n          sqDim,\n          bestFitNameForSq\n        })\n      }\n\n      let positioned = false\n\n      // We do square resizing synchronously to ensure the crop is consistent:\n\n      for (const sq of ImageSize.sq()) {\n        const start = Date.now()\n        const inputDim = sqDim!\n        const outputSize = sq.outputSize(sqDim ?? origDim)\n        if (outputSize == null) {\n          this.logger.debug(\"skipping square output for \" + sq.max)\n          continue\n        }\n\n        // Positioning the crop takes time, even if it's a no-op, so only do it if\n        // the input isn't square already.\n        if (!positioned) {\n          outputSize.position = Settings.squareThumbStrategy.valueOrDefault\n          positioned = true\n        }\n\n        this.logger.debug(\"Applying \", { outputSize })\n\n        const dest = this.ap\n          .fileForWidth(sq.reducer.name, outputSize.width)\n          .wip()\n\n        sq.resize(outputSize, sqSharp!)\n\n        sqDim = outputSize\n        await sq.toJpeg({\n          path: dest.nativePath,\n          sh: sqSharp!,\n          outputSize\n          // no srcFile, no need to embed previews for tiny squares.\n        })\n        pe.onProgress()\n        files.push(dest)\n        this.logger.debug(\n          \"resize(\" +\n            sq.name +\n            \") \" +\n            fmtDim(inputDim) +\n            \" -> \" +\n            fmtDim(outputSize) +\n            \" in \" +\n            (Date.now() - start) +\n            \" ms\"\n        )\n      }\n    }\n\n    try {\n      await includePreviewTags_(srcFile, previewTagFiles).catch(error => {\n        this.logger.warn(\n          \"Failed to restore metadata tags into previews for \" + srcFile,\n          {\n            error\n          }\n        )\n      })\n      // don't unlink just-unwipped files!\n      const oldPaths = new Set(priorExistingFiles.map(ea => ea.nativePath))\n      for (const ea of files) {\n        const unwipped = await ea.unwip_()\n        oldPaths.delete(unwipped.nativePath)\n      }\n      await unlink(oldPaths)\n      await this.ap.writeInfo(info)\n      this.logger.debug(\"Previews unwipped and info written\", { info })\n    } catch (cause) {\n      await unlink(files)\n      throw new WrappedError(\"Failed to create previews from \" + srcFile, {\n        cause,\n        path: srcFile.nativePath,\n        fatal: false\n      })\n    }\n    return info\n  }\n}\n","import { Downloadable } from \"../../fe/api/Asset\"\nimport { assetImgLink } from \"../../fe/AssetUrls\"\nimport { Dimensions, dimToSize, fmtDim } from \"../../fe/Dimensions\"\nimport { ReducerName, ReducerNames } from \"../../fe/ImageReducers\"\nimport { map2 } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0, toInt } from \"../../fe/Number\"\nimport { SizeDescription } from \"../../fe/Units\"\nimport { thenMap } from \"../async/Promise\"\nimport { extname } from \"../fs/Path\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { mkLogger } from \"../Logger\"\nimport { extractInt } from \"../Number\"\nimport { stripSuffix } from \"../String\"\nimport { dimensions } from \"./FileDimensions\"\n\nexport interface PreviewInfo {\n  file: PosixFile\n  assetId: number\n  reducer?: ReducerName\n  width?: number\n}\n\nconst epilog = mkLogger(\"extractPreviewInfo\")\n\nexport function extractPreviewInfo(\n  previewsRoot: PosixFile,\n  file: PosixFile\n): Maybe<PreviewInfo> {\n  // For \".photostructure/previews/000/000/21-sq-w480.jpg\"\n  const posixPath = file.posixPathFrom(previewsRoot)\n  // \"000/000/21-sq-w480.jpg\"\n  const arr = posixPath.replace(/\\//g, \"\").split(\"-\")\n  // [\"00000021\", \"sq\", \"w480.jpg\"]\n  const assetId = toInt(arr[0])\n  const reducer = ReducerNames.getCI(arr[1])\n  const width = extractInt(arr[2])\n  if (!gt0(assetId)) {\n    epilog.warn(\"Failed to extract preview info\", {\n      file,\n      previewsRoot,\n      arr,\n      assetId,\n      reducer,\n      width\n    })\n    return\n  } else {\n    return { file, assetId, reducer, width }\n  }\n}\n\nexport async function previewToDownloadable(\n  basename: string,\n  pi: PreviewInfo\n): PromiseMaybe<Downloadable> {\n  return map2(pi.assetId, pi.width, (assetId, width) =>\n    thenMap(dimensions(pi.file), d => {\n      const size = dimToSize(d)\n      const name = stripSuffix(basename, extname(basename))\n      return {\n        size,\n        basename: `${name}-${size}${pi.file.ext}`,\n        title: mkDownloadableTitle(pi.file, size, \"image\", d),\n        description: `Download ${size}`,\n        details: `(${fmtDim(d)} ${pi.file.ext})`,\n        href: assetImgLink({ assetId, reducer: ReducerNames.fit, width })\n      }\n    })\n  )\n}\n\nexport function mkDownloadableTitle(\n  f: PosixFile,\n  s: SizeDescription,\n  imageOrVideo: string,\n  d: Dimensions\n): string {\n  return `Download ${s} ${f.ext} ${imageOrVideo} (${fmtDim(d)})`\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { compact, isEmpty } from \"../../fe/Array\"\nimport {\n  assetImgAttrs,\n  assetImgLink,\n  assetSqImgAttrs\n} from \"../../fe/AssetUrls\"\nimport { ReducerName, ReducerNames } from \"../../fe/ImageReducers\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { StringValued, pick } from \"../../fe/Object\"\nimport { leftPad } from \"../../fe/Pad\"\nimport { ID, id2id } from \"../../fe/api/ID\"\nimport { greatestBy, leastBy } from \"../Array\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { splitEvery } from \"../String\"\nimport { sortByAsync } from \"../async/Promise\"\nimport { InternalErrorFlag } from \"../error/ErrorFlags\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { max } from \"../math/Vector\"\nimport { PreviewInfo, extractPreviewInfo } from \"./AssetPreviewInfo\"\n\n/**\n * Contents of the JSON metadata files stored alongside the previews:\n */\nexport interface AssetPreviewInfo {\n  assetId: number\n  assetFileId: number\n  uri: string\n  uris: string[]\n  path: string\n  mimetype: string\n  width: number\n  height: number\n  /**\n   * If filesize and maxStatMs matches, we can assume this metadata is still correct:\n   */\n  mtime: number\n  filesize: number\n  sha: string\n  rotation?: number\n  fitSizes: string\n  sqWidths: number[]\n  fitWidths: number[]\n}\n\nexport class AssetPreviews {\n  readonly logger: Logger\n  readonly assetId: number\n  readonly parent: PosixFile\n  readonly basename: string\n\n  constructor(\n    readonly previewsRoot: PosixFile,\n    id: number | ID\n  ) {\n    this.logger = mkLogger(\"AssetPreviews(assetId:\" + id2id(id) + \")\")\n    this.assetId = id2id(id)!\n    // To simplify debugging, we use the base-10 (rather, than, say, geohash\n    // radix encoded) ID in the path.\n\n    // MacOS finder and Windows Explorer crashes with folders > 1000, so that\n    // (ish) should be considered the largest allowable number of items in a\n    // given directory. dir_stat reads in chunks of 32k, so smaller than that is\n    // better.\n\n    // FAT and FAT32 maximum number of files on disk: 65,517\n\n    // As there will be ~10 files per image, we can have ~100 assets per\n    // directory\n\n    // See discussion:\n    // https://docs.google.com/document/d/1UzrntF9-gQhvmvKgecMI3Em623hsMP5iKBdkPHR5mC0/edit#heading=h.kyfjnq6c2j4i\n\n    // If we pad to 8 digits and split every 3 (assuming 99 million is an upper\n    // bound, which is ridiculously large), we get /000/000/01-fit-w480.jpg\n\n    // We could make this leftPad(5 or 8 or 11) based on the size of assetId,\n    // but let's just make this simple and only support assetIds < 100 million.\n    const paddedId = leftPad(this.assetId, 8, \"0\")\n    const assetPath = splitEvery(paddedId, 3)\n    // NOTE: make sure the \"-\" stays here, or else removeAll may remove other\n    // asset's files!\n    this.basename = assetPath.pop() + \"-\"\n    this.parent = previewsRoot.join(...assetPath)\n  }\n\n  parentNotExists() {\n    return this.parent.clear().notExists()\n  }\n\n  async existingFiles() {\n    return (\n      (await this.parent\n        .clear()\n        .childFiles(ea => ea.base.startsWith(this.basename))) ?? []\n    )\n  }\n\n  async existingJpgs() {\n    return (await this.existingFiles()).filter(ea => ea.ext === \".jpg\")\n  }\n\n  async #existingFilesWithInfo() {\n    const result = []\n    for (const ea of await this.existingFiles()) {\n      const info = extractPreviewInfo(this.previewsRoot, ea)\n      if (info != null) result.push(info)\n    }\n    return result\n  }\n\n  // Sorted by size ascending\n  async previewInfos(): Promise<PreviewInfo[]> {\n    return sortByAsync({\n      name: \"img.AssetPreviews.previews\",\n      arr: this.#existingFilesWithInfo(),\n      f: ea => ea?.file.size()\n    })\n  }\n\n  async deleteAll() {\n    const arr = await this.existingFiles()\n    if (arr.length > 20) {\n      throw new Error(\n        \"deleteAll(): rejected: > 20 existing files?!\" + InternalErrorFlag\n      )\n    }\n    for (const ea of arr) {\n      await ea.unlink()\n    }\n    return arr\n  }\n\n  fileForSuffix(suffix: string): PosixFile {\n    return this.parent.join(this.basename + suffix)\n  }\n\n  mp4(): PosixFile {\n    return this.fileForSuffix(\"video.mp4\")\n  }\n\n  infoJson(): PosixFile {\n    return this.fileForSuffix(\"info.json\")\n  }\n\n  readonly readInfo = lazy<PromiseMaybe<AssetPreviewInfo>>(() =>\n    // PERF: don't stat then read--just try to read.\n    this.infoJson().readJson<AssetPreviewInfo>(\"debug\")\n  )\n\n  writeInfo(info: AssetPreviewInfo): PromiseMaybe<PosixFile> {\n    this.readInfo.unset()\n    return this.infoJson().writeJson(\n      // make sure we only write out expected fields\n      pick(\n        info,\n        \"assetId\",\n        \"assetFileId\",\n        \"uri\",\n        \"uris\",\n        \"path\",\n        \"mimetype\",\n        \"width\",\n        \"height\",\n        \"mtime\",\n        \"filesize\",\n        \"sha\",\n        \"rotation\",\n        \"fitSizes\",\n        \"fitWidths\"\n      )\n    )\n  }\n\n  fileForWidth(reducer: ReducerName, width: number): PosixFile {\n    return this.fileForSuffix(reducer + \"-w\" + width + \".jpg\")\n  }\n\n  async filesForReducer(reducer: ReducerName): Promise<PosixFile[]> {\n    const prefix = this.basename + reducer + \"-\"\n    return this.logger.tap({\n      msg: \"filesForReducer(\" + reducer + \")\",\n      result: (await this.existingFiles()).filter(ea =>\n        ea.base.startsWith(prefix)\n      )\n    })\n  }\n\n  async smallestFileForReducer(reducer: ReducerName): PromiseMaybe<PosixFile> {\n    return leastBy(\n      await this.filesForReducer(reducer),\n      f => extractPreviewInfo(this.previewsRoot, f)?.width\n    )\n  }\n\n  async largestFileForReducer(reducer: ReducerName): PromiseMaybe<PosixFile> {\n    return greatestBy(\n      await this.filesForReducer(reducer),\n      f => extractPreviewInfo(this.previewsRoot, f)?.width\n    )\n  }\n\n  async widths(reducer: ReducerName): PromiseMaybe<number[]> {\n    const info = await this.readInfo()\n    const field = reducer === ReducerNames.sq ? \"sqWidths\" : \"fitWidths\"\n    const result = info?.[field]\n    if (!isEmpty(result)) return result\n\n    // We have to scan the filesystem to find the widths\n    const widths = compact(\n      (await this.previewInfos())\n        .filter(ea => ea.reducer === reducer)\n        .map(ea => ea.width)\n    )\n    if (info != null) {\n      info[field] = widths\n      await this.writeInfo(info)\n    }\n    return widths\n  }\n\n  async posterLink(): Promise<string> {\n    const widths = await this.widths(ReducerNames.fit)\n    return assetImgLink({\n      assetId: this.assetId,\n      reducer: ReducerNames.fit,\n      width: max(widths)\n    })\n  }\n\n  /**\n   * @param stat if true, always look at the filesystem\n   */\n  async imgAttrs(\n    reducer: ReducerName,\n    stat = false,\n    lazyLoad = true\n  ): Promise<StringValued> {\n    if (!stat && reducer === ReducerNames.sq) {\n      return assetSqImgAttrs({ assetId: this.assetId, lazyLoad })\n    } else {\n      const info =\n        reducer === ReducerNames.fit ? await this.readInfo() : undefined\n      return assetImgAttrs({\n        assetId: this.assetId,\n        reducer,\n        widths: await this.widths(reducer),\n        lazyLoad,\n        af: info\n      })\n    }\n  }\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const CropStrategies = strEnum(\"center\", \"entropy\", \"attention\")\nexport type CropStrategy = StrEnumKeys<typeof CropStrategies>\n","import sharp from \"sharp\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { rgb2labArray } from \"../color/Colorspace\"\n\n// From https://github.com/btd/sharp-phash/blob/master/index.js\n\nconst SAMPLE_SIZE = 32\n\nfunction initSQRT(len: number) {\n  const c = new Array(len)\n  for (let i = 1; i < len; i++) {\n    c[i] = 1\n  }\n  c[0] = 1 / Math.sqrt(2.0)\n  return c\n}\n\nconst SQRT = initSQRT(SAMPLE_SIZE)\n\nfunction initCOS(len: number) {\n  const cosines = new Array(len)\n  for (let k = 0; k < len; k++) {\n    cosines[k] = new Array(len)\n    for (let n = 0; n < len; n++) {\n      cosines[k][n] = Math.cos(((2 * k + 1) / (2 * len)) * n * Math.PI)\n    }\n  }\n  return cosines\n}\n\nconst COS = initCOS(SAMPLE_SIZE)\n\nfunction applyDCT(matrix: number[][], size: number) {\n  const N = size\n\n  const F = new Array(N)\n  for (let u = 0; u < N; u++) {\n    F[u] = new Array(N)\n    for (let v = 0; v < N; v++) {\n      let sum = 0\n      for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n          sum += COS[i][u] * COS[j][v] * matrix[i][j]\n        }\n      }\n      sum *= (SQRT[u] * SQRT[v]) / 4\n      F[u][v] = sum\n    }\n  }\n  return F\n}\n\nconst LOW_SIZE = 8\n\nexport async function dctHash(img: sharp.Sharp): Promise<(0 | 1)[]> {\n  return dctPixels(\n    await img\n      .greyscale()\n      .resize({ width: SAMPLE_SIZE, height: SAMPLE_SIZE, fit: sharp.fit.fill })\n      .raw()\n      .toBuffer()\n  )\n}\n\nexport async function dctHashCIELAB(img: sharp.Sharp): Promise<(0 | 1)[]> {\n  const rgb = await img\n    .resize({ width: SAMPLE_SIZE, height: SAMPLE_SIZE, fit: sharp.fit.fill })\n    .raw()\n    .toBuffer()\n  const lab = rgb2labArray(rgb)\n  return flatten(lab.map(dctPixels))\n}\n\nexport function dctPixels(pixels: Buffer | number[]): (0 | 1)[] {\n  // copy signal\n  const s: number[][] = new Array(SAMPLE_SIZE)\n  for (let x = 0; x < SAMPLE_SIZE; x++) {\n    s[x] = new Array(SAMPLE_SIZE)\n    for (let y = 0; y < SAMPLE_SIZE; y++) {\n      s[x][y] = pixels[SAMPLE_SIZE * y + x]\n    }\n  }\n\n  // apply 2D DCT II\n  const dct = applyDCT(s, SAMPLE_SIZE)\n\n  // get AVG on high frequencies\n  let totalSum = 0\n  for (let x = 0; x < LOW_SIZE; x++) {\n    for (let y = 0; y < LOW_SIZE; y++) {\n      totalSum += dct[x + 1][y + 1]\n    }\n  }\n\n  const avg = totalSum / (LOW_SIZE * LOW_SIZE)\n\n  // compute hash\n  const result: (0 | 1)[] = [] // not new Array(): we're just using push().\n\n  for (let x = 0; x < LOW_SIZE; x++) {\n    for (let y = 0; y < LOW_SIZE; y++) {\n      result.push(dct[x + 1][y + 1] > avg ? 1 : 0)\n    }\n  }\n\n  return result\n}\n","import { compact } from \"../../fe/Array\"\nimport { Dimensions, dmegapixels } from \"../../fe/Dimensions\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, lt, lte, sigFigs, toInt } from \"../../fe/Number\"\nimport { Rotation, Rotations } from \"../../fe/Rotation\"\nimport { toS } from \"../../fe/toS\"\nimport { ExifTags } from \"../tags/ExifTags\"\nimport { roundAspectRatio } from \"./Ratio\"\n\nexport function tmegapixels(t: ExifTags) {\n  if (t.dimensions != null) return dmegapixels(t.dimensions)\n  if (gt0(t.Megapixels)) return t.Megapixels\n  return\n}\n\n/**\n * @return true if `lhs` is wholly contained by `rhs`.\n */\nexport function ltBoth(lhs: Partial<Dimensions>, rhs: Partial<Dimensions>) {\n  return lt(lhs.width, rhs.width) && lt(lhs.height, rhs.height)\n}\n\n/**\n * @return true if `lhs` is wholly contained by `rhs`.\n */\nexport function lteBoth(lhs: Partial<Dimensions>, rhs: Partial<Dimensions>) {\n  return lte(lhs?.width, rhs?.width) && lte(lhs?.height, rhs?.height)\n}\n\n/**\n * @return true if `lhs` is wholly contained by `rhs`.\n */\nexport function ltEither(lhs: Partial<Dimensions>, rhs: Partial<Dimensions>) {\n  return lt(lhs.width, rhs.width) || lt(lhs.height, rhs.height)\n}\n\nexport function parseDimensions(s: Maybe<string>): Maybe<Dimensions> {\n  const arr = compact(\n    toS(s)\n      .split(/[x×]/)\n      .map(ea => toInt(ea))\n  )\n  return arr.length === 2 ? { width: arr[0], height: arr[1] } : undefined\n}\n\nexport function fitToResolution(\n  dim: Dimensions,\n  pixelCount: number\n): Dimensions {\n  if (dim.width * dim.height <= pixelCount) return dim\n  const aspect_ratio = dim.width / dim.height\n  const widthF = Math.round(Math.sqrt(pixelCount * aspect_ratio))\n  return {\n    width: widthF,\n    height: Math.round(widthF / aspect_ratio)\n  }\n}\n\nexport function aspectRatio(\n  d: Maybe<Partial<Dimensions>>,\n  thresh?: number\n): Maybe<number> {\n  return d != null && gt0(d.width) && gt0(d.height)\n    ? sigFigs(roundAspectRatio(d.width / d.height, thresh), 3)\n    : undefined\n}\n\nexport function rotateDimensions(d: Dimensions, r: Rotation): Dimensions {\n  return r === 0 || r === 180 ? d : { width: d.height, height: d.width }\n}\n\nexport function validRotations(\n  src: Dimensions,\n  dest: Dimensions,\n  thresh = 0.2\n): Rotation[] {\n  const targetRatio = aspectRatio(src, thresh)\n  return targetRatio == null\n    ? []\n    : Rotations.filter(\n        r => aspectRatio(rotateDimensions(dest, r), thresh) === targetRatio\n      )\n}\n","import { Sharp } from \"sharp\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Dimensions } from \"../../fe/Dimensions\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { map2Numeric } from \"../../fe/Number\"\nimport { mkLogger } from \"../Logger\"\nimport { thenMap } from \"../async/Promise\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { extractSizeInfoFromFile } from \"../tags/SizeInfo\"\nimport { isSharp } from \"./Sharp\"\n\nconst logger = lazy(() => mkLogger(\"img.FileDimensions\"))\n\nexport async function dimensions(\n  file: Maybe<PosixFile | string | Sharp>\n): PromiseMaybe<Dimensions> {\n  try {\n    if (file == null) return\n    if (isSharp(file)) {\n      const m = await file.metadata()\n      return map2Numeric(m.width, m.height, (width, height) => ({\n        width,\n        height\n      }))\n    } else {\n      return thenMap(extractSizeInfoFromFile(file), ea => ({\n        width: ea.ImageWidth,\n        height: ea.ImageHeight\n      }))\n    }\n  } catch (error) {\n    logger().warn(\"dimensions() failed\", { error })\n    return\n  }\n}\n","import { compactBlanks, includesAll } from \"../../fe/Array\"\nimport { Dimensions, dmegapixels } from \"../../fe/Dimensions\"\nimport { isMimeTypeSupportedByBrowser } from \"../tags/MimeTypes\"\nimport { ImageSize } from \"./ImageSize\"\nimport { OutputSize } from \"./Reducers\"\n\n// For tag galleries, we always want the littlest sizes:\nconst FitAlways = [ImageSize.QVGA, ImageSize.QQVGA]\n\n/**\n * @param dim is final, post-rotated dimension (the caller must flip if rotation\n * is 90 or 270)\n */\nexport function fitSizes(\n  dim: Dimensions,\n  mimetype: string\n): [OutputSize, ImageSize][] {\n  const sizes = ImageSize.fit()\n\n  const results: [OutputSize, ImageSize][] = []\n  let smallestDim = isMimeTypeSupportedByBrowser(mimetype) ? dim : undefined\n\n  for (let idx = 0; idx < sizes.length; idx++) {\n    const size = sizes[idx]\n    const d = size.outputSize(dim)\n    if (d == null) continue\n\n    // The goal here is to generate the \"correct\" number of thumbnails: we\n    // want to avoid too many different resolutions (which would waste disk\n    // space), and at the same time, we want to be efficient with network\n    // bandwidth (which would prefer lots of different resolutions).\n    const keep =\n      smallestDim == null ||\n      FitAlways.includes(size) ||\n      dmegapixels(smallestDim) / dmegapixels(d) > 3 ||\n      dmegapixels(d) - dmegapixels(smallestDim) > 2.5\n\n    if (keep) {\n      smallestDim = d\n      results.push([d, size])\n    }\n  }\n  return results\n}\n\nfunction old2new(s: string) {\n  // Unfortunately, prior v0.3.8 encoded wvga as qhd, and wvgap as qhdp.\n  // As of v0.6.0, portrait sizes went away.\n  if (s === \"qhd\") return \"wvga\"\n  if (s === \"uhd\") return \"uhd4k\"\n  return s\n}\n\nexport function equivalentFitSizes(\n  oldArr: string[],\n  newArr: string[]\n): boolean {\n  return includesAll(\n    compactBlanks(oldArr).map(old2new),\n    compactBlanks(newArr).map(old2new)\n  )\n}\n","import { blank, toNotBlank } from \"../../fe/Blank\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { lazy } from \"../Lazy\"\nimport { mkLogger } from \"../Logger\"\nimport { hasApt, osNameMac } from \"../OperatingSystem\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { ee } from \"../event/EventEmitter\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { aptInstalledVersion } from \"../platform/Apt\"\nimport { isMac } from \"../platform/Platform\"\nimport { Settings } from \"../settings/Settings\"\nimport { heif2png_, heifConvertPath } from \"./HeifConvert\"\nimport { ToolDetails } from \"./ToolDetails\"\nimport { sips2jpeg_, sipsPath } from \"./sips\"\n\nconst logger = lazy(() => mkLogger(\"img.Heif\"))\n\nexport const getHeifSupportDetails = lazy<PromiseMaybe<ToolDetails>>(\n  async () => {\n    try {\n      if (isMac) {\n        try {\n          const path = await sipsPath()\n          if (!blank(path)) {\n            return { path, version: osNameMac(), isSupportedVersion: true }\n          }\n        } catch (err) {\n          logger().warn(\n            \"Failed to find the sips tool (either in PATH or /usr/bin).\",\n            err\n          )\n        }\n      }\n\n      const nativePath = await heifConvertPath()\n      if (blank(nativePath)) {\n        logger().warn(\"Failed to find heif-convert\", {\n          heifConvertPath: Settings.heifConvertPath.valueOrDefault\n        })\n        return\n      } else {\n        let errs = \"\"\n        const output = await stdout_(nativePath, [], {\n          timeoutMs: ShortCommandTimeoutMs,\n          quiet: true,\n          ignoreExitCode: true, // help message returns 5\n          isIgnorableError: err => {\n            errs += err.message\n            return true\n          }\n        })\n        let version = extractHeifConvertVersion(output + errs)\n\n        if (blank(version) && hasApt()) {\n          const pkgs = await aptInstalledVersion(nativePath)\n          version = pkgs?.find(ea => ea.pkg === \"libheif-examples\")?.version\n        }\n\n        return {\n          path: nativePath,\n          version: toNotBlank(version) ?? \"(unknown)\",\n          isSupportedVersion: true // TODO: should we not support older versions?\n        }\n      }\n    } catch (error) {\n      logger().warn(\"Failed to get heif-convert tool details\", { error })\n      return\n    }\n  }\n)\n\nexport function extractHeifConvertVersion(helptext: string): Maybe<string> {\n  // version 1.14 and later will emit version information to stderr:\n\n  // $ heif-convert.exe\n  // heif-convert  libheif version: 1.14.0\n  // -------------------------------------------\n  // Usage: heif-convert [options]  <input-image> <output-image>\n\n  // The program determines the output file format from the output filename suffix.\n  // These suffices are recognized: jpg, jpeg, png, y4m.\n  // Options:\n  //  -h, --help              show help\n  //  -q, --quality           quality (for JPEG output)\n  //      --with-aux          also write auxiliary images (e.g. depth images)\n  //      --with-xmp          write XMP metadata to file (output filename with .xmp suffix)\n  //      --with-exif         write EXIF metadata to file (output filename with .exif suffix)\n  //      --skip-exif-offset  skip EXIF metadata offset bytes\n  //      --no-colons         replace ':' characters in auxiliary image filenames with '_'\n  //      --quiet             do not output status messages to console\n\n  // Versions before 1.14:\n\n  // USAGE: heif-convert [-q quality 0..100] <filename> <output>\n\n  return toS(helptext).match(\n    /(?:heif-convert|libheif)\\s+version[^\\d.]*(?<version>[\\d.]{5,})/i\n  )?.groups?.version\n}\n\nexport async function isHeifSupported(): Promise<boolean> {\n  return (await getHeifSupportDetails())?.isSupportedVersion === true\n}\n\n/**\n * Converts the given HEIF to either a JPEG or PNG, depending on the platform\n */\nexport async function heif2img(src: PosixFile) {\n  if (isMac) {\n    return sips2jpeg_(src)\n  } else if (await isHeifSupported()) {\n    return heif2png_(src)\n  } else {\n    logger().throw(\"HEIF support is missing\", {\n      src: src.nativePath\n    })\n    return\n  }\n}\n\nlater(() => ee().on(\"clearCache\", () => getHeifSupportDetails.unset()))\n","import { lazy } from \"../../core/Lazy\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { KB } from \"../../fe/Units\"\nimport { mkLogger } from \"../Logger\"\nimport { stdoutResult_ } from \"../child/ChildProcess\"\nimport { ee } from \"../event/EventEmitter\"\nimport { pathTo } from \"../fs/PathTo\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { Settings } from \"../settings/Settings\"\nimport { dimensions } from \"./FileDimensions\"\nimport { withImageCache_ } from \"./ImageCache\"\n\nconst logger = lazy(() => mkLogger(\"img.HeifConvert\"))\n\nexport const heifConvertPath = lazy(async () => {\n  const result = logger().tap({\n    msg: \"heifConvertPath\",\n    result: await pathTo({\n      tool: \"heif-convert\",\n      alternativePath: Settings.heifConvertPath.valueOrDefault\n    })\n  })\n  // They may install heif-convert after we check. If it's missing, try again in a minute:\n  heifConvertPath.setTTL(result == null ? minuteMs : undefined)\n  return result\n})\n\nfunction clearCache() {\n  heifConvertPath.unset()\n}\n\nlater(() => {\n  ee().on(\"clearCache\", clearCache)\n  ee().on(\"clearToolCache\", clearCache)\n})\n\nexport async function isHeifConvertSupported() {\n  return notBlank(await heifConvertPath())\n}\n\n/**\n * Returns a file holding the binary stream associated to the given tag.\n * Orientation is copied from the src to the result.\n */\nexport async function heif2png_(src: PosixFile): PromiseMaybe<PosixFile> {\n  if (!(await isHeifConvertSupported())) return\n  const dims = await dimensions(src)\n  if (dims == null) {\n    logger().throw(\"heif2png_() failed: no dimensions for \" + src)\n  }\n\n  // PNG (vs JPG) IS A BUG WORKAROUND FOR\n  // https://forum.photostructure.com/t/incorrectly-rotated-heic-images/34/15?u=mrm\n\n  return withImageCache_(src, \"heif\", \".png\", dest => _heif2png_(src, dest))\n}\n\nasync function _heif2png_(src: PosixFile, dest: PosixFile) {\n  try {\n    await stdoutResult_(\n      Settings.heifConvertPath.valueOrDefault,\n      [\n        // No need to specify quality: the output is a lossless PNG.\n        // \"-q\",\n        // String(Settings.previewQuality.valueOrDefault),\n        src.nativePath,\n        // heif-convert does TERRIBLE things to the output path.\n        dest.base\n      ],\n      {\n        cwd: dest.dir,\n        timeoutMs: minuteMs, // should only take a couple seconds\n        ignoreStderr: true // heif-convert may grump about \"Can't open -urn:com:apple:photo:2020:aux:hdrgainmap.WIP-heif.png: Invalid argument\\ncould not write auxiliary image\"\n      }\n    )\n    if (await dest.clear().isEmptyFile(KB)) {\n      logger().throw(\"heif2png_() failed: empty output\", { src, dest })\n    }\n  } catch (error) {\n    logger().throw(\"heif2png() failed\", { error, src: src.nativePath })\n  }\n}\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\n\nconst HeifMimeTypeRE = /^image\\/hei[fc]$/i\n\nexport function isHeifMimeType(mimetype: Maybe<string>) {\n  return !blank(mimetype) && HeifMimeTypeRE.test(toS(mimetype))\n}\n","import { rm } from \"fs/promises\"\nimport { lazy } from \"../../core/Lazy\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { isProd, isTest } from \"../NodeEnv\"\nimport { ensurePrefix, splitEvery } from \"../String\"\nimport { shortFsStringSha } from \"../StringHash\"\nimport { ciSafePath } from \"../ciSafePath\"\nimport { cacheDir_ } from \"../dir/CacheDir\"\nimport { getDevEnvFlag } from \"../env/DevEnvFlags\"\nimport { ee } from \"../event/EventEmitter\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFile, basename } from \"../fs/SimpleFile\"\nimport { TokenRadix } from \"../math/Radix\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\n\nconst logger = lazy(() => mkLogger(\"img.ImgCache\"))\n\nexport const ImageCacheName = \"image-cache\"\n// NOTE: sync service is in charge of cleaning cacheDir. See `setup()`.\n\n/**\n * @throws if imgCacheDir cannot be created.\n */\nexport const imageCacheDir_ = lazy(() => {\n  watchCacheDir()\n  return PosixFile.for(cacheDir_()).join(ImageCacheName).mkdirp_()\n})\n\nconst watchCacheDir = lazy(() => {\n  cacheDir_.watchLater(() => imageCacheDir_.unset())\n})\n\nexport async function rmImageCacheDir() {\n  if (isProd) throw new Error(\"rmImgCacheDir is for tests\")\n  for (const ea of toA(await (await imageCacheDir_()).clear().children())) {\n    await rm(ea.nativePath, {\n      recursive: ea.isDirectorySync(),\n      maxRetries: 32,\n      retryDelay: 250,\n      force: true\n    })\n  }\n  ee().emit(\"fileChanged\")\n  ee().emit(\"clearCache\")\n}\n\nfunction imgCacheSubdir(src: PosixFile): string[] {\n  // Ideally, we'd use the file SHA, but that's expensive, so use a less stable but cheaper hash that includes filesize and mtime:\n  const s = src.statSync({ refresh: true })\n\n  // We're SHA'ing the JSON to avoid name collisions with files that end with\n  // a file size (! highly unlikely)\n  const sha = shortFsStringSha(\n    JSON.stringify({\n      // we have to use baseWithGrandparent for tests (as SharpReadable.spec\n      // uses these paths!)\n      np: isTest ? ciSafePath(src) : src.nativePath,\n      size: s?.size,\n      mtime: isTest ? 0 : s?.mtime // < make tests deterministic\n    }),\n    24\n  )\n\n  // Truncated to 24 to hopefully avoid max path issues on windows: (linux\n  // kernel has to truncate to 15 chars (64 bits) to avoid collisions, so 24\n  // at base32 (120 bits) should be fine). we could probably get away with\n  // dropping all the files directly into the imgtmp dir because they have to\n  // be cleaned up, but having 2-deep directories (1024 * 1024) should cover\n  // at least an hour of processing:\n\n  return splitEvery(sha.slice(0, 24), 2, 3)\n}\n\n/**\n * Random tempfile for easy-to-produce image caching.\n *\n * DON'T USE FOR RAW! use cachedImgFile_() instead!\n */\nexport async function tmpImageFile_(args: {\n  src: SimpleFile\n  tag: string\n  ext: string\n}): Promise<PosixFile> {\n  const dir = await imageCacheDir_()\n  const result = getDevEnvFlag(\"PS_NO_RANDOM_IMAGE_CACHE\")\n    ? // path needs to be predictable for tests\n      dir.join(\n        \"tmp\",\n        basename(args.src.dir).normalize(),\n        args.src.name.normalize(),\n        args.tag + args.ext\n      )\n    : dir.join(\n        \"tmp-\" + TokenRadix.randomChars(2),\n        TokenRadix.randomChars(16) + toS(args.ext)\n      )\n  await result.parent().mkdirp_()\n  return result\n}\n\n/**\n * @throws on error\n */\nexport async function cachedImageFile_(\n  src: PosixFile,\n  desc?: string,\n  ext?: string\n): Promise<PosixFile> {\n  const dir = await imageCacheDir_()\n\n  desc ??= src.name\n  ext = ensurePrefix(ext ?? src.ext, \".\")\n\n  const parent = dir.join(...imgCacheSubdir(src))\n  await parent.mkdirp_()\n  // make sure we don't prematurely delete the parent cache dir.\n\n  // note: we don't need to touch the whole directory ancestry: we just need to\n  // touch the parent (grandparents will then not be empty)\n\n  // we're using utimes() here instead of touch() to avoid the extra call to\n  // ensureExists():\n  await parent.utimes()\n\n  const result = parent.join(desc + ext)\n\n  logger().debug(\"cachedImgFile(\" + src.baseWithGrandparent + \")\", {\n    desc,\n    ext,\n    result\n  })\n  return result\n}\n\n/**\n * Only applies the readable thunk if the tmpfile doesn't already exist.\n *\n * @throws if f() has issues generating a readable, or the readable has errors\n * during stream.\n */\nexport async function readableToFile_({\n  src,\n  desc,\n  suffix,\n  f\n}: {\n  src: PosixFile\n  desc: string\n  suffix: string\n  f: (destination: PosixFile) => Promise<void>\n}): PromiseMaybe<PosixFile> {\n  const dest = await cachedImageFile_(src, desc, suffix)\n  return dest.applyIfEmpty_({ fn_: f, timeoutMs: 2 * minuteMs })\n}\n\n/** Only applies the thunk if the tmpfile doesn't already exist */\nexport async function withImageCache_(\n  src: PosixFile,\n  desc: string,\n  ext: string,\n  applyIfEmpty_: (dest: PosixFile) => Promise<any>\n): Promise<PosixFile> {\n  try {\n    const dest = await cachedImageFile_(src, desc, ext)\n    await dest.applyIfEmpty_({\n      fn_: applyIfEmpty_,\n      skipFsLock: false,\n      skipWip: false,\n      timeoutMs: commandTimeoutMs(),\n      minSizeBytes: 256,\n      dirty: true // It's ok to leave the fslock directories. They'll get cleaned up later. Speedy finishes SharpReadable.spec in 40s with dirty, 55s with !dirty.\n    })\n    return dest\n  } catch (error) {\n    return logger().throw(\"withImgCache_() failed\", {\n      error,\n      src: src.nativePath,\n      desc,\n      ext\n    })\n  }\n}\n","import _sharp from \"sharp\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { dmegapixels } from \"../../fe/Dimensions\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { time } from \"../async/PromiseTimer\"\nimport { rgb2labTriplets } from \"../color/Colorspace\"\nimport { DominantColor } from \"../color/DominantColor\"\nimport { extractDominantColors } from \"../color/DominantColors\"\nimport { labsAreGreyscale } from \"../color/Lab\"\nimport { isModeData, omitModeData, WithModeData } from \"../color/ModeData\"\nimport { isEnvTrue } from \"../env/GetEnv\"\nimport { DoNotSendErrorFlag, NonFatalErrorFlag } from \"../error/ErrorFlags\"\nimport { FileCache } from \"../fs/FileCache\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFile, toNativePath_ } from \"../fs/SimpleFile\"\nimport { mkLogger } from \"../Logger\"\nimport { b64encodeBits } from \"../math/b64\"\nimport { Settings } from \"../settings/Settings\"\nimport { shim1 } from \"../Shim1\"\nimport { isVideoMimeType, normalizeMimetype } from \"../tags/MimeTypes\"\nimport { extractSizeInfoFromFile, SizeInfo } from \"../tags/SizeInfo\"\nimport { dctHash, dctHashCIELAB } from \"./DCTHash\"\nimport { fitToResolution } from \"./Dimensions\"\nimport { meanDiffHash, meanDiffHashCIELAB } from \"./MeanDiffHash\"\nimport {\n  DescribedSharpReadable,\n  sharpReadable_,\n  toSharp\n} from \"./SharpReadable\"\n\n// https://datascience.stackexchange.com/questions/48642/how-to-measure-the-similarity-between-two-images\n\n// Research later: https://erdogant.github.io/undouble/pages/html/hash_functions.html\n\nexport interface ImageHash {\n  mimetype: string\n\n  /**\n   * b64 8x8 L*a*b* triplet ahash\n   */\n  meanHash: string\n  dctHash: string\n  diffHash: string\n\n  dominantColors: DominantColor[]\n  dominantColorsDescription?: string\n  dominantColorScore?: number\n\n  /** width of original image */\n  width: number\n  /** height of original image */\n  height: number\n  /** is the original image greyscale? */\n  isGreyscale: boolean // asset files don't have this\n\n  /** is the image on disk rotated by metadata? */\n  rotation: number\n}\n\n/**\n * How many bits-wide values can be bit-concatted into a single value?\n */\nexport function maxPerBits(bits: number): number {\n  // We don't want to overflow Javascript numbers, hence the 52:\n  return Math.floor(52 / bits)\n}\n\nconst logger = lazy(() => mkLogger(\"img.ImageHash\"))\n\n/**\n * Image fingerprint to find duplicate images (so strive for no false\n * positives).\n *\n * May match against global exposure changes.\n *\n * Does not need to match cropping or free rotations.\n *\n * Moving the pixels to L*a*b* means we can pick bin to perceptual ranges.\n */\nexport async function imageHash(\n  f: string | SimpleFile\n): Promise<Maybe<ImageHash>> {\n  try {\n    return await imageHash_(toNativePath_(f))\n  } catch (err) {\n    logger().warn(\"imageHash() failed for \" + f, err)\n    return\n  }\n}\n\nconst cache = lazy(\n  () =>\n    new FileCache<Maybe<ImageHash>>({\n      name: \"img.imageHash\",\n      timeoutMs: minuteMs\n    })\n)\n\nexport const imageHash_ = shim1({\n  name: \"img.imageHash\",\n  cache,\n  impl: _imageHash_\n})\n\nexport async function _imageHash_(nativePath: string): Promise<ImageHash> {\n  const file = PosixFile.for(nativePath)\n\n  const sizeInfo = await extractSizeInfoFromFile(file)\n  if (sizeInfo == null) {\n    throw new Error(\n      \"Failed to read dimensions for \" +\n        nativePath +\n        NonFatalErrorFlag +\n        DoNotSendErrorFlag\n    )\n  }\n\n  const minDim = fitToResolution(\n    sizeInfo.dimensions,\n    Math.round(Settings.dominantColorPixels.valueOrDefault)\n  )\n\n  // Don't count sharp-readable time inside the image-hash time!\n  const readable = await sharpReadable_({ src: file, minDim })\n  return time(`img.imageHash`, () => __imageHash_({ file, readable, sizeInfo }))\n}\n\nexport function isImageHash(o: any): o is ImageHash {\n  return (\n    o != null &&\n    notBlank(o.meanHash) &&\n    notBlank(o.mimetype) &&\n    isNotEmpty(o.dominantColors) // < prevents empty dominant color array from \"matching\"\n    // isGreyscale is optional\n  )\n}\n\nexport type ImageHashish =\n  | ImageHash\n  | (Omit<ImageHash, \"dominantColors\"> & WithModeData)\n\nexport function toImageHash(ih: Maybe<ImageHashish>): Maybe<ImageHash> {\n  if (ih == null) return\n  if (isImageHash(ih)) {\n    return ih\n  }\n  // The AssetFile model is stores the colors in columns:\n  if (isModeData(ih)) {\n    const result = {\n      ...omitModeData(ih),\n      dominantColors: DominantColor.fromModeData(ih)\n    }\n    if (isImageHash(result)) return result\n  }\n  return\n}\n\n// If this is 4, SyncService tests fail to validate against preview images:\nexport const HashDim = 8\n// larger values don't seem to impact accuracy:\n// meanHamm 3: { k: 18, avg: 0.962, min: 0.86, max: 1, sd: 0.05 }\n// meanHamm 4: { k: 18, avg: 0.968, min: 0.89, max: 1, sd: 0.04 }\n// meanHamm 5: { k: 18, avg: 0.963, min: 0.87, max: 1, sd: 0.03 },\n// meanHamm 6: { k: 18, avg: 0.958, min: 0.88, max: 1, sd: 0.04 },\n// meanHamm 7: { k: 18, avg: 0.945, min: 0.86, max: 1, sd: 0.04 }\n// meanHamm 8: { k: 18, avg: 0.959, min: 0.85, max: 1, sd: 0.04 },\n\n// Most EXIF thumbprints are 120x160, so less than that should be fine.\n// NOTE: smaller dimensions (like 48) cause panoramas to fail tests.\n\nasync function __imageHash_({\n  file,\n  readable,\n  sizeInfo\n}: {\n  file: PosixFile\n  readable: Maybe<DescribedSharpReadable>\n  sizeInfo: SizeInfo\n}): Promise<ImageHash> {\n  const l = mkLogger(\"ImageHash(\" + file + \")\")\n  if (readable == null) {\n    return l.throw(\"Cannot build readable stream\")\n  }\n\n  const s1dims = fitToResolution(\n    sizeInfo.dimensions,\n    Settings.dominantColorPixels.valueOrDefault\n  )\n\n  if (isEnvTrue(\"DEBUG_IMAGE_HASH\" as any)) {\n    const out = \"/tmp/image-hash-\" + file.base + \"-orig.jpg\"\n    await toSharp(readable).jpeg().toFile(out)\n    console.log({ out, readable })\n  }\n\n  let s1 = toSharp(readable)\n    // PNGs and TIFFs can have an alpha channel. We don't want that.\n    .removeAlpha()\n  // Some TIFFs and HEIFs are in a different colorspace. Normalize to sRGB.\n  // .toColorspace(\"srgb\")\n  // NOTE: DON'T NORMALIZE s1, it mucks up what the actual dominant colors are!\n\n  // Video frames will have been rotated for us already by ffmpeg.\n  if (!isVideoMimeType(readable.mimetype)) {\n    // Sharp doesn't do rotation correctly with raw images, so we have to be\n    // explicit with the rotation.\n    s1 = s1.rotate(sizeInfo.rotation)\n  }\n\n  if (dmegapixels(sizeInfo.dimensions) < 0.1) {\n    s1 = s1\n      // Some thumbnails have \"letterboxing\" (black bars) on the top and bottom. This won't be found on larger previews or original images.\n      .trim({ background: \"#000\", threshold: 0 })\n  }\n\n  s1 = s1.resize({\n    fit: _sharp.fit.outside,\n    ...s1dims,\n    withoutEnlargement: true\n  })\n\n  // _We_ have to do the RGB to L*a*b* conversion because raw() doesn't work:\n  // https://github.com/lovell/sharp/issues/681\n  const { data: rgb, info: rgbInfo } = await s1\n    .raw()\n    .toBuffer({ resolveWithObject: true })\n\n  if (isEnvTrue(\"DEBUG_IMAGE_HASH\" as any)) {\n    const out = \"/tmp/image-hash-\" + file.base + \"-\" + rgbInfo.width + \"w.jpg\"\n    await _sharp(rgb, { raw: { ...rgbInfo, channels: 3 } })\n      .jpeg()\n      .toFile(out)\n    console.log({ out, rgbInfo, readable })\n  }\n\n  const labTriplets = rgb2labTriplets(rgb)\n\n  const dc = extractDominantColors(labTriplets)\n\n  const isGreyscale = labsAreGreyscale(labTriplets)\n\n  const img = () => _sharp(rgb, { raw: { ...rgbInfo, channels: 3 } })\n\n  const meanDiff = await (isGreyscale ? meanDiffHash : meanDiffHashCIELAB)(\n    img()\n  )\n  const phashBits = await (isGreyscale ? dctHash : dctHashCIELAB)(img())\n\n  return {\n    meanHash: b64encodeBits(meanDiff.meanHash),\n    diffHash: b64encodeBits(meanDiff.diffHash),\n    dctHash: b64encodeBits(phashBits),\n    dominantColors: dc.dominantColors,\n    dominantColorsDescription: dc.description,\n    dominantColorScore: dc.dominantColorScore,\n\n    isGreyscale,\n    mimetype: normalizeMimetype(readable.mimetype),\n    ...sizeInfo.dimensions,\n    rotation: sizeInfo.rotation ?? 0\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { isEmpty, sum } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { isCloseAspectRatio, maybeDimSwap } from \"../../fe/Dimensions\"\nimport { andList } from \"../../fe/FmtList\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { clamp, gte, isNumber, lt, sigFigs } from \"../../fe/Number\"\nimport { pickCompact } from \"../../fe/Object\"\nimport { padding } from \"../../fe/Pad\"\nimport { MaybeReadonlyArray } from \"../../fe/Readonly\"\nimport { Rotation, Rotations } from \"../../fe/Rotation\"\nimport { greatestBy } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { hammRatioIntArrays, within } from \"../Number\"\nimport { closestLab } from \"../color/Colorspace\"\nimport { diffCIECorr } from \"../color/DeltaE\"\nimport { dominantColorCorrelation } from \"../color/DominantColorCorrelation\"\nimport { Triplet } from \"../color/Triplet\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { LogLevel } from \"../log/LogLevel\"\nimport { Average } from \"../math/Average\"\nimport { rotateSquareMatrix } from \"../math/SquareMatrix\"\nimport { avg } from \"../math/Vector\"\nimport { b64decode, b64encode } from \"../math/b64\"\nimport { Settings } from \"../settings/Settings\"\nimport { aspectRatio, validRotations } from \"./Dimensions\"\nimport {\n  HashDim,\n  ImageHashish,\n  imageHash,\n  isImageHash,\n  toImageHash\n} from \"./ImageHash\"\nimport { fmtAspectRatio } from \"./Ratio\"\n\nconst logger = lazy(() => mkLogger(\"img.ImageHashComparison\"))\n\nexport type ImageHashComparison = NonNullable<\n  ReturnType<typeof compareImageHashes>\n>\n\n// export interface ImageHashComparison {\n//   a: ImageHash\n//   b: ImageHash\n//   // rename these \"corr\" to \"coeff\"\n//   meanHashCorr: number\n//   // not set if images are rotated\n//   diffHashCorr?: number\n//   // not set if images are rotated\n//   dctHashCorr?: number\n//   minImageCorr: number\n//   imageCoeffDelta: number\n//   colorCorr: number\n//   minColorCorr: number\n//   colorCoeffDelta: number\n//   isGreyscale: boolean\n//   /**\n//    * How many degrees does `a` need to be rotated to match `b`?\n//    */\n//   aRotation: number\n//   aAspectRatio?: number\n//   bAspectRatio?: number\n//   isSimilar: boolean\n//   whyNotSimilar: Maybe<string>\n// }\n\nexport function isImageHashComparison(obj: any): obj is ImageHashComparison {\n  return (\n    obj != null &&\n    isImageHash(obj.a) &&\n    isImageHash(obj.b) &&\n    [obj.imageCorr, obj.colorCorr, obj.aRotation].every(isNumber)\n  )\n}\n\n/** @return 1 for full color correlation, 0 for no color correlation */\nexport function labsCorr2(a: Triplet[], b: Triplet[]) {\n  const diffs =\n    sum(a, ea => diffCIECorr(ea, closestLab(b, ea))) +\n    sum(b, ea => diffCIECorr(ea, closestLab(a, ea)))\n\n  const len = Math.max(a.length, b.length, diffs)\n\n  return (len - diffs) / len\n}\n\nconst GreyscaleRE = /A{20}=?$/\n\nexport function isGreyscaleMeanHash(meanHash: Maybe<string>) {\n  // 11 characters to encode 64 bits with base 64 (b64 encodes 6 bits per\n  // character)\n  return (\n    meanHash != null &&\n    (within(7, 12, meanHash.length) || meanHash?.match(GreyscaleRE) != null)\n  )\n}\n\n/**\n * image hashes are produced by b64encodeBits(flatten(l[], a[], b[])): so the\n * lightness mean bits are the first dim^2 bits.\n *\n * @param b64 assumed to have been produced by b64encodeBits(flatten(l[], a[], b[])):\n *\n * @return number[] dim^2 long, ready to be rotated.\n */\nfunction splitbits(\n  b64: string,\n  greyscale: boolean,\n  dim: number = HashDim\n): number[] {\n  // We may be given a color meanhash but asked to render as greyscale.\n  const bits = b64decode(b64)\n    .toString(2)\n    .split(\"\")\n    .map(ea => (ea === \"1\" ? 1 : 0)) // < binary parseInt\n\n  const dim2 = dim * dim\n\n  // left pad with 0s\n  while (bits.length % dim2 !== 0) {\n    bits.unshift(0)\n  }\n\n  // console.log(\"splitbits()\", {\n  //   b64,\n  //   decoded: b64decode(b64),\n  //   bitsLen: bits.length\n  // })\n\n  const only_l_bits = bits.length === dim2\n  if (only_l_bits || greyscale) return bits.slice(0, dim2)\n\n  const result = bits.slice(0, dim2).map((ea, idx) => {\n    const l = ea\n    const a = bits[idx + dim2]\n    const b = bits[idx + dim2 * 2]\n    return l * 4 + a * 2 + b\n  })\n\n  return result\n}\n\nexport function meanHashVariants(\n  a: string,\n  greyscale = false,\n  dim: number = HashDim\n) {\n  greyscale = greyscale || a.match(GreyscaleRE) != null\n  const suffix = greyscale ? padding(\"0\", 2 * dim * dim) : \"\"\n  const m_a = splitbits(a, greyscale, dim)\n  return Rotations.map(deg =>\n    b64encode(\n      BigInt(\n        \"0b0\" +\n          rotateSquareMatrix(m_a, deg)\n            .map(ea => ea.toString(2))\n            .join(\"\") +\n          suffix\n      )\n    )\n  )\n}\n\n/**\n * @param a is a b64-encoded set of ModeBits^2 triple-bits (one bit for L*,\n * one for a*, one for b*).\n * @return bRotation is the number of degrees that `b` needs to be rotated to\n * match `a`.\n */\nexport function hammRatio({\n  a,\n  b,\n  greyscale,\n  dim = HashDim,\n  rotationsToCheck\n}: {\n  a: Maybe<string>\n  b: Maybe<string>\n  greyscale: boolean\n  dim?: number\n  rotationsToCheck: MaybeReadonlyArray<Rotation>\n}): { hammRatio: number; bRotation: number } {\n  if (blank(a) || blank(b)) return { hammRatio: 0, bRotation: 0 }\n  if (a === b) return { hammRatio: 1, bRotation: 0 }\n\n  const m_a = splitbits(a, greyscale, dim)\n  const m_b = splitbits(b, greyscale, dim)\n\n  if (isEmpty(rotationsToCheck)) rotationsToCheck = [0]\n\n  const results = rotationsToCheck.map(bRotation => ({\n    bRotation,\n    hammRatio: sigFigs(\n      hammRatioIntArrays(\n        m_a,\n        rotateSquareMatrix(m_b, bRotation),\n        greyscale ? 1 : 3\n      ),\n      2\n    )\n  }))\n\n  logger().debug(\"hammRatio()\", { results, rotationsToCheck })\n\n  // If quality scores are similar, prefer no rotation, or 90 degrees left or\n  // right:\n  const result = greatestBy(results, ea => [\n    sigFigs(ea.hammRatio, 1), // < hamming distance is only directionally accurate\n    -Rotations.indexOf(ea.bRotation as any)\n  ])!\n  return {\n    bRotation: result.bRotation,\n    hammRatio: sigFigs(result.hammRatio, 2)\n  }\n}\n\nexport async function isSimilarImage(\n  a: PosixFile,\n  b: PosixFile,\n  level: LogLevel = \"debug\",\n  opts: ComparisonOptions = {}\n): PromiseMaybe<boolean> {\n  return logger().tap({\n    msg: `isSimilarImage(${a},${b})`,\n    level,\n    result: isSimilarImageHash(await imageHash(a), await imageHash(b), opts)\n  })\n}\n\nexport interface ComparisonOptions {\n  capturedAtIsFuzzy?: boolean\n  forceColor?: boolean\n  forceGreyscale?: boolean\n  minImageCorr?: number\n  minColorCorr?: number\n  rotationsToCheck?: MaybeReadonlyArray<Rotation>\n}\n\nexport function compareImageHashes(\n  a_: Maybe<ImageHashish>,\n  b_: Maybe<ImageHashish>,\n  opts: ComparisonOptions = {}\n) {\n  // toImageHash will return null if the object is invalid (like if dominantColors is empty or meanHash is blank)\n  const a = toImageHash(a_)\n  const b = toImageHash(b_)\n  if (a == null || b == null) return\n\n  const capturedAtIsFuzzy = isTrue(opts.capturedAtIsFuzzy)\n  const isGreyscale = isTrue(opts.forceColor)\n    ? false\n    : isTrue(opts.forceGreyscale) ||\n      (a.isGreyscale ?? isGreyscaleMeanHash(a.meanHash)) ||\n      (b.isGreyscale ?? isGreyscaleMeanHash(b.meanHash))\n\n  const meanHashCorr = hammRatio({\n    a: a.meanHash,\n    b: b.meanHash,\n    greyscale: isGreyscale,\n    rotationsToCheck: opts.rotationsToCheck ?? validRotations(a, b)\n  })\n\n  const diffHashCorr = hammRatio({\n    a: a.diffHash,\n    b: b.diffHash,\n    greyscale: isGreyscale,\n    rotationsToCheck: [] // < dhash bits can't be rotated\n  })\n\n  const dctHashCorr = hammRatio({\n    a: a.dctHash,\n    b: b.dctHash,\n    greyscale: isGreyscale, // dcthash is always greyscale\n    rotationsToCheck: [] // < dcthash bits can't be rotated\n  })\n\n  const colorCorr = dominantColorCorrelation(a.dominantColors, b.dominantColors)\n\n  if (colorCorr == null) {\n    logger().debug(\"imageHashCompare(): missing color correlation\")\n    return\n  }\n\n  const mimeMatches = a.mimetype === b.mimetype\n\n  const aAspectRatio = aspectRatio(a)\n  const bAspectRatio = aspectRatio(maybeDimSwap(b, meanHashCorr.bRotation))\n\n  // Only reject image hashes if they both include an aspect ratio, and they aren't rotated.\n  const aspectRatioMismatches =\n    aAspectRatio != null &&\n    bAspectRatio != null &&\n    !isCloseAspectRatio(aAspectRatio, bAspectRatio)\n\n  let imageCoeffDelta = 0\n  let colorCoeffDelta = 0\n\n  if (capturedAtIsFuzzy) {\n    colorCoeffDelta += Settings.imageHashFuzzyDateDelta.valueOrDefault\n    imageCoeffDelta += Settings.imageHashFuzzyDateDelta.valueOrDefault\n  }\n  if (!mimeMatches) {\n    colorCoeffDelta += Settings.imageHashDifferentMimetypesDelta.valueOrDefault\n    imageCoeffDelta += Settings.imageHashDifferentMimetypesDelta.valueOrDefault\n  }\n  if (isGreyscale) {\n    imageCoeffDelta += Settings.imageHashGreyscaleDelta.valueOrDefault\n    colorCoeffDelta += Settings.imageHashGreyscaleDelta.valueOrDefault\n  }\n\n  const minImageCorr = clamp01(\n    (imageCoeffDelta +\n      (opts.minImageCorr ?? Settings.minImageCoeffPct.valueOrDefault)) /\n      100\n  )\n\n  const minColorCorr = clamp01(\n    (colorCoeffDelta +\n      (opts.minColorCorr ?? Settings.minColorCoeffPct.valueOrDefault)) /\n      100\n  )\n\n  const why: string[] = []\n\n  if (aspectRatioMismatches) {\n    why.push(\n      `aspect ratio mismatch (${fmtAspectRatio(\n        aAspectRatio\n      )} vs ${fmtAspectRatio(bAspectRatio)})`\n    )\n  }\n\n  const failingImageHashes: string[] = []\n  const hashAvg = new Average()\n  hashAvg.push(meanHashCorr.hammRatio)\n\n  if (meanHashCorr.hammRatio < minImageCorr) {\n    failingImageHashes.push(\"mean\")\n  }\n\n  // We can't use these hashes if there's rotation involved. *tear*\n  const onlyMeanHash = meanHashCorr.bRotation !== 0\n  if (!onlyMeanHash) {\n    map(diffHashCorr?.hammRatio, ea => hashAvg.push(ea))\n    map(dctHashCorr?.hammRatio, ea => hashAvg.push(ea))\n\n    if (lt(diffHashCorr?.hammRatio, minImageCorr)) {\n      failingImageHashes.push(\"gradient\")\n    }\n    if (lt(dctHashCorr?.hammRatio, minImageCorr)) {\n      failingImageHashes.push(\"DCT\")\n    }\n  }\n\n  if (failingImageHashes.length > 0) {\n    why.push(\"different image content (\" + andList(failingImageHashes) + \")\")\n  }\n\n  const colorPass = colorCorr >= minColorCorr\n  // If any of the hashes are quite sure they are different, they will pull\n  // down the average to reject the match.\n  const isSimilar = colorPass && hashAvg.avg! >= minImageCorr\n\n  if (!colorPass) {\n    why.push(\"different dominant colors\")\n  }\n\n  const result = {\n    meanHashCorr: sigFigs(meanHashCorr.hammRatio, 2),\n    diffHashCorr: onlyMeanHash\n      ? undefined\n      : map(diffHashCorr, ea => sigFigs(ea.hammRatio, 2)),\n    dctHashCorr: onlyMeanHash\n      ? undefined\n      : map(dctHashCorr, ea => sigFigs(ea.hammRatio, 2)),\n    hashCorrAvg: hashAvg.avg!,\n    minImageCorr,\n    imageCoeffDelta,\n    colorCorr: sigFigs(colorCorr, 2),\n    minColorCorr,\n    colorCoeffDelta,\n    isGreyscale,\n    bRotation: meanHashCorr.bRotation,\n    aAspectRatio,\n    bAspectRatio,\n    isSimilar,\n    whyNotSimilar: isSimilar ? undefined : andList(why)\n  }\n\n  logger().info(\"compareImageHashes\", {\n    a: pickCompact(a as any, \"uri\", \"id\", \"assetId\"),\n    b: pickCompact(b as any, \"uri\", \"id\", \"assetId\"),\n    ...result\n  })\n\n  return {\n    a,\n    b,\n    ...result\n  }\n}\n\nexport async function isVerySimilarImage(\n  a: PosixFile,\n  b: PosixFile,\n  level: LogLevel = \"debug\",\n  opts: ComparisonOptions = {}\n): PromiseMaybe<boolean> {\n  return isSimilarImage(a, b, level, {\n    rotationsToCheck: [0],\n    ...opts,\n    minImageCorr: 0.92,\n    minColorCorr: 0.92\n  })\n}\n\nexport function isSimilarImageHash(\n  a: Maybe<ImageHashish>,\n  b: Maybe<ImageHashish>,\n  opts?: ComparisonOptions\n): boolean {\n  return compareImageHashes(a, b, opts)?.isSimilar ?? false\n}\n\nfunction clamp01(i: number): number {\n  return sigFigs(clamp(0, 1, i), 3)\n}\n\nexport function isVerySimilarImageHash(\n  a: Maybe<ImageHashish>,\n  b: Maybe<ImageHashish>,\n  opts: ComparisonOptions = {}\n): boolean {\n  return isVerySimilarComparison(compareImageHashes(a, b, opts))\n}\n\nexport function isVerySimilarComparison(\n  c: Maybe<ImageHashComparison>\n): boolean {\n  if (c == null) return false\n  return gte(c.meanHashCorr, 0.9) && gte(c.colorCorr, 0.9)\n}\n\n/**\n * @return 1 for perfect match, < .6 for different images\n */\nexport function imageHashSimilarity(\n  a: Maybe<ImageHashish>,\n  b: Maybe<ImageHashish>\n): Maybe<number> {\n  return map(compareImageHashes(a, b), c => avg([c.meanHashCorr, c.colorCorr]))\n}\n","import _sharp from \"sharp\"\nimport { inspect } from \"util\"\nimport { lazy } from \"../../core/Lazy\"\nimport {\n  Dimensions,\n  dimSwap,\n  dmegapixels,\n  isPortrait\n} from \"../../fe/Dimensions\"\nimport { ImageSizeName } from \"../../fe/ImageSizes\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { megapixels } from \"../../fe/Units\"\nimport { greatestBy } from \"../Array\"\nimport { Settings } from \"../settings/Settings\"\nimport { Fit, OutputSize, Reducer, Square } from \"./Reducers\"\nimport { sharpRenderOptions } from \"./Sharp\"\n\n// https://www.bhphotovideo.com/FrameWork/charts/resolutionChartPopup.html\n// says 2240 x 1680, or 4 Megapixels, is \"Photo Quality\" 8x10 prints. That's\n// ~210 pixels per inch, which is fine for some continuous tone images, but\n// high-contrast line art should see 300 at least.\n\n// We want to render assets on a 5k display quickly.\n\n// If we can cheaply stream the original file, we don't need to save a\n// 5K UHD-resized version.\n\n// \"cheaply stream\" requires the following to be true:\n\n// * not RAW\n// * not enormous (> 20MP)\n\n// x2 image resolutions results in a 20MB, 318 file previews directory.\n// x3 image resolutions results in a 17MB, 210 file previews directory.\n\n// Possible resize strategies:\n\n// megapixel-based (.5MP, 1MP, 2MP, 3MP, ...)\n\n// file size based (2k, 8k, 32k, 128k, ...)\n\n// use popular display sizes, k-means grouping with 4 sizes\n\n// there are *many* display resolutions from 720p through 5k--we'll get it\n// wrong--so what are we trying to do here?\n\n// * We want to make the UI fast by reducing the bytes needed to render a page,\n//   so we want different sizes of previews.\n\n// * We want to minimize the work the browser and webserver need to do to per\n//   request, so if we're going to resize previews, it needs to be < 100ms of\n//   work per image.\n\n// * We want a previews directory that is only as large as it needs to be.\n\n// We could probably serve smaller image resizes on the fly if the source image\n// was small enough (< 2 MP)? But that won't save much disk space.\n\n// A page of several hundred thumbnails would crush the webserver's CPU if the\n// per-request expense is sufficiently high.\n\n// Each halving of width quarters the size of the image, of course, so size\n// drops geometrically.\n\n// https://docs.google.com/spreadsheets/d/18j8oBFwPu9lwQKk2RgpeDIZ5k2bpb5WF7rbHFQwP_4s/edit?usp=sharing\n\n// Display sizes:\n// 1136 × 640: iPhone SE\n// 1280 × 720: HD, cheap android phones\n// 1334 x 750: iPhone 6, iPhone 7\n// 1920 x 1080: FHD: TVs, iPhone 6 Plus, iPhone 7 Plus, Google Pixel, Nexus 5x, Chromebooks\n// 2048 x 1536: iPads, Nexus 9\n// 2436 x 1125: iPhone X\n// 2560 x 1440: QHD: Nexus 6P, Google Pixel XL, Samsung Note 5\n// 3120 x 1440: OnePlus 7 Pro\n// 2560 x 1600: 13\" Retina Macbook\n// 2880 x 1440: QHD+: Pixel 2 XL\n// 2732 x 2048: iPad Pro\n// 2880 x 1800: 15\" Retina Macbook\n// 3840 × 2160: UHD 4k monitor\n// 5120 × 2880: iMac 5k\n\n// Camera resolutions:\n// First(ish) camera with selfie cam: iPhone 4: front: VGA (480P) rear: 2592x1936\n\n// srcset only works with widths, so images fit to common native screen\n// resolutions will most likely not be the native resolution width, hence the\n// name\n\n// https://en.wikipedia.org/wiki/Graphics_display_resolution\n// https://en.wikipedia.org/wiki/Pixel#/media/File:Sensoraufl%C3%B6sungen.svg\n\nexport class ImageSize {\n  static readonly #sizes: ImageSize[] = []\n\n  static sq(): ImageSize[] {\n    return this.#sizes.filter(ea => ea.reducer === Square)\n  }\n  static largestSq(): ImageSize {\n    return greatestBy(this.sq(), ea => ea.megapixels())!\n  }\n\n  static fit(): ImageSize[] {\n    const arr = Settings.previewResolutions.valueOrDefault\n    return this.#sizes.filter(ea => ea.reducer === Fit && arr.includes(ea.name))\n  }\n  static largestFit(): ImageSize {\n    return greatestBy(this.fit(), ea => ea.megapixels())!\n  }\n\n  static all(): ImageSize[] {\n    return [...this.#sizes]\n  }\n\n  // Landscape fullscreen native resolution sizes:\n\n  // These images are fit to these boundaries without any cropping\n\n  // static readonly UHD5K = new ImageSize(\"uhd5k\", 5120, 5120, Fit)\n\n  // fit-* files are reduced in size until the entire image fits in the given\n  // dimensions. No cropping is done.\n\n  // Given that we always serve the original as a width, UHD and QHD isn't\n  // needed. FHD is only used to reduce network load.\n\n  // 5K UHD: (14.7 MP)\n  // UHD: (8.3 MP) ~1MiB\n  // FHD: (2 MP) ~500KiB\n  // FWXGA: (1.2 MP) ~300K\n  // HD: (.9 MP) ~100K\n  // SD: (.3 MP) 46K\n  // w240 (.1 MP) 13K\n\n  // These aren't rotational (as of 2020):\n  static readonly UHD8k = new ImageSize(\"uhd8k\", 7680, 4320, Fit, false)\n  static readonly UHD5k = new ImageSize(\"uhd5k\", 5120, 2880, Fit, false) // < 15 MP\n\n  // As of 2020, 4k displays are *normally* landscape.\n  static readonly UHD = new ImageSize(\"uhd4k\", 4096, 2160, Fit)\n\n  // Flagship smartphone screens. Rotational.\n  static readonly QHD = new ImageSize(\"qhd\", 3120, 1440, Fit)\n\n  // 1920x1080 is 1080p. fit to 1920x1920 to fill a 1080p display (most smartphones)\n  // Only one of these will be built, and it depends on the orientation of the image:\n  static readonly FHD = new ImageSize(\"fhd\", 1920, 1080, Fit)\n\n  // FWXGA is so close to FHD, just send them the fhd and save time and space.\n  // // 1366x768 (FWXGA) is (at least as of 2018) the most popular screen\n  // // resolution, according to\n  // // http://gs.statcounter.com/screen-resolution-stats/desktop/worldwide\n  // but 720 video is 720x1280, so this makes a better poster image:\n  static readonly HD = new ImageSize(\"hd\", 1280, 720, Fit)\n\n  // 720x480 is WVGA or 480p (aka \"EDTV\"). Presumably will be used if the window\n  // isn't full screen.\n  static readonly WVGA = new ImageSize(\"wvga\", 720, 480, Fit)\n\n  // old videos are 320x240, so 256 is slightly too big, and made the thumbnails horrible.\n  static readonly QVGA = new ImageSize(\"qvga\", 320, 240, Fit)\n\n  // 160x100 is the wonderfully descriptive QQVGA standard.\n  static readonly QQVGA = new ImageSize(\"qqvga\", 160, 120, Fit)\n\n  // Anything smaller than qqvga is silly, because sending <1k JPEGs vs ~1.5k\n  // JPEGs, it's still just one TCP packet. Note that each additional file\n  // also makes scanning the previews directory slower.\n\n  // sq-* are constrained to a square:\n\n  // Typical file sizes:\n  // sq-w480: ~40-100k\n  // sq-w240: 10-30k\n  // sq-w120: 4-8k\n  // sq-w60: 1-3k\n\n  static readonly S480 = new ImageSize(\"s480\", 480, 480, Square)\n  static readonly S240 = new ImageSize(\"s240\", 240, 240, Square)\n  static readonly S120 = new ImageSize(\"s120\", 120, 120, Square)\n  static readonly S60 = new ImageSize(\"s60\", 60, 60, Square)\n\n  // See the note about about f80 being silly.\n\n  // static readonly S32 = new ImageSize(\"s32\", 32, 32, Square, \"s64\")\n\n  readonly max: Dimensions\n\n  private constructor(\n    readonly name: ImageSizeName,\n    readonly maxWidth: number,\n    readonly maxHeight: number,\n    readonly reducer: Reducer,\n    readonly rotational = true\n  ) {\n    this.max = { width: maxWidth, height: maxHeight }\n    ImageSize.#sizes.push(this)\n  }\n\n  [inspect.custom]() {\n    return {\n      ctor: \"ImageSize\",\n      name: this.name + \" (\" + this.reducer.name + \")\",\n      maxDim: this.maxWidth + \"×\" + this.maxHeight,\n      maxMP: this.megapixels()\n    }\n  }\n\n  get aspectRatio() {\n    return this.maxWidth / this.maxHeight\n  }\n\n  get maxPixels() {\n    return this.maxWidth * this.maxHeight\n  }\n\n  get minDimension() {\n    return Math.min(this.maxWidth, this.maxHeight)\n  }\n\n  readonly megapixels = lazy(() => megapixels(this.maxWidth * this.maxHeight))\n\n  outputSize(inputSize: Dimensions): Maybe<OutputSize> {\n    return this.reducer.reduce(\n      this.rotational && isPortrait(inputSize) ? dimSwap(this.max) : this.max,\n      inputSize\n    )\n  }\n\n  resize(outputSize: Dimensions, s: _sharp.Sharp): _sharp.Sharp {\n    // SITS: SHARP TYPINGS ARE CRAP\n    s = (s as any).resize({\n      ...outputSize,\n      fit: this.reducer.fit,\n      withoutEnlargement: true\n    })\n\n    return s\n  }\n\n  toJpeg({\n    path,\n    sh,\n    outputSize\n  }: {\n    path: string\n    sh: _sharp.Sharp\n    outputSize: Dimensions\n  }): Promise<_sharp.OutputInfo> {\n    // we don't need to add colorspace or metadata, as sRGB and tag stripping is\n    // on by default.\n\n    const mp = dmegapixels(outputSize)\n    if (mp < 2 || Settings.previewSharpen.valueOrDefault) {\n      sh = sh.sharpen()\n    }\n    return sh.jpeg(sharpRenderOptions()).toFile(path)\n  }\n\n  toString() {\n    return this.name\n  }\n}\n","import { WriteTags } from \"exiftool-vendored\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { assignFields, isEmptyObj, pick } from \"../../fe/Object\"\nimport { mkLogger } from \"../Logger\"\nimport { time } from \"../async/PromiseTimer\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { Settings } from \"../settings/Settings\"\nimport { ExifTags } from \"../tags/ExifTags\"\nimport { overwriteTags_, readTags } from \"../tags/ExifTool\"\n\nconst logger = lazy(() => mkLogger(\"img.includePreviewTags\"))\n\nexport async function includePreviewTags_(src: PosixFile, files: PosixFile[]) {\n  if (\n    false === Settings.includePreviewTags.valueOrDefault ||\n    Settings.includedPreviewTags.isEmpty() ||\n    isEmpty(files)\n  ) {\n    // no-op\n    return\n  }\n\n  logger().info(\"Re-adding metadata to previews...\")\n  await time(\"img.includePreviewTags\", async () => {\n    const writeTags: Partial<ExifTags> & WriteTags = pick(\n      (await readTags(src)) as any,\n      ...Settings.includedPreviewTags.values\n    )\n    // also handle the captured-at and exposure settings\n    const ca = writeTags?.capturedAt\n    if (ca != null) {\n      delete writeTags.capturedAt\n      assignFields(writeTags, ca.asExifTag())\n    }\n    const exp = writeTags?.exposureSettings\n    if (exp != null) {\n      delete writeTags.exposureSettings\n      // These tag locations make Eye of Gnome and Apple Previews happy:\n      writeTags.FocalLength = exp.focalLength\n      writeTags.FNumber = exp.aperture\n      writeTags.ExposureTime = exp.shutterSpeed\n      writeTags.ISO = exp.iso\n    }\n    if (Settings.includedPreviewTags.has(\"Source\")) {\n      writeTags.Source = src.nativePath\n    }\n    if (isEmptyObj(writeTags)) {\n      logger().warn(\n        \"not adding tags to previews: no values for tags in source file\",\n        {\n          src,\n          includedPreviewTags: Settings.includedPreviewTags.values\n        }\n      )\n    } else {\n      logger().info(\"Overwriting preview tags...\", {\n        src,\n        writeTags\n      })\n      await Promise.all(files.map(ea => overwriteTags_(ea, writeTags)))\n    }\n  })\n}\n","import sharp from \"sharp\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { toA } from \"../../fe/toA\"\nimport { rgb2labArray } from \"../color/Colorspace\"\nimport { avg } from \"../math/Vector\"\nimport { HashDim } from \"./ImageHash\"\n\nexport type Binary = 0 | 1\n\nexport function mhash(arr: Buffer | number[]): Binary[] {\n  const m = avg(arr)\n  // Buffer.map() DOES NOT DO WHAT YOU WANT. toA() is REQUIRED.\n  return m == null ? [] : toA(arr).map(ea => (ea >= m ? 1 : 0))\n}\n\nexport function dhash(arr: Buffer | number[]): (0 | 1)[] {\n  // Buffer.map() DOES NOT DO WHAT YOU WANT. toA() is REQUIRED.\n  const pixels = toA(arr)\n  const dim = Math.round(Math.sqrt(pixels.length))\n  return pixels.map((ea, idx) => {\n    // first pixel looks down. first column looks up. all others look left.\n    const p =\n      idx === 0 ? arr[dim] : idx % dim === 0 ? arr[idx - dim] : arr[idx - 1]\n    return ea >= p ? 1 : 0\n  })\n}\n\nexport async function meanDiffHash(img: sharp.Sharp, hashSize = HashDim) {\n  const pixels = await img\n    .greyscale()\n    .resize({\n      // We want to resize to a small square. \"fill\" ignores the aspect ratio:\n      fit: sharp.fit.fill,\n      width: hashSize,\n      height: hashSize\n    })\n    .raw()\n    .toBuffer()\n\n  return {\n    meanHash: mhash(pixels),\n    diffHash: dhash(pixels)\n  }\n}\n\nexport async function meanDiffHashCIELAB(img: sharp.Sharp, hashSize = HashDim) {\n  const rgb = await img\n    .resize({\n      // We want to resize to a small square. \"fill\" ignores the aspect ratio:\n      fit: sharp.fit.fill,\n      width: hashSize,\n      height: hashSize\n    })\n    .raw()\n    .toBuffer()\n\n  // [[L* values], [a* values], [b* values]]:\n  const lab = rgb2labArray(rgb)\n  return {\n    meanHash: flatten(lab.map(mhash)),\n    diffHash: flatten(lab.map(dhash))\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { readFileType_ } from \"../fs/FileType\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { mkLogger } from \"../Logger\"\nimport { Settings } from \"../settings/Settings\"\nimport { shim1 } from \"../Shim1\"\nimport { isMimeTypeSupportedByBrowser } from \"../tags/MimeTypes\"\nimport { withImageCache_ } from \"./ImageCache\"\nimport { includePreviewTags_ } from \"./IncludePreviewTags\"\nimport { sharpRenderOptions } from \"./Sharp\"\nimport { sharpReadable_, toSharp } from \"./SharpReadable\"\n\nconst logger = lazy(() => mkLogger(\"img.PrepareFileForBrowser\"))\n\nexport interface PrepFileForBrowserArgs {\n  nativePath: string\n  userAgent?: string\n  sha?: string\n  mimetype?: string\n}\n\nexport const prepFileForBrowser = shim1({\n  name: \"img.prepFileForBrowser\",\n  impl: _prepFileForBrowser\n})\n\nexport async function _prepFileForBrowser(\n  info: PrepFileForBrowserArgs\n): PromiseMaybe<string> {\n  try {\n    const file = PosixFile.for(info.nativePath)\n    if (await file.notExists()) return\n    const mimetype =\n      info.mimetype ?? (await readFileType_(file.nativePath))?.mime\n    if (isMimeTypeSupportedByBrowser(mimetype, info.userAgent)) {\n      return file.nativePath\n    }\n    logger().info(\"prepFileForBrowser(): non-browser-supported mimetype\", {\n      file,\n      info\n    })\n    // 20220502: we have to tell sharpReadable to ignore rotation, or images get\n    // rotated twice:\n    return (\n      await withImageCache_(file, \"web\", \".jpg\", async dest => {\n        const sr = await sharpReadable_({ src: file })\n        if (sr == null)\n          throw new Error(\"prepFileForBrowser(): can't read \" + file.nativePath)\n        await toSharp(sr).jpeg(sharpRenderOptions()).toFile(dest.nativePath)\n        if (Settings.includePreviewTags.valueOrDefault) {\n          await includePreviewTags_(file, [dest])\n        }\n      })\n    )?.nativePath\n  } catch (error) {\n    logger().warn(\"prepFileForBrowser() failed\", { error })\n    return\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { map } from \"../../fe/Maybe\"\nimport { ID } from \"../../fe/api/ID\"\nimport { mkLogger } from \"../Logger\"\nimport { shim1 } from \"../Shim1\"\nimport { libraryPreviewsDirPosixFile } from \"../dir/LibraryDirs\"\nimport { ForceContext } from \"../settings/ForceContext\"\nimport { AssetPreviewBuilder, PreviewAssetFile } from \"./AssetPreviewBuilder\"\nimport { AssetPreviews } from \"./AssetPreviews\"\n\nexport class Previews {\n  static readonly instance = lazy(() => {\n    mkLogger(\"Previews\").info(\".instance()\", {\n      libraryPreviewsDir: libraryPreviewsDirPosixFile()\n    })\n    return map(libraryPreviewsDirPosixFile(), dir => new Previews(dir))\n  })\n\n  constructor(readonly root: PosixFile) {}\n\n  apb(\n    assetId: number,\n    assetFiles: PreviewAssetFile[],\n    opts: ForceContext\n  ): AssetPreviewBuilder {\n    return new AssetPreviewBuilder(this.ap(assetId), assetFiles, opts)\n  }\n\n  ap(assetId: number | ID) {\n    return new AssetPreviews(this.root, assetId)\n  }\n}\n\nexport interface BuildAssetPreviewsArgs extends ForceContext {\n  assetId: number\n  assetFiles: PreviewAssetFile[]\n  validate?: boolean | undefined\n}\n\nexport const buildAssetPreviews_ = shim1({\n  name: \"img.buildAssetPreviews\",\n  impl: (opts: BuildAssetPreviewsArgs) =>\n    Previews.instance()!.apb(opts.assetId, opts.assetFiles, opts).build_()\n})\n","import { uniqBy } from \"../../fe/Array\"\nimport { Dimensions, maybeDimSwap } from \"../../fe/Dimensions\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { absdiff, isNumber, sigFigs, toGt0 } from \"../../fe/Number\"\nimport { lt } from \"../../fe/Primitive\"\nimport { flatMap, leastBy, leastByCtx } from \"../Array\"\nimport { mapGt0f } from \"../Number\"\n\nexport const Ratios = uniqBy(\n  flatMap(\n    // Common image ratios (hopefully in order of popularity):\n    [\n      [3, 2],\n      [4, 3],\n      [16, 9],\n      [1, 1],\n      [10, 8],\n      [7, 5],\n      // panoramas:\n      [2, 1],\n      [3, 1],\n      [4, 1],\n      [5, 1]\n    ],\n    ([w, h]) => [\n      { i: w / h, s: w + \":\" + h },\n      { i: h / w, s: h + \":\" + w }\n    ]\n  ),\n  ea => ea.s\n)\n\nexport const StandardAspectRatios = Ratios.map(ea => ea.i)\nexport const RatioEpsilon = 0.045\n\nexport function roundToNearestRatio(\n  ratioOrDimension: number | Dimensions,\n  delta: number = RatioEpsilon * 2\n): Maybe<number> {\n  return mapGt0f(\n    isNumber(ratioOrDimension)\n      ? ratioOrDimension\n      : (toGt0(ratioOrDimension.width) ?? 0) /\n          (toGt0(ratioOrDimension.height) ?? 0),\n    ratio => {\n      const closest = leastBy(StandardAspectRatios, ea => {\n        const diff = Math.abs(ratio - ea)\n        return diff > delta ? undefined : diff\n      })\n      return closest ?? ratio\n    }\n  )\n}\n\nexport function similarRatios(\n  a: number | Dimensions,\n  b: number | Dimensions,\n  delta: number = RatioEpsilon\n): boolean {\n  return lt(absdiff(roundToNearestRatio(a), roundToNearestRatio(b)), delta)\n}\n\nexport function similarRatiosWithRotation(\n  a: { dimensions: Dimensions; rotation?: number },\n  b: { dimensions: Dimensions; rotation?: number },\n  delta: number = 0.05\n) {\n  return similarRatios(\n    maybeDimSwap(a.dimensions, a.rotation),\n    maybeDimSwap(b.dimensions, b.rotation),\n    delta\n  )\n}\n\nfunction nearestAspectRatio(n: number, thresh: number) {\n  return leastByCtx(Ratios, ea => {\n    const diff = Math.abs(ea.i - n)\n    return diff < thresh ? diff : undefined\n  })\n}\n\nexport function roundAspectRatio(n: number, thresh = 0.05) {\n  return nearestAspectRatio(n, thresh)?.result.i ?? n\n}\n\nexport function fmtAspectRatio(n: number, thresh = 0.05): string {\n  return nearestAspectRatio(n, thresh)?.result.s ?? String(sigFigs(n, 3))\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { Dimensions } from \"../../fe/Dimensions\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toGt0 } from \"../../fe/Number\"\nimport { FifoCacheAsync } from \"../FifoCacheAsync\"\nimport { mkLogger } from \"../Logger\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { ee } from \"../event/EventEmitter\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { statTimeoutMs } from \"../fs/StatTimeout\"\nimport { rawIdentifyNativePath_ } from \"../fs/Tools\"\n\nconst logger = lazy(() => mkLogger(\"img.RawInfo\"))\n\nexport type RawInfo = {\n  Filename: string\n  Make: string\n  Model: string\n  ImageSize: Dimensions\n}\n\nconst cache = lazy(\n  () =>\n    new FifoCacheAsync<RawInfo>({\n      maxSize: 512,\n      name: \"img.RawInfoCache\",\n      timeoutMs: ShortCommandTimeoutMs\n    })\n)\n\nee().on(\"clearCache\", () => cache.prior()?.clear())\nee().on(\"fileChanged\", ea =>\n  ea == null ? cache.prior()?.clear() : cache.prior()?.delete(ea)\n)\n\nexport async function rawInfo(src: PosixFile): PromiseMaybe<RawInfo> {\n  return rawInfo_(src).catch(error => {\n    logger().warn(\"rawInfo() failed\", { error, src })\n    return undefined\n  })\n}\n\nexport async function rawInfo_(src: PosixFile): Promise<RawInfo> {\n  return cache().getOrSetAsync(src.nativePath, async () => {\n    const cmd = await rawIdentifyNativePath_()\n    // -u -f returns something that _isn't_ the rendered TIFF dimensions.\n    return parseRawInfoOutput_(\n      await stdout_(cmd, [\"-s\", src.nativePath], {\n        timeoutMs: statTimeoutMs()\n      })\n    )\n  })\n}\n\nexport function parseRawInfoOutput_(input: string): RawInfo {\n  const [Filename, Make, Model, w, h] = input.split(\"\\t\")\n  const width = toGt0(w)\n  const height = toGt0(h)\n  if (width == null || height == null) {\n    return logger().throw(\"parseRawInfoOutput_ failed (missing dimensions)\", {\n      cause: input\n    })\n  } else {\n    return logger().tap({\n      msg: \"parseRawInfoOutput()\",\n      result: {\n        Filename,\n        Make,\n        Model,\n        ImageSize: { width, height }\n      },\n      meta: { input }\n    })\n  }\n}\n","import { ResizeOptions } from \"sharp\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Dimensions, fmtDim, pixels } from \"../../fe/Dimensions\"\nimport { fitInside } from \"../../fe/Fit\"\nimport { ReducerName, ReducerNames } from \"../../fe/ImageReducers\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\nimport { mkLogger } from \"../Logger\"\nimport { ltBoth, lteBoth } from \"./Dimensions\"\n\n// See http://sharp.pixelplumbing.com/en/stable/api-resize/ and\n// https://github.com/lovell/sharp/issues/1135\nexport const SharpFits = strEnum(\n  \"cover\",\n  \"contain\", // this adds background to fill the expected dim, instead of cropping\n  \"fill\",\n  \"inside\",\n  \"outside\"\n)\nexport type SharpFit = StrEnumKeys<typeof SharpFits>\n\nexport type OutputSize = ResizeOptions & Dimensions\n\nexport interface Reducer {\n  name: ReducerName\n  fit: SharpFit\n  reduce(max: Dimensions, input: Dimensions): Maybe<OutputSize>\n}\n\n/**\n * Reduce the smaller dimension and crop the larger dimension to fill the given\n * constraints. As this is the default behavior of sharp, the implementation is\n * the identity function.\n */\nexport namespace Square {\n  const logger = lazy(() => mkLogger(\"img.Reducers.Square\"))\n  export const name = ReducerNames.sq\n  export const fit = \"cover\"\n  export function reduce(\n    max: Dimensions,\n    input: Dimensions\n  ): Maybe<OutputSize> {\n    const result = !lteBoth(max, input)\n      ? undefined\n      : {\n          ...max,\n          fit: SharpFits.cover\n        }\n\n    return logger().tap({\n      msg: \"reduce()\",\n      result,\n      meta: {\n        max,\n        input\n      }\n    })\n  }\n}\n\n/**\n * Reduce `input` to match `aspectRatio`'s aspect ratio.\n */\nexport function fitInsideToAspectRatio(\n  input: Dimensions,\n  aspectRatio: number\n): Dimensions {\n  return input.width / input.height >= aspectRatio\n    ? {\n        width: Math.floor(input.height * aspectRatio),\n        height: input.height\n      }\n    : {\n        width: input.width,\n        height: Math.floor(input.width / aspectRatio)\n      }\n}\n\n/**\n * Reduce `input` to match `aspectRatio`'s aspect ratio.\n */\nexport function fitInsideToMaxPixels(\n  input: Dimensions,\n  maxPixels: number\n): Maybe<Dimensions> {\n  if (input == null || !gt0(input.width) || !gt0(input.height)) return\n  if (pixels(input) < maxPixels) return // no need to reduce\n  const aspectRatio = input.width / input.height\n  const height = Math.floor(Math.sqrt(maxPixels / aspectRatio))\n  const width = Math.floor(aspectRatio * height)\n  return { width, height }\n}\n\n/**\n * Reduce the entire image to fit given constraints\n */\nexport namespace Fit {\n  const logger = lazy(() => mkLogger(\"img.Reducers.Fit\"))\n\n  export const name = ReducerNames.fit\n  export const fit = \"inside\"\n  export function reduce(\n    max: Dimensions,\n    input: Dimensions\n  ): Maybe<OutputSize> {\n    // if input height < max AND input width < max, max is too big.\n    if (ltBoth(input, max)) {\n      logger().trace(\n        `reduce(): input ${fmtDim(input)} is too small for ${fmtDim(max)}`\n      )\n      return\n    }\n    return fitInside(input, max)\n  }\n}\n\n// /**\n//  * Reduce the entire image to fit given constraints\n//  */\n// export namespace Fill {\n//   const logger = lazy(() => mkLogger(\"img.Reducers.Fill\"))\n\n//   export const name = ReducerNames.fill\n//   export const fit = \"inside\"\n//   export function reduce(\n//     max: Dimensions,\n//     input: Dimensions\n//   ): Maybe<OutputSize> {\n//     // if input height < max AND input width < max, max is too big.\n//     if (ltEither(input, max)) {\n//       logger().debug(\"reduce(): input is too small for max\", { input, max })\n//       return\n//     }\n\n//     const inputAspectRatio = input.width / input.height\n//     const maxAspectRatio = max.width / max.height\n\n//     return inputAspectRatio >= maxAspectRatio\n//       ? {\n//           // wider, height takes aspect ratio into account.\n//           width: Math.floor((input.width * max.height) / input.height),\n//           height: max.height\n//         }\n//       : {\n//           // too tall, width takes aspect ratio\n//           width: max.width,\n//           height: Math.floor((input.height * max.width) / input.width)\n//         }\n//   }\n// }\n\n// Ensure all namespaces implement Reducer:\nexport const Reducers: Reducer[] = [Square, Fit]\n","import _sharp, { JpegOptions } from \"sharp\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../Logger\"\nimport { Settings } from \"../settings/Settings\"\n\n// SITS: why isn't this exported in the typing?\nexport interface OutputInfo {\n  format: string\n  size: number\n  width: number\n  height: number\n  channels: number\n}\n\nconst logger = lazy(() => mkLogger(\"img.Sharp\"))\n\nexport function isSharp(object: any): object is _sharp.Sharp {\n  return (\n    typeof object === \"object\" &&\n    typeof object.jpeg === \"function\" &&\n    typeof object.raw === \"function\" &&\n    typeof object.toBuffer === \"function\"\n  )\n}\n\nexport async function sharpClone(s: _sharp.Sharp): Promise<_sharp.Sharp> {\n  try {\n    return s.clone()\n  } catch (err) {\n    logger().info(\"sharp.clone() failed\", err)\n  }\n  try {\n    const { data, info } = await s.raw().toBuffer({ resolveWithObject: true })\n    return sharpFromRawBuffer(data, info)\n  } catch (error) {\n    return logger().throw(\"clone via sharp.raw().toBuffer() failed\", {\n      error\n    })\n  }\n}\n\nexport function sharpFromRawBuffer(\n  b: Buffer,\n  info: Pick<OutputInfo, \"width\" | \"height\" | \"channels\">\n) {\n  return _sharp(b, {\n    raw: info as any\n  })\n}\n\nexport function sharpRenderOptions(): JpegOptions {\n  return {\n    quality: Settings.previewQuality.valueOrDefault,\n    progressive: Settings.previewProgressive.valueOrDefault,\n    mozjpeg: Settings.previewMinimized.valueOrDefault\n  }\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const SharpFailOns = strEnum(\"none\", \"truncated\", \"error\", \"warning\")\nexport type SharpFailOn = StrEnumKeys<typeof SharpFailOns>\n","import { BinaryField, Tags } from \"exiftool-vendored\"\nimport _sharp, { Sharp } from \"sharp\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank } from \"../../fe/Blank\"\nimport { Dimensions, dmegapixels } from \"../../fe/Dimensions\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { closeTo, gt, lt } from \"../../fe/Number\"\nimport { pick } from \"../../fe/Object\"\nimport { isString } from \"../../fe/String\"\nimport { toErr } from \"../../fe/toErr\"\nimport { mkLogger } from \"../Logger\"\nimport { map2Gt0 } from \"../Number\"\nimport { LaterMaybe } from \"../async/Later\"\nimport { thenMap } from \"../async/Promise\"\nimport { time } from \"../async/PromiseTimer\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFile, isSimpleFile } from \"../fs/SimpleFile\"\nimport { Settings } from \"../settings/Settings\"\nimport { exiftool, extractBinaryTag, readRawTags } from \"../tags/ExifTool\"\nimport {\n  isLibrawMimeType,\n  isSharpMimeType,\n  isVideoMimeType\n} from \"../tags/MimeTypes\"\nimport { orientationRequiresMirroring } from \"../tags/Orientation\"\nimport { readMimeType } from \"../tags/ReadMimeType\"\nimport { extractSizeInfoFromFile } from \"../tags/SizeInfo\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { sharpThreadsPerProcess } from \"../work/MaxCpus\"\nimport { aspectRatio, lteBoth } from \"./Dimensions\"\nimport { heif2img, isHeifSupported } from \"./Heif\"\nimport { isHeifMimeType } from \"./HeifFilter\"\nimport { tmpImageFile_ } from \"./ImageCache\"\nimport { isSharp } from \"./Sharp\"\nimport { SharpFailOn } from \"./SharpFailOn\"\nimport { extractVideoFrame_, isVideoSupported } from \"./Video\"\nimport { raw2tiff_ } from \"./libraw\"\n\nconst logger = lazy(() => mkLogger(\"img.SharpReadable\"))\n\n// Sharp can cause RSS bloat with high-CPU-count machines. See\n// https://github.com/lovell/sharp/issues/955\nconst setupSharp = lazy(() => {\n  _sharp.simd(Settings.enableSIMD.valueOrDefault)\n  _sharp.cache(Settings.enableVipsCache.valueOrDefault)\n  _sharp.concurrency(sharpThreadsPerProcess())\n})\n\nexport async function _imgFromExif_(\n  src: PosixFile,\n  tag: keyof Tags,\n  useBuffer: boolean\n): PromiseMaybe<string | Buffer> {\n  if (useBuffer) {\n    return await exiftool().extractBinaryTagToBuffer(tag, src.nativePath)\n  } else {\n    return (await extractImageForThumbs_(src, tag))?.nativePath\n  }\n}\n\n/**\n * If the file is rotated (in camera or post), there aren't good assumptions to\n * be made regarding the embedded image, so we can't use it.\n *\n * If orientation of the original image is normal, and EXIF thumb aspect ratio\n * agrees with source image, EXIF thumb is valid. In all other jpeg cases, EXIF\n * thumb needs to be ignored. For raw and video, which are much less likely to\n * be edited, if both raw images are landscape, use the orientation.\n */\nexport async function imgFromExif_(\n  src: PosixFile,\n  tags: Maybe<Tags>,\n  tag: keyof Tags,\n  minDim: Dimensions,\n  fileAspectRatio: Maybe<number>\n): PromiseMaybe<SharpReadable> {\n  const val = tags?.[tag] as Maybe<BinaryField>\n  if (!(val instanceof BinaryField)) return\n\n  const useBuffer = val.bytes < Settings.maxEmbeddedBuffer.valueOrDefault\n\n  try {\n    const input = await _imgFromExif_(src, tag, useBuffer)\n    if (input == null) return\n\n    const s = _sharp(input, {\n      failOn: Settings.imageFailOn.valueOrDefault as SharpFailOn\n    })\n    const m = await s.metadata()\n\n    // This is the aspect ratio without taking EXIF orientation into account:\n    const renderedAspectRatio = aspectRatio(m)\n\n    // TODO: when is m.width or m.height not set?\n\n    // If the fileAspectRatio  the aspect ratio incorrect?\n    if (\n      fileAspectRatio != null &&\n      renderedAspectRatio != null &&\n      !closeTo(fileAspectRatio, renderedAspectRatio, 0.2)\n    ) {\n      // (ignore square dimension requests)\n      logger().info(\n        \"imgFromExif(\" +\n          src +\n          \", \" +\n          tag +\n          \"): rejecting (aspect ratio mismatch)\",\n        {\n          fileAspectRatio,\n          renderedAspectRatio\n        }\n      )\n      return\n    }\n\n    const valid = lteBoth(minDim, m)\n\n    logger().debug(\"imgFromExif(\" + src + \", \" + tag + \")\", {\n      valid,\n      minDim,\n      useBuffer,\n      fileAspectRatio,\n      renderedAspectRatio,\n      dim: pick(m, \"width\", \"height\")\n    })\n    return valid\n      ? {\n          sharp: s,\n          file: isString(input) ? PosixFile.for(input) : undefined\n        }\n      : undefined\n  } catch (error) {\n    logger().info(\"Failed to read image from EXIF tag \" + tag, { src, error })\n    return\n  }\n}\n\nexport function toSharp(s: SharpReadable): Sharp {\n  const a: any = s // TODO SITS TS TYPING\n  if (isSharp(a.sharp)) {\n    return a.sharp\n  } else if (isSimpleFile(a.file)) {\n    return _sharp(a.file.nativePath, {\n      failOn: Settings.imageFailOn.valueOrDefault as SharpFailOn\n    })\n  } else {\n    throw new Error(\"toSharp(): not a Sharp object: \" + stringify(s))\n  }\n}\n\ntype HasPosixFile = { file: SimpleFile }\ntype HasSharp = { sharp: _sharp.Sharp }\n\nexport type SharpReadable = HasPosixFile | HasSharp | (HasPosixFile & HasSharp)\n\nexport type Described = { desc: string; rot?: number; mimetype: string }\n\nexport type DescribedSharpReadable = SharpReadable & Described\n\n/**\n * @throws if we can't get `src` into a format that sharp can read.\n */\nexport function sharpReadable_(args: {\n  src: PosixFile\n  minDim?: Dimensions\n  skipEmbedded?: boolean\n}): PromiseMaybe<DescribedSharpReadable> {\n  return time(`img.sharpReadable${args.src.ext.toUpperCase()}`, () =>\n    _sharpReadable_(args)\n  )\n}\n\nasync function _sharpReadable_({\n  src,\n  minDim,\n  skipEmbedded\n}: {\n  src: PosixFile\n  minDim?: Dimensions\n  skipEmbedded?: boolean\n}): PromiseMaybe<DescribedSharpReadable> {\n  const log = logger().addParameterContext(src.nativePath)\n  setupSharp()\n  const mt = await readMimeType(src)\n  if (blank(mt)) {\n    // this shouldn't happen: PosixFileFilters should have rejected this file already!\n    return log.throw(src + \" is not supported (missing MIMEType)\", {\n      doNotSend: true\n    })\n  }\n\n  const sizeInfo = await extractSizeInfoFromFile(src)\n  if (sizeInfo == null) {\n    log.warn(\"Failed to extract size info from \" + src)\n    return\n  }\n\n  const _strategies: ({ desc: string } & LaterMaybe<SharpReadable>)[] = []\n\n  function addStrategy(desc: string, f: LaterMaybe<SharpReadable>) {\n    ;(f as any).desc = desc\n    _strategies.push(f as any)\n  }\n\n  const rot = sizeInfo.rotation\n  const isVideo = isVideoMimeType(mt)\n  const isRaw = isLibrawMimeType(mt)\n\n  // libRaw is _really_ expensive, and doesn't always render correct images\n  // (like with Canon .cr3 and newer Sony cameras): if an embedded preview is\n  // 90% of the desired dimension, and we don't have rotation, just use that.\n\n  const sid = sizeInfo.dimensions\n\n  const dim: Maybe<Dimensions> =\n    minDim ??\n    map2Gt0(sid.width, sid.height, (w, h) => ({\n      width: Math.round(w * 0.9),\n      height: Math.round(h * 0.9)\n    }))\n\n  if (dim?.width == null || dim?.height == null) {\n    return log.throw(src + \" is not supported (missing dimensions)\", {\n      dim,\n      doNotSend: true,\n      mimetype: mt,\n      isRaw,\n      isVideo\n    })\n  }\n\n  // Don't include metadata thumbnails if:\n\n  // 1. src is a video, because some thumbnails are cutesy and add filmstrip\n  //    borders, which we don't really want to try to \"trim\"\n\n  // 2. the on-file dimensions are portrait--this means the image has been\n  //    rotated/edited, and the preview thumbnails are no longer trustworthy\n\n  const fileAspectRatio = aspectRatio(sizeInfo.fileDimensions)\n  const isFilePortrait = lt(fileAspectRatio, 1)\n  const isSharpMimeAndNoMinDim = isSharpMimeType(mt) && minDim == null\n  const isMirrorOrientation = orientationRequiresMirroring(sizeInfo.orientation)\n\n  if (\n    skipEmbedded === true ||\n    isVideo ||\n    isFilePortrait ||\n    isSharpMimeAndNoMinDim ||\n    isMirrorOrientation\n  ) {\n    log.debug(\"not pulling previews from tags\", {\n      isVideo,\n      isFilePortrait,\n      isSharpMimeAndNoMinDim,\n      isMirrorOrientation\n    })\n  } else {\n    const includeSidecars = false\n    const t = await readRawTags(src, includeSidecars)\n    if (t == null) {\n      log.warn(\"Cannot pull previews from tags: readRawTags() failed\")\n    } else {\n      const tagsToExtract = [...Settings.embeddedPreviews.values] as string[]\n      if (minDim != null && dmegapixels(minDim) < 1) {\n        tagsToExtract.unshift(...Settings.embeddedThumbnails.values)\n      }\n      // We're trying to fetch the nearest thumbnail to deliver at least minDim.\n      // Previews compressed more than 95% will look terrible:\n      const minBytes = dim.width * dim.height * 0.05\n      const sizeSortedTagNames = sortBy(\n        tagsToExtract.filter(key => (t as any)[key] instanceof BinaryField),\n        key => {\n          const bytes = (t as any)[key]?.bytes\n          return gt(bytes, minBytes) ? bytes : undefined\n        }\n      )\n      if (!isEmpty(sizeSortedTagNames)) {\n        log.debug(\"checking previews from tags\", { sizeSortedTagNames })\n        for (const ea of sizeSortedTagNames) {\n          addStrategy(\"imgFromExif.\" + ea, () =>\n            imgFromExif_(src, t, ea as any, dim, fileAspectRatio)\n          )\n        }\n      }\n    }\n  }\n\n  if (isSharpMimeType(mt)) {\n    addStrategy(\"sharp\", async () => ({ file: src }))\n  }\n\n  if (isHeifMimeType(mt) && (await isHeifSupported())) {\n    addStrategy(\"heif\", () => thenMap(heif2img(src), file => ({ file })))\n  }\n\n  if (isRaw) {\n    addStrategy(\"raw2tiff\", () => thenMap(raw2tiff_(src), file => ({ file })))\n  }\n\n  if (isVideo) {\n    addStrategy(\"extractVideoFrame\", async () => {\n      if (!(await isVideoSupported())) {\n        log.warn(\"video file, but video support is missing\", {\n          src: src.nativePath,\n          mimetype: mt,\n          minDim\n        })\n        return\n      } else {\n        try {\n          return await thenMap(extractVideoFrame_(src), file => ({ file }))\n        } catch (error: any) {\n          throw new WrappedError(\n            \"Failed to extract video frame for \" + src,\n            error\n          )\n        }\n      }\n    })\n  }\n\n  const causes: Error[] = []\n\n  for (const s of _strategies) {\n    try {\n      const result = await time(\"img.read.\" + s.desc, s)\n      if (result != null) {\n        log.debug(s.desc + \" strategy succeeded\", {\n          src,\n          minDim,\n          rot,\n          img: (result as any).file?.nativePath\n        })\n        return {\n          desc: s.desc,\n          rot,\n          mimetype: mt,\n          ...result\n        }\n      } else {\n        log.debug(s.desc + \" returned null\", {\n          src,\n          minDim,\n          rot\n        })\n      }\n    } catch (error) {\n      log.warn(s.desc + \" failed\", error)\n      causes.push(toErr(error)!)\n    }\n  }\n\n  throw new WrappedError(\"Failed to render \" + src, {\n    causes,\n    path: String(src),\n    fatal: false,\n    doNotSend: true,\n    retriable: false\n  })\n}\n\n/**\n * Returns a file holding the binary stream associated to the given tag.\n * Orientation is copied from the src to the result.\n */\nexport async function extractImageForThumbs_(\n  src: PosixFile,\n  tag: keyof Tags\n): PromiseMaybe<PosixFile> {\n  const suffix = tag.toLowerCase().endsWith(\"tiff\") ? \".tiff\" : \".jpg\"\n  try {\n    // extracting a binary tag takes millis. No need to re-use between\n    // processes, because handling errors and lock contention is something we\n    // can just skip here.\n    const f = await tmpImageFile_({ src, tag, ext: suffix })\n    return await f.applyIfEmpty_({\n      retries: 2,\n      fn_: dest => extractBinaryTag(tag, src.nativePath, dest.nativePath),\n      timeoutMs: commandTimeoutMs()\n    })\n  } catch (error) {\n    // if this returns undefined, applyIfEmpty_ will wait for a timeout.\n    logger().throw(\n      \"Failed to extract embedded \" + tag + \" from \" + src.nativePath,\n      { error }\n    )\n    return\n  }\n}\n","import { lerp2d } from \"../../core/math/Lerp\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { orElse } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { KB, MB } from \"../../fe/Units\"\nimport { mapGt0 } from \"../Number\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { thenMap } from \"../async/Promise\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { readRawTags } from \"../tags/ExifTool\"\nimport { isRawImageExt, isVideoExt } from \"../tags/FileTypes\"\nimport { MinIoRate, commandTimeoutMs } from \"../volumes/VolumeTtls\"\n\n// Handle general system churn/hiccups/external drive spinups:\nexport const MinSyncFileTimeoutMs = minuteMs\n\n// This number needs to be greater than the slowest computer's file processing\n// time under load.\n\n// TODO: LATER: make timeouts more accurate by using the current system's\n// processing times.\n\nexport const BytesPerSecond = KB\n\n// Sync file time is going to be governed by\n\n// 1. DB insert time (normally less than a second, let's say 5 seconds)\n// 2. Metadata extraction (should be less than a second, worst-case, 30 seconds)\n// 3. Copy to library (assume 4-5mb/sec transfer speed for a slow nas, should\n//    typically be more like 20-50mb/s, though) + SHA, == MaxFileSize / 4mb\n// 4. Thumbnail generation (normally less than a second, can be 30 seconds for\n//    RAW images)\n// 5. Video transcoding (may a no-op, or only be remuxing, which is fast, or\n//    actual transcoding, which is ~1-50x longer than the actual duration of the\n//    video, and can be limited by disk I/O as well).\n\n// linux timings:\n//           ubu mac win\n//  7M .MTS:     30s\n// 18M .MTS: 23s 60s\n// 8M  .AVI: 4s\n// 30M .MOV: 18s 40s\n\n// HEVC is ~2MB/second for 1080p/30, and 12Mb/s for 4k/60, but transcode time\n// varies _widely_, and ffmpeg doesn't seem to hang, so we'll just use the\n// file size as a proxy for transcode time.\n\n// 5,931 ms for speedy to convert 56,637,237 bytes, so roughly 10mb/s, or divide bytes by 10,000 to get millis.\n\n// I suspect RPi to be 6-10x slower, so 1mb/s: divide bytes by 1000.\n\n// These timings are all from the Raspberry Pi 4, the slowest supported CPU.\n\nconst ImagePoints = {\n  p0: { x: 0.8 * MB, y: 4 * secondMs },\n  p1: { x: 20 * MB, y: 12 * secondMs }\n}\n\nconst RawPoints = {\n  p0: { x: 11 * MB, y: 12 * secondMs },\n  p1: { x: 26 * MB, y: 24 * secondMs }\n}\n\nexport function syncFileTimeoutForFileMs(file: PosixFile) {\n  return thenMap(syncFileTimeoutForFile(file), ea => ea.result)\n}\n\nexport function syncFileTimeoutForFile(file: PosixFile) {\n  return thenMap(readMeta(file), syncFileTimeout)\n}\n\nfunction readMeta(file: PosixFile): PromiseMaybe<FileTimeoutMeta> {\n  return thenMap(file.size(), async bytes => ({\n    bytes,\n    ext: file.ext,\n    durationMs: isVideoExt(file.ext)\n      ? await thenMap(readRawTags(file), t =>\n          mapGt0(t.Duration, d => d * secondMs)\n        )\n      : undefined\n  }))\n}\n\nexport interface FileTimeoutMeta {\n  bytes: number\n  ext: string\n  durationMs?: number\n}\n\nexport function dcrawTimeout(bytes: Maybe<number>): number {\n  return lerp2d(\n    clamp(11 * MB, 100 * MB, orElse(bytes, 0)),\n    RawPoints.p0,\n    RawPoints.p1\n  )\n}\n\nexport function syncFileTimeout(meta: FileTimeoutMeta) {\n  if (isVideoExt(meta.ext)) return { result: 0 }\n\n  // Time to sync is DB + tags + copy op + sha + thumbs + transcode.\n\n  // db lookup time. Should be ~10ms, but the system might be borked:\n  const dbMs = ShortCommandTimeoutMs\n\n  // tag extraction time. Should be normally ~5-50ms, but we may need to fetch\n  // tags for sibling variants (5? 10?) over a slow LAN NAS.\n  const tagMs = commandTimeoutMs()\n\n  // Copy time will be directly proportional to the asset size. Assume 2mb/s for\n  // a really crappy NAS and a 100baseT network, and that we need to do it twice\n  // (once to copy, once to SHA-verify the copy):\n\n  const copyMs = meta.bytes / MinIoRate\n\n  const lerpPoints = (p: typeof ImagePoints) =>\n    lerp2d(clamp(0.5 * MB, 50 * MB, meta.bytes), p.p0, p.p1)\n\n  const thumbMs = lerpPoints(ImagePoints)\n\n  const rawDecodeMs = isRawImageExt(meta.ext) ? lerpPoints(RawPoints) : 0\n\n  const result = Math.max(\n    MinSyncFileTimeoutMs,\n    dbMs + tagMs + copyMs + thumbMs + rawDecodeMs\n  )\n\n  return {\n    result,\n    dbMs,\n    tagMs,\n    copyMs,\n    thumbMs,\n    rawDecodeMs\n  }\n}\n","import _sharp, { FailOnOptions } from \"sharp\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { mkLogger } from \"../Logger\"\nimport { shim1 } from \"../Shim1\"\nimport { includesIgnoreCase } from \"../String\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { FileCache } from \"../fs/FileCache\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport {\n  SimpleFileOrString,\n  isSimpleFile,\n  toNativePath_\n} from \"../fs/SimpleFile\"\nimport { Settings } from \"../settings/Settings\"\nimport { isVideoMimeType } from \"../tags/MimeTypes\"\nimport { readMimeType } from \"../tags/ReadMimeType\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { isSharp } from \"./Sharp\"\nimport { DescribedSharpReadable, sharpReadable_ } from \"./SharpReadable\"\nimport { validVideo_ } from \"./Video\"\nimport { validJpeg_ } from \"./jpegtran\"\n\nconst logger = lazy(() => mkLogger(\"img.ValidFile\"))\n\n/**\n * @return true if the file is valid, or false if the file is invalid.\n */\nexport async function isValidFile(\n  fileOrPath: SimpleFileOrString\n): Promise<boolean> {\n  return blank(await whyInvalidFile(toNativePath_(fileOrPath)))\n}\n\n/**\n * Try to validate the contents of an image or video are not corrupt\n * @throws on invalid file\n */\nexport async function throwIfInvalidFile_(\n  fileOrPath: SimpleFileOrString\n): Promise<void> {\n  if (\n    // it's turned off:\n    !Settings.validateJpegImages.valueOrDefault &&\n    !Settings.validateRawImages.valueOrDefault &&\n    !Settings.validateVideos.valueOrDefault\n  ) {\n    logger().debug(\"file validation is disabled for \" + fileOrPath, {\n      validateJpegImages: Settings.validateJpegImages.valueOrDefault,\n      validateRawImages: Settings.validateRawImages.valueOrDefault,\n      validateVideos: Settings.validateVideos.valueOrDefault\n    })\n    return\n  }\n  const nativePath = toNativePath_(fileOrPath)\n\n  const why = logger().tap({\n    msg: \"whyInvalidFile(\" + nativePath + \")\",\n    result: await whyInvalidFile(nativePath)\n  })\n\n  if (notBlank(why)) {\n    logger().throw(why, {\n      path: nativePath,\n      retriable: false,\n      doNotSend: true, // we expect these to happen.\n      ignorable: true // we expect these to happen.\n    })\n  }\n}\n\nconst cache = lazy(\n  () =>\n    new FileCache<string>({\n      name: \"img.validFile\",\n      maxSize: 256,\n      // https://forum.photostructure.com/t/initial-import-of-library-fails/1643/2\n      timeoutMs: Math.max(\n        minuteMs,\n        Settings.validateVideos.valueOrDefault\n          ? 5 * minuteMs\n          : commandTimeoutMs()\n      )\n    })\n)\n\nexport function clearInvalidFileCache() {\n  return cache().clear()\n}\n\nexport const whyInvalidFile = shim1({\n  name: \"img.whyInvalidFile\",\n  cache,\n  toKey: toNativePath_,\n  impl: async (nativePath: string) => {\n    const src = PosixFile.for(nativePath)\n    if (!(await src.isFile()) || !(await src.isReadable())) {\n      return src + \" is not a readable file\"\n    }\n    if (await src.isEmpty()) {\n      return src + \" is empty\"\n    }\n    // Use the raw tags--if we're missing dimensions or something else, it still\n    // might be valid.\n    try {\n      const mt = await readMimeType(src)\n      if (mt == null) {\n        throw new Error(\"Cannot validate, no mimetype\")\n      }\n      if (isVideoMimeType(mt)) {\n        if (Settings.validateVideos.valueOrDefault) {\n          logger().debug(\"validating \" + src)\n          await validVideo_(src)\n        }\n      } else if (mt.startsWith(\"image/\")) {\n        if (mt === \"image/jpeg\") {\n          if (Settings.validateJpegImages.valueOrDefault) {\n            await validJpeg_(src)\n          }\n        } else if (Settings.validateRawImages.valueOrDefault) {\n          if (\n            includesIgnoreCase(Settings.validateMimetypeSkiplist.values, mt)\n          ) {\n            logger().info(\n              \"Skipping validation of \" +\n                src +\n                \": validateMimetypeSkiplist matches\",\n              { mime: mt }\n            )\n          } else {\n            // heif? what else?\n            const sr = await sharpReadable_({ src, skipEmbedded: true })\n            const s = await toSharpFailOnError(sr)\n            await s.tiff().toBuffer()\n          }\n        }\n      } else {\n        throw new Error(\"Unsupported mimetype \" + stringify(mt))\n      }\n      return \"\"\n    } catch (cause) {\n      // The error doesn't need to include the filename: the sync report will\n      // already be on that line.\n      return new WrappedError(\"Failed to validate\", {\n        cause,\n        path: nativePath,\n        doNotSend: true\n      }).toS()\n    }\n  }\n})\n\nasync function toSharpFailOnError(\n  input: Maybe<DescribedSharpReadable>,\n  failOn: FailOnOptions = Settings.imageFailOn.valueOrDefault as FailOnOptions\n): Promise<_sharp.Sharp> {\n  const a: any = input\n\n  if (isSimpleFile(a.file)) {\n    return _sharp(a.file.nativePath, { failOn })\n  }\n\n  if (isSharp(a.sharp)) {\n    const { data, info } = await a.sharp\n      .raw()\n      .toBuffer({ resolveWithObject: true })\n    return _sharp(data, { ...info, failOnError: true })\n  }\n\n  throw new Error(\"Cannot read input \" + input?.desc)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../Logger\"\nimport { orRegExpPatterns } from \"../RegExp\"\nimport { errorToS } from \"../error/Error\"\nimport { Settings } from \"../settings/Settings\"\n\nconst logger = lazy(() => mkLogger(\"img.ValidationError\"))\n\nexport function isIgnorableValidationError(err: any) {\n  const s = errorToS(err)\n  return logger().tap({\n    msg: \"isIgnorableValidationError\",\n    result:\n      validationErrorAllowlist().test(s) || !validationErrorBlocklist().test(s),\n    meta: { err }\n  })\n}\nconst validationErrorBlocklist = lazy(() =>\n  orRegExpPatterns(Settings.validationErrorBlocklist.values, \"i\")\n)\nconst validationErrorAllowlist = lazy(() =>\n  orRegExpPatterns(Settings.validationErrorAllowlist.values, \"i\")\n)\n","import { Tags } from \"exiftool-vendored\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { fitInside } from \"../../fe/Fit\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport {\n  clamp,\n  closeTo,\n  gt0,\n  gte,\n  roundEven,\n  sigFigs,\n  toGt0\n} from \"../../fe/Number\"\nimport { gt } from \"../../fe/Primitive\"\nimport { mkLogger } from \"../Logger\"\nimport { isProd } from \"../NodeEnv\"\nimport { mapGt0 } from \"../Number\"\nimport { shim1 } from \"../Shim1\"\nimport { includesIgnoreCase } from \"../String\"\nimport { TTLMap } from \"../TTLMap\"\nimport { Deferred } from \"../async/Deferred\"\nimport { time } from \"../async/PromiseTimer\"\nimport { untilTrue } from \"../async/until\"\nimport { ee } from \"../event/EventEmitter\"\nimport { FileCache } from \"../fs/FileCache\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFile, toNativePath_ } from \"../fs/SimpleFile\"\nimport { lerp2d } from \"../math/Lerp\"\nimport { max } from \"../math/Vector\"\nimport { PullProgressObserver } from \"../progress/PullProgressObserver\"\nimport { Settings } from \"../settings/Settings\"\nimport { extractBitrateKbps } from \"../tags/Bitrate\"\nimport { extractDurationSec } from \"../tags/Duration\"\nimport { deleteAllTags_, readRawTags, readTags } from \"../tags/ExifTool\"\nimport { isVideoMimeType } from \"../tags/MimeTypes\"\nimport { extractRotation } from \"../tags/Orientation\"\nimport { extractSizeInfoFromTags } from \"../tags/SizeInfo\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { dimensions } from \"./FileDimensions\"\nimport { cachedImageFile_ } from \"./ImageCache\"\nimport { ToolDetails } from \"./ToolDetails\"\nimport {\n  ffmpegFrame_,\n  ffmpegTranscode_,\n  ffmpegValidVideo_,\n  ffmpegVersion_,\n  isFFmpegSupported\n} from \"./ffmpeg\"\n\nconst logger = lazy(() => mkLogger(\"img.Video\"))\n\nfunction mkLog(method: string, src: string | SimpleFile) {\n  return mkLogger(\"img/Video.\" + method + \"(\" + src + \")\")\n}\n\nexport async function getVideoToolDetails_(opts?: {\n  ignoreffmpeg: any\n}): PromiseMaybe<ToolDetails> {\n  if (isProd) opts = undefined\n  return isTrue(opts?.ignoreffmpeg) ? undefined : await ffmpegVersion_()\n}\n\nexport const isVideoSupported = lazy(async () => {\n  try {\n    return (await getVideoToolDetails_())?.isSupportedVersion === true\n  } catch (error) {\n    logger().warn(\"isVideoSupported\", { error })\n    return false\n  }\n})\n\nlater(() => ee().on(\"clearCache\", () => isVideoSupported.unset()))\n\n// These are \"high quality\" bitrates for a given video resolution.\nexport const bitrateKps = (pixelCount: number) =>\n  sigFigs(\n    lerp2d(\n      pixelCount,\n      { x: 320 * 240, y: Settings.transcodeBitrateQVGA.valueOrDefault },\n      { x: 3840 * 2160, y: Settings.transcodeBitrateUHD.valueOrDefault }\n    ),\n    2\n  )\n\nfunction extractMaxBitrate(src: PosixFile, rawTags: Tags) {\n  const log = mkLog(\"extractMaxBitrate\", src)\n  // These dimensions will be enforced by PosixFileFilters, before this. We need\n  // reasonable dimensions to give to VLC, though, so re-validating them here is\n  // excusable. Hopefully.\n  const minDim = Settings.minVideoDimension.valueOrDefault\n  const width = rawTags.ImageWidth\n  if (width != null && !gte(width, minDim)) {\n    return log.throw(\"invalid width: \" + width, { ignorable: true })\n  }\n  const height = rawTags.ImageHeight\n  if (height != null && !gte(height, minDim)) {\n    return log.throw(\"invalid height: \" + height, { ignorable: true })\n  }\n\n  const bitrateKbps =\n    extractBitrateKbps(rawTags) ?? Settings.transcodeBitrateUHD.valueOrDefault\n\n  // Don't let video bitrate exceed the encoded bitrate:\n  const videoBitrateKbps = mapGt0(width, w =>\n    mapGt0(height, h => clamp(0, bitrateKbps, bitrateKps(w * h)))\n  )\n\n  const result = { width, height, videoBitrateKbps }\n  log.debug(\"dim()\", { src, result })\n  return result\n}\n\nconst cache = lazy(\n  () =>\n    new FileCache<string>({\n      name: \"img.videoFrame\",\n      timeoutMs: minuteMs\n    })\n)\n\nexport async function extractVideoFrame_(file: string | PosixFile) {\n  return (await isVideoSupported())\n    ? PosixFile.for(await _extractVideoFrame_(toNativePath_(file)))\n    : undefined\n}\n\n// only exported for shim\nexport const _extractVideoFrame_ = shim1({\n  name: \"img.extractVideoFrame\",\n  cache,\n  impl: (nativePath: string) => __extractVideoFrame_(nativePath)\n})\n\n// only exported for tests\nexport async function __extractVideoFrame_(\n  nativePath: string,\n  forceImpl?: {\n    useFfmpeg?: boolean\n  }\n): Promise<string> {\n  const log = mkLog(\"extractVideoFrame\", nativePath)\n  const src = PosixFile.for(nativePath)\n  const useFfmpeg = isTrue(forceImpl?.useFfmpeg) || (await isFFmpegSupported()) // < try to use ffmpeg if possible\n  if (!useFfmpeg) return log.throw(\"no video implementation\")\n\n  // We don't use BaseFile.applyIfEmpty here, because we want to verify the\n  // dimensions are reasonable:\n\n  const dest = await cachedImageFile_(src, \"frame\", \".jpg\")\n  log.debug(\"extractVideoFrame(\" + dest + \")\")\n\n  const srcMtime = await src.mtimeMs()\n  if (srcMtime == null) {\n    return log.throw(\"null mtime\")\n  }\n\n  const rawTags = await readRawTags(src)\n  if (rawTags == null) {\n    return log.throw(\"no tags\")\n  }\n  const rot = extractRotation(rawTags)\n  log.debug(\"video orientation:\" + rot)\n\n  // Note that width and height may be missing from videos like AVCHD:\n  const srcDim = extractSizeInfoFromTags(rawTags, rot)?.dimensions\n\n  const destStat = await dest.stat()\n  // If the file doesn't exist, don't tease ExifTool:\n  const destDim = destStat == null ? undefined : await dimensions(dest)\n\n  if (\n    destStat != null &&\n    destStat.mtimeMs > srcMtime &&\n    destDim != null &&\n    (srcDim == null ||\n      (destDim.height === srcDim.height && destDim.width === srcDim.width))\n  ) {\n    log.debug(\"prior dest, \" + dest + \" seems reasonable\", { srcDim, destDim })\n    return dest.nativePath\n  }\n  const duration = extractDurationSec(rawTags)\n  const startAtSec = Math.min(\n    duration ?? 0,\n    Settings.videoFrameAtSec.valueOrDefault\n  )\n  log.info(\"extracted metadata\", {\n    startAtSec,\n    duration\n  })\n\n  await dest.applyIfEmpty_({\n    fn_: async destWip => {\n      const args = {\n        src,\n        dest: destWip,\n        startAtSec,\n        ...srcDim\n      }\n\n      await ffmpegFrame_(args)\n\n      if (\n        false ===\n        (await untilTrue(\n          async () =>\n            log.tap({\n              msg: \"frame extracted?\",\n              result: await destWip.clear().isNonEmptyFile()\n            }),\n          { timeoutMs: 5 * secondMs, intervalMs: 500 }\n        ))\n      ) {\n        log.throw(\"ffmpeg failed to extract frame\")\n      }\n\n      await deleteAllTags_(destWip, destWip)\n\n      // If we have to add VLC support again, remember that it doesn't\n      // auto-rotate. FFmpeg does.\n      // if (useVlc && rot != null && rot !== 0) {\n      //   log.info(\"rotating in place...\" + destWip, { rot })\n      //   await rotateInPlace_(destWip, rot)\n      // }\n    },\n    timeoutMs: commandTimeoutMs()\n  })\n  return dest.nativePath\n}\n\nexport async function isVideoTranscodingSupported() {\n  return Settings.transcodeVideos.valueOrDefault && (await isFFmpegSupported())\n}\n\nexport async function needsTranscoding(f: PosixFile) {\n  const log = mkLog(\"needsTranscoding\", f)\n\n  if (!(await isVideoTranscodingSupported())) {\n    return log.tap({\n      msg: \"videoTranscodingSupported is false\",\n      result: false\n    })\n  }\n\n  const t = await readRawTags(f)\n  if (t == null) {\n    return log.tap({\n      msg: \"Cannot transcode files that exiftool can't read\",\n      result: false\n    })\n  }\n\n  const mimetype = t.MIMEType!\n\n  if (!isVideoMimeType(mimetype)) {\n    return log.tap({\n      msg: \"not transcoding (unsupported mimetype)\",\n      result: false,\n      meta: { mimetype }\n    })\n  }\n\n  const duration = extractDurationSec(t)\n\n  if (!gt(duration, Settings.minVideoDurationSec.valueOrDefault)) {\n    return log.tap({\n      msg: \"not transcoding (video duration is too short)\",\n      result: false,\n      meta: { duration }\n    })\n  }\n\n  const audioCodecs = compactBlanks([t.AudioFormat])\n  const isSafeAudioCodec = audioCodecs.some(ea =>\n    includesIgnoreCase(Settings.doNotTranscodeAudioCodecs.values, ea)\n  )\n\n  const videoCodecs = compactBlanks([\n    t.VideoCodec,\n    t.CompressorID,\n    (t as any).CompressorName\n  ])\n  const isSafeVideoCodec = videoCodecs.some(ea =>\n    includesIgnoreCase(Settings.doNotTranscodeVideoCodecs.values, ea)\n  )\n\n  const isSafeMimeType = includesIgnoreCase(\n    Settings.doNotTranscodeMimeTypes.values,\n    mimetype\n  )\n\n  return log.tap({\n    level: \"info\",\n    msg: \"result\",\n    result: !(isSafeAudioCodec && isSafeVideoCodec && isSafeMimeType),\n    meta: {\n      mimetype,\n      isSafeMimeType,\n      audioCodecs,\n      isSafeAudioCodec,\n      videoCodecs,\n      isSafeVideoCodec\n    }\n  })\n}\n\n/**\n * @return true iff `dest` seems to be an up to date transcoded version of\n * `src`\n */\nasync function isTranscodeOf(src: PosixFile, dest: PosixFile) {\n  const destRawTags = await readRawTags(dest)\n  const srcRawTags = await readRawTags(src)\n  const srcDurationSec = extractDurationSec(srcRawTags)\n  const destDurationSec = extractDurationSec(destRawTags)\n  return logger().tap({\n    msg: \"isTranscodeOf()\",\n    result: closeTo(srcDurationSec, destDurationSec, 1.5),\n    meta: {\n      srcDurationSec,\n      destDurationSec,\n      src: src.nativePath,\n      dest: dest.nativePath\n    }\n  })\n}\n\nconst currentTranscodes = new TTLMap<string, Deferred<void>>(15 * minuteMs)\n\n/**\n * This will no-op if a reasonable transcoded video already exists at dest (unless ctx.force is true)\n */\nexport async function transcode_(\n  src: PosixFile,\n  dest: PosixFile,\n  ctx?: { force?: boolean }\n): PromiseMaybe<PosixFile> {\n  if (!(await isVideoTranscodingSupported())) {\n    return\n  }\n\n  const log = mkLog(\"transcode\", src)\n\n  const prior = currentTranscodes.get(dest.nativePath)\n  if (prior != null && !isTrue(ctx?.force)) {\n    // TODO: What if src doesn't match the prior src? kill the prior?\n    log.info(\"already transcoding\", { dest, priorSrc: prior.name })\n    return prior.promise.then(() => dest)\n  }\n  const d = new Deferred<void>(src.nativePath)\n  currentTranscodes.set(dest.nativePath, d)\n\n  if (false === (await needsTranscoding(src))) {\n    log.info(\"no transcoding needed\")\n    return\n  }\n\n  const filesize = await src.size()\n  if (!gt0(filesize)) {\n    return log.throw(\"source is empty or cannot read\")\n  }\n\n  const srcTags = await readTags(src)\n  if (srcTags == null) {\n    return log.throw(\"source cannot be read by ExifTool\")\n  }\n\n  if (true === ctx?.force) {\n    await dest.unlink()\n  } else {\n    if (await isTranscodeOf(src, dest)) {\n      log.info(\"no-op, dest duration looks reasonable\", { dest })\n      return dest\n    }\n  }\n\n  return time(\"video.transcode()\", async () => {\n    const durationSec = extractDurationSec(srcTags) ?? 60\n    const args: any = {\n      src,\n      ...extractMaxBitrate(src, srcTags)\n    }\n    const expectedFilesize = guessExpectedSize(\n      filesize,\n      args.videoBitrateKbps,\n      durationSec\n    )\n\n    const maxDim = Settings.transcodeMaxDim.valueOrDefault\n    const srcMaxDim = max([srcTags.dimensions.height, srcTags.dimensions.width])\n    if (gt0(maxDim) && gt(srcMaxDim, maxDim)) {\n      const output = fitInside(srcTags.dimensions, {\n        width: maxDim,\n        height: maxDim\n      })\n      if (output == null) {\n        log.warn(\n          \"Cannot downsample transcoded video: fitInside() returned null\",\n          { input: srcTags.dimensions, maxPixels: maxDim }\n        )\n      } else {\n        // libx264 requires even dimensions:\n        args.width = roundEven(output.width)\n        args.height = roundEven(output.height)\n        log.info(\"Downsampling transcoded video\", {\n          original: srcTags.dimensions,\n          output\n        })\n      }\n    }\n\n    const _transcode_ = async (destWip: PosixFile) => {\n      log.info(\"starting...\", { destWip })\n      const obs = new PullProgressObserver(\n        { path: src.nativePath, op: \"Transcoding video\" },\n        expectedFilesize,\n        async () => {\n          return (await dest.clear().size()) ?? 0\n        }\n      )\n\n      args.dest = destWip\n\n      args.fps = toGt0(srcTags.VideoFrameRate)\n\n      const result = await obs.observe(ffmpegTranscode_(args))\n      if (result.code !== 0) {\n        log.throw(\"transcode failed with code \" + result.code)\n      }\n    }\n\n    await dest.applyWip_({\n      fn_: destWip => _transcode_(destWip),\n      skipFsLock: false,\n      timeoutMs: 0\n    })\n    return dest\n  })\n}\n\nexport function guessExpectedSize(\n  filesize: number,\n  videoBitrateKbps: Maybe<number>,\n  durationSec: Maybe<number>\n) {\n  return Math.min(\n    filesize,\n    // SITS: these constants are not really defensible\n    (durationSec ?? 10) * (videoBitrateKbps ?? 1000)\n  )\n}\n\n/**\n * @throws on errors\n */\nexport async function validVideo_(src: PosixFile) {\n  // quick pre-check:\n  const f = await extractVideoFrame_(src)\n  if (f == null) {\n    mkLog(\"validVideo\", src).throw(\"Could not extract a video frame\")\n  }\n  return ffmpegValidVideo_(src)\n}\n","import { satisfies } from \"semver\"\nimport { compact, compactBlanks } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { isDisabled } from \"../../fe/Boolean\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { Dimensions } from \"../../fe/Dimensions\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0, lte, roundEven, sigFigs } from \"../../fe/Number\"\nimport { toS } from \"../../fe/toS\"\nimport { lazy } from \"../Lazy\"\nimport { mkLogger } from \"../Logger\"\nimport { mapGte0f } from \"../Number\"\nimport { thenMapOr } from \"../async/Promise\"\nimport { untilTrue } from \"../async/until\"\nimport { StdoutResult, stdoutResult_ } from \"../child/ChildProcess\"\nimport { errorToS } from \"../error/Error\"\nimport { ee } from \"../event/EventEmitter\"\nimport { pathTo } from \"../fs/PathTo\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { unlink } from \"../fs/Unlink\"\nimport { Settings } from \"../settings/Settings\"\nimport { debianVersionToSemver } from \"../version/SemVer\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { ToolDetails } from \"./ToolDetails\"\nimport { isIgnorableValidationError } from \"./ValidationErrors\"\nimport { ffmpegThreads } from \"./ffmpegThreads\"\n\nconst logger = lazy(() => mkLogger(\"img.ffmpeg\"))\n\n// This may be something reasonable, like \"ffmpeg version 3.2.1\", but if it's a\n// nightly build, \"ffmpeg version N-94833-g9d1e98afee\"\nconst versionRe = /ffmpeg version (?<version>\\S+)/i\n\nconst _ffmpegVersion_ = lazy<PromiseMaybe<ToolDetails>>(async () => {\n  const ffmpegPath = await pathTo({\n    tool: \"ffmpeg\",\n    alternativePath: Settings.ffmpegPath.valueOrDefault\n  })\n  if (ffmpegPath == null) {\n    logger().info(\"failed to find ffmpeg in $PATH\", {\n      ffmpegPath: Settings.ffmpegPath.valueOrDefault\n    })\n    return\n  }\n  const result = await stdoutResult_(ffmpegPath, [\"-version\"], {\n    timeoutMs: commandTimeoutMs(),\n    ignoreStderr: true\n  })\n  const version: Maybe<string> = versionRe.exec(result.result)?.[1]\n  logger().debug(\"ffmpegVersion\", {\n    version,\n    code: result.code,\n    stdout: result.result.split(\"\\n\", 1)[0]\n  })\n  return {\n    path: ffmpegPath,\n    version: version ?? \"(unknown)\",\n    isSupportedVersion:\n      map(debianVersionToSemver(version), ea => satisfies(ea, \">=3.2\")) ?? false\n  }\n})\n\nexport const ffmpegVersionDescription = lazy(() =>\n  thenMapOr(\n    _ffmpegVersion_(),\n    ver => \"version \" + ver,\n    () => \"(not found)\"\n  )\n)\n\nfunction clearCaches() {\n  _ffmpegVersion_.unset()\n  ffmpegVersionDescription.unset()\n}\n\nlater(() => {\n  ee().on(\"clearCache\", clearCaches)\n  ee().on(\"clearToolCache\", clearCaches)\n})\n\nexport async function ffmpegVersion_(): PromiseMaybe<ToolDetails> {\n  return (await _ffmpegVersion_.prior()) ?? _ffmpegVersion_.refresh()\n}\n\nexport async function isFFmpegSupported() {\n  // TODO: what versions do we *actually* require?\n  return (await _ffmpegVersion_()) != null\n}\n\n// Example errors:\n\n// [h264 @ 0x5642cf833640] left block unavailable for requested intra mode\n\n// [h264 @ 0x5642cf833640] error while decoding MB 0 16, bytestream 99553\n\n// [mov,mp4,m4a,3gp,3g2,mj2 @ 0x556e03cfb8c0] stream 0, offset 0x184ef: partial file\n\n// Invalid data found when processing input\n\n// Nothing was written into output file 0 (pipe:), because at least one of its streams received no packets.\n\n// Error: [mov,mp4,m4a,3gp,3g2,mj2 @ 0x560b7c7f59a0] Referenced QT chapter track not found\n\n/*\n-vframes number (output) Set the number of video frames to output. This is an\nalias for \"-frames:v\".\n\n-f fmt (input/output) Force input or output file format. The format is normally\nauto detected for input files and guessed from the file extension for output\nfiles, so this option is not needed in most cases.\n\npipe:[number] number is the number corresponding to the file descriptor of the\npipe (e.g. 0 for stdin, 1 for stdout, 2 for stderr). If number is not specified,\nby default the stdout file descriptor will be used for writing, stdin for\nreading.\n\n-ss position (input/output) When used as an input option (before -i), seeks in\nthis input file to position. Note that in most formats it is not possible to\nseek exactly, so ffmpeg will seek to the closest seek point before position.\nWhen transcoding and -accurate_seek is enabled (the default), this extra segment\nbetween the seek point and position will be decoded and discarded. When doing\nstream copy or when -noaccurate_seek is used, it will be preserved.\n\nWhen used as an output option (before an output url), decodes but discards input\nuntil the timestamps reach position.\n\nposition must be a time duration specification, see (ffmpeg-utils)the Time\nduration section in the ffmpeg-utils(1) manual.\n*/\nexport async function ffmpegFrame_(args: {\n  src: PosixFile\n  dest: PosixFile\n  startAtSec?: number\n  width?: number\n  height?: number\n}) {\n  await args.dest.parent().mkdirp_()\n\n  await stdoutResult_(\n    Settings.ffmpegPath.valueOrDefault,\n    compact([\n      // we don't use hwaccel here: it doesn't speed things up.\n      \"-loglevel\",\n      \"error\",\n      \"-i\",\n      args.src.nativePath,\n      ...(mapGte0f(args.startAtSec, ea => [\"-ss\", ea.toFixed(1)]) ?? []),\n      \"-vframes\",\n      \"1\",\n      // This didn't seem to really help much, and made it slower.\n      // \"-q:v\", // require quality to be <= 2 (range between 1 and 31)\n      // \"2\",\n      // This seems to lead to distorted outputs?\n      // ...(args.width != null && args.height != null\n      //   ? [\"-s\", `${round(args.width)}x${round(args.height)}`]\n      //   : []),\n      \"-y\", // overwrite output files\n      args.dest.nativePath\n    ]),\n    {\n      timeoutMs: minuteMs, // extracting a single frame should take less than a second.\n      isIgnorableError: isIgnorableValidationError\n    }\n  )\n  if (\n    !(await untilTrue(() => args.dest.clear().isNonEmptyFile(), {\n      timeoutMs: 3 * secondMs\n    }))\n  ) {\n    throw new Error(\"Failed to extract frame for \" + args.src)\n  }\n}\n\nfunction hwaccel(args: { ffmpegHwaccel?: string }) {\n  const s = args?.ffmpegHwaccel ?? Settings.ffmpegHwaccel.valueOrDefault\n  return blank(s) || isDisabled(s) ? [] : [\"-hwaccel\", s]\n}\n\nexport function avcArgs(args: Partial<Dimensions>): string[] {\n  const result = [...Settings.ffmpegAvcTranscodeArgs.values] as string[]\n\n  if (\n    !gt0(args.width) ||\n    !gt0(args.height) ||\n    !gt0(Settings.transcodeMaxDim.valueOrDefault)\n  ) {\n    return result\n  }\n\n  // the `-vf scale=720x480` format doesn't seem to work (!?!)\n  // see: https://ffmpeg.org/ffmpeg.html#filter_005foption and\n\n  const w = roundEven(args.width)\n  const h = roundEven(args.height)\n\n  const dim = w + \"x\" + h\n  switch (Settings.ffmpegScaleType.valueOrDefault) {\n    case \"s\":\n      return [\"-s\", dim, ...result]\n    case \"vf\":\n      const vfIdx = result.indexOf(\"-vf\")\n      if (vfIdx >= 0) {\n        result[vfIdx + 1] += \":scale=\" + dim\n      } else {\n        result.push(\"-vf\", \"scale=\" + dim)\n      }\n      return result\n  }\n}\n\n/**\n * @see https://trac.ffmpeg.org/wiki/Limiting%20the%20output%20bitrate\n */\nfunction videoBitrateArgs(bitrateKbps: Maybe<number>) {\n  if (!gt0(bitrateKbps)) return []\n\n  const m = sigFigs(bitrateKbps, 2)\n  return [\n    \"-b:v\",\n    m + \"k\",\n    \"-maxrate\",\n    m + \"k\",\n    \"-bufsize\",\n    sigFigs(m / 2, 2) + \"k\"\n  ]\n}\n\nfunction framerateArgs(args?: { fps?: number }) {\n  const r = Settings.transcodeFrameRate.valueOrDefault\n  return !gt0(r) || lte(args?.fps, r) ? [] : [\"-r\", Math.round(r)]\n}\n\nexport async function ffmpegTranscode_(args: {\n  src: PosixFile\n  dest: PosixFile\n  width: Maybe<number>\n  height: Maybe<number>\n  fps?: number\n  videoBitrateKbps?: number\n  ffmpegHwaccel?: string\n}) {\n  try {\n    await args.dest.parent().mkdirp_()\n\n    return await stdoutResult_(\n      Settings.ffmpegPath.valueOrDefault,\n      compactBlanks([\n        \"-loglevel\",\n        \"error\",\n\n        ...hwaccel(args),\n\n        \"-i\", // --input\n        args.src.nativePath,\n\n        ...avcArgs(args),\n\n        ...framerateArgs(args),\n\n        // -threads must be AFTER the input!\n        // https://ffmpeg-user.ffmpeg.narkive.com/jvDZY1aP/threads-option-has-no-effect#post6\n        \"-threads\",\n        toS(ffmpegThreads()),\n\n        ...videoBitrateArgs(args.videoBitrateKbps),\n\n        args.dest.nativePath // < output\n      ]),\n      {\n        timeoutMs: 0,\n        isIgnorableError: isIgnorableValidationError\n      }\n    )\n  } catch (error) {\n    await unlink(args.dest)\n    const s = errorToS(error, { maxLen: 1024 })\n    if (\n      Settings.ffmpegScaleType.valueOrDefault !== \"s\" &&\n      /option 'scale' not found/i.test(s)\n    ) {\n      logger().warn(\n        \"ffmpegTranscode_() failed: scale not found. Switching to old-style ffmpeg resizing and retrying...\",\n        { args, error }\n      )\n      // WOAH WOAH WOAH WTH!?!\n\n      // Chiilax, future me.\n\n      // Scaling approaches depend on the version of ffmpeg, which won't be\n      // changing.\n\n      // Hardware accelleration, though, may work for some input formats and\n      // not others, so it needs to be specific to the input.\n\n      Settings.ffmpegScaleType.envValue = \"s\"\n      return ffmpegTranscode_(args)\n    } else if (\n      !isDisabled(\n        args.ffmpegHwaccel ?? Settings.ffmpegHwaccel.valueOrDefault\n      ) &&\n      /hwaccel.*error/i.test(s)\n    ) {\n      logger().warn(\n        \"ffmpegTranscode_() failed: bad -hwaccel arg? Disabling hwaccel and retrying...\",\n        { args, error }\n      )\n      return ffmpegTranscode_({ ...args, ffmpegHwaccel: \"disabled\" })\n    } else {\n      throw error\n    }\n  }\n}\n\n/**\n * @throws on errors\n */\nexport async function ffmpegValidVideo_(src: PosixFile): Promise<StdoutResult> {\n  return logger().tap({\n    msg: \"ffmpegValidVideo\",\n    meta: { src: src.nativePath },\n    result: await stdoutResult_(\n      Settings.ffmpegPath.valueOrDefault,\n      // `-v error` may also complains about minor encoding issues, so we have to\n      // pass the error messages through that RegExp.\n      [\n        \"-v\",\n        \"error\",\n        \"-nostats\",\n        \"-i\",\n        src.nativePath,\n        \"-threads\",\n        toS(ffmpegThreads()),\n        \"-f\",\n        \"null\",\n        \"-\"\n      ],\n      {\n        timeoutMs: 0,\n        isIgnorableError: isIgnorableValidationError,\n        ignoreExitCode: true,\n        quiet: false // < raise the error\n      }\n    )\n  })\n}\n","import { clamp, round, toGt0 } from \"../../fe/Number\"\nimport { lazy } from \"../Lazy\"\nimport { Settings } from \"../settings/Settings\"\nimport { maxCpus } from \"../work/MaxCpus\"\n\n// Don't hammer the system too hard--we're doing work too!\nexport const ffmpegThreads = lazy(\n  () => toGt0(Settings.ffmpegThreads.value) ?? clamp(1, 6, round(maxCpus() / 4))\n)\n","import { lazy } from \"../../core/Lazy\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { isRotation } from \"../../fe/Rotation\"\nimport { mkLogger } from \"../Logger\"\nimport { stdoutResult_, stdout_ } from \"../child/ChildProcess\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { jpegtranNativePath_ } from \"../fs/Tools\"\nimport { isWin } from \"../platform/Platform\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { isIgnorableValidationError } from \"./ValidationErrors\"\n\nconst devnull = isWin ? \"NUL\" : \"/dev/null\"\n\nconst logger = lazy(() => mkLogger(\"img.jpegtran\"))\n\n/**\n * @throws if the jpeg is not valid.\n */\nexport async function validJpeg_(\n  src: PosixFile,\n  isIgnorableError = isIgnorableValidationError\n): Promise<void> {\n  const cmd = await jpegtranNativePath_()\n  try {\n    await stdoutResult_(cmd, [\"-outfile\", devnull, src.nativePath], {\n      timeoutMs: commandTimeoutMs(),\n      isIgnorableError,\n      ignoreExitCode: true\n    })\n  } catch (cause: any) {\n    logger().warn(\"validJpeg caught invalid file\", { src, cause })\n    throw new WrappedError(\"Invalid JPEG: \" + src, {\n      cause,\n      path: src.nativePath,\n      doNotSend: true,\n      fatal: false,\n      retriable: false\n    })\n  }\n}\n\n/**\n * @throws if error\n */\nexport async function rotateInPlace_(\n  src: PosixFile,\n  degrees: number\n): Promise<void> {\n  logger().info(\"rotateInPlace(\" + src + \")\", degrees)\n  await src.applyWip_({\n    fn_: dest => rotate_(src, dest, degrees),\n    skipFsLock: false,\n    minSizeBytes: 512,\n    timeoutMs: minuteMs\n  })\n}\n\n/**\n * @throws if error\n */\nexport async function rotate_(\n  src: PosixFile,\n  dest: PosixFile,\n  degrees: number\n): Promise<void> {\n  const cmd = await jpegtranNativePath_()\n  if (!isRotation(degrees)) {\n    throw new Error(\"refusing to rotate(\" + src + \", \" + degrees + \")\")\n  }\n  await stdout_(\n    cmd,\n    [\n      \"-copy\",\n      \"all\",\n      \"-trim\",\n      \"-rotate\",\n      degrees.toFixed(0),\n      \"-outfile\",\n      dest.nativePath,\n      src.nativePath\n    ],\n    { timeoutMs: minuteMs }\n  )\n  dest.clear() // < emit fileChanged\n  return\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { dmegapixels } from \"../../fe/Dimensions\"\nimport { MB } from \"../../fe/Units\"\nimport { isError } from \"../../fe/isError\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { endProcess, execFile } from \"../child/ChildProcess\"\nimport { errorToS } from \"../error/Error\"\nimport { DoNotSendErrorFlag, NonRetriableErrorFlag } from \"../error/ErrorFlags\"\nimport { WrappedError, toWrappedError } from \"../error/WrappedError\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { dcrawEmuNativePath_ } from \"../fs/Tools\"\nimport { PullProgressObserver } from \"../progress/PullProgressObserver\"\nimport { Settings } from \"../settings/Settings\"\nimport { isLibrawMimeType } from \"../tags/MimeTypes\"\nimport { readMimeType } from \"../tags/ReadMimeType\"\nimport { dimensions } from \"./FileDimensions\"\nimport { readableToFile_ } from \"./ImageCache\"\nimport { ImageSize } from \"./ImageSize\"\nimport { dcrawTimeout } from \"./SyncFileTimeout\"\nimport { isIgnorableValidationError } from \"./ValidationErrors\"\n\nconst logger = lazy(() => mkLogger(\"img.libraw\"))\n\nexport async function librawSupported(src: PosixFile): Promise<boolean> {\n  // THIS SHOULD NOT CALL mimetype(), because we may already be trying to\n  // service a readTags request for src.\n  try {\n    return isLibrawMimeType(await readMimeType(src.nativePath))\n  } catch (err) {\n    logger().warn(\"librawSupported(\" + src + \"): failed to read filetype\", err)\n    return false\n  }\n}\n\nexport async function raw2tiff_(src: PosixFile) {\n  return readableToFile_({\n    src,\n    desc: \"dcraw\", // < this becomes the basename\n    suffix: \".tiff\",\n    f: dest => dcraw_emu_(src, dest)\n  })\n}\n\nconst TiffOutput = [\"-T\"]\nconst WriteToStdout = [\"-Z\", \"-\"]\n// -o [0-6]  Output colorspace (raw,sRGB,...):\nconst Colorspace = [\"-o\", \"1\"]\n// disable auto-flip/auto-rotate, because libraw is sometimes wrong:\nconst IgnoreOrientation = [\"-t\", \"0\", \"-j\"]\n\n/**\n * Tell dcraw to convert src to dest (as a TIFF)\n */\nexport async function dcraw_emu_(\n  src: PosixFile,\n  dest: PosixFile\n): Promise<void> {\n  // NOTE: this is already time()d by sharpReadable\n  const start = Date.now()\n\n  const srcDim = await dimensions(src)\n  if (srcDim == null) {\n    return logger().throw(\n      \"Cannot decode RAW \" +\n        src +\n        \": no EXIF dimensions.\" +\n        DoNotSendErrorFlag +\n        NonRetriableErrorFlag\n    )\n  }\n\n  const fitDim = ImageSize.largestFit().outputSize(srcDim)\n\n  const maybeHalfSize: string[] = []\n\n  if (fitDim != null && 4 * dmegapixels(fitDim) < dmegapixels(srcDim)) {\n    logger().debug(\"Large original source: using -h\")\n    maybeHalfSize.push(\"-h\")\n  }\n\n  const cmd = await dcrawEmuNativePath_()\n  const args = [\n    ...TiffOutput,\n    ...WriteToStdout,\n    ...Colorspace,\n    ...maybeHalfSize,\n    ...IgnoreOrientation,\n    ...Settings.dcrawEmuArgs.values,\n    src.nativePath\n  ]\n  const timeout = 5 * minuteMs\n  const opts = {\n    encoding: \"buffer\",\n    timeout,\n    maxBuffer: 250 * MB\n  }\n  logger().debug(\"dcraw_emu()\", { cmd, args, opts })\n  const childProc = execFile(cmd, args, timeout, opts)\n  const errors: Error[] = []\n\n  function onError(err: Error | string | Buffer) {\n    const msg = isError(err) ? errorToS(err) : toS(err)\n    if (isIgnorableValidationError(msg)) {\n      logger().info(\"dcraw_emu():  warning\", { src, msg })\n    } else {\n      logger().warn(\"dcraw_emu(): error\", { src, msg })\n      const e = isError(err) ? err : toWrappedError(msg, { fatal: false })\n      errors.push(e)\n    }\n  }\n  childProc.on(\"error\", onError)\n  childProc.stderr!.on(\"data\", onError)\n\n  // The timeout is very pessimistic:\n  const expectedElapsedMs = dcrawTimeout(await src.size()) / 7\n\n  const obs = new PullProgressObserver(\n    { path: src.nativePath, op: \"Converting raw image\" },\n    expectedElapsedMs,\n    () => Date.now() - start\n  )\n\n  childProc.on(\"close\", () => obs.end())\n  await dest.writeStream_(childProc.stdout!)\n  if (isNotEmpty(errors)) {\n    throw new WrappedError(\"Failed to convert RAW image \" + src, {\n      causes: errors,\n      path: src.nativePath\n    })\n  }\n\n  void endProcess(childProc)\n\n  return\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { stdoutResult_ } from \"../child/ChildProcess\"\nimport { pathTo } from \"../fs/PathTo\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { isMac } from \"../platform/Platform\"\nimport { Settings } from \"../settings/Settings\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { withImageCache_ } from \"./ImageCache\"\n\n// No one knows nor cares about the version: we just hope they're all compatible with eachother, ish.\n\nexport const sipsPath = lazy(async () => {\n  return isMac ? pathTo({ tool: \"sips\" }) : undefined\n})\n\n// sips -s format png oldpic.jpg --out newpic.png\n\nexport async function sips2jpeg_(src: PosixFile): PromiseMaybe<PosixFile> {\n  return withImageCache_(src, \"heif\", \".jpeg\", dest =>\n    stdoutResult_(\n      \"sips\",\n      [\n        \"-s\",\n        \"format\",\n        \"jpeg\",\n        \"-s\",\n        \"formatOptions\",\n        String(Settings.previewQuality.valueOrDefault),\n        src.nativePath,\n        \"--out\",\n        dest.base\n      ],\n      {\n        cwd: dest.dir,\n        timeoutMs: commandTimeoutMs()\n      }\n    )\n  )\n}\n","import { rolazy } from \"../../core/Lazy\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { gt } from \"../../fe/Primitive\"\nimport { mkLogger } from \"../Logger\"\nimport { shortFsStringSha } from \"../StringHash\"\nimport { version, versionMajor, versionMinor } from \"../Version\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { request } from \"../net/Request\"\nimport { Settings } from \"../settings/Settings\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { j } from \"./BrotliDecode\"\nimport { m, p } from \"./Licensing\"\nimport { sids } from \"./SystemIds\"\nimport { writeLicense } from \"./WriteLicense\"\n\nconst logger = defer(() => mkLogger(k().l))\n\n// console.dir(\n//   require(\"zlib\")\n//     .brotliCompressSync(\n//       JSON.stringify({\n//         a: \"license\",\n//         l: \"AutoRefreshLicense\",\n//         n: [\"plus\"], // non-free subscription tiers\n//         r: { method: \"POST\", headers: { \"content-type\": \"application/json\" } },\n//         s: \"autoRefreshLicense\",\n//         u: \"https://account.photostructure.com/license/refresh\"\n//       })\n//     )\n//     .toString(\"base64\")\n// )\n\nconst k = rolazy<{\n  a: \"license\"\n  l: \"AutoRefreshLicense\"\n  n: [\"plus\"] // non-free subscription tiers\n  r: { method: \"POST\"; headers: { \"content-type\": \"application/json\" } }\n  s: \"autoRefreshLicense\"\n  u: \"https://account.photostructure.com/license/refresh\"\n}>(() =>\n  j(\n    \"G8oAKIzTFfOihHWPgG6m/h0h65IqCWu72UHSOixdfW12GgbIbSdJW2sLEmvLsqcHfOPXk00SqojDRomicXUE+MuLfPaoTzFWZPq8AdmWyQVUWERkBLoYBhqafaAvY27+LDra0blcQ4Vnjn/ukQh/C4o0cd0B\"\n  )\n)\n\n/**\n * Automatically attempt to refresh the license in the background iff\n *\n * 1) Settings.autoRefreshLicense is true\n *\n * 2) there isn't a currently valid license\n *\n * 3) there is a prior license with a customer id hash (required by POST)\n *\n * 4) the license has expired\n *\n * 5) there hasn't been a license refresh for that license\n */\nexport const r = rolazy(async () => {\n  const ctx = k().s + \": \"\n  try {\n    if (!Settings[k().s].valueOrDefault) {\n      return logger().debug(ctx + \"no-op (settings disabled)\")\n    }\n    // These all have a valid (but possibly expired) license:\n    const arr = (await m()).filter(ea => ea.l != null && notBlank(ea.s))\n    const now = new Date()\n    // We're actually checking the expiration time here, because .ok gives the\n    // expiration date a day of leeway:\n    const current = arr.find(ea => ea.ok && gt(now, ea.l?.exp))\n    if (current != null) {\n      return logger().debug(ctx + \"no-op: \", current)\n    }\n    const dir = await map(configDir(), ea =>\n      PosixFile.for(ea)\n        .join(k().s + \"-v\" + versionMajor + \".\" + versionMinor)\n        .mkdirp_()\n    )\n    for (const ea of arr) {\n      // skip over empty or unexpired licenses:\n      if (blank(ea.s) || ea.l == null || now < ea.l!.exp) continue\n      const c = ea.l.uids.find(s => s.startsWith(\"cu:\"))\n      if (c == null) {\n        logger().debug(ctx + \"skipping (no cu)\", ea)\n        continue\n      }\n      // We're using .applyIfEmpty as a way to only auto-refresh once:\n      await dir?.join(shortFsStringSha(ea.s, 14) + \".txt\").applyIfEmpty_({\n        fn_: async dest => {\n          await fsl_(c) // < fetchAndStoreLicense\n          await dest.writeJson_({ l: ea.l, at: Date.now() })\n          logger().warn(ctx + \"requested\", ea)\n        },\n        timeoutMs: commandTimeoutMs()\n      })\n      // if we're good, don't keep refreshing\n      if (await p()) break\n    }\n  } catch (err) {\n    logger().warn(ctx + \"failed\", err)\n  }\n}, 15 * minuteMs)\n\n/**\n * Fetch and store a new license. Should normally only be run via r()\n * (auto-refresh license)\n */\nasync function fsl_(cuid: string) {\n  const uids = await sids({ timeoutMs: commandTimeoutMs() }) // < we've got time to wait\n  if (isEmpty(uids)) {\n    return logger().warn(\"no-op: empty sids\")\n  }\n  // Add the customer ids to the current system ids so\n  // account.photostructure.com knows our customer:\n  const body = stringify({\n    uids: [...uids, cuid],\n    coupon: Settings.coupon.valueOrDefault,\n    version\n  })\n  const req = {\n    // headers are included in k().r\n    ...k().r,\n    body\n  }\n  const response = await request(k().u, req)\n  logger().info(k().u, { req, response })\n  if (response.ok) {\n    // If this is successfull, w() (writeLicense) will automatically unset m()\n    // (readAllLicenses):\n    await writeLicense(JSON.parse(response.body)?.[k().a], commandTimeoutMs())\n  } else {\n    logger().warn(k().u, { req, response })\n  }\n}\n","import { brotliDecompressSync } from \"zlib\"\n\n/**\n * Decode and parse a brotli-compressed, base64 string\n */\nexport function j(s: string) {\n  return JSON.parse(\n    brotliDecompressSync(Buffer.from(s, \"base64\")).toString(\"utf8\")\n  )\n}\n","import { notBlank } from \"../../fe/Blank\"\nimport { Settings } from \"../settings/Settings\"\nimport { m } from \"./Licensing\"\n\nexport async function getEmail() {\n  const s = Settings.email.value\n  if (notBlank(s)) return s\n  for (const ea of await m()) {\n    if (notBlank(ea.l?.sub)) return ea.l?.sub\n  }\n  return\n}\n","import { License } from \"../../fe/api/License\"\nimport { S } from \"../../fe/api/Subscriptions\"\nimport { compact, uniq } from \"../../fe/Array\"\nimport { dayMs } from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { Obj } from \"../../fe/Object\"\nimport { cmp, Comparable } from \"../../fe/Primitive\"\nimport { intersection } from \"../Array\"\nimport { within } from \"../Number\"\nimport { k, ParsedLicense } from \"./Licensing\"\nimport { getScheme, prefix2scheme } from \"./SystemIdSchemes\"\n\nexport class L implements ParsedLicense {\n  static for(opts: {\n    str: string\n    l: Maybe<License>\n    sids: string[]\n    src: string\n  }) {\n    return new this(opts.str, opts.l, opts.sids, opts.src)\n  }\n  readonly meta: Obj\n  /**\n   * @param s the actual license string\n   * @param _l the parsed License\n   */\n  private constructor(\n    readonly s: string,\n    readonly _l: Maybe<License>,\n    readonly _sids: string[],\n    src: string\n  ) {\n    this.meta = { src }\n  }\n\n  get l(): Maybe<License> {\n    return this._l\n  }\n\n  get ok(): boolean {\n    if (this._l == null) return false\n    const matchedUids = intersection(this._sids, this._l.uids)\n    const matchedSchemeIds = uniq(matchedUids.map(getScheme))\n    const matchedSchemes = compact(\n      matchedSchemeIds.map(ea => prefix2scheme(ea as any))\n    )\n    const uidsOK = matchedSchemes.length >= this._l.mat\n    const dateOK = within(\n      this._l.iat?.getTime(),\n      this._l.exp?.getTime() + dayMs,\n      Date.now()\n    )\n\n    this.meta[k().o] = dateOK\n    this.meta[k().u] = uidsOK\n    this.meta[k().m] = matchedSchemes\n\n    // console.log(\"L.ok()\", {\n    //   dateOK,\n    //   uidsOK,\n    //   sids: this._sids,\n    //   l_uids: this._l.uids,\n    //   matchedSchemes,\n    //   matchedUids,\n    //   matchedSchemePrefixes\n    // })\n    return dateOK && uidsOK\n  }\n\n  cmpVal(): Comparable[] {\n    return [\n      this.ok,\n      -(S.indexOf(this.l?.[k().T]) ?? 0),\n      this.l?.exp?.getTime() ?? 1,\n      this.meta.matchedSchemes // more is better\n    ]\n  }\n\n  /**\n   * @return 1 if this > b, -1 if this < b, 0 if this == b.\n   */\n  cmp(p: L) {\n    return cmp(this.cmpVal(), p.cmpVal())\n  }\n}\n","import { rolazy } from \"../../core/Lazy\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { defer } from \"../../fe/Defer\"\nimport { later } from \"../../fe/Delay\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toGte0 } from \"../../fe/Number\"\nimport { Obj } from \"../../fe/Object\"\nimport { ensurePrefix } from \"../../fe/String\"\nimport { License } from \"../../fe/api/License\"\nimport { S } from \"../../fe/api/Subscriptions\"\nimport { isError } from \"../../fe/isError\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { AppName } from \"../AppName\"\nimport { mkLogger } from \"../Logger\"\nimport { someOrTimeout, sortByAsync } from \"../async/Promise\"\nimport { utcIsoToTs } from \"../date/Date\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { libraryDataDirPosixFile } from \"../dir/LibraryDirs\"\nimport { getDevEnvFlag } from \"../env/DevEnvFlags\"\nimport { ee } from \"../event/EventEmitter\"\nimport { BaseFile } from \"../fs/BaseFile\"\nimport { Settings } from \"../settings/Settings\"\nimport { j } from \"./BrotliDecode\"\nimport { L } from \"./L\"\nimport { V } from \"./Paseto\"\nimport { sids } from \"./SystemIds\"\nimport { UserTimeoutMs } from \"./UserTimeoutMs\"\n\n// prevent greps for \"*license*\" or \"*validate*\":\n\n// console.dir(\n//   require(\"zlib\")\n//     .brotliCompressSync(\n//       JSON.stringify({\n//         a: \"mat\",\n//         b: \"uids\",\n//         c: \"reloadLicenses\",\n//         d: \"licenses\",\n//         e: \"Token verification failed: \",\n//         f: \"lite\",\n//         g: \"plus\",\n//         l: \"Licensing\",\n//         i: \"iat\",\n//         r: \"exp\",\n//         m: \"matchedSchemes\",\n//         n: \"set\",\n//         o: \"dateOK\",\n//         p: \"v2.public.\",\n//         R: \"autoRefreshLicense\",\n//         L: \"license\",\n//         T: \"tier\",\n//         t: \"trial\",\n//         u: \"uidsOK\",\n//         v: \"validate\",\n//         x: \"PS_FORCE_LITE\",\n//         y: \"PS_FORCE_TRIAL\"\n//       })\n//     )\n//     .toString(\"base64\")\n// )\n\n/**\n * licensing keys\n */\nexport const k = rolazy<{\n  a: \"mat\"\n  b: \"uids\"\n  c: \"reloadLicenses\"\n  d: \"licenses\"\n  e: \"Token verification failed: \"\n  f: \"lite\"\n  g: \"plus\"\n  l: \"Licensing\"\n  i: \"iat\"\n  r: \"exp\"\n  m: \"matchedSchemes\"\n  n: \"set\"\n  o: \"dateOK\"\n  p: \"v2.public.\"\n  R: \"autoRefreshLicense\"\n  L: \"license\"\n  T: \"tier\"\n  t: \"trial\"\n  u: \"uidsOK\"\n  v: \"validate\"\n  x: \"PS_FORCE_LITE\"\n  y: \"PS_FORCE_TRIAL\"\n}>(() =>\n  j(\n    \"G1UBABwHdkz4hUIkFCfPXW5LlfvrWKSr9W3AIyIhUiw68NDfvLLHVop/bGoNnRxQlnqi2TZp0IJaX+lUHBoi+vMy2LMNpHCv8xVkUGsmQsgB8ldHoDqJeUQzbdybwikWVRs2KSWKjE5LnuqhTNSp3gTLhNfE9EqBLeaXP+UM9YqTGSXcyrcL03rIPMDAVyJplSZC0xoUgguOYJKvrcYFbNArN7BrQsnnsJ4hMtcSxOTxxRdxzETtL93qa3vjDw==\"\n  )\n)\n\nconst logger = defer(() => mkLogger(k().l))\n\n// /**\n//  * Extract the footer from a token\n//  */\n// function extractFooter(t: string): Maybe<string> {\n//   return map(t.split(\".\")[3], b64decodeString)\n// }\n\n/**\n * Verify token, but don't validate against current system IDs\n */\nexport async function v_(str: Maybe<string>) {\n  const o = (await V(ensurePrefix(toS(str).trim(), k().p))) as Obj\n  const iat = utcIsoToTs(o[k().i])\n  if (iat == null) {\n    throw new Error(\"bad \" + k().i + \": \" + o[k().i] + \" (\" + str + \")\")\n  }\n  const exp = utcIsoToTs(o[k().r])\n  if (exp == null) {\n    throw new Error(\"bad \" + k().r + \": \" + o[k().r] + \" (\" + str + \")\")\n  }\n\n  // Set PS_FORCE_TRIAL=1 to force all licenses into trial mode\n  if (getDevEnvFlag(k().y)) {\n    o[k().t] = true\n  }\n\n  o[k().a] = toGte0(o[k().a]) ?? 2\n  o[k().i] = new Date(iat)\n  o[k().r] = new Date(exp)\n  o[k().b] = toS(o.uids).split(\",\")\n  return o as License\n}\n\nexport interface ParsedLicense {\n  ok: boolean\n  /**\n   * the actual license string\n   */\n  s: string\n  l?: License\n  meta: Obj\n}\n\n/**\n * Verify and validate the given stringified license\n */\nexport async function v(\n  str: Maybe<string>,\n  src: string,\n  timeoutMs: number,\n  _sids?: string[]\n): PromiseMaybe<ParsedLicense | L> {\n  try {\n    return blank(str)\n      ? undefined\n      : L.for({\n          str,\n          l: await v_(str),\n          sids: _sids != null ? _sids : await sids({ timeoutMs }),\n          src\n        })\n  } catch (err) {\n    return logger().tap({\n      msg: k().v,\n      result: {\n        s: str!,\n        ok: false,\n        meta: { err }\n      }\n    })\n  }\n}\n\n/**\n * Only return an L if the license string validates and is currently good.\n */\nexport async function vok(\n  str: Maybe<string>,\n  src: string,\n  timeoutMs: number\n): PromiseMaybe<L> {\n  if (blank(str)) return\n  const ea = await v(str, src, timeoutMs)\n  return isTrue(ea?.ok) && ea instanceof L ? ea : undefined\n}\n\n/**\n * Return all available licenses and metadata from either the PS_LICENSE\n * environment variable, or licenses stored on the filesystem.\n *\n * The first element will be the \"best\" license.\n */\nexport const m = rolazy<Promise<ParsedLicense[]>>(async () => {\n  // Set PS_FORCE_LITE=1 to ignore all licenses\n  if (getDevEnvFlag(k().x)) {\n    return []\n  }\n  const _sids = await sids({ timeoutMs: UserTimeoutMs })\n  const ud = map(configDir(), ea => BaseFile.for(ea))\n  const result = sorted(\n    flatten(\n      (\n        await someOrTimeout<ParsedLicense | ParsedLicense[]>(\n          [\n            // Read from env, system, and library. sb() will sort the best one to be the first\n            () => rawLicenseFromSettings(_sids),\n            () => rawFromDir(ud?.join(k().d), _sids),\n            () => rawFromDir(libraryDataDirPosixFile()?.join(k().d), _sids),\n            () =>\n              rawFromDir(\n                ud?.sibling(AppName().toLowerCase()).join(k().d),\n                _sids\n              )\n          ],\n          { timeoutMs: UserTimeoutMs }\n        )\n      ).filter(ea => {\n        if (ea instanceof Error) {\n          return false\n        } else {\n          return true\n        }\n      })\n    )\n  )\n  return logger().tap({\n    msg: k().d + \"()\",\n    result\n  })\n})\n\nfunction rawLicenseFromSettings(_sids: string[]) {\n  return v(\n    Settings[k().L].value,\n    \"Settings\",\n    UserTimeoutMs,\n    _sids\n  ) as Promise<ParsedLicense>\n}\n\nasync function rawFromDir(dir: Maybe<BaseFile>, _sids: string[]) {\n  const results: ParsedLicense[] = []\n  const children = await sortByAsync({\n    name: \"rawLicenseFromDir(\" + dir + \")\",\n    arr: dir?.childFiles(),\n    f: ea => ea.mtimeMs()\n  })\n\n  // youngest files first:\n  for (const ea of children.reverse()) {\n    const result = await v(\n      toA(await ea.readLines())\n        .map(str => str.trim())\n        .join(\"\"),\n      ea.nativePath,\n      UserTimeoutMs,\n      _sids\n    )\n    if (result != null) results.push(result)\n  }\n  return results\n}\n/**\n * @return ParsedLicense[], best license first.\n */\nfunction sorted(arr: Maybe<Partial<ParsedLicense> | Error>[]): ParsedLicense[] {\n  return sortBy(\n    // If .l (the License object) is null, it couldn't be parsed:\n    arr.filter(ea => {\n      if (ea == null) return false\n      if (isError(ea)) {\n        logger().warn(k().d + \": \", ea)\n      }\n      return ea != null && !isError(ea) && ea?.l != null\n    }) as ParsedLicense[],\n    ea => [\n      !ea.ok,\n      S.indexOf(ea.l?.[k().T]) ?? S.length + 1,\n      -(ea.l?.exp?.getTime() ?? 1) // later expiration is better\n    ]\n  )\n}\n\nlater(() => {\n  ee().on(\"clearCache\", () => m.unset())\n  ee().on(k().c, () => m.unset()) // reloadLicenses\n})\n\n/**\n * @return the best license available\n */\nexport async function b() {\n  const arr = await m()\n  return arr[0]?.ok ? arr[0] : undefined\n}\n\n/**\n * @return the current subscription tier\n */\nexport async function t() {\n  return (await b())?.l?.[k().T] ?? k().f\n}\n\n/**\n * @return true if the license is \"lite\"\n */\nexport async function l() {\n  try {\n    return (await t()) === k().f\n  } catch {\n    return true\n  }\n}\n\n/**\n * @return true if the license is \"plus\"\n */\nexport async function p() {\n  try {\n    return (await t()) === k().g\n  } catch {\n    return false\n  }\n}\n","import { decode, V2 } from \"paseto\"\nimport { lazy } from \"../../core/Lazy\"\nimport { notBlankOr } from \"../../fe/Blank\"\nimport { j } from \"./BrotliDecode\"\n\n// console.dir(\n//   require(\"zlib\")\n//     .brotliCompressSync(\n//       JSON.stringify({\n//         c: \"crypto\",\n//         m: \"createPublicKey\",\n//         d: \"2RHuDkCTP\", // default license if k is missing\n//         o: [\n//           {\n//             k: \"2RHuDkCTP\",\n//             format: \"pem\",\n//             type: \"spki\",\n//             key: \"-----BEGIN PUBLIC KEY-----\\nMCowBQYDK2VwAyEA5XK+l4rxUbUfFOUkFN3S5kk0xpQo4zA3bGNY9SdL1XE=\\n-----END PUBLIC KEY-----\\n\"\n//           },\n//           {\n//             k: \"2SoVY4nUP\",\n//             format: \"pem\",\n//             type: \"spki\",\n//             key: \"-----BEGIN PUBLIC KEY-----\\nMCowBQYDK2VwAyEAb3JzxWd0rNW8Sft1X9FgEXcbPmCtKT/Eqmh+qx3wczk=\\n-----END PUBLIC KEY-----\\n\"\n//           }\n//         ],\n//         w: \"verify\"\n//       })\n//     )\n//     .toString(\"base64\")\n// )\n\nexport const l = lazy<{\n  c: \"crypto\"\n  m: \"createPublicKey\"\n  d: \"2RHuDkCTP\" // default license if k is missing\n  o: [\n    {\n      k: \"2RHuDkCTP\"\n      format: \"pem\"\n      type: \"spki\"\n      key: \"-----BEGIN PUBLIC KEY-----\\nMCowBQYDK2VwAyEA5XK+l4rxUbUfFOUkFN3S5kk0xpQo4zA3bGNY9SdL1XE=\\n-----END PUBLIC KEY-----\\n\"\n    },\n    {\n      k: \"2SoVY4nUP\"\n      format: \"pem\"\n      type: \"spki\"\n      key: \"-----BEGIN PUBLIC KEY-----\\nMCowBQYDK2VwAyEAb3JzxWd0rNW8Sft1X9FgEXcbPmCtKT/Eqmh+qx3wczk=\\n-----END PUBLIC KEY-----\\n\"\n    }\n  ]\n  w: \"verify\"\n}>(\n  () =>\n    j(\n      \"G54BgBwHzrkukKDR8Ar6KkW29gbXlfrqQX46gTu5Wfq6dELYTjfBokB0d5+E2SAINBtxlmPquWe3PMUoNgaJrD982QMslkNeZ4BEqcBbQT59DVl9RnoTNi50diuT7NQg0YHxkr8SwDwtmFUOf+LwNVDDnPXUrzTOU++M3b+lcyfr7PXZndKHzho8iztNkZgt+/19//aXe+gvmC0HIdnn64wdLeYeLM7S9jmjTp52SzFsvIVbd4D0+rdtdjiz6R4vc2cmY398kuXiKG7fNXWS/I93etxXiVNPd4RXJF+k6JnuMUKk03GWHQQ=\"\n    ) as any\n)\n\n/**\n * V2.verify the given token string\n */\nexport function V(s: string) {\n  const d = decode(s)\n  const payload: any = d.payload\n  if (payload == null) throw new Error(\"Missing payload\")\n  // Tokens generated in 2021 didn't have a public key sha. Default to the 2021 key:\n  const sha = notBlankOr(payload.k, l().d)\n  const k = l().o.find(ea => ea.k === sha)\n  if (k == null) throw new Error(\"Unknown key\")\n  return V2.verify(s, k)\n}\n","import { uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank } from \"../../fe/Blank\"\nimport { defer } from \"../../fe/Defer\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\nimport { toS } from \"../../fe/toS\"\nimport { CountingSet } from \"../CountingSet\"\nimport { lazy } from \"../Lazy\"\nimport { mkLogger } from \"../Logger\"\nimport { shortStringSha } from \"../StringHash\"\nimport { Radix58 } from \"../math/Radix\"\nimport { j } from \"./BrotliDecode\"\n\n// To edit:\n\n// 1. Uncomment the console.dir() call below.\n// 2. Edit the object passed to JSON.stringify().\n// 3. Run the console.dir() call in Node REPL.\n// 4. Copy the output and paste it into the j() call below.\n// 5. Copy the object to the k type, and reformat.\n\n// console.dir(\n//   require(\"zlib\")\n//     .brotliCompressSync(\n//       JSON.stringify({\n//         // Sort order:\n//         cu: \"customerUid\",\n\n//         // linux\n//         lc: \"linuxCpuUid\", // cpu serial from `cpuid` (not available on docker)\n//         lm: \"linuxMachineUid\", // /etc/machine-id or /var/lib/dbus/machine-id\n//         lp: \"linuxProductUid\", // /sys/class/dmi/id/product_uuid (root-only)\n//         lb: \"linuxBoardSerial\", // /sys/devices/virtual/dmi/id/board_serial (root-only).\n\n//         // mac\n//         mp: \"macOsPlatformUid\", // IOPlatformUUID\n//         ms: \"macOsPlatformSerial\", // IOPlatformSerialNumber\n\n//         // windows\n//         wm: \"windowsMachineUid\",\n\n//         // less-good hardware ids:\n//         cm: \"cpuModel\", // SHA of os.cpus()[0].model\n//         bm: \"boardModel\", // SHA of /sys/devices/virtual/dmi/id/board_[vendor,name] (grep -iv o.e.m)\n//         nm: \"networkMac\", // SHA of all network interface MAC addresses\n\n//         // filesystem ids:\n//         li: \"libraryUid\",\n//         si: \"systemUid\",\n//         vl: \"volumeUid\"\n//       })\n//     )\n//     .toString(\"base64\")\n// )\n\ntype K = {\n  // Sort order:\n  cu: \"customerUid\"\n\n  // linux\n  lc: \"linuxCpuUid\" // cpu serial from `cpuid` (not available on docker)\n  lm: \"linuxMachineUid\" // /etc/machine-id or /var/lib/dbus/machine-id\n  lp: \"linuxProductUid\" // /sys/class/dmi/id/product_uuid (root-only)\n  lb: \"linuxBoardSerial\" // /sys/devices/virtual/dmi/id/board_serial (root-only).\n\n  // mac\n  mp: \"macOsPlatformUid\" // IOPlatformUUID\n  ms: \"macOsPlatformSerial\" // IOPlatformSerialNumber\n\n  // windows\n  wm: \"windowsMachineUid\"\n\n  // less-good hardware ids:\n  cm: \"cpuModel\" // SHA of os.cpus()[0].model\n  bm: \"boardModel\" // SHA of /sys/devices/virtual/dmi/id/board_[vendor,name] (grep -iv o.e.m)\n  nm: \"networkMac\" // SHA of all network interface MAC addresses\n\n  // filesystem ids:\n  li: \"libraryUid\"\n  si: \"systemUid\"\n  vl: \"volumeUid\"\n}\n\n/**\n * licensing keys\n */\nconst k = defer<K>(() =>\n  j(\n    \"GyABAIzUYs0Z7mSuLfVL1SwGefr+3nCwyXBMg6nD0qduA8HycFjUGK1N/ikYqhiqYLGbs7oxTBbzRPxteP9gA3L9DS0EJ2BJ1pYNa/DtEE2aPI2o03hHx3k9MhdE7jAeRUvKQ6tY3Q1fcIPe8GBMZvOeKibTymyo3Cw/7Ua42DKPjpL3wxWv+7TCGA==\"\n  )\n)\n\n/**\n * System ID schemes, in order of importance\n */\nexport const S = strEnum(\n  ...([\n    \"cu\",\n    \"lc\",\n    \"lm\",\n    \"lp\",\n    \"lb\",\n    \"mp\",\n    \"ms\",\n    \"wm\",\n    \"cm\",\n    \"bm\",\n    \"nm\",\n    \"li\",\n    \"si\",\n    \"vl\"\n  ] as const satisfies readonly (keyof K)[])\n)\nexport type SchemePrefix = StrEnumKeys<typeof S>\n\nexport function getScheme(uid: string): Maybe<SchemePrefix> {\n  const scheme = uid.split(\":\", 1)[0]\n  return S.has(scheme) ? scheme : undefined\n}\n\nexport function sortUids(uids: string[]) {\n  return sortBy(uniq(uids.filter(isValidUid)), ea => [\n    S.indexOf(getScheme(ea)) ?? S.length + 1,\n    ea\n  ])\n}\n\nexport function prefix2scheme(prefix: SchemePrefix) {\n  return k()[prefix]\n}\n\nconst GenericUUIDs = [\n  // https://www.freedesktop.org/software/systemd/man/machine-id.html#Initialization\n  \"uninitialized\",\n  // https://github.com/Kicksecure/dist-base-files/blob/master/etc/machine-id\n  \"b08dfa6083e7567a1921a715000001fb\"\n]\n\nexport const UidLength = 15\n\nexport function toUID(\n  pfx: SchemePrefix,\n  id: Maybe<string | Buffer>\n): Maybe<string> {\n  try {\n    const str = toS(id).replace(/[^a-z\\d=/+]+/gi, \"\")\n    return blank(str) ||\n      GenericUUIDs.includes(str.toLowerCase()) ||\n      str.match(/^[\\s0:_/-]*$/) != null\n      ? undefined\n      : pfx + \":\" + shortStringSha(str, UidLength, Radix58)\n  } catch (err) {\n    mkLogger(\"toUID\").warn(\"failed\", { pfx, err })\n    return\n  }\n}\n\nconst uidRE = defer(\n  () => new RegExp(`^(?:${S.values.join(\"|\")}):[0-9a-zA-Z]{${UidLength}}$`)\n)\n\nexport function isValidUid(s: string) {\n  return s != null && uidRE().exec(s) != null\n}\n\nexport class SchemeCounts {\n  readonly #uids = new Set<string>()\n\n  constructor(uids?: string[]) {\n    if (uids != null) this.addUids(uids)\n  }\n\n  get size() {\n    return this.#uids.size\n  }\n\n  addUids(uids: string[]) {\n    for (const ea of uids) {\n      if (getScheme(ea) != null && !this.#uids.has(ea)) {\n        this.#uids.add(ea)\n        this.schemeCounts.unset()\n      }\n    }\n  }\n\n  count(scheme: SchemePrefix): number {\n    return this.schemeCounts().get(scheme)\n  }\n\n  readonly schemeCounts = lazy(() => {\n    const cs = new CountingSet<SchemePrefix>()\n    for (const ea of this.#uids) {\n      const s = getScheme(ea)\n      if (s != null) cs.incr(s)\n    }\n    return cs\n  })\n}\n","import { compactBlanks, uniq } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { entries } from \"../../fe/Object\"\nimport { isString } from \"../../fe/String\"\nimport { ThunkOrLater } from \"../../fe/Thunk\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { someOrTimeout, thenMap } from \"../async/Promise\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { splitLines } from \"../fs/CRLF\"\nimport { fileGrep_ } from \"../fs/GrepReader\"\nimport { readFileMaybe } from \"../fs/ReadFile\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { LibraryUIDStore, SystemUIDStore } from \"../fs/UIDStore\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { networkMacAddresses } from \"../net/ip\"\nimport { isLinux, isMac, isWin } from \"../platform/Platform\"\nimport { PowerShell } from \"../pwsh/PowerShell\"\nimport { volumes } from \"../volumes/Volumes\"\nimport { cpuInfo } from \"../work/CpuInfo\"\nimport { j } from \"./BrotliDecode\"\nimport { S, sortUids, toUID } from \"./SystemIdSchemes\"\n\n// console.dir(\n//   require(\"zlib\")\n//     .brotliCompressSync(\n//       JSON.stringify({\n//         n: \"SystemIds\",\n//         i: \"ioreg\",\n//         pc: \"/proc/cpuinfo\",\n//         ia: [\"-rd1\", \"-c\", \"IOPlatformExpertDevice\"],\n//         lm: [\"/etc/machine-id\", \"/var/lib/dbus/machine-id\"],\n//         lp: [\"/sys/class/dmi/id/product_uuid\"],\n//         lb: [\"/sys/devices/virtual/dmi/id/board_serial\"],\n//         bm: [\n//           \"/sys/devices/virtual/dmi/id/board_vendor\",\n//           \"/sys/devices/virtual/dmi/id/board_name\"\n//         ],\n//         w: \"Get-ItemProperty -Path hklm:\\\\SOFTWARE\\\\Microsoft\\\\Cryptography -Name MachineGuid | Select-Object -Property MachineGuid\"\n//       })\n//     )\n//     .toString(\"base64\")\n// )\n\n/**\n * licensing keys\n */\nexport const k = defer<{\n  n: \"SystemIds\"\n  i: \"ioreg\"\n  pc: \"/proc/cpuinfo\"\n  ia: [\"-rd1\", \"-c\", \"IOPlatformExpertDevice\"]\n  lm: [\"/etc/machine-id\", \"/var/lib/dbus/machine-id\"]\n  lp: [\"/sys/class/dmi/id/product_uuid\"]\n  lb: [\"/sys/devices/virtual/dmi/id/board_serial\"]\n  bm: [\n    \"/sys/devices/virtual/dmi/id/board_vendor\",\n    \"/sys/devices/virtual/dmi/id/board_name\"\n  ]\n  w: \"Get-ItemProperty -Path hklm:\\\\SOFTWARE\\\\Microsoft\\\\Cryptography -Name MachineGuid | Select-Object -Property MachineGuid\"\n}>(() =>\n  j(\n    \"G9ABYIzDOIZ8NLQ4t7qW8tNrmrOzz+qFGfAxl8jW4E2tLxwWRZT5TueCnPcwgTzT1DN3veRB+e7EYGlYHg6nhjBDQv7zI6EcYWk35z6QuZC3Q0itjrLCbmgd0iED0BvGiYLBJwRU1O9/3Agbl8IfG6ITVFWDRwyTw3rbUMo/XMyAVW7R23mkwUx0l4/7iA13RV/nmPuJFKp5BvJW7SoXJZoWEfdSNYYhN5UCtkbC7O1AaPIbU3P6uRLmEyb4TaHWzFigvrlmZVUzzp9j/Mz55vqN88ewd1Nrfh7gkVRQ7TtB7Ztz3XJxYC3ogdJHg8HGsG4=\"\n  )\n)\n\nconst logger = defer(() => mkLogger(k().n))\n\nexport async function readInfo(\n  f: string | SimpleFile = k().pc\n): PromiseMaybe<string[]> {\n  // This is really only found on Raspberry Pis, but certainly not on Windows:\n  if (!isLinux) return\n  try {\n    const info = await fileGrep_(\n      f,\n      /^\\s*(?:hardware|revision|serial|model)\\s*[:=]\\s*[a-z\\d]{6}.*$/i\n    )\n    // normalize whitespace and order:\n    const lines = compactBlanks(\n      splitLines(info).map(ea => ea.replace(/\\s+/g, \" \"))\n    ).sort()\n    return lines.some(ea => ea.match(/^serial/i) != null) ? lines : undefined\n  } catch {\n    //\n    return\n  }\n}\n\nconst cpuinfoSerial = defer(() =>\n  thenMap(readInfo(), arr => toUID(S.lc, arr.join(\",\")))\n)\n\nconst oemRe = /o\\.e\\.m\\./i\n\nasync function readFiles(key: keyof ReturnType<typeof k>) {\n  return uniq(\n    await Promise.all(\n      (k()[key] as string[]).map(ea => readFileMaybe(ea, LogLevels.trace))\n    )\n  )\n    .map(toS)\n    .filter(ea => notBlank(ea) && null == ea.match(oemRe))\n}\n\nasync function linuxMachineUid() {\n  return isLinux\n    ? (await readFiles(\"lm\")).map(ea => toUID(S.lm, ea))\n    : undefined\n}\n\nasync function linuxProductUid() {\n  return isLinux\n    ? (await readFiles(\"lp\")).map(ea => toUID(S.lp, ea))\n    : undefined\n}\n\nasync function linuxBoardSerial() {\n  return isLinux\n    ? (await readFiles(\"lb\")).map(ea => toUID(S.lb, ea))\n    : undefined\n}\n\nasync function mac_IOPlatformUUID_() {\n  const out = await stdout_(k().i, k().ia, {\n    timeoutMs: 5 * secondMs\n  })\n  // \"IOPlatformUUID\" = \"123ABC45-67DE-8F90-ABC1-23456DEF7890\"\n  const mp = out.match(/uuid\" = \"([a-z\\d-]{12,})\"/i)?.[1]\n\n  // \"IOPlatformSerialNumber\" = \"ABC0123XYZ45\"\n  const ms = out.match(/SerialNumber\" = \"([a-z\\d-]{10,})\"/i)?.[1]\n  return { mp, ms }\n}\n\nasync function macUids() {\n  if (!isMac) return\n  try {\n    return entries(await mac_IOPlatformUUID_()).map(([pfx, id]) =>\n      toUID(pfx, id)\n    )\n  } catch (err) {\n    logger().warn(k().i + \" failed\", err)\n    return\n  }\n}\n\n// exposed for tests\nexport async function win_machineGuid_() {\n  return (await PowerShell.instance().executeJson(k().w))?.MachineGuid\n}\n\nasync function winMachineUid() {\n  return isWin ? toUID(S.wm, await win_machineGuid_()) : undefined\n}\n\nconst cpuModel = defer(() => toUID(S.cm, cpuInfo()[0].model))\n\nasync function boardModel() {\n  return isLinux\n    ? toUID(\n        S.bm,\n        compactBlanks(await readFiles(\"bm\"))\n          .map(ea => ea.trim())\n          .join(\"\\n\")\n      )\n    : []\n}\n\nasync function libraryUid() {\n  return toUID(S.li, await LibraryUIDStore()?.readUid_())\n}\n\nasync function systemUid() {\n  return toUID(S.si, await SystemUIDStore()?.readUid_())\n}\n\nfunction networkMacUids() {\n  return networkMacAddresses().map(ea => toUID(S.nm, ea))\n}\n\nasync function volumeIds() {\n  return toA(await volumes()).map(v => toUID(S.vl, v.uuid))\n}\n\nconst priorSids = new Set<string>()\n\nexport async function sids({ timeoutMs }: { timeoutMs: number }) {\n  const startTs = Date.now()\n  const sidFuncs: ThunkOrLater<Maybe<string | Maybe<string>[]>>[] = [\n    // easiest/most important first:\n    cpuModel,\n    cpuinfoSerial,\n    macUids,\n    libraryUid,\n    systemUid,\n    boardModel,\n    linuxMachineUid,\n    linuxProductUid,\n    linuxBoardSerial,\n    winMachineUid,\n    networkMacUids,\n    volumeIds\n  ]\n  const flat = flatten(await someOrTimeout(sidFuncs, { timeoutMs }))\n  const arr = flat.filter(isString)\n  for (const ea of arr) {\n    priorSids.add(ea)\n  }\n  return logger().tap({\n    msg: \"sids()\",\n    result: sortUids([...priorSids, ...arr]),\n    meta: {\n      timeoutMs,\n      elapsedMs: Date.now() - startTs\n    }\n  })\n}\n\nexport function addSids(arr: string[]) {\n  if (isTest) {\n    for (const ea of arr) {\n      priorSids.add(ea)\n    }\n  }\n}\n\nexport function clearSids() {\n  if (isTest) priorSids.clear()\n}\n","import { secondMs } from \"../../fe/Date\"\n\n// 8 seconds is considered \"broken\" for any user-facing operation, according\n// to Internet Lore\nexport const UserTimeoutMs = 7 * secondMs\n","import { defer } from \"../../fe/Defer\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { mkLogger } from \"../Logger\"\nimport { shortFsStringSha } from \"../StringHash\"\nimport { mapAsyncSerial } from \"../async/Promise\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { libraryDataDirPosixFile } from \"../dir/LibraryDirs\"\nimport { broadcastEvent_ } from \"../event/BroadcastEvent\"\nimport { BaseFile } from \"../fs/BaseFile\"\nimport { L } from \"./L\"\nimport { k, m, vok } from \"./Licensing\"\n\nconst logger = defer(() => mkLogger(\"writeLicense\"))\n\n/**\n * Write license\n * @param t paseto token (\"v2.public....\")\n */\nexport async function writeLicense(str: string, timeoutMs: number) {\n  // This throws if validation fails\n  const pl = await vok(str, \"candidate\", timeoutMs)\n  if (pl == null) {\n    return logger().error(\"!ok\", str)\n  }\n  // Only store the license if it's better than what we've got already for any\n  // given directory:\n  await saveIfBetter(pl, libraryDataDirPosixFile()?.join(k().d), timeoutMs)\n  await saveIfBetter(\n    pl,\n    map(configDir(), ea => BaseFile.for(ea).join(k().d)),\n    timeoutMs\n  )\n\n  // We always want the new license to have a chance to switch from LITE to PLUS:\n  await m.refresh()\n}\n\nexport async function licensesInDirectory(\n  dir: BaseFile,\n  timeoutMs: number\n): Promise<L[]> {\n  return (\n    await mapAsyncSerial({\n      name: \"read\",\n      arr: dir.childFiles(),\n      f: async ea => vok(await ea.readTextFile(), ea.nativePath, timeoutMs)\n    })\n  ).filter(ea => ea.ok && ea instanceof L) as L[]\n}\n\nexport async function saveIfBetter(\n  pl: L,\n  dir: Maybe<BaseFile>,\n  timeoutMs: number\n) {\n  if (dir == null) return\n  const prior = await licensesInDirectory(dir, timeoutMs)\n  if (prior.some(ea => ea.cmp(pl) >= 0)) {\n    logger().info(\"saveIfBetter(): no-op for \" + dir)\n    return\n  } else {\n    const f = dir.join(shortFsStringSha(pl.s) + \".txt\")\n    try {\n      await f.writeFile_(pl.s)\n      void broadcastEvent_(\"reloadLicenses\")\n      logger().info(\"saveIfBetter(): wrote to \" + f)\n      return f\n    } catch (error) {\n      logger().error(\"saveIfBetter(): failed to save license to \" + dir, error)\n      return\n    }\n  }\n}\n","import { isNotEmpty } from \"../../fe/Array\"\nimport { hourMs, minuteMs, secondMs } from \"../../fe/Date\"\nimport { delay } from \"../../fe/Delay\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { fromEntries, values } from \"../../fe/Object\"\nimport { cmp, gte, lt } from \"../../fe/Primitive\"\nimport { thenMap } from \"../../fe/Promise\"\nimport { BoundedGreatestSet } from \"../BoundedGreatestSet\"\nimport { mkLogger } from \"../Logger\"\nimport { withBoundedConcurrency } from \"../async/Promises\"\nimport { untilTrue } from \"../async/until\"\nimport { errorToS } from \"../error/Error\"\nimport { DirectoryEntry } from \"../fs/DirectoryEntry\"\nimport { Settings } from \"../settings/Settings\"\nimport { LogEntry, logEntrySorter } from \"./LogEntry\"\nimport { LogLevels } from \"./LogLevel\"\nimport { LogReader } from \"./LogReader\"\nimport { writeRecentLogEntries } from \"./WriteRecentLogEntries\"\n\nexport function recentLogFiles(ttlMs = 10 * minuteMs) {\n  const minMtime = Date.now() - ttlMs\n  return thenMap(DirectoryEntry.for(Settings.logDir.valueOrDefault), dir =>\n    dir.filterDescendantFiles(\n      async ea =>\n        [\".log\", \".log.gz\"].includes(ea.ext) &&\n        gte(await ea.mtimeMs(), minMtime)\n    )\n  )\n}\n\nexport async function allRecentLogEntries(maxEntriesPerLevel = 50) {\n  writeRecentLogEntries()\n\n  const entriesByLevel: {\n    [level: string]: BoundedGreatestSet<LogEntry>\n  } = fromEntries(\n    LogLevels.values.map(logLevel => [\n      logLevel,\n      new BoundedGreatestSet(maxEntriesPerLevel, logEntrySorter)\n    ])\n  )\n\n  const oldestTs = Date.now() - hourMs\n  const logger = mkLogger(\"allRecentLogEntries()\")\n\n  await thenMap(recentLogFiles(), files =>\n    withBoundedConcurrency({\n      name: \"allRecentLogEntries()\",\n      laters: files.map(f => async () => {\n        try {\n          const errors: Error[] = []\n          const lr = new LogReader(f, err => errors.push(err))\n          await untilTrue(() => lr.ready(), { timeoutMs: 10 * secondMs })\n          while (!lr.complete() && !lr.hasErrors()) {\n            const le = lr.shift()\n            if (le == null) {\n              // We exhausted the buffer. Wait for it to fill again.\n              await delay(5)\n            } else if (le.ts > oldestTs) {\n              entriesByLevel[le.l]?.add(le)\n            }\n          }\n          if (isNotEmpty(errors)) {\n            logger.warn(\"Read error(s) for \" + f, errors)\n            if (\n              errors.some(\n                (ea: any) =>\n                  ea.code === \"Z_BUF_ERROR\" ||\n                  errorToS(ea).includes(\"unexpected end of file\")\n              ) &&\n              lt(await f.mtimeMs(), Date.now() - minuteMs)\n            ) {\n              logger.warn(\"Unlinking corrupt logfile \" + f)\n              await f.unlink_()\n            }\n          }\n        } catch (err) {\n          logger.warn(\"Failed to read entries from \" + f, err)\n        }\n      })\n    })\n  )\n\n  const entries = flatten(values(entriesByLevel).map(ea => ea.vacuum()))\n  return entries.sort((a, b) => cmp(a.ts, b.ts))\n}\n","import { inspect } from \"util\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport {\n  bgBlack,\n  bgRedBright,\n  black,\n  blue,\n  blueBright,\n  cyan,\n  darkGrey,\n  green,\n  magenta,\n  redBright,\n  yellow,\n  yellowBright\n} from \"../Chalk\"\nimport { isTest } from \"../NodeEnv\"\nimport { processName } from \"../ServiceNames\"\nimport { Settings } from \"../settings/Settings\"\nimport { LogEntry } from \"./LogEntry\"\nimport { logFilter } from \"./LogFilter\"\nimport { FormatterOptions, LogFormatter } from \"./LogFormatter\"\nimport { LogLevel } from \"./LogLevel\"\nimport { prepMeta } from \"./LogMeta\"\n\nconst procColors = lazy(() => [\n  { re: /billing|worker/, f: cyan },\n  { re: /sync/, f: blue },\n  { re: /web/, f: green },\n  { re: /main/, f: yellow },\n  { re: /info/, f: blueBright },\n  { re: /test|log/, f: magenta }\n])\n\nexport function colorProcessName(s: string): string {\n  if (blank(s)) return \"\"\n  const pc = procColors().find(ea => s.match(ea.re))\n  return pc != null ? bgBlack(pc.f(s)) : s\n}\n\nexport class ColoredLogFormatter implements LogFormatter {\n  private readonly logLevels: Record<LogLevel, string> = {\n    trace: \"trace\",\n    debug: darkGrey(\"debug\"),\n    // the underscores support grepping by log level:\n    info: cyan(\"info_\"),\n    warn: yellowBright(\"warn_\"),\n    error: redBright(\"error_\"),\n    fatal: bgRedBright(black(\"fatal\"))\n  }\n\n  readonly inspectOptions: FormatterOptions\n\n  defaultProcessName!: string\n\n  constructor(readonly _inspectOptions: Partial<FormatterOptions> = {}) {\n    this.inspectOptions = {\n      showHidden: false,\n      depth: 5,\n      colors: true,\n      compact: true,\n      customInspect: true,\n      maxArrayLength: Settings.logContextLimit.valueOrDefault + 3, // +3 so inspect doesn't do any array trimming\n      processName: processName,\n      ...this._inspectOptions\n    }\n    if (isTest) {\n      this.inspectOptions.breakLength = 255\n    }\n    // This assumes we'll only make one of these! DON'T LEAK!\n    Settings.logContextLimit.watchLater(curr => {\n      this.inspectOptions.maxArrayLength = curr + 1\n    })\n    this.inspectOptions.processName.watch(\n      ea => (this.defaultProcessName = colorProcessName(ea))\n    )\n  }\n\n  formatMeta(meta?: Maybe<any[]>) {\n    if (meta == null) return undefined\n    const m = prepMeta(meta)\n    return m == null ? undefined : inspect(m, this.inspectOptions)\n  }\n\n  formatLogEntry(le: LogEntry): string {\n    const contextColor = logFilter().highlight(le.ctx) ? yellow : blue\n    return compactBlanks([\n      darkGrey(new Date(le.ts).toISOString()),\n      le.from == null ? this.defaultProcessName : colorProcessName(le.from),\n      this.logLevels[le.l],\n      contextColor(le.ctx),\n      le.msg,\n      this.formatMeta(le.meta)\n    ])\n      .map(ea => toS(ea))\n      .join(\" \")\n  }\n\n  format(\n    level: LogLevel,\n    context: string,\n    message: string,\n    meta?: any\n  ): string {\n    return this.formatLogEntry({\n      ts: Date.now(),\n      l: level,\n      from: processName(),\n      ctx: context,\n      msg: message,\n      meta\n    })\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { processName } from \"../ServiceNames\"\nimport { logFilter } from \"./LogFilter\"\nimport { SimpleLogger } from \"./Logger\"\nimport { LogLevel } from \"./LogLevel\"\nimport { pushLogEntries } from \"./LogTailEntries\"\n\n/**\n * Works in concert with LogTail so both local and remote log messages are\n * emitted in chronological order.\n */\nexport class ConsoleLogger implements SimpleLogger {\n  static readonly instance = lazy(() => new ConsoleLogger())\n\n  log(level: LogLevel, context: string, msg: string, meta?: any) {\n    if (this.enabled(level, context)) {\n      pushLogEntries({\n        ts: Date.now(),\n        l: level,\n        from: processName(),\n        ctx: context,\n        msg,\n        meta\n      })\n    }\n  }\n\n  enabled(level: LogLevel, context: string): boolean {\n    return logFilter().enabled(level, context)\n  }\n\n  async flush() {\n    // no op\n  }\n\n  end() {\n    // no op\n  }\n\n  toJSON() {\n    // if we add an object that contains a logger to LogEntry.meta...\n    return {\n      _ctor: \"ConsoleLogger\"\n    }\n  }\n}\n","import { Logger } from \"batch-cluster\"\nimport { toNotBlank } from \"../../fe/Blank\"\nimport { shortStack } from \"../../fe/Error\"\nimport { Later } from \"../../fe/Later\"\nimport { map } from \"../../fe/Maybe\"\nimport { Obj } from \"../../fe/Object\"\nimport { Thunk } from \"../../fe/Thunk\"\nimport { isFunction } from \"../../fe/isFunction\"\nimport { rootLoggers } from \"../Logger\"\nimport { mapGt0 } from \"../Number\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { AbortError } from \"../async/AbortError\"\nimport { NewWrappedError, toWrappedError } from \"../error/WrappedError\"\nimport { LogLevel, LogLevels, msTolevel } from \"./LogLevel\"\nimport { SimpleLogger } from \"./Logger\"\n\n/**\n * Delegates to a SimpleLogger, applying filters, and exposing level-specific\n * log methods.\n */\nexport class ContextualLogger implements SimpleLogger, Logger {\n  readonly context: string\n  constructor(\n    context: string,\n    readonly loggers = rootLoggers\n  ) {\n    // shite goes real south if context is blank, so let's make sure it's not:\n    this.context =\n      toNotBlank(context) ??\n      // We have to skip over lazy(), mkLogger(), and this constructor:\n      shortStack().find(ea => !ea.includes(\"Logger\")) ??\n      \"\"\n  }\n\n  toLogJSON() {\n    return \"CtxLogger(\" + this.context + \")\"\n  }\n\n  /**\n   * @return `this.context + s`\n   */\n  addContext(s: string) {\n    return new ContextualLogger(this.context + s, this.loggers)\n  }\n\n  addParameterContext(param: string) {\n    return new ContextualLogger(this.context + \"(\" + param + \")\", this.loggers)\n  }\n\n  throwIfAborted(signal?: AbortSignal) {\n    if (signal?.aborted === true) {\n      const reason = signal.reason ?? \"(no reason given)\"\n      this.warn(\"process aborted: \" + (signal.reason ?? \"(no reason given)\"))\n      throw new AbortError(reason)\n    }\n  }\n\n  throw(\n    e: string | Error,\n    meta?: (NewWrappedError & { error: Error }) | Obj\n  ): never {\n    const result = toWrappedError(e, { ...meta, message: this.context })\n    this.log(\n      result.ignorable === true ? \"warn\" : \"error\",\n      \".throw() \" + result.message,\n      { stack: result.stack, ...meta }\n    )\n    throw result\n  }\n\n  tap<T>(o: { level?: LogLevel; msg: string; result: T; meta?: any }): T {\n    const level =\n      o.level ?? mapGt0(o.meta?.elapsedMs, msTolevel) ?? LogLevels.debug\n    this.log(level, o.msg, { result: o.result, ...o.meta })\n    return o.result\n  }\n\n  tapThunk<T>(o: {\n    level?: LogLevel\n    msg: string\n    result: Thunk<T>\n    meta?: any\n  }): T {\n    const start = Date.now()\n    let slowTimer\n    try {\n      slowTimer = setTimeout(\n        () => this.log(\"warn\", \"slow: \" + o.msg),\n        ShortCommandTimeoutMs\n      )\n      const result = o.result()\n      const elapsedMs = Date.now() - start\n      return this.tap({\n        level: o.level,\n        msg: o.msg,\n        result,\n        meta: { ...o.meta, elapsedMs }\n      })\n    } catch (error) {\n      this.log(\"error\", \"error: \" + o.msg, { error, ...o.meta })\n      throw error\n    } finally {\n      map(slowTimer, clearTimeout)\n    }\n  }\n\n  async tapAsync<T>(o: {\n    level?: LogLevel\n    errorLevel?: LogLevel\n    msg: string\n    errorMsg?: string\n    result: Later<T> | Promise<T>\n    meta?: any\n  }): Promise<T> {\n    const level =\n      o.level ?? mapGt0(o.meta?.elapsedMs, msTolevel) ?? LogLevels.debug\n    try {\n      const result = await (isFunction(o.result) ? o.result() : o.result)\n      this.log(level, o.msg, { result, ...o.meta })\n      return result\n    } catch (error) {\n      this.log(o.errorLevel ?? \"warn\", o.errorMsg ?? o.msg + \" failed\", {\n        error,\n        ...o.meta\n      })\n      throw error\n    }\n  }\n\n  /**\n   * Is _any_ logger enabled?\n   */\n  enabled(level: LogLevel, context?: string): boolean {\n    // PERF: avoid closure allocation:\n    for (const ea of this.loggers()) {\n      if (ea.enabled(level, context ?? this.context)) return true\n    }\n    return false\n  }\n\n  log(level: LogLevel, message: string, meta?: any): void {\n    for (const ea of this.loggers()) {\n      ea.log(level, this.context, message, meta)\n    }\n  }\n\n  elapsed(message: string, elapsedMs: number, meta?: any) {\n    this.log(msTolevel(elapsedMs), message, { elapsedMs, ...meta })\n  }\n\n  async flush() {\n    for (const ea of this.loggers()) {\n      await ea.flush()\n    }\n  }\n\n  async end() {\n    for (const ea of this.loggers()) {\n      await ea.end()\n    }\n  }\n\n  // Using fat arrows force the methods to stay bound to this instance:\n  readonly error = (msg: string, args?: any) => {\n    this.log(\"error\", msg, args)\n  }\n\n  readonly warn = (msg: string, args?: any) => {\n    this.log(\"warn\", msg, args)\n  }\n\n  readonly info = (msg: string, args?: any) => {\n    this.log(\"info\", msg, args)\n  }\n\n  readonly debug = (msg: string, args?: any) => {\n    this.log(\"debug\", msg, args)\n  }\n\n  readonly trace = (msg: string, args?: any) => {\n    this.log(\"trace\", msg, args)\n  }\n}\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { rootLoggers } from \"../Logger\"\nimport { LogWriter } from \"./LogWriter\"\n\nexport function currentFileLogger(): Maybe<LogWriter> {\n  return rootLoggers().find(ea => ea instanceof LogWriter) as LogWriter\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { LogFormatter } from \"./LogFormatter\"\nimport { PlaintextLogFormatter } from \"./PlaintextLogFormatter\"\n\nexport const DefaultLogFormatter = lazy<LogFormatter>(\n  () => new PlaintextLogFormatter()\n)\n","import { UnwrapLazy, lazy } from \"../../core/Lazy\"\nimport { compactBlanks, uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { later } from \"../../fe/Delay\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toInt } from \"../../fe/Number\"\nimport { entries, fromEntries } from \"../../fe/Object\"\nimport { SimpleAppName } from \"../AppName\"\nimport { serviceName } from \"../ServiceNames\"\nimport { stripAnsiEsc } from \"../String\"\nimport { errorToVerbose } from \"../error/Error\"\nimport { LogEntry } from \"./LogEntry\"\nimport { LogFormatter } from \"./LogFormatter\"\nimport { level2syslog } from \"./LogLevel\"\nimport { prepMeta } from \"./LogMeta\"\n\n// https://docs.greylog.org/v1/docs/gelf#gelf-payload-specification\ninterface Payload {\n  version: \"1.1\"\n  host: string\n  short_message: string\n  full_message?: string\n  timestamp: number\n  // https://en.wikipedia.org/wiki/Syslog#Severity_level\n  level: number\n}\n\nconst defaultFrom = lazy<{ _service: string; _pid?: number }>(() => ({\n  _service: serviceName(),\n  _pid: process.pid\n}))\n\nlater(() => serviceName.watchLater(() => defaultFrom.unset()))\n\nfunction extractFrom(from?: Maybe<string>): UnwrapLazy<typeof defaultFrom> {\n  if (from == null) {\n    return defaultFrom()\n  } else {\n    const [_service, pidStr] = from.split(\"-\", 2)\n\n    return blank(_service) ? defaultFrom() : { _service, _pid: toInt(pidStr) }\n  }\n}\n\n/**\n * @see https://docs.greylog.org/v1/docs/gelf\n */\nexport class GelfLogFormatter implements LogFormatter {\n  formatLogEntry(logEntry: LogEntry): string {\n    const payload: Payload = {\n      version: \"1.1\",\n      level: level2syslog(logEntry.l) ?? 7,\n      host: SimpleAppName,\n      timestamp: logEntry.ts / 1000,\n      short_message: stripAnsiEsc(\n        uniq(compactBlanks([logEntry.ctx, logEntry.msg])).join(\" \")\n      ),\n      full_message: map(logEntry.meta?.error, errorToVerbose)\n    }\n\n    return stringify({\n      ...payload,\n      ...extractFrom(logEntry.from),\n      ...fromEntries(\n        entries(prepMeta(logEntry.meta, 3) ?? {}).map(([k, v]) =>\n          k === \"id\" ? undefined : [\"_\" + k, stringify(v)]\n        )\n      )\n    })\n  }\n\n  format(\n    level: \"fatal\" | \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\",\n    ctx: string,\n    msg: string,\n    meta?: any\n  ): string {\n    return this.formatLogEntry({\n      ts: Date.now(),\n      l: level,\n      ctx,\n      msg,\n      meta\n    })\n  }\n}\n","import { createConnection, Socket } from \"net\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Latch } from \"../../fe/Latch\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, toInt } from \"../../fe/Number\"\nimport { EndableRanks } from \"../async/Endable\"\nimport { EndableWrapper } from \"../async/EndableWrapper\"\nimport { mkConsoleLogger } from \"../Logger\"\nimport { rateLimited } from \"../RateLimited\"\nimport { Settings } from \"../settings/Settings\"\nimport { GelfLogFormatter } from \"./GelfLogFormatter\"\nimport { LogFilterImpl } from \"./LogFilterImpl\"\nimport { SimpleLogger } from \"./Logger\"\nimport { LogLevel } from \"./LogLevel\"\n\nconst consoleLogger = lazy(() => mkConsoleLogger(\"log.LogBroadcaster\"))\n\nconst nul = String.fromCharCode(0)\n\nfunction parseLogServerSetting() {\n  const [host, portStr] = (Settings.logServer.valueOrDefault ?? \"\").split(\":\")\n  const port = toInt(portStr)\n  return blank(host) || !gt0(port) ? undefined : { host, port }\n}\n\nexport const logBroadcaster = lazy(() => {\n  const server = parseLogServerSetting()\n  if (server == null) {\n    if (Settings.logServer.hasValue()) {\n      consoleLogger().info(\n        `setup(): no-op: invalid PS_LOG_SERVER setting (expecting \"host:port\", got ${stringify(\n          Settings.logServer.valueOrDefault\n        )})`\n      )\n    }\n    return\n  } else {\n    return new LogBroadcaster(server.host, server.port)\n  }\n})\n\nclass LogBroadcaster extends EndableWrapper implements SimpleLogger {\n  readonly logFormatter = new GelfLogFormatter()\n  readonly logFilter = new LogFilterImpl(Settings.logServerLevel)\n  socket: Maybe<Socket>\n\n  constructor(\n    readonly host: string,\n    readonly port: number\n  ) {\n    super(\n      \"log.LogBroadcaster(\" + host + \":\" + port + \")\",\n      () => this.socket?.end(),\n      EndableRanks.logtail\n    )\n    void this.#mkSocket()\n  }\n\n  enabled(level: LogLevel, context?: string | undefined): boolean {\n    return this.logFilter.enabled(level, context)\n  }\n\n  log(level: LogLevel, context: string, msg: string, meta?: any) {\n    if (this.enabled(level, context)) {\n      try {\n        const s = this.socket\n        if (s == null) {\n          void this.#mkSocket()\n        } else {\n          s.write(this.logFormatter.format(level, context, msg, meta) + nul)\n        }\n      } catch (error) {\n        consoleLogger().warn(\"Failed to write log entry to socket\", {\n          level,\n          context,\n          msg,\n          meta,\n          error\n        })\n      }\n    }\n  }\n\n  flush() {\n    const l = new Latch()\n    this.socket?.write(\"\", () => l.resolve())\n    return l.promise\n  }\n\n  readonly #mkSocket = rateLimited({\n    f: async () => {\n      try {\n        const s = (this.socket = createConnection({\n          host: this.host,\n          port: this.port\n        }))\n        s.on(\"close\", () => {\n          this.socket = undefined\n        })\n        s.on(\"error\", (error: any) => {\n          consoleLogger().warn(\"Error from logging server\", error)\n          try {\n            s.end()\n          } catch {\n            //\n          }\n        })\n      } catch (error) {\n        consoleLogger().warn(\"Failed to connect to the log server\", error)\n      }\n    },\n    minCallDelayMs: minuteMs,\n    name: \"#mkSocket\"\n  })\n}\n","export const DefaultLogFlushMs = 250\n","import { join } from \"path\"\nimport { fmtIsoDate } from \"../../fe/Date\"\nimport { Settings } from \"../settings/Settings\"\n\nexport function datedLogDir(logDir?: string, date?: Date): string {\n  return join(\n    logDir ?? Settings.logDir.valueOrDefault,\n    fmtIsoDate(date ?? new Date())\n  )\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { weekMs } from \"../../fe/Date\"\nimport { isBillingService } from \"../ServiceNames\"\nimport { FileCleanup } from \"../fs/FileCleanup\"\nimport { isExt } from \"../fs/FileExt\"\nimport { Settings } from \"../settings/Settings\"\n\n// Don't run logdir cleanup on account.photostructure.com!\n\nexport const LogDirCleanup = lazy(() =>\n  isBillingService()\n    ? undefined\n    : new FileCleanup(\n        \"logDirCleanup\",\n        () => Settings.logDir.valueOrDefault,\n        weekMs,\n        f => isExt(f.ext, \".log\", \".log.gz\")\n      )\n)\n","import { sortByInPlace } from \"../../fe/ArraySort\"\nimport { isNumber } from \"../../fe/Number\"\nimport { isString } from \"../../fe/String\"\nimport { LogLevel, LogLevels } from \"./LogLevel\"\n\n/**\n * field names are abbreviated as they are encoded in JSON on disk.\n */\nexport interface LogEntry {\n  /**\n   * timestamp\n   */\n  ts: number\n  /**\n   * log level\n   */\n  l: LogLevel\n  /**\n   * context\n   */\n  ctx: string\n  /** message */\n  msg: string\n  meta?: any\n  from?: string\n}\n\nexport function isLogEntry(ea: any): ea is LogEntry {\n  return (\n    ea != null &&\n    isNumber(ea?.ts) &&\n    isString(ea?.msg) &&\n    LogLevels.includes(ea.l)\n  )\n}\n\nexport function logEntrySorter(ea: LogEntry) {\n  return ea?.ts\n}\n\nexport function sortLogEntriesInPlace(arr: LogEntry[]) {\n  sortByInPlace(arr, ea => ea.ts)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { levelIndex, LogLevel, LogLevels } from \"./LogLevel\"\n\nexport interface LogFilter {\n  highlight(context: string): boolean\n\n  /**\n   * @return true iff the given level and context are not configured to be\n   * squelched/omitted from downstream log writers.\n   */\n  enabled(level: LogLevel, context?: string): boolean\n  /**\n   * The level index that is enabled by default (ignoring context-specific overrides)\n   */\n  readonly defaultLevelIndex: number\n  silent: boolean\n}\n\nexport class SimpleLogFilter implements LogFilter {\n  readonly defaultLevelIndex\n  constructor(readonly minLogLevel: LogLevel) {\n    this.defaultLevelIndex = levelIndex(minLogLevel)\n  }\n  highlight() {\n    return false\n  }\n  enabled(level: LogLevel) {\n    // fatal < error < info < debug < trace\n    return levelIndex(level) <= this.defaultLevelIndex\n  }\n  silent = false\n}\n\nexport const LogLevelRe = /^(?:(.+?):)?(fatal|error|warn|info|debug|trace)$/i\n\nexport interface LogLevelContext {\n  prefix: string\n  levelIndex: number\n}\n\n// Replaced with a LogFilterImpl at log setup time (to avoid a dependency loop)\nexport const logFilter = lazy<LogFilter>(\n  () => new SimpleLogFilter(LogLevels.warn)\n)\n\n// set to watch Settings.logLevel by SetupLogger:\nexport const defaultLogLevel = lazy(\n  () => LogLevels.values[logFilter().defaultLevelIndex]\n)\n\nexport function isDefaultLogLevelAtLeast(logLevel: LogLevel) {\n  return logFilter().defaultLevelIndex >= levelIndex(logLevel)\n}\n\nexport function silently<T>(f: () => T): T {\n  try {\n    logFilter().silent = true\n    return f()\n  } finally {\n    logFilter().silent = false\n  }\n}\n\nexport async function silentlyAsync<T>(f: () => PromiseLike<T>): Promise<T> {\n  try {\n    logFilter().silent = true\n    return await f()\n  } finally {\n    logFilter().silent = false\n  }\n}\n\n/**\n * Apply `f()` if the given logLevel is enabled.\n */\nexport function ifLog<T>(logLevel: LogLevel, f: () => T): Maybe<T> {\n  return logFilter().enabled(logLevel) ? f() : undefined\n}\n\nexport function isLogged(logLevel: LogLevel, context?: string) {\n  return logFilter().enabled(logLevel, context)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { Settings } from \"../settings/Settings\"\nimport { StringSetting } from \"../settings/StringSetting\"\nimport { LogFilter, LogLevelContext, LogLevelRe } from \"./LogFilter\"\nimport { LogLevel, LogLevels, levelIndex } from \"./LogLevel\"\n\nexport class LogFilterImpl implements LogFilter {\n  silent = false\n  defaultLevelIndex!: number\n  private readonly contexts: LogLevelContext[] = []\n\n  /**\n   * Parse out directives like LOG=ExifTag:debug,FileIterator:info,warn\n   */\n  constructor(readonly setting: StringSetting = Settings.logLevel) {\n    setting.watch(() => this.#setup.refresh())\n  }\n\n  readonly #setup = lazy(() => {\n    this.contexts.length = 0\n    const logLevel = this.setting.valueOrDefault\n    this.defaultLevelIndex =\n      LogLevels.indexOf(logLevel) ??\n      LogLevels.indexOf(this.setting.defaultValue) ??\n      LogLevels.indexOf(LogLevels.warn)!\n    const arr = compactBlanks(logLevel.split(/[,;]/))\n    for (const ea of arr) {\n      const match = LogLevelRe.exec(ea.trim())\n      if (match == null) {\n        console.error(\"LogFilterImpl: Ignoring '\" + ea + \"' from \" + logLevel)\n      } else {\n        const prefix = toS(match[1]).toLowerCase()\n        const idx = levelIndex(match[2])\n        if (blank(prefix)) {\n          this.defaultLevelIndex = idx\n        } else {\n          this.contexts.push({ prefix, levelIndex: idx })\n        }\n      }\n    }\n  })\n\n  private contextOverride(context?: string): Maybe<LogLevelContext> {\n    if (context == null || this.contexts.length === 0 || blank(context)) return\n    const s = toS(context).toLowerCase()\n    return this.contexts.find(ea => s.startsWith(ea.prefix))\n  }\n\n  enabled(level: LogLevel, context?: string): boolean {\n    if (this.silent) return false\n    const li = levelIndex(level)\n\n    // PERF: unrolled from Opt\n    if (context != null) {\n      const co = this.contextOverride(context)\n      if (co != null) {\n        return li <= co.levelIndex\n      }\n    }\n    return li <= this.defaultLevelIndex\n  }\n\n  highlight(context: string): boolean {\n    // PERF: unrolled from Opt\n    const co = this.contextOverride(context)\n    return co != null && co.levelIndex >= this.defaultLevelIndex\n  }\n}\n","import { secondMs } from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gte } from \"../../fe/Number\"\nimport { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\n/**\n * These are driven by the `console` API\n */\nexport const LogLevels = strEnum(\n  \"fatal\",\n  \"error\",\n  \"warn\",\n  \"info\",\n  \"debug\",\n  \"trace\"\n)\nexport type LogLevel = StrEnumKeys<typeof LogLevels>\n\nconst TraceLevelIndex = LogLevels.indexOf(\"trace\")!\n\nexport function levelIndex(logLevel: string): number {\n  return (\n    LogLevels.indexOf(logLevel) ??\n    LogLevels.indexOf(logLevel.trim().toLowerCase()) ??\n    TraceLevelIndex\n  )\n}\n\nexport function levelGte(lhs: LogLevel | string, rhs: LogLevel | string) {\n  return gte(LogLevels.indexOf(lhs), LogLevels.indexOf(rhs))\n}\n\n// https://en.wikipedia.org/wiki/Syslog#Severity_level\nconst LogLevel2SyslogLevel = new Map<LogLevel, number>([\n  [LogLevels.fatal, 1],\n  [LogLevels.error, 3],\n  [LogLevels.warn, 4],\n  [LogLevels.info, 6],\n  [LogLevels.debug, 7]\n])\n\nexport function level2syslog(logLevel: string): Maybe<number> {\n  return LogLevel2SyslogLevel.get(logLevel as any)\n}\n\nexport function msTolevel(\n  elapsedMs: number,\n  errorMs: number = 7 * secondMs\n): LogLevel {\n  return elapsedMs >= errorMs\n    ? \"error\"\n    : elapsedMs >= errorMs / 2\n    ? \"warn\"\n    : elapsedMs >= errorMs / 4\n    ? \"info\"\n    : \"debug\"\n}\n","import { isNotEmpty } from \"../../fe/Array\"\nimport { keys } from \"../../fe/Object\"\nimport { isPromiseLike } from \"../../fe/Promise\"\nimport { ellipsize, isString } from \"../../fe/String\"\nimport { isError } from \"../../fe/isError\"\nimport { diff } from \"../Array\"\nimport { mapNullEntries } from \"../Object\"\nimport { errorToVerbose } from \"../error/Error\"\nimport { Settings } from \"../settings/Settings\"\nexport const PromisePlaceholder = \"(promise)\"\n\n/**\n * Prepare a log entry's `meta` for serialization\n */\nexport function prepMeta(meta: any, levels = 4): any {\n  if (meta == null) {\n    return null // <- util.inspect removes `undefined` object key/value pairs\n  }\n  if (levels < 0) return \"…\"\n  // If it's a primitive, we're done:\n  if (isString(meta) || Buffer.isBuffer(meta)) {\n    return ellipsize(meta.toString(), 256, 32)\n  }\n  if (isError(meta)) {\n    return errorToVerbose(meta)\n  }\n  if (Array.isArray(meta)) {\n    const limit = Settings.logContextLimit.valueOrDefault\n    const len = Math.floor(limit / 2)\n    return meta.length <= limit\n      ? meta\n      : [\n          ...meta.slice(0, len).map(ea => prepMeta(ea, levels - 1)),\n          `… (${meta.length} total entries)`,\n          ...meta.slice(-len).map(ea => prepMeta(ea, levels - 1))\n        ]\n  }\n  // lazy() returns a function!\n  if (typeof meta === \"object\" || typeof meta === \"function\") {\n    for (const meth of [\"toLogJSON\", \"toJSON\"]) {\n      if (typeof meta[meth] === \"function\") {\n        return prepMeta(meta[meth](), levels - 1)\n      }\n    }\n    if (isPromiseLike(meta)) {\n      // Deferred and Latch already have a toLogJSON, so meta must not be\n      // something from us.\n      return PromisePlaceholder\n    }\n\n    // Have we already truncated this object?\n    if (\"…\" in meta) return meta\n\n    const result = mapNullEntries(\n      meta,\n      (_, v) => prepMeta(v, levels - 1),\n      Settings.logContextLimit.valueOrDefault\n    )\n\n    const omittedKeys = diff(keys(meta), keys(result))\n    if (isNotEmpty(omittedKeys)) {\n      result[\"…\"] = \"omitted: \" + ellipsize(omittedKeys.join(\", \"), 128, 32)\n    }\n    return result\n  }\n\n  // Otherwise give up:\n  return meta\n}\n","import { createReadStream, ReadStream } from \"fs\"\nimport { createBrotliDecompress, createGunzip } from \"zlib\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { stripCopySuffixFromName } from \"../fs/FuzzyNames\"\nimport { isExtOrCompressedExt } from \"../fs/Gzip\"\nimport { LineReader } from \"../fs/LineReader\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { SortedSet } from \"../SortedSet\"\nimport { LogEntry, logEntrySorter } from \"./LogEntry\"\nimport { chunkToLogEntry } from \"./ReadLogEntries\"\n\n// Lines were out of order on speedy with 128, and seemed OK at 512.\nconst LowWatermark = 1024\nconst HighWatermark = LowWatermark * 10\n\nexport class LogReader {\n  readonly start = Date.now()\n  readonly lines = new SortedSet<LogEntry>(logEntrySorter)\n  private readonly fileStream: ReadStream\n  private readonly stream: LineReader\n  private readonly from: string\n  #ended = false\n  #paused = false\n  #hasErrors = false\n\n  constructor(\n    readonly f: SimpleFile,\n    errorHandler: (error: Error) => any\n  ) {\n    this.from = stripCopySuffixFromName(f.name)\n    this.fileStream = createReadStream(f.nativePath, { autoClose: true })\n    if (!isExtOrCompressedExt(f.ext, \".log\")) {\n      throw new Error(f + \" is not a logfile\")\n    }\n    this.stream = (\n      f.ext.toLowerCase().endsWith(\".gz\")\n        ? this.fileStream.pipe(createGunzip())\n        : f.ext.toLowerCase().endsWith(\".br\")\n        ? this.fileStream.pipe(createBrotliDecompress())\n        : this.fileStream\n    )\n      .pipe(new LineReader())\n      .on(\"error\", err => {\n        errorHandler(err)\n        this.#hasErrors = true\n      })\n    this.stream.on(\"data\", this.#onData.bind(this))\n    this.stream.on(\"close\", () => {\n      this.fileStream.resume()\n      this.#ended = true\n    })\n    this.stream.on(\"end\", () => {\n      this.#ended = true\n    })\n  }\n\n  #onData(chunk: string) {\n    if (chunk === null) {\n      this.#ended = true\n    } else {\n      const le = chunkToLogEntry(chunk)\n      if (le != null) {\n        this.lines.add({ ...le, from: this.from } as LogEntry)\n      }\n      if (this.lines.length > HighWatermark && !this.#paused) {\n        this.fileStream.pause()\n        this.#paused = true\n      }\n    }\n  }\n\n  toString() {\n    return \"LogReader(\" + this.f.nativePath + \")\"\n  }\n\n  status() {\n    return {\n      hasErrors: this.#hasErrors,\n      ended: this.#ended,\n      destroyed: this.stream.destroyed,\n      lines: this.lines.length,\n      paused: this.#paused\n    }\n  }\n\n  hasErrors() {\n    return this.#hasErrors\n  }\n\n  get ended() {\n    return this.#ended\n  }\n\n  ready() {\n    return this.ended || this.lines.length > 32\n  }\n\n  complete() {\n    return this.ended && this.lines.length === 0\n  }\n\n  peek(): Maybe<LogEntry> {\n    return this.ready() ? this.lines.store[0] : undefined\n  }\n\n  shift() {\n    const result = this.lines.store.shift()\n    if (result != null) this.#onShift()\n    return result\n  }\n\n  shiftLte(ts: number) {\n    const result = this.lines.shiftLte(ts)\n    if (result.length > 0) this.#onShift()\n    return result\n  }\n\n  #onShift() {\n    if (this.lines.length < LowWatermark && this.#paused) {\n      this.fileStream.resume()\n      this.#paused = false\n    }\n  }\n}\n","import { FSWatcher, watch } from \"fs\"\nimport { join, sep } from \"path\"\nimport { pid, stdout } from \"process\"\nimport { clearInterval, setInterval } from \"timers\"\nimport { lazy } from \"../../core/Lazy\"\nimport { notBlank, notBlankOr } from \"../../fe/Blank\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gte } from \"../../fe/Primitive\"\nimport { thenMap } from \"../../fe/Promise\"\nimport { isTest } from \"../NodeEnv\"\nimport { serviceName } from \"../ServiceNames\"\nimport { consoleError, consoleLog } from \"../Stdout\"\nimport { stdoutEnded } from \"../StdoutEnded\"\nimport { TTLSet } from \"../TTLSet\"\nimport { EndableRanks, ending } from \"../async/Endable\"\nimport { EndableWrapper } from \"../async/EndableWrapper\"\nimport { Promises } from \"../async/Promises\"\nimport { nowish } from \"../date/Date\"\nimport { errorToS } from \"../error/Error\"\nimport { DirectoryEntry } from \"../fs/DirectoryEntry\"\nimport { mkdirp_ } from \"../fs/Path\"\nimport { Settings } from \"../settings/Settings\"\nimport { readSystemSettings } from \"../settings/SettingsIO\"\nimport { DefaultLogFormatter } from \"./DefaultLogFormatter\"\nimport { DefaultLogFlushMs } from \"./LogCommon\"\nimport { datedLogDir } from \"./LogDir\"\nimport { LogEntry } from \"./LogEntry\"\nimport { ifLog } from \"./LogFilter\"\nimport { LogLevels } from \"./LogLevel\"\nimport {\n  popExpiredLogEntries,\n  pushLogEntries,\n  setLogTailEnabled\n} from \"./LogTailEntries\"\nimport { readLogEntries } from \"./ReadLogEntries\"\n\nexport function DefaultLogEntryWriter(arr: LogEntry[]) {\n  const f = DefaultLogFormatter()\n  for (const ea of arr) {\n    consoleLog(f.formatLogEntry(ea))\n  }\n}\n\n/**\n * Tail all PhotoStructure✱/log/✱✱/✱.log files.\n */\nexport class LogTail extends EndableWrapper {\n  static readonly instance = lazy(() => {\n    return stdoutEnded() ? undefined : new LogTail()\n  })\n  private root!: DirectoryEntry\n  private watchers: Map<string, FSWatcher> = new Map()\n  private flushTimeout?: NodeJS.Timeout\n  private scanTimeout?: NodeJS.Timeout\n  private ignorableFilename: string\n  private readonly filenameMutexes = new Promises(\"log.LogTail\", () => 8)\n\n  private readonly file2pos = new Map<string, number>()\n  private readonly lastReadFiles = new TTLSet<string>(5 * secondMs)\n\n  constructor(\n    readonly rootNativePath: Maybe<string> = undefined,\n    readonly writer = DefaultLogEntryWriter\n  ) {\n    super(\"LogTail\", () => this.close(), EndableRanks.logtail)\n    this.ignorableFilename = sep + serviceName() + \"-\" + pid + \"-\"\n    if (stdout.writableFinished) return\n\n    setLogTailEnabled(true)\n    // Not an unref'ed interval, so logtail doesn't exit:\n    this.flushTimeout = setInterval(() => this.flush(), DefaultLogFlushMs / 2)\n    this.scanTimeout = setInterval(() => this.scan(), minuteMs)\n    stdout.on(\"end\", () => this.end())\n    void this.setup()\n  }\n\n  readonly setup = lazy(async () => {\n    await readSystemSettings()\n    const logdir = notBlankOr(\n      this.rootNativePath,\n      Settings.logDir.valueOrDefault\n    )\n    if (isTest) consoleLog(\"tailing \" + logdir + \"...\")\n    await mkdirp_(logdir)\n    this.root = (await DirectoryEntry.for(logdir))!\n    await this.scan(true)\n  })\n\n  async flush() {\n    this.writer(popExpiredLogEntries())\n  }\n\n  private readable(nativePath: string) {\n    return (\n      // Don't tail .gz files: they're never updated.\n      nativePath.endsWith(\".log\") &&\n      !nativePath.includes(this.ignorableFilename)\n    )\n  }\n\n  private watchDir(dir: string) {\n    if (ending() || this.ended) return\n    getOrSet(this.watchers, dir, () => {\n      ifLog(LogLevels.debug, () => consoleLog(\"LogTail(): watching \" + dir))\n      try {\n        return watch(dir, (event: string, filename: string | null) => {\n          if (notBlank(filename)) {\n            void this.watchListener(event, join(dir, filename))\n          }\n        })\n      } catch (err) {\n        ifLog(LogLevels.warn, () =>\n          consoleError(\"LogTail(): failed to read \" + dir, err)\n        )\n        return\n      }\n    })\n  }\n\n  async scan(firstTime = false) {\n    if (ending() || this.ended) return\n    // scan through logs and set the position for all current entries:\n    await this.root.visitDescendants(async ea => {\n      if (!this.readable(ea.nativePath)) return\n      if (firstTime) {\n        await thenMap(ea.size(), size => this.file2pos.set(ea.nativePath, size))\n      }\n      if (nowish(await ea.mtimeMs(), 5 * minuteMs)) {\n        this.watchDir(ea.dir)\n      }\n    })\n    if (ending() || this.ended) return\n    const currentLogDir = datedLogDir(this.root.nativePath)\n    try {\n      // if they start logtail before anything else, we want to see those new\n      // files:\n      await mkdirp_(currentLogDir)\n      this.watchDir(currentLogDir)\n    } catch (err) {\n      ifLog(LogLevels.warn, () =>\n        consoleError(\n          \"LogTail(): Failed to list or mkdir -p \" +\n            currentLogDir +\n            \": there may be permission issues.\",\n          err\n        )\n      )\n    }\n    if (ending() || this.ended) return\n    if (firstTime) {\n      consoleLog(\"LogTail(): Tailing \" + this.root + \"/**/*.log...\")\n    }\n  }\n\n  private async close() {\n    setLogTailEnabled(false)\n    map(this.flushTimeout, clearInterval)\n    this.flushTimeout = undefined\n    map(this.scanTimeout, clearInterval)\n    this.scanTimeout = undefined\n    for (const ea of this.watchers.values()) {\n      ea.close()\n    }\n    this.watchers.clear()\n    for (const ea of this.lastReadFiles) {\n      await this.watchListener(\"onEnd\", ea)\n    }\n    try {\n      this.writer(popExpiredLogEntries(-1))\n    } catch (error) {\n      console.warn(\"failed to flush last log entries\", error)\n    }\n  }\n\n  private async watchListener(event: string, filename: string) {\n    if (!this.readable(filename) || event === \"rename\") {\n      return\n    }\n    await this.filenameMutexes.serial(filename, async () => {\n      try {\n        const f = await DirectoryEntry.for(filename)\n        if (f == null) {\n          // file was deleted or compressed. DON'T FREAK OUT.\n          return\n        }\n        // if (!nowish(await f.mtimeMs(), 10 * minuteMs)) return // old file\n        const currentSize = await f.size()\n        if (currentSize == null || currentSize <= 0) {\n          // consoleError(\"watchListener: empty file\", { event, filename })\n          return\n        }\n        const priorSize = this.file2pos.get(f.nativePath) ?? 0\n        if (gte(priorSize, currentSize)) return\n        await thenMap(\n          readLogEntries(f, { start: priorSize, end: currentSize }),\n          arr => pushLogEntries(...arr)\n        )\n        this.lastReadFiles.add(f.nativePath)\n        // If gzip reading fails, don't update current size:\n        this.file2pos.set(f.nativePath, currentSize)\n      } catch (err) {\n        ifLog(LogLevels.warn, () =>\n          consoleError(\"Failed to read \" + filename + \": \" + errorToS(err))\n        )\n      }\n    })\n    return\n  }\n}\n","import { SortedSet } from \"../SortedSet\"\nimport { stdoutEnded } from \"../StdoutEnded\"\nimport { DefaultLogFormatter } from \"./DefaultLogFormatter\"\nimport { DefaultLogFlushMs } from \"./LogCommon\"\nimport { LogEntry, logEntrySorter } from \"./LogEntry\"\n\n// Separated from LogTail to break dependency loops\n\nlet _logTailEnabled = false\n\nexport function logTailEnabled() {\n  return _logTailEnabled\n}\n\nexport function setLogTailEnabled(b: boolean) {\n  _logTailEnabled = b\n}\n\nexport const logEntries = new SortedSet<LogEntry>(logEntrySorter)\n\n// WTH, AMIRITE? ConsoleLogger calls this method. If we're not tailing logs,\n// we don't need to order our log entries correctly, and can just console.log\n// immediately.\n\nexport function pushLogEntries(...arr: LogEntry[]) {\n  // PERF: for loop instead of .forEach\n  for (const ea of arr) {\n    // don't use Settings.logTail:\n    if (_logTailEnabled) {\n      logEntries.add(ea)\n    } else {\n      // if stdout is closed, don't try to write to it!\n      if (!stdoutEnded()) {\n        console.log(DefaultLogFormatter().formatLogEntry(ea))\n      }\n    }\n  }\n}\n\n/**\n * @param ttl if zero, pop everything (we're shutting down)\n */\nexport function popExpiredLogEntries(ttl = DefaultLogFlushMs * 2) {\n  return logEntries.shiftLte(Date.now() - ttl)\n}\n","import _fs from \"fs\"\nimport { join } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { nextMidnightTs, secondMs } from \"../../fe/Date\"\nimport { delay } from \"../../fe/Delay\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { Thunk } from \"../../fe/Thunk\"\nimport { RateLimited, rateLimited } from \"../RateLimited\"\nimport { processName } from \"../ServiceNames\"\nimport { stripAnsiEsc } from \"../String\"\nimport { EndableRanks } from \"../async/Endable\"\nimport { EndableInterval } from \"../async/EndableInterval\"\nimport { ensureNewNativePath_ } from \"../fs/EnsureNew\"\nimport { gzip_ } from \"../fs/Gzip\"\nimport { endStream } from \"../fs/Streams\"\nimport { Settings } from \"../settings/Settings\"\nimport { ConsoleLogger } from \"./ConsoleLogger\"\nimport { DefaultLogFlushMs } from \"./LogCommon\"\nimport { datedLogDir } from \"./LogDir\"\nimport { LogEntry } from \"./LogEntry\"\nimport { LogFilter, logFilter } from \"./LogFilter\"\nimport { ContextProvider } from \"./LogFormatter\"\nimport { LogLevel } from \"./LogLevel\"\nimport { prepMeta } from \"./LogMeta\"\nimport { SimpleLogger } from \"./Logger\"\nimport { clearRecentLogEntries, recentLogEntries } from \"./RecentLogs\"\n\nexport class CaptureLogger implements SimpleLogger {\n  readonly logEntries: LogEntry[] = []\n  log(level: LogLevel, context: string, message: string, meta?: any) {\n    this.logEntries.push({\n      ts: Date.now(),\n      l: level,\n      ctx: context,\n      msg: message,\n      meta\n    })\n  }\n\n  enabled() {\n    return true\n  }\n\n  end() {\n    // no-op\n  }\n\n  async flush() {\n    // no-op\n  }\n}\n\nexport interface LogWriterOptions extends ContextProvider {\n  maxLinesPerFile: number\n  errorLogger: SimpleLogger\n  flushEveryMs: number\n  logFilter?: Thunk<LogFilter>\n}\n\ninterface Logfile {\n  stream: NodeJS.WritableStream\n  nativePath: string\n}\n\nfunction defaultLogWriterOptions(): Required<LogWriterOptions> {\n  return {\n    maxLinesPerFile: 250000, // ~ 10-20 Mb\n    errorLogger: ConsoleLogger.instance(),\n    flushEveryMs: DefaultLogFlushMs,\n    processName: processName,\n    logFilter: logFilter\n  }\n}\n\n/**\n * Writes to logDir/YYYY-MM-DD/name-00N.log\n */\nexport class LogWriter extends EndableInterval implements SimpleLogger {\n  private readonly logOpts: Required<LogWriterOptions>\n  private readonly pendingWrites: LogEntry[] = []\n  private _linesSinceRotate: number = 0\n  private _nextForcedRotateTs = nextMidnightTs()\n  private _logfile: Maybe<Logfile>\n\n  readonly flush: RateLimited<void>\n\n  private _startIndex = 0\n\n  // gzipping the logfiles should not take longer than 10 seconds (assuming logs\n  // are on fast local disk)\n  readonly endTimeoutMs = 15 * secondMs\n\n  constructor(\n    readonly logDir: string,\n    options: Partial<LogWriterOptions> = {}\n  ) {\n    super({\n      name: \"LogWriter(\" + logDir + \")\",\n      callback: () => this.flush(),\n      intervalMs: Math.round(options.flushEveryMs ?? DefaultLogFlushMs * 1.25),\n      rank: EndableRanks.logger\n    })\n    this.logOpts = {\n      ...defaultLogWriterOptions(),\n      ...options\n    }\n    this.onEnds.push(() => this.#end())\n    this.setIntervalMs(this.logOpts.flushEveryMs)\n\n    this.flush = rateLimited({\n      name: \"LogWriter.flush()\",\n      minCallDelayMs: this.logOpts.flushEveryMs,\n      f: () => this.#flush()\n    })\n  }\n\n  toJSON() {\n    return {\n      _ctor: \"LogWriter\",\n      logDir: this.logDir\n    }\n  }\n\n  enabled(level: LogLevel, context?: string): boolean {\n    return this.logOpts.logFilter().enabled(level, context)\n  }\n\n  log(level: LogLevel, context: string, msg: string, meta?: any) {\n    if (this.enabled(level, context)) {\n      if (this.ended && level === \"error\") {\n        // If it's bad, send the message someplace, at least.\n        this.logOpts.errorLogger.log(level, context, msg, meta)\n      } else {\n        const entry: LogEntry = { ts: Date.now(), l: level, ctx: context, msg }\n        if (meta != null) entry.meta = prepMeta(meta)\n        if (level === \"error\") {\n          // If we push entry before this, the recentLogEntries show out of order:\n          this.writeRecentLogEntries()\n        }\n        this.pendingWrites.push(entry)\n      }\n    }\n  }\n\n  // must not be async (so this.log can stay sync)\n  writeRecentLogEntries() {\n    this.pendingWrites.push(...recentLogEntries())\n    // we don't want to write these entries more than once:\n    clearRecentLogEntries()\n  }\n\n  readonly #end = lazy(async () => {\n    await this.flush.force()\n    return this.#closeCurrent()\n  })\n\n  shouldRotate() {\n    return (\n      this._logfile == null ||\n      this._linesSinceRotate >= this.logOpts.maxLinesPerFile ||\n      Date.now() >= this._nextForcedRotateTs\n    )\n  }\n\n  async #flush() {\n    const toFlush = [...this.pendingWrites]\n    this.pendingWrites.length = 0\n    while (toFlush.length > 0) {\n      if (this.shouldRotate()) await this.#rotate()\n      const stream = this._logfile?.stream\n      if (stream == null) {\n        this.logOpts.errorLogger.log(\n          \"error\",\n          \"LogWriter.flush()\",\n          \"this._rotate() returned an empty stream\"\n        )\n        return\n      }\n      const remainingCapacity = clamp(\n        0,\n        toFlush.length,\n        this.logOpts.maxLinesPerFile - this._linesSinceRotate\n      )\n\n      const lines = toFlush.splice(0, remainingCapacity)\n\n      this._linesSinceRotate += lines.length\n      stream.write(lines.map(ea => stringify(ea) + \"\\n\").join(\"\"))\n    }\n    return\n  }\n\n  #onError(source: string, error: any) {\n    this.logOpts.errorLogger.log(\"error\", \"Caught error from \" + source, error)\n  }\n\n  #errback(source: string) {\n    return (error: any) => {\n      this.#onError(source, error)\n      return this.#closeCurrent()\n    }\n  }\n\n  // Must only be called by this._flush()\n  async #rotate(): Promise<void> {\n    await this.#closeCurrent()\n    const name = stripAnsiEsc(this.logOpts.processName())\n    const nativePath = await ensureNewNativePath_({\n      nativePath: join(datedLogDir(this.logDir), name + \".log\"),\n      emptyIsNew: true,\n      startIndex: ++this._startIndex,\n      requireNumber: true,\n      leftPad: 3 // we're in trouble if we're writing more than 100 log files a day.\n    })\n    const stream = _fs\n      .createWriteStream(nativePath)\n      .on(\"error\", this.#errback(\"file write stream\"))\n    this._logfile = { stream, nativePath }\n    this._nextForcedRotateTs = nextMidnightTs()\n  }\n\n  async #closeCurrent() {\n    // not this.end(), because we don't want to flush:\n    const prior = this._logfile\n    this._logfile = undefined\n    this._linesSinceRotate = 0\n\n    if (prior != null) {\n      try {\n        await endStream(prior.stream)\n        if (Settings.logCompression.valueOrDefault) {\n          // let logtail see the result of the file:\n          await delay(this.logOpts.flushEveryMs)\n          await gzip_(prior.nativePath)\n        }\n      } catch (err) {\n        this.#onError(\"_closeCurrent()\", err)\n      }\n    }\n  }\n}\n","import { inspect, InspectOptions } from \"util\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { map } from \"../../fe/Maybe\"\nimport { fromEntries } from \"../../fe/Object\"\nimport { toS } from \"../../fe/toS\"\nimport { processName } from \"../ServiceNames\"\nimport { rightPad, stripAnsiEsc } from \"../String\"\nimport { LogEntry } from \"./LogEntry\"\nimport { LogFormatter } from \"./LogFormatter\"\nimport { LogLevel, LogLevels } from \"./LogLevel\"\n\nexport class PlaintextLogFormatter implements LogFormatter {\n  constructor(\n    readonly inspectOptions: InspectOptions = {\n      colors: false,\n      depth: 4,\n      compact: true,\n      customInspect: true\n    }\n  ) {}\n\n  readonly paddedLogLevels = fromEntries(\n    LogLevels.values.map(ea => [ea, rightPad(ea, 5, \" \")])\n  )\n\n  formatLogEntry(le: LogEntry): string {\n    return compactBlanks([\n      new Date(le.ts).toISOString(),\n      le.from ?? processName(),\n      this.paddedLogLevels[le.l],\n      stripAnsiEsc(le.ctx),\n      stripAnsiEsc(le.msg),\n      map(le.meta, ea => inspect(ea, this.inspectOptions))\n    ])\n      .map(ea => toS(ea))\n      .join(\" \")\n  }\n\n  format(\n    level: LogLevel,\n    context: string,\n    message: string,\n    meta?: any\n  ): string {\n    return this.formatLogEntry({\n      ts: Date.now(),\n      l: level,\n      from: processName(),\n      ctx: context,\n      msg: message,\n      meta\n    })\n  }\n}\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { splitLines } from \"../fs/CRLF\"\nimport { stripCopySuffixFromName } from \"../fs/FuzzyNames\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { zcat } from \"../fs/zcat\"\nimport { LogEntry, isLogEntry } from \"./LogEntry\"\n\nexport async function readLogEntries(\n  f: SimpleFile,\n  options?: { start?: number; end?: number }\n): PromiseMaybe<LogEntry[]> {\n  const from = stripCopySuffixFromName(f.name)\n  const result: LogEntry[] = []\n  const buf = await zcat(f.nativePath, options)\n  if (buf != null) {\n    for (const line of splitLines(buf)) {\n      const le = chunkToLogEntry(line)\n      if (le != null) result.push({ ...le, from })\n    }\n  }\n  return result\n}\n\nexport function chunkToLogEntry(chunk: any): Maybe<LogEntry> {\n  if (blank(chunk)) return\n  try {\n    const le = JSON.parse(chunk)\n    return isLogEntry(le) ? le : undefined\n  } catch (error) {\n    return\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { fromEntries, values } from \"../../fe/Object\"\nimport { BoundedList } from \"../BoundedList\"\nimport { LogEntry } from \"./LogEntry\"\nimport { LogLevel, LogLevels } from \"./LogLevel\"\n\nexport const SentLogLevels = lazy(() =>\n  LogLevels.values.filter(ea => ea !== LogLevels.trace)\n)\n\nconst MaxPerLevel = 48\n\n// https://github.com/Microsoft/TypeScript/issues/24220#issuecomment-449325451\ntype Level2Recent = { [l in LogLevel]: BoundedList<LogEntry> }\n\n/**\n * These are log entries that were *not* written to the log file (but will be\n * interesting if we want to \"send recent logs\".\n *\n * They are flushed to the logfile by log.error or by calling\n * writeRecentLogEntries()\n */\nconst recentLogEntriesByLevel = lazy<Level2Recent>(() =>\n  fromEntries(\n    SentLogLevels().map(ea => [ea, new BoundedList<LogEntry>(MaxPerLevel)])\n  )\n)\n\nexport function clearRecentLogEntries() {\n  values(recentLogEntriesByLevel()).forEach(ea => ea.clear())\n}\n\nexport function addRecentLogEntry(le: LogEntry) {\n  recentLogEntriesByLevel()[le.l]?.push(le)\n}\n\nexport function recentLogEntries() {\n  const arr: LogEntry[] = []\n  for (const bl of values(recentLogEntriesByLevel())) {\n    arr.push(...bl.toA())\n  }\n  return sortBy(arr, ea => ea.ts)\n}\n","import { join } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { map } from \"../../fe/Maybe\"\nimport { setColorEnabled } from \"../Chalk\"\nimport { rootLoggers } from \"../Logger\"\nimport { end } from \"../async/Endable\"\nimport { cacheDir } from \"../dir/CacheDir\"\nimport { logDir } from \"../dir/LogDir\"\nimport { env } from \"../env/Env\"\nimport { isEnvTrue } from \"../env/GetEnv\"\nimport { writeTextfile_ } from \"../fs/WriteFile\"\nimport { Settings } from \"../settings/Settings\"\nimport { ColoredLogFormatter } from \"./ColoredLogFormatter\"\nimport { ConsoleLogger } from \"./ConsoleLogger\"\nimport { currentFileLogger } from \"./CurrentFileLogger\"\nimport { DefaultLogFormatter } from \"./DefaultLogFormatter\"\nimport { logBroadcaster } from \"./LogBroadcaster\"\nimport { defaultLogLevel, logFilter } from \"./LogFilter\"\nimport { LogFilterImpl } from \"./LogFilterImpl\"\nimport { LogTail } from \"./LogTail\"\nimport { LogWriter } from \"./LogWriter\"\nimport { SimpleLogger } from \"./Logger\"\nimport { PlaintextLogFormatter } from \"./PlaintextLogFormatter\"\n\nconst readme = `PhotoStructure writes logfiles to this directory.\n\nAlthough you _can_ directly read these .json files, you don't need to!\n\nUse PhotoStructure's \"logcat\" and \"logtail\" tools to merge and pretty-print these files.\n\nSee https://photostructure.com/server/tools/#logging for details.\n`\n\nexport const setupLogger = lazy(() => {\n  if (!(logFilter() instanceof LogFilterImpl)) {\n    logFilter.set(new LogFilterImpl())\n  }\n  setupLogFormatter()\n\n  const dir = logDir()\n  let fl = currentFileLogger()\n  if (fl == null || fl.logDir !== dir) {\n    void end(fl)\n    void writeTextfile_(join(dir, \"README.txt\"), readme).catch(() => null)\n    fl = new LogWriter(dir)\n  }\n  const loggers: SimpleLogger[] = [fl]\n  const pushConsoleLogger =\n    isEnvTrue(\"logStdout\") ||\n    Settings.logStdout.valueOrDefault ||\n    Settings.tailLogs.valueOrDefault\n\n  if (pushConsoleLogger) {\n    loggers.push(ConsoleLogger.instance())\n  }\n  map(logBroadcaster(), ea => loggers.push(ea))\n\n  rootLoggers.set(loggers)\n\n  if (Settings.tailLogs.valueOrDefault) {\n    LogTail.instance()\n  }\n\n  Settings.logLevel.watchLater(() => defaultLogLevel.unset())\n\n  setColorEnabled(Settings.logColor.valueOrDefault)\n\n  // make sure cacheDir() is set up for FileCache():\n  cacheDir()\n\n  // After we're done, then watch for later changes:\n  watchSettings()\n})\n\nexport const setupLogFormatter = lazy(() => {\n  const current = DefaultLogFormatter()\n  const currentIsColored = current instanceof ColoredLogFormatter\n  const settingIsColored =\n    env().NO_COLOR == null && Settings.logColor.valueOrDefault\n  if (currentIsColored !== settingIsColored) {\n    DefaultLogFormatter.set(\n      settingIsColored ? new ColoredLogFormatter() : new PlaintextLogFormatter()\n    )\n  }\n})\n\nconst watchSettings = lazy(() => {\n  // watch later, because this is called by setupLogger() already...\n  Settings.logStdout.watchLater(() => setupLogger.refresh())\n  Settings.logDir.watchLater(() => setupLogger.refresh())\n  Settings.tailLogs.watchLater(() => setupLogger.refresh())\n  Settings.logColor.watchLater(() => setupLogFormatter.refresh())\n})\n","import { currentFileLogger } from \"./CurrentFileLogger\"\n\nexport function writeRecentLogEntries() {\n  return currentFileLogger()?.writeRecentLogEntries()\n}\n","import { inspect } from \"util\"\nimport { mapNotEmpty } from \"../../fe/Array\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isNumber, sigFigs } from \"../../fe/Number\"\nimport { tap } from \"../../fe/Object\"\nimport { toA } from \"../../fe/toA\"\nimport { zip } from \"../Array\"\nimport { BoundedList } from \"../BoundedList\"\nimport { CountingSet } from \"../CountingSet\"\nimport { mapGte0f } from \"../Number\"\nimport {\n  MaybeNumericList,\n  avg,\n  max,\n  min,\n  slope,\n  stdDev,\n  variance,\n  weightedAvg\n} from \"./Vector\"\n\nexport interface AverageStats {\n  k: number\n  mean?: number\n  mode?: number\n  sd?: number\n  max?: number\n  min?: number\n  sum?: number\n}\n\nexport function averageStats(vec: number[]) {\n  return new Average().pushAll(vec).stats()\n}\n\nexport class Average {\n  static merge(a: Average, b: Average): Average {\n    if (a.n === 0 && b.n === 0) {\n      return new Average(Math.max(a.maxSamples, b.maxSamples))\n    } else if (a.n === 0) {\n      return b.clone()\n    } else if (b.n === 0) {\n      return a.clone()\n    } else if (a.n <= a.maxSamples) {\n      const r = b.clone()\n      r.pushAll(a.samples)\n      return r\n    } else if (b.n <= b.maxSamples) {\n      const r = a.clone()\n      r.pushAll(b.samples)\n      return r\n    } else {\n      const r = new Average(Math.max(a.maxSamples, b.maxSamples))\n      r._n = a.n + b.n\n      r._min = Math.min(a._min!, b._min!)\n      r._max = Math.max(a._max!, b._max!)\n      r._m = (a._m! * a.n) / r.n + (b._m! * b.n) / r.n\n      r._s = (a._s! * a.n) / r.n + (b._s! * b.n) / r.n\n      const samples = flatten(zip(a.samples, b.samples))\n      r._samples.push(...samples)\n      r._weightedTotalAvg = weightedAvg([r._m, ...samples])\n      return r\n    }\n  }\n\n  protected _n: number\n  protected _min?: number\n  protected _max?: number\n  protected _m?: number\n  protected _s?: number\n  protected _weightedTotalAvg?: number\n  protected readonly _samples: BoundedList<number>\n\n  constructor(readonly maxSamples: number = 20) {\n    this._n = 0\n    this._samples = new BoundedList(maxSamples)\n  }\n\n  [inspect.custom]() {\n    return this.stats()\n  }\n\n  toJSON() {\n    return {\n      _ctor: \"Average\",\n      n: this._n,\n      _m: this._m,\n      _s: this._s,\n      min: this._min,\n      max: this._max,\n      samples: this._samples.toA()\n    }\n  }\n\n  static fromJSON(obj: ReturnType<Average[\"toJSON\"]>) {\n    return new Average().with(obj)\n  }\n\n  with(obj: ReturnType<Average[\"toJSON\"]>) {\n    this._n = obj.n\n    this._min = obj.min\n    this._max = obj.max\n    this._m = obj._m\n    this._s = obj._s\n    this._samples.push(...toA(obj.samples))\n  }\n\n  merge(b: Maybe<Average>) {\n    if (b == null || b.n === 0) return this\n    if (this.n === 0) return this.with(b.toJSON())\n    this._min = min([this._min, b.min])\n    this._max = max([this._max, b.max])\n    const n = this.n + b.n\n    this._m = (this._m! * this.n) / n + (b._m! * b.n) / n\n    this._s = (this._s! * this.n) / n + (b._s! * b.n) / n\n    this._n += b._n\n    this._samples.push(...toA(b.samples))\n    return this\n  }\n\n  push(x: number): number {\n    if (!isFinite(x)) throw new Error(\"Average.push(\" + x + \"): not a number\")\n    this._n++\n    this._samples.push(x)\n    this._min = this._min == null ? x : Math.min(x, this._min)\n    this._max = this._max == null ? x : Math.max(x, this._max)\n\n    // https://math.stackexchange.com/a/116344\n    // https://www.johndcook.com/blog/standard_deviation/\n    if (\n      this._n === 1 ||\n      this._m == null ||\n      this._s == null ||\n      this._weightedTotalAvg == null\n    ) {\n      this._m = x\n      this._s = 0\n      this._weightedTotalAvg = x\n    } else {\n      const priorM = this._m\n      this._m += (x - priorM) / this._n\n      // CAUTION: this isn't correct variation: it's a streaming estimation.\n      this._s += ((x - this._m) * (x - this._m) - this._s!) / this._n\n      this._weightedTotalAvg = (this._weightedTotalAvg + x) / 2\n    }\n    return x\n  }\n\n  clone(): Average {\n    return tap(new Average(this.maxSamples), ea => {\n      ea._n = this._n\n      ea._m = this._m\n      ea._s = this._s\n      ea._min = this._min\n      ea._max = this._max\n      ea._weightedTotalAvg = this._weightedTotalAvg\n      ea._samples.push(...this._samples)\n    })\n  }\n\n  pushAll(arr: MaybeNumericList): this {\n    if (arr != null) {\n      for (const ea of arr) {\n        if (isNumber(ea)) this.push(ea)\n      }\n    }\n    return this\n  }\n\n  stats(sigfigs = 2): AverageStats {\n    const sf = (i?: number) =>\n      map(i, (ea: number) => (ea > 100 ? Math.round(ea) : sigFigs(ea, sigfigs)))\n    const o: AverageStats = {} as any\n    o.k = sf(this.n)!\n    if (!this.empty) {\n      o.mean = sf(this.avg)\n      o.sum = sf(this.sum)\n      // o.mode = sf(this.sampleMode)\n      o.sd = sf(this.stdDev)\n      o.max = sf(this.max)\n      o.min = sf(this.min)\n    }\n    return o\n  }\n\n  get empty(): boolean {\n    return this._n === 0\n  }\n\n  /**\n   * @return the total number of samples provided to `push()`\n   */\n  get n(): number {\n    return this._n\n  }\n\n  get avg(): Maybe<number> {\n    return this.empty ? undefined : sigFigs(this._m!, 4)\n  }\n\n  get sum(): number {\n    return this._n > 0 ? this._m! * this._n : 0\n  }\n\n  get max(): Maybe<number> {\n    return this._max\n  }\n\n  get min(): Maybe<number> {\n    return this._min\n  }\n\n  get last(): Maybe<number> {\n    return this._samples.last\n  }\n\n  #p(sigmasFromMean: number) {\n    return mapGte0f(this.avg, mu =>\n      mapGte0f(this.stdDev, sigma => sigFigs(mu + sigma * sigmasFromMean, 4))\n    )\n  }\n\n  // https://www.desmos.com/calculator/s2ybihaqjup\n\n  /**\n   * @return mean - 1 SD\n   */\n  get p16(): Maybe<number> {\n    return this.#p(-1)\n  }\n\n  get p29(): Maybe<number> {\n    return this.#p(-0.5)\n  }\n\n  get p38(): Maybe<number> {\n    return this.#p(-0.25)\n  }\n\n  /**\n   * @return mean + 1 SD\n   * @see https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule\n   */\n  get p84(): Maybe<number> {\n    return this.#p(1)\n  }\n\n  /**\n   * 97.5% = 50% + (95% / 2)\n   * @return mean + 1 SD\n   * @see https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule\n   */\n  get p98(): Maybe<number> {\n    return this.#p(2)\n  }\n\n  /**\n   * 99.86% = 50% + (99.73% / 2)\n   * @return mean + 1 SD\n   * @see https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule\n   */\n  get p99(): Maybe<number> {\n    return this.#p(3)\n  }\n\n  /**\n   * @return streaming estimation of variance\n   */\n  get variance(): Maybe<number> {\n    return this._s\n  }\n\n  /**\n   * @return streaming estimation of stdev\n   */\n  get stdDev(): Maybe<number> {\n    const v = this.variance\n    return v == null ? undefined : Math.sqrt(v)\n  }\n\n  get sampleMode(): Maybe<number> {\n    return this.sampleModes(1)?.[0]\n  }\n\n  sampleModes(n: number): Maybe<number[]> {\n    if (this.empty) return\n    const c = new CountingSet<number>()\n    this._samples.forEach(ea => c.incr(ea))\n    return c.topKeys(n)\n  }\n\n  get sampleVariance(): Maybe<number> {\n    return mapNotEmpty(this._samples, variance)\n  }\n\n  get sampleStdDev(): Maybe<number> {\n    return mapNotEmpty(this._samples, stdDev)\n  }\n\n  get sampleAvg(): Maybe<number> {\n    return mapNotEmpty(this._samples, avg)\n  }\n\n  get sampleSlope(): number {\n    return orElse(mapNotEmpty(this._samples, slope), 0)\n  }\n\n  get samples(): number[] {\n    return [...this._samples]\n  }\n\n  /**\n   * weighted average of the last `sampleCount` values\n   */\n  get weightedSampleAvg(): Maybe<number> {\n    return map(weightedAvg(this._samples), ea => sigFigs(ea, 4))\n  }\n\n  /**\n   * weighted average of all values\n   */\n  get weightedTotalAvg(): Maybe<number> {\n    return this._weightedTotalAvg\n  }\n\n  clear(): void {\n    this._n = 0\n    this._m = undefined\n    this._s = undefined\n    this._weightedTotalAvg = 0\n    this._samples.length = 0\n  }\n}\n","import { sum } from \"../../fe/Array\"\nimport { map2 } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { absdiff, clamp, times, toInt } from \"../../fe/Number\"\nimport { randomInt } from \"../../fe/Random\"\nimport { zip } from \"../Array\"\nimport { BitZipDimension } from \"./BitZipDimension\"\nimport { avg } from \"./Vector\"\n\nexport interface Dimension {\n  min: number\n  max: number\n}\nexport interface ValuedDimension extends Dimension {\n  value: number\n}\n\nexport interface BitMixArgs {\n  dims: ValuedDimension[]\n  bitDepth: number\n}\n\nexport function concatBits(arr: number[], bitsPerValue: number): number {\n  const max = Math.pow(2, bitsPerValue)\n  return arr.reduce(\n    (acc, i) => acc * max + clamp(0, max, toInt(i, { defaultValue: 0 })!),\n    0\n  )\n}\n\nexport function splitBits(n: number, bitsPerValue: number): number[] {\n  const max = Math.pow(2, bitsPerValue)\n  const result: number[] = []\n  while (n > 0) {\n    result.unshift(n % max)\n    n = Math.floor(n / max)\n  }\n  return result\n}\n\nexport function diffConcattedBits(\n  a: Maybe<number>,\n  b: Maybe<number>,\n  bitsPerValue: number\n): Maybe<number> {\n  return map2(a, b, (ea1, ea2) =>\n    sum(\n      zip(splitBits(ea1, bitsPerValue), splitBits(ea2, bitsPerValue)),\n      ([i, j]) => absdiff(i, j)!\n    )\n  )\n}\n\nexport class BitZip {\n  constructor(readonly dims: BitZipDimension[]) {}\n\n  clampValue(arr: number[]): number[] {\n    return arr.map((ea, i) => clamp(this.dims[i].min, this.dims[i].max, ea))\n  }\n\n  randomValue() {\n    return this.dims.map(dim => randomInt(dim.min, dim.max))\n  }\n\n  zipMin(bitDepth: number): number {\n    return this.zip(\n      this.dims.map(ea => ea.min),\n      bitDepth\n    )\n  }\n\n  zipMax(bitDepth: number): number {\n    return this.zip(\n      this.dims.map(ea => ea.max),\n      bitDepth\n    )\n  }\n\n  zip(value: number[], bitDepth: number) {\n    // We clone these because we change them as we process bits.\n    const min = this.dims.map(d => d.min)\n    const max = this.dims.map(d => d.max)\n    const clamped = this.clampValue(value)\n\n    let result = 0\n\n    for (let bit = 0; bit < bitDepth; bit++) {\n      // shift left, but this may be > 32 bits, so we can't use << operator,\n      // YAY JAVASCRIPT\n      result *= 2\n\n      const dimIndex = bit % min.length\n      const mid = (min[dimIndex] + max[dimIndex]) / 2\n      if (clamped[dimIndex] > mid) {\n        result += 1 // < no bit twiddling, we may be > 32 bits!\n        min[dimIndex] = mid\n      } else {\n        max[dimIndex] = mid\n      }\n    }\n    return result\n  }\n\n  unzip(n: number, bitDepth: number) {\n    const min = this.dims.map(d => d.min)\n    const max = this.dims.map(d => d.max)\n    for (let bit = 0; bit < bitDepth; bit++) {\n      const dIdx = bit % min.length\n      const mid = (min[dIdx] + max[dIdx]) / 2\n      if (isBitSet(n, bitDepth - bit - 1)) min[dIdx] = mid\n      else max[dIdx] = mid\n    }\n    return times(min.length, i => (min[i] + max[i]) / 2)\n  }\n}\n\nconst BitShiftMax = Math.pow(2, 32) - 1\n\nexport function isBitSet(n: number, bit: number, disableBitshifting?: boolean) {\n  if (disableBitshifting !== true && n < BitShiftMax && bit < 32) {\n    return ((n >> bit) & 1) === 1\n  } else {\n    return 1 === Math.floor(n / Math.pow(2, bit)) % 2\n  }\n}\n\nexport function bitZip(a: BitMixArgs): number {\n  a.dims.forEach(dim => (dim.value = clamp(dim.min, dim.max, dim.value)))\n\n  let result = 0\n\n  for (let bit = 0; bit < a.bitDepth; bit++) {\n    result *= 2 // < no bit twiddling, we may be > 32 bits!\n    const dIdx = bit % a.dims.length\n    const d = a.dims[dIdx]\n    const mid = avg([d.min, d.max])!\n    if (d.value > mid) {\n      result += 1 // < no bit twiddling, we may be > 32 bits!\n      d.min = mid\n    } else {\n      d.max = mid\n    }\n  }\n  return result\n}\n\nexport interface BitUnmixArgs {\n  dims: Dimension[]\n  bitDepth: number\n}\n\nexport function bitUnzip(n: number, a: BitUnmixArgs): Maybe<number[]> {\n  if (a.bitDepth > 52 || a.bitDepth < 0) return\n  const setBits = bitsSetBig(n)\n  for (let bit = 0; bit < a.bitDepth; bit++) {\n    const dIdx = bit % a.dims.length\n    const d = a.dims[dIdx]\n    const mid = avg([d.min, d.max])!\n    if (setBits.includes(a.bitDepth - bit - 1)) {\n      d.min = mid\n    } else {\n      d.max = mid\n    }\n  }\n  return a.dims.map(d => avg([d.min, d.max])!)\n}\n\n// Supports > 32 bit numbers\nexport function bitsSetBig(n: number): number[] {\n  return [...n.toString(2)]\n    .reverse()\n    .map((ea, idx) => (ea === \"1\" ? idx : -1))\n    .filter(ea => ea !== -1)\n}\n\n/**\n * Number of set bits in `x`\n * @see https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer#109117\n */\nexport function pop(x: number): number {\n  x = x - ((x >> 1) & 0x55555555)\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n  x = (x + (x >> 4)) & 0x0f0f0f0f\n  x = x + (x >> 8)\n  x = x + (x >> 16)\n  return x & 0x0000003f\n}\n\nexport function bits<T>(arr: T[], f: (t: T, index: number) => boolean): number {\n  return sum(arr, (ea, index) =>\n    f(ea, index) ? Math.pow(2, arr.length - index - 1) : 0\n  )\n}\n","import { compact } from \"../../fe/Array\"\nimport { minuteMs, weekMs } from \"../../fe/Date\"\nimport { fmtDuration } from \"../../fe/FmtDuration\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { lt } from \"../../fe/Number\"\nimport { mkLogger } from \"../Logger\"\nimport { mapGt0 } from \"../Number\"\nimport { Average } from \"./Average\"\nimport { avg } from \"./Vector\"\n\nexport class ETA {\n  private readonly remainingMs = new Average(10)\n  private readonly logger = mkLogger(\"ETA\")\n\n  push(ms: Maybe<number>) {\n    mapGt0(ms, ea => this.remainingMs.push(ea))\n  }\n\n  clear() {\n    this.remainingMs.clear()\n  }\n\n  avg() {\n    return avg(\n      compact([this.remainingMs.weightedSampleAvg, this.remainingMs.sampleMode])\n    )\n  }\n\n  fmtEstimate(delta = 1): Maybe<string> {\n    return mapGt0(this.avg(), ea => {\n      const eta = ea * delta\n      if (eta < minuteMs) {\n        return \"less than a minute remains\"\n      }\n      if (\n        // no crazy-long estimates:\n        eta < weekMs &&\n        // No wildly-fluctuating estimates. 1 sigma should\n        // be < 1/3 mean (people may be irritated with higher fluctuations)\n        lt(this.remainingMs.sampleStdDev, ea / 5)\n      ) {\n        return (\n          \"about \" +\n          fmtDuration(eta, 1, { plural: \"remains\", singular: \"remain\" })\n        )\n      } else {\n        this.logger.debug(\n          \"Skipping remaining, avgMillisRemaining is too wiggly\",\n          {\n            avg: eta,\n            ...this.remainingMs.stats()\n          }\n        )\n        return\n      }\n    })\n  }\n}\n","import { sortBy } from \"../../fe/ArraySort\"\n\nconst ml_kmeans = require(\"ml-kmeans\")\n\nexport interface KMeansOptions {\n  maxIterations: number\n  tolerance: number\n  withIterations: boolean\n  distanceFunction: (a: number[], b: number[]) => number\n  seed: number\n  initialization: \"kmeans++\" | \"random\" | \"mostDistant\" | number[][]\n  description?: string\n  id?: string\n}\n\nexport interface Centroid {\n  centroid: number[]\n  error?: number\n  size: number\n}\n\nexport interface KMeansResult {\n  clusters: number[][]\n  centroids: Centroid[]\n  iterations: number\n  converged: boolean\n}\n\nexport function kmeans(\n  data: number[][],\n  k: number,\n  options?: Partial<KMeansOptions>\n): KMeansResult {\n  const result: KMeansResult = ml_kmeans(data, k, options)\n  return {\n    ...result,\n    centroids: sortBy(\n      result.centroids.filter(ea => ea.size > 0),\n      ea => -ea.size\n    )\n  }\n}\n\n// When ml-kmeans v6.0+ works:\n\n// import { kmeans as ml_kmeans } from \"ml-kmeans\"\n\n// export function kmeans(\n//   data: number[][],\n//   k: number,\n//   options?: Partial<KMeansOptions>\n// ): KMeansResult {\n//   const result = ml_kmeans(data, k, options ?? {})\n//   const info = result.computeInformation(data)\n//   return {\n//     ...result,\n//     centroids: sortBy(\n//       info.filter(ea => ea.size > 0),\n//       ea => -ea.size\n//     )\n//   }\n// }\n","import { sortBy } from \"../../fe/ArraySort\"\n\nexport function lerp(v0: number, v1: number, t = 0.5): number {\n  // See https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n  return (1 - t) * v0 + t * v1\n}\n\nexport interface Point {\n  x: number\n  y: number\n}\n\n/**\n * @return y for the given x, given the line defined p0 and p1\n */\nexport function lerp2d(x: number, ...arr: Point[]): number {\n  const nearest2 = sortBy(arr, ea => Math.abs(x - ea.x)).slice(0, 2)\n  const [p0, p1] = sortBy(nearest2, ea => ea.x)\n\n  const dx = p1.x - p0.x\n  const xdx = x - p0.x\n  const t = xdx / dx\n  return lerp(p0.y, p1.y, t)\n}\n\nexport function lerp2d_(x: number, p0: Point, p1: Point): number {\n  // https://en.wikipedia.org/wiki/Linear_interpolation\n  return (p0.y * (p1.x - x) + p1.y * (x - p0.x)) / (p1.x - p0.x)\n}\n","import { range, stepRange } from \"../../fe/Array\"\nimport { mapFinite } from \"../../fe/Number\"\nimport { concat, greatestIndex, leastIndex } from \"../Array\"\nimport { Average } from \"./Average\"\nimport { mode, sumf } from \"./Vector\"\n\nexport function vecXvec(a: number[], b: number[]): number[] {\n  return a.map((v, idx) => v * b[idx])\n}\n\nexport function matXvec(matrix: number[][], vector: number[]): number[] {\n  return matrix.map((row, rowIdx) => {\n    if (row.length !== vector.length) {\n      throw new Error(\"misshaped matrix on row \" + rowIdx)\n    }\n    return sumf(row, (col, colIdx) => col * vector[colIdx])\n  })\n}\n\nexport interface Index2d {\n  col: number\n  row: number\n}\n\n/**\n * @param to is exclusive, like slice\n */\nexport function slice(m: number[][], from: Index2d, to: Index2d): number[][] {\n  const rowFrom = Math.max(0, from.row)\n  const rowTo = Math.min(m.length, to.row) // range is exclusive\n  const colFrom = Math.max(0, from.col)\n  const colTo = Math.min(m[0].length, to.col)\n  return range(rowFrom, rowTo, row => m[row].slice(colFrom, colTo))\n}\n\nexport function index1D(dim: Index2d, row: number, col: number) {\n  return row * dim.col + col\n}\n\n/**\n * Returns the index values for a 1d matrix that correspond with the given\n * from and to.\n * @param dim holds the number of rows and columns in the 2d matrix\n * @param from inclusive\n * @param to exclusive\n */\nexport function submatrixForEach(\n  dim: Index2d,\n  from: Index2d,\n  to: Index2d,\n  f: (i: number) => any\n): void {\n  const rowFrom = Math.floor(Math.max(0, from.row))\n  const rowTo = Math.ceil(Math.min(dim.row, to.row)) // range is exclusive\n  const colFrom = Math.floor(Math.max(0, from.col))\n  const colTo = Math.ceil(Math.min(dim.col, to.col))\n  for (let row = rowFrom; row < rowTo; row++) {\n    for (let col = colFrom; col < colTo; col++) {\n      f(row * dim.col + col)\n    }\n  }\n}\n\nexport function submatrixMagnitude(\n  m: number[],\n  dim: Index2d,\n  from: Index2d,\n  to: Index2d\n): number {\n  let agg = 0\n  submatrixForEach(dim, from, to, i => mapFinite(m[i], v => (agg += v * v)))\n  return Math.sqrt(agg)\n}\n\nexport function submatrixStdDev(\n  m: number[],\n  dim: Index2d,\n  from: Index2d,\n  to: Index2d\n): number {\n  const a = new Average()\n  submatrixForEach(dim, from, to, i => mapFinite(m[i], v => a.push(v)))\n  return a.stdDev!\n}\n\nexport function submatrixMode(\n  m: number[],\n  dim: Index2d,\n  from: Index2d,\n  to: Index2d\n): number {\n  const arr: number[] = []\n  submatrixForEach(dim, from, to, i => mapFinite(m[i], v => arr.push(v)))\n  return mode(arr)!\n}\n\n/**\n * Returns the quarter submatrix with the largest magnitude, in quadrant order:\n *\n * 1 | 0\n * - + -\n * 2 | 3\n */\nexport function leastMagQuarter(m: number[], dim: Index2d): number {\n  const c = dim.col\n  const r = dim.row\n  const quarterMagnitudes = [\n    submatrixMagnitude(m, dim, { col: c / 2, row: 0 }, { col: c, row: r / 2 }),\n    submatrixMagnitude(m, dim, { col: 0, row: 0 }, { col: c / 2, row: r / 2 }),\n    submatrixMagnitude(m, dim, { col: 0, row: r / 2 }, { col: c / 2, row: r }),\n    submatrixMagnitude(m, dim, { col: c / 2, row: r / 2 }, { col: c, row: r })\n  ]\n  return leastIndex(quarterMagnitudes)\n}\n\nexport function leastVariantQuarter(m: number[], dim: Index2d): number {\n  const c = dim.col\n  const r = dim.row\n  return leastIndex([\n    submatrixStdDev(m, dim, { col: c / 2, row: 0 }, { col: c, row: r / 2 }),\n    submatrixStdDev(m, dim, { col: 0, row: 0 }, { col: c / 2, row: r / 2 }),\n    submatrixStdDev(m, dim, { col: 0, row: r / 2 }, { col: c / 2, row: r }),\n    submatrixStdDev(m, dim, { col: c / 2, row: r / 2 }, { col: c, row: r })\n  ])\n}\n\n/**\n * Returns the quarter submatrix with the largest magnitude, in quadrant order:\n *\n *   0\n * 1 + 3\n *   2\n */\nexport function greatestHalf(m: number[], dim: Index2d): number {\n  const c = dim.col\n  const r = dim.row\n  const quarterMagnitudes = [\n    submatrixMode(m, dim, { col: 0, row: 0 }, { col: c, row: r / 2 }),\n    submatrixMode(m, dim, { col: 0, row: 0 }, { col: c / 2, row: r }),\n    submatrixMode(m, dim, { col: 0, row: r / 2 }, { col: c, row: r }),\n    submatrixMode(m, dim, { col: c / 2, row: 0 }, { col: c, row: r })\n  ]\n  return greatestIndex(quarterMagnitudes)\n}\n\nexport function submatrixCollect(\n  dim: Index2d,\n  from: Index2d,\n  to: Index2d\n): number[] {\n  const r: number[] = []\n  submatrixForEach(dim, from, to, i => r.push(i))\n  return r\n}\n\n/**\n * Reduce to dimXdim matrix, using the mode of surrounding values in the\n * matrix\n */\nexport function modeReduce(\n  m: number[],\n  fromDim: Index2d,\n  toDim: Index2d\n): number[] {\n  const colDelta = Math.floor(fromDim.col / toDim.col)\n  const rowDelta = Math.floor(fromDim.row / toDim.row)\n  const avg = new Average(Math.ceil(colDelta * rowDelta))\n  return concat(\n    ...stepRange(0, fromDim.row, rowDelta, rowStart =>\n      stepRange(0, fromDim.col, colDelta, colStart => {\n        avg.clear()\n        const from = { col: colStart, row: rowStart }\n        const to = { col: colStart + colDelta, row: rowStart + rowDelta }\n        submatrixForEach(fromDim, from, to, i =>\n          mapFinite(m[i], ea => avg.push(ea))\n        )\n        return avg.sampleMode\n      })\n    )\n  )\n}\n","import { sortBy } from \"../../fe/ArraySort\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { sigFigs } from \"../../fe/Number\"\nimport { PrimeBins, PrimesPerBin, SeedCount } from \"../../fe/PRNG\"\nimport { numericSha } from \"../fs/Hash\"\nimport { memoize } from \"../MemoizedFunc\"\nimport { encodeDigits } from \"./Radix\"\n\n// TODO: This whole thing is SITS, because we should be able to just give the\n// random function in SQLite a seed\n\n// but we can't\n\n// because everything is terrible\n\n// The score for a given row is (ax^2 + bx)(cx + d)\n\n// X^2 is required for reasonable diff distribution between X_ks.\n\n// Related: https://en.wikipedia.org/wiki/Linear_congruential_generator\n\nexport function prngOrderByClause(\n  seed: number,\n  idColumn: string,\n  max: number\n): string {\n  const [a, b, c, d, e] = factors(seed)\n  const x = idColumn\n  const i = `(${a}*${x}*${x}+${b}*${x})%${max}`\n  const j = `(${c}*${x}+${d})%${max}`\n  return `((${i})*(${j})+${e})%${max}`\n}\n\nexport function prng(seed: number, x: number, max: number): number {\n  const [a, b, c, d, e] = factors(seed)\n  const y1 = (a * x * x + b * x) % max\n  const y2 = (c * x + d) % max\n  return Math.round((y1 * y2 + e) % max)\n}\n\n// https://primes.utm.edu/curios/index.php?start=5&stop=5\nexport const primes = [\n  [353868013, 472882027, 479001599, 517294153],\n  [1012573, 1230587, 1355297, 1572751],\n  [756065159, 812182027, 899809343, 989450477],\n  [3959297, 4514113, 4823201, 5133127],\n  [573259391, 666101999, 694847533, 746151647],\n  [2275327, 2770513, 3073703, 3511973],\n  [173313197, 182557181, 203457869, 222230231],\n  [6054613, 6189107, 7752103, 9852103]\n]\n\n// 20200902: Adding a static intercept didn't help the quality of the PRNG.\n\nexport const primeInt = [\n  1012573, 1101689, 1183811, 1196089, 1230587, 1355297, 1419641, 1483733,\n  1572751, 2275327, 2770513, 3010349, 3073703, 3118691, 3174823, 3511973,\n  3959297, 4514113, 4690451, 4823201, 5133127, 5375327, 6019889, 6054613,\n  6189107, 7752103, 7752103, 9852103\n]\n\nexport function primeSeeds(seed: number): number[] {\n  const indexes = encodeDigits(PrimesPerBin, seed, PrimeBins)\n  return indexes.map((ea, idx) => primes[idx][ea])\n}\n\nexport const factors = memoize(\n  (seed: number) => {\n    const [a, b, c, d, e, f, g, h] = primeSeeds(seed % SeedCount)\n    const result = [a / b, c / d, e / f, g / h].map(ea => sigFigs(ea, 7))\n    result.push(primeInt[seed % primeInt.length])\n    return result\n  },\n  { maxSize: 128, ttlMs: minuteMs }\n)\n\nexport function stableIndexShuffle<T>(arr: T[], seed = 1): T[] {\n  return sortBy(arr, (_, idx) => prng(seed, idx, arr.length))\n}\n\nexport function stableContentShuffle<T>(arr: T[], seed = 1): T[] {\n  return sortBy(arr, ea => numericSha(String(ea) + seed))\n}\n","import { randomBytes } from \"crypto\"\nimport { blank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isFunction } from \"../../fe/isFunction\"\nimport { identity } from \"../Object\"\nimport { splitEvery } from \"../String\"\n\nconst zero: any = BigInt(0)\n\nexport function encodeDigits(base: number, i: number, minLength = 0): number[] {\n  if (!isFinite(i) || base <= 1) return []\n\n  const digits: number[] = []\n  if (i === 0) {\n    digits.unshift(0)\n  } else {\n    while (i > 0) {\n      digits.unshift(i % base)\n      i = Math.floor(i / base)\n    }\n  }\n  while (digits.length < minLength) digits.unshift(0)\n  return digits\n}\n\nexport class Radix {\n  readonly base: number\n  constructor(\n    readonly name: string,\n    readonly numerals: string,\n    readonly decodePreparser: (s: string) => string = identity\n  ) {\n    this.base = numerals.length\n  }\n\n  private digitsToNumerals(digits: number[]): string {\n    return digits.map(d => this.numerals[d]).join(\"\")\n  }\n\n  encode(num: number, minLength: number = 0): string {\n    if (!isFinite(num)) return \"\"\n    // r is a reversed array of chars:\n    const negate = num < 0\n    if (negate) {\n      num = Math.abs(num)\n      minLength-- // accommodate the sign\n    }\n    return (\n      (negate ? \"-\" : \"\") +\n      this.digitsToNumerals(encodeDigits(this.base, num, minLength))\n    )\n  }\n\n  encodeBigInt(bi: bigint): string {\n    if (typeof bi !== \"bigint\") throw new Error(\"bad input\")\n    if (bi === zero) return this.numerals[0]\n\n    const digits: number[] = []\n    const b = BigInt(this.base)\n    let i: any = bi\n\n    while (i > zero) {\n      digits.push(Number(i % b))\n      i = i / b\n    }\n    return this.digitsToNumerals(digits.reverse())\n  }\n\n  encodeBuffer(buf: Buffer): string {\n    if (buf == null || buf.length === 0) return \"\"\n    const digits = [0]\n    for (let b of buf) {\n      digits.forEach((d, i) => {\n        // const b0 = b\n        b += d << 8\n        digits[i] = b % this.base\n        b = Math.floor(b / this.base)\n        // console.dir({ i, b0, b, d0: d, d: digits[i], digits })\n      })\n\n      while (b > 0) {\n        digits.push(b % this.base)\n        b = Math.floor(b / this.base)\n        // console.dir({ b, digits })\n      }\n    }\n    return this.digitsToNumerals(digits.reverse())\n  }\n\n  decode(s: Maybe<string>): Maybe<number> {\n    return map(this.decodeBigInt(s), ea => {\n      if (ea > BigInt(Number.MAX_SAFE_INTEGER)) {\n        throw new Error(\"decode(\" + s + \") is > 2^53\")\n      } else {\n        return Number(ea)\n      }\n    })\n  }\n\n  normalize(s: string): string {\n    return this.decodePreparser(s)\n  }\n\n  decodeBigInt(s: Maybe<string>): Maybe<bigint> {\n    if (s == null || blank(s)) return\n    s = isFunction(this.decodePreparser) ? this.decodePreparser(s) : s\n    const negate = s[0] === \"-\"\n    if (negate) {\n      s = s.slice(1)\n    }\n    const b = BigInt(this.base)\n    let acc = BigInt(0)\n    for (const ch of s) {\n      const idx = this.numerals.indexOf(ch)\n      if (idx < 0) {\n        return undefined\n      }\n      acc = acc * b + BigInt(idx)\n    }\n    return negate ? BigInt(-1) * acc : acc\n  }\n\n  randomChars(length: number): string {\n    // bits per char is Math.log2(this.base).\n    // we need bpc * length / 8 = random bytes.\n    const s = this.encodeBuffer(\n      randomBytes(Math.ceil((Math.log2(this.base) * (length + 4)) / 8))\n    )\n    return s.slice(2, 2 + length)\n  }\n\n  /**\n   * UIDs are easier to parse or read if dashes break up the string.\n   *\n   * Reading 4-char groups is comfortable, 5 chars \"won-aye-six-gee-why\" is\n   * doable, I think, so split every 5?\n   *\n   * For GeoRadix, each char encodes 5 bits, so 20 chars is only 100 bits of\n   * entropy. 24 chars is 120. We need 32 chars for 160 bits, that's a lot.\n   */\n  randomUid(chars = 20, splitEveryN = 5, sepChar = \"-\"): string {\n    return splitEvery(this.randomChars(chars), splitEveryN).join(sepChar)\n  }\n\n  tokenEql(a: string, b: string, minLen: number): boolean {\n    const an = this.normalizeToken(a)\n    const bn = this.normalizeToken(b)\n    return an.length >= minLen && an === bn\n  }\n\n  normalizeToken(a: string) {\n    return [...this.decodePreparser(a.trim())]\n      .filter(ea => this.numerals.includes(ea))\n      .join(\"\")\n  }\n}\n\nexport const Hex = new Radix(\"hex\", \"0123456789abcdef\", s => s.toLowerCase())\n\n/**\n * URL-safe charset used for bitcoin and IPFS hashes\n * @see https://en.wikipedia.org/wiki/Base58\n */\nexport const Radix58 = new Radix(\n  \"Radix58\",\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n)\n\n/**\n * CAUTION! This doesn't do standard base64 padding!\n * @see b64.ts\n */\nexport const Base64 = new Radix(\n  \"Radix64\",\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n)\n\n/**\n * Used by StringSimilarity.radixDiff\n */\nexport const RadixAlphaNum = new Radix(\n  \"RadixAlphaNum\",\n  \"0123456789abcdefghijklmnopqrstuvwxyz\",\n  s => s.toLowerCase()\n)\n\n/**\n * Base 32 charset for case-insensitive filesystems and human consumption\n * @see https://en.wikipedia.org/wiki/Geohash\n */\nexport const GeoRadix = new Radix(\n  \"GeoRadix\",\n  \"0123456789bcdefghjkmnpqrstuvwxyz\", // y no a?\n  s => s.toLowerCase()\n)\n\n/**\n * Base 32 charset for case-insensitive filesystems and human consumption.\n *\n * Similar glyphs include 0O, 1lI, 2z, 5S, 9g\n */\nexport const TokenRadix = new Radix(\n  \"TokenRadix\",\n  \"0123456789abcdefhjkmnpqrtuvwxy\",\n  s =>\n    s\n      .toLowerCase()\n      .replace(/o/g, \"0\")\n      .replace(/[il]/g, \"1\")\n      .replace(/z/g, \"2\")\n      .replace(/s/g, \"5\")\n      .replace(/g/g, \"9\")\n)\n\nexport const AlphaRadix = new Radix(\n  \"AlphaRadix\",\n  \"abcdefghjkmnopqrtuvwxyz\",\n  s =>\n    s\n      .toLowerCase()\n      .replace(/0/g, \"o\")\n      .replace(/2/g, \"z\")\n      .replace(/5/g, \"s\")\n      .replace(/9/g, \"g\")\n)\n\nexport const NumericRadix = new Radix(\"NumericRadix\", \"0123456789\", s =>\n  s\n    .toLowerCase()\n    .replace(/o/g, \"0\")\n    .replace(/[il]/g, \"1\")\n    .replace(/z/g, \"2\")\n    .replace(/s/g, \"5\")\n    .replace(/g/g, \"9\")\n)\n","import { Rate } from \"batch-cluster\"\n\nexport function rateStats(r: Rate) {\n  return {\n    eventCount: r?.eventCount,\n    eventsPerSecond: r?.eventsPerSecond,\n    msSinceLastEvent: r?.msSinceLastEvent\n  }\n}\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { toInt } from \"../../fe/Number\"\nimport { toS } from \"../../fe/toS\"\n\nexport const RomanNumerals = [\n  undefined,\n  \"I\",\n  \"II\",\n  \"III\",\n  \"IV\",\n  \"V\",\n  \"VI\",\n  \"VII\",\n  \"VIII\",\n  \"IX\",\n  \"X\",\n  \"XI\",\n  \"XII\",\n  \"XIII\",\n  \"XIV\",\n  \"XV\",\n  \"XVI\",\n  \"XVII\",\n  \"XVIII\",\n  \"XIX\",\n  \"XX\",\n  \"XXI\",\n  \"XXII\",\n  \"XXIII\",\n  \"XXIV\",\n  \"XXV\",\n  \"XXVI\",\n  \"XXVII\",\n  \"XXVIII\",\n  \"XXIX\",\n  \"XXX\",\n  \"XXXI\",\n  \"XXXII\",\n  \"XXXIII\",\n  \"XXXIV\",\n  \"XXXV\",\n  \"XXXVI\",\n  \"XXXVII\",\n  \"XXXVIII\",\n  \"XXXIX\",\n  \"XL\",\n  \"XLI\",\n  \"XLII\",\n  \"XLIII\",\n  \"XLIV\",\n  \"XLV\",\n  \"XLVI\",\n  \"XLVII\",\n  \"XLVIII\",\n  \"XLIX\",\n  \"L\",\n  \"LI\",\n  \"LII\",\n  \"LIII\",\n  \"LIV\",\n  \"LV\",\n  \"LVI\",\n  \"LVII\",\n  \"LVIII\",\n  \"LIX\",\n  \"LX\"\n] as const\n\nexport function romanToInt(s: string): Maybe<number> {\n  const index = RomanNumerals.indexOf(s as any)\n  return index === -1 ? undefined : index\n}\n\n/**\n * @param i an integer between 1 and 60\n * @return the Roman numeral for `i`, or `i` as a string if `i` is not between 1 and 42\n */\nexport function intToRoman(i: number | string): string {\n  return RomanNumerals[toInt(i) as any] ?? toS(i)\n}\n","import { normalizeRotation } from \"../../fe/Rotation\"\n\nexport function rotateSquareMatrix<T>(m: T[], degrees: number) {\n  const d = normalizeRotation(degrees)\n  // clone m so we don't cause side-effects:\n  return d === 0 ? m : new SquareMatrix([...m]).rotate(degrees).m\n}\n\nexport class SquareMatrix<T> {\n  readonly rows: number\n  constructor(\n    readonly m: T[],\n    readonly ary = 1\n  ) {\n    this.rows = Math.sqrt(m.length / ary)\n    if (this.rows !== Math.floor(this.rows)) {\n      throw new Error(\n        `Only square tuple matrices are supported: ${\n          this.ary === 1 ? \"\" : this.ary\n        }(${this.rows}×${this.rows}) != ${m.length}`\n      )\n    }\n  }\n\n  index(row: number, col: number) {\n    return this.ary * (col + row * this.rows)\n  }\n\n  swap(index_a: number, index_b: number) {\n    for (let i = 0; i < this.ary; i++) {\n      const n = this.m[index_a + i]\n      this.m[index_a + i] = this.m[index_b + i]\n      this.m[index_b + i] = n\n    }\n  }\n\n  transpose(): this {\n    for (let row = 0; row < this.rows; row++) {\n      for (let col = row + 1; col < this.rows; col++) {\n        this.swap(this.index(row, col), this.index(col, row))\n      }\n    }\n    return this\n  }\n\n  reverseRows(): this {\n    for (let col = 0; col < this.rows; col++) {\n      for (let row = 0; row < this.rows / 2; row++) {\n        this.swap(this.index(row, col), this.index(this.rows - 1 - row, col))\n      }\n    }\n    return this\n  }\n\n  reverseCols(): this {\n    for (let row = 0; row < this.rows; row++) {\n      for (let col = 0; col < this.rows / 2; col++) {\n        this.swap(this.index(row, col), this.index(row, this.rows - 1 - col))\n      }\n    }\n    return this\n  }\n\n  reverse(): this {\n    const l = this.rows ** 2\n    for (let i = 0; i < l / 2; i++) {\n      this.swap(i, l - 1 - i)\n    }\n    return this\n  }\n\n  rotate(degrees: number): this {\n    switch (normalizeRotation(degrees)) {\n      case 0:\n        break\n      case 90:\n        this.transpose()\n        this.reverseCols()\n        break\n      case 180:\n        this.reverse()\n        break\n      case 270:\n        this.transpose()\n        this.reverseRows()\n        break\n      default:\n        throw new Error(\"unsupported rotate(\" + degrees + \")\")\n    }\n    return this\n  }\n}\n","import { randomBytes } from \"crypto\"\nimport { decuss } from \"../words/Cuss\"\n\n/**\n * Type-4 UUID\n *\n * @see https://en.wikipedia.org/wiki/Universally_unique_identifier\n */\nexport function uuid() {\n  const b = randomBytes(16)\n\n  // Set the version bits:\n  b[6] = (b[6] & 0x0f) | 0x40\n\n  // RFC 4122 Section 3 requires that the characters be generated in lower case\n  const s = b.toString(\"hex\")\n\n  // canonical 8-4-4-4-12 format string:\n  return [\n    s.slice(0, 8),\n    s.slice(8, 12),\n    s.slice(12, 16),\n    s.slice(16, 20),\n    s.slice(20)\n  ].join(\"-\")\n}\n\n/**\n * Type-4 UUID without naughty words\n */\nexport function safeUUID(): string {\n  return decuss(uuid)\n}\n\n// only useful for tests:\nexport const UUIDRegExp = /^\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}$/\n","import { isEmpty } from \"../../fe/Array\"\nimport { List } from \"../../fe/List\"\nimport { map } from \"../../fe/Maybe\"\nimport { Defined, Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, finiteOrElse, isInvalidNumber, isNumber } from \"../../fe/Number\"\nimport { toA } from \"../../fe/toA\"\nimport { CountingSet } from \"../CountingSet\"\nimport { intersection, union } from \"../Set\"\nimport { Average } from \"./Average\"\n\nexport type NumericList =\n  | List<number>\n  | Iterable<number>\n  | number[]\n  | Float32Array\n  | Uint32Array\n  | Int32Array\n\nexport type MaybeNumericList =\n  | List<Maybe<number>>\n  | Iterable<Maybe<number>>\n  | Maybe<number>[]\n  | Float32Array\n  | Uint32Array\n  | Int32Array\n\nexport function min<T>(vec: List<Maybe<T>>): Maybe<T> {\n  let result\n  for (const ea of vec) {\n    if (ea != null) {\n      if (result == null || ea < result) {\n        result = ea\n      }\n    }\n  }\n  return result\n}\n\nfunction isDefined<T>(ea: T): ea is Defined<T> {\n  return ea != null && !isInvalidNumber(ea)\n}\n\nexport function max<T>(vec: Maybe<List<Maybe<T>>>) {\n  if (vec == null) return\n  let result\n  for (const ea of vec) {\n    if (isDefined(ea)) {\n      if (result == null || ea > result) {\n        result = ea\n      }\n    }\n  }\n  return result\n}\n\n/**\n * @return `[arr[1] - arr[0], arr[2] - arr[1], ...]`\n */\nexport function deltas(vec: NumericList): number[] {\n  const l = toA(vec)\n  if (vec == null || l.length <= 1) return []\n  return l.slice(1).map((ea, idx) => ea - l[idx])\n}\n\nexport function modes(vec: MaybeNumericList, topN: number): number[] {\n  const cs = new CountingSet<number>()\n  for (const ea of vec) {\n    if (isNumber(ea)) {\n      cs.incr(ea)\n    }\n  }\n  return cs.topKeys(topN)\n}\n\nexport function mode(vec: MaybeNumericList): Maybe<number> {\n  return modes(vec, 1)[0]\n}\n\nexport function sum(vec: MaybeNumericList | Iterable<Maybe<number>>): number {\n  let acc = 0\n  for (const ea of vec) {\n    if (isNumber(ea)) {\n      acc += ea\n    }\n  }\n  return acc\n}\n\nexport function sumf<T>(\n  iter: Iterable<Maybe<T>>,\n  f: (t: T, index: number) => Maybe<number>\n): number {\n  let index = 0\n  let acc = 0\n  for (const ea of iter) {\n    if (ea != null) {\n      const i = f(ea, index)\n      if (isNumber(i)) {\n        acc += i\n      }\n    }\n    index++\n  }\n  return acc\n}\n\nexport class Mean {\n  #idx = 0\n  #mean: Maybe<number>\n\n  push(i: Maybe<number>) {\n    if (isNumber(i)) {\n      // prevent overflow:\n      // https://math.stackexchange.com/a/116344\n      // https://www.johndcook.com/blog/standard_deviation/\n      this.#mean =\n        this.#mean == null\n          ? i\n          : (this.#mean * this.#idx) / (this.#idx + 1) + i / (this.#idx + 1)\n      this.#idx++\n    }\n  }\n\n  get mean() {\n    return this.#mean\n  }\n}\n\nexport function avg(vec: MaybeNumericList): Maybe<number> {\n  const m = new Mean()\n  for (const ea of vec) {\n    m.push(ea)\n  }\n  return m.mean\n}\n\n// export function covariance(args: {\n//   a: number[]\n//   b: number[]\n//   aMean?: number\n//   bMean?: number\n// }): Maybe<number> {\n//   if (isEmpty(args.a) || isEmpty(args.b) || args.a.length !== args.b.length)\n//     return\n//   const a_mean = args.aMean ?? avg(args.a)!\n//   const b_mean = args.bMean ?? avg(args.b)!\n//   const cov = new Mean()\n//   for (let i = 0; i < args.a.length; i++) {\n//     cov.push((args.a[i] - a_mean) * (args.b[i] - b_mean))\n//   }\n//   return cov.mean\n// }\n\n/**\n * @param strength how strong should the normalization be applied. [0,1]\n */\nexport function normalize({\n  x,\n  strength = 1,\n  normMin,\n  normMax\n}: {\n  x: number[]\n  strength?: number\n  normMin: number\n  normMax: number\n}): number[] {\n  const xMin = min(x)!\n  const xRange = max(x)! - xMin\n  const normRange = normMax - normMin\n  return x.map(\n    ea =>\n      (1 - strength) * ea +\n      strength * (normMin + (normRange * (ea - xMin)) / xRange)\n  )\n}\n\nexport function slope(vec: MaybeNumericList): Maybe<number> {\n  const l = toA(vec).filter(isNumber)\n  const x_mean = avg(l)\n  if (x_mean != null) {\n    const y_mean = (l.length - 1) / 2\n    const num = sumf(l, (x, y) => (x - x_mean) * (y - y_mean))\n    const denom = sumf(l, x => (x - x_mean) ** 2)\n    return denom === 0 ? 0 : num / denom\n  } else {\n    return\n  }\n}\n\nexport function variance(arr: MaybeNumericList): Maybe<number> {\n  const mean = avg(arr)\n  if (mean == null) return undefined\n  let acc = 0\n  let len = 0\n  for (const i of arr) {\n    if (isNumber(i)) {\n      len++\n      acc += (i - mean) * (i - mean)\n    }\n  }\n  return acc / len\n}\n\nexport function stdDev(arr: MaybeNumericList): Maybe<number> {\n  return map(variance(arr), Math.sqrt)\n}\n\nexport function p84(arr: MaybeNumericList): Maybe<number> {\n  return new Average().pushAll(arr).p84\n}\n\n/**\n * @param carryForward ratio of prior means to average with subsequent values\n */\nexport function weightedAvg(\n  arr: List<number> | Iterable<number>,\n  carryForward = 0.5\n): Maybe<number> {\n  let acc\n  carryForward = clamp(0, 1, carryForward)\n  for (const ea of arr) {\n    acc = acc == null ? ea : acc * carryForward + ea * (1 - carryForward)\n  }\n  return acc\n}\n\n// export function euclidean<T extends NumericList>(x: T, y: T): number {\n//   return Math.sqrt(\n//     toA(x).reduce((sum_, ea, idx) => sum_ + Math.pow(ea - y[idx], 2), 0)\n//   )\n// }\n\nexport function centroid(vectors: number[][]): Maybe<number>[] {\n  const len = vectors[0].length\n  const arr: Maybe<number>[] = []\n  for (let i = 0; i < len; i++) {\n    arr.push(avg(vectors.map(ea => ea[i])))\n  }\n  return arr\n}\n\n/**\n * Euclidean norm, or L2 norm, of a given vector\n * @see https://en.wikipedia.org/wiki/Norm_(mathematics)\n */\nexport function l2norm(vec: List<number>): number {\n  // PERF: no closures\n  let acc = 0\n  for (const ea of vec) {\n    acc += ea * ea\n  }\n  return Math.sqrt(acc)\n}\n\n/**\n * @see https://en.wikipedia.org/wiki/Euclidean_vector#Dot_product\n */\nexport function dot(x: number[], y: number[]): number {\n  // PERF: no closures\n  let acc = 0\n  for (let i = 0; i < x.length; i++) {\n    acc += x[i] * y[i]\n  }\n  return acc\n}\n\n/**\n * Ranges between -1 (anticorrelation) to 1 (correlation)\n * @see https://en.wikipedia.org/wiki/Cosine_similarity\n */\nexport function cosineSimilarity(x: number[], y: number[]): Maybe<number> {\n  return finiteOrElse(dot(x, y) / (l2norm(x) * l2norm(y)), undefined)\n}\n\n/**\n * Ranges between 0 (no overlap) to 1 (complete overlap)\n */\nexport function jaccard(x: number[], y: number[]): Maybe<number> {\n  return isEmpty(x) && isEmpty(y)\n    ? 0\n    : finiteOrElse(intersection(x, y).size / union(x, y).size, undefined)\n}\n","import { gunzipSync, gzipSync } from \"zlib\"\nimport { mapNotBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { hammRatioBigInt } from \"../Number\"\n\nexport function hex2b64(hex: string): string {\n  return Buffer.from(hex, \"hex\").toString(\"base64\")\n}\n\nexport function b64encode(i: number | bigint): string {\n  const hex = i.toString(16)\n  // Make sure we're padded to even characters. Buffer.from(\"\", \"hex\") IGNORES ODD LENGTHS !!!WTFOMG!?!\n  const pad = hex.length % 2 === 0 ? \"\" : \"0\"\n  return Buffer.from(pad + hex, \"hex\").toString(\"base64\")\n}\n\nexport function b64decode(base64: string): bigint {\n  return BigInt(\"0x0\" + Buffer.from(base64, \"base64\").toString(\"hex\"))\n}\n\n// use gzip rather than brotli as a head-fake to licensing\nexport function gz64encodeString(s: string): string {\n  return gzipSync(Buffer.from(s, \"utf8\")).toString(\"base64\")\n}\n\nexport function d(s: string): string {\n  return gunzipSync(Buffer.from(s, \"base64\")).toString(\"utf8\")\n}\n\nexport const gz64decodeString = d\n\n/**\n * hamm...ratio...operator\n */\nexport function b64hammRatio(\n  a: Maybe<string>,\n  b: Maybe<string>\n): Maybe<number> {\n  return mapNotBlank(a, ea1 =>\n    mapNotBlank(b, ea2 => hammRatioBigInt(b64decode(ea1), b64decode(ea2)))\n  )\n}\n\nexport function b64encodeBits(m: (0 | 1)[]): string {\n  // TODO: don't just use BigInt and Buffer, but actually do the work ourselves.\n  return b64encode(BigInt(\"0b0\" + m.map(ea => (ea === 1 ? \"1\" : \"0\")).join(\"\")))\n}\n","import _os from \"os\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { stripDiacritics } from \"../String\"\nimport { Settings } from \"../settings/Settings\"\n\nexport const hostname = lazy(() => Settings.hostname.value ?? _os.hostname())\n\nlater(() => Settings.hostname.watchLater(() => hostname.unset()))\n\nexport function cleanHostname(_hostname?: Maybe<string>) {\n  if (blank(_hostname)) {\n    if (!blank(Settings.hostname.value)) return Settings.hostname.value\n  }\n  return (_hostname ?? _os.hostname())\n    .replace(/\\.local$/, \"\")\n    .replace(/-?\\d+$/, \"\")\n}\n\nexport function fsSafeHostname(_hostname = hostname()) {\n  return stripDiacritics(_hostname)\n    .replace(/[^a-z\\d\\s-]/gi, \"\")\n    .trim()\n    .replace(/\\s+/g, \"-\")\n    .toLowerCase()\n}\n","import { IncomingHttpHeaders, IncomingMessage } from \"http\"\nimport https from \"https\"\nimport { URL } from \"url\"\nimport { blank } from \"../../fe/Blank\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { AppName } from \"../AppName\"\nimport { within } from \"../Number\"\nimport { version } from \"../Version\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { URI } from \"../uri/URI\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\n\nexport interface HttpsRequestOptions extends https.RequestOptions {\n  body?: string | Buffer\n}\n\nexport interface RequestResponse {\n  ok: boolean\n  headers: IncomingHttpHeaders\n  body: string\n  statusCode: Maybe<number>\n  statusMessage: string | undefined\n}\n\nexport async function request(\n  url: string | URI | URL,\n  options: HttpsRequestOptions = {}\n) {\n  if (options.headers == null) options.headers = {}\n  if (blank(options.headers[\"user-agent\"])) {\n    options.headers[\"user-agent\"] = AppName + \" v\" + version\n  }\n\n  return new Promise<RequestResponse>((resolve, reject) => {\n    const req = https.request(url.toString(), options)\n    req.setTimeout(orElse(options.timeout, commandTimeoutMs()), () => {\n      reject(\n        new WrappedError(\"Timeout fetching <\" + url + \">\", {\n          doNotSend: true,\n          retriable: true\n        })\n      )\n    })\n\n    req\n      .on(\"response\", (response: IncomingMessage) => {\n        const dataChunks: (Buffer | string)[] = []\n        response.setEncoding(\"utf8\")\n        response.on(\"data\", chunk => dataChunks.push(chunk))\n        response.on(\"end\", () => {\n          resolve({\n            ok: within(200, 399, response.statusCode),\n            headers: response.headers,\n            body: dataChunks.join(\"\"),\n            statusCode: response.statusCode,\n            statusMessage: response.statusMessage\n          })\n        })\n      })\n      .on(\"error\", e => {\n        reject(e)\n      })\n\n    map(options.body, ea => req.write(ea))\n    req.end()\n  })\n}\n\n// Just use https://nodejs.org/dist/latest-v14.x/docs/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options\n// export function urlencodedForm(obj: Obj) {\n//   return entries(obj)\n//     .map(([k, v]) => encodeURIComponent(k) + \"=\" + encodeURIComponent(toS(v)))\n//     .join(\"&\")\n// }\n","import { networkInterfaces } from \"os\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks, uniq } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toInt, within } from \"../../fe/Number\"\nimport { values } from \"../../fe/Object\"\nimport { mkLogger } from \"../Logger\"\nimport { stripPrefix } from \"../String\"\n\nexport const myIpAddresses = lazy(\n  () =>\n    uniq(\n      compactBlanks(flatten(values(networkInterfaces())).map(ea => ea.address))\n    ),\n  minuteMs\n)\n\nexport const networkMacAddresses = lazy(\n  () =>\n    uniq(\n      compactBlanks(flatten(values(networkInterfaces())).map(ea => ea.mac))\n    ).filter(ea => ea !== \"00:00:00:00:00:00\"),\n  minuteMs\n)\n\nexport function myExternalIpAddresses() {\n  return myIpAddresses().filter(ea => !isLoopback(ea))\n}\n\nexport function myExternalIp4Addresses() {\n  return myExternalIpAddresses().filter(ea => !ea.includes(\":\"))\n}\n\nconst logger = lazy(() => mkLogger(\"net.ip\"))\n\nconst loopbackPatterns = [\n  /^(?:::ffff:)?127\\.\\d{1,3}.\\d{1,3}.\\d{1,3}$/i,\n  /^::1$/\n]\n\nexport function isLoopback(address: string) {\n  return (\n    notBlank(address) &&\n    (parseQuad(address)?.[0] === 127 ||\n      loopbackPatterns.some(re => re.exec(address) != null))\n  )\n}\n\nfunction parseQuad(address: string): Maybe<[number, number, number, number]> {\n  const arr = address.split(\".\").map(ea => toInt(ea))\n  return (\n    arr.length !== 4 || arr.some(ea => ea == null || !within(0, 255, ea))\n      ? undefined\n      : arr\n  ) as any\n}\n\nexport function isLocalhost(address: Maybe<string>) {\n  return logger().tap({\n    msg: \"isLocalhost\",\n    level: \"info\",\n    result: blank(address)\n      ? false\n      : myIpAddresses().includes(address) ||\n        myIpAddresses().includes(stripPrefix(address, \"::ffff:\")) ||\n        isLoopback(address),\n    meta: { address }\n  })\n}\n","import { promises as dns } from \"dns\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toInt } from \"../../fe/Number\"\nimport { Timeout, thenOrTimeout } from \"../../fe/ThenOrTimeout\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { within } from \"../Number\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { equalsIgnoreCase } from \"../String\"\nimport { memoizeAsync } from \"../async/MemoizedAsyncFunc\"\nimport { thenMap2Or } from \"../async/Promise\"\nimport { ee } from \"../event/EventEmitter\"\nimport { ipv4Re } from \"./ping\"\n\nconst octetRE = new RegExp(\"^\" + ipv4Re.source + \"$\")\n\n/**\n * Try to return the \"canonical\" name for the given `ipOrName`.\n */\nexport const friendlyname = memoizeAsync(\n  async (ipOrName: string) => {\n    const result =\n      octetRE.exec(ipOrName) == null ? ipOrName : await nslookup(ipOrName)\n    return toS(result).toLowerCase().normalize()\n  },\n  {\n    name: \"net.nslookup.friendlyname\",\n    maxSize: 128,\n    timeoutMs: ShortCommandTimeoutMs\n  }\n)\n\nconst loopbackRE = /^(?:localhost\\.?(?:localdomain\\.?)?|127(?:\\.\\d{1,3}){3})$/i\n\nexport function isLoopback(name: string): boolean {\n  return loopbackRE.exec(name) != null\n}\n\nexport function octets(nameOrIp: string): Maybe<number[]> {\n  const result: number[] = nameOrIp\n    .split(\".\")\n    .map(ea => toInt(ea))\n    .filter(ea => within(0, 255, ea)) as number[]\n  return result.length === 4 ? result : undefined\n}\n\n/**\n * @return 1 or more IPv4 addresses for the given name or IP address\n */\nexport const resolve4 = memoizeAsync(\n  async (nameOrIp: string): PromiseMaybe<string[]> => {\n    if (blank(nameOrIp)) return\n    if (octets(nameOrIp) != null) return [nameOrIp]\n    try {\n      return await dns.resolve4(nameOrIp)\n    } catch (err) {\n      logger().warn(\"No name found for \" + nameOrIp)\n      return\n    }\n  },\n  {\n    name: \"net.nslookup.resolve4\",\n    maxSize: 256,\n    timeoutMs: ShortCommandTimeoutMs,\n    clearEveryMs: 10 * minuteMs\n  }\n)\n\nconst logger = lazy(() => mkLogger(\"net.nslookup\"))\n\nlater(() => ee().on(\"clearCache\", () => nslookup.clear()))\n\n/**\n * @return the name or IP address\n */\nexport const nslookup = memoizeAsync(\n  async (nameOrIp: string) => {\n    try {\n      const names = await thenOrTimeout(\n        isLoopback(nameOrIp)\n          ? nameOrIp.startsWith(\"127.\")\n            ? [\"localhost\"]\n            : [\"127.0.0.1\"]\n          : octets(nameOrIp) != null\n          ? dns.reverse(nameOrIp)\n          : dns.resolve4(nameOrIp),\n        5 * secondMs // < DNS resolution should be milliseconds.\n      )\n      if (names === Timeout) {\n        logger().info(\"nslookup(\" + nameOrIp + \"): timeout\")\n        return nameOrIp\n      }\n      const firstNonBlank = names.find(notBlank)\n      if (firstNonBlank == null) {\n        logger().warn(\"No name found for \" + nameOrIp)\n        return nameOrIp\n      } else {\n        return firstNonBlank\n      }\n    } catch (err) {\n      logger().warn(\"Failed to look up \" + nameOrIp + \", using name.\", err)\n      return nameOrIp\n    }\n  },\n  {\n    name: \"net.nslookup\",\n    maxSize: 256,\n    timeoutMs: ShortCommandTimeoutMs,\n    clearEveryMs: 10 * minuteMs\n  }\n)\n\nexport async function isEquivalentHost(\n  a: Maybe<string>,\n  b: Maybe<string>\n): Promise<boolean> {\n  if (blank(a) || blank(b)) return false\n  if (equalsIgnoreCase(a, b)) return true\n  if (isLoopback(a) && isLoopback(b)) return true\n  return thenMap2Or(\n    resolve4(a),\n    resolve4(b),\n    (aAddrs, bAddrs) => aAddrs.some(ea => bAddrs.includes(ea)),\n    () => false\n  )\n}\n","import { notBlank } from \"../../fe/Blank\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { times } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { toS } from \"../../fe/toS\"\nimport { memoizeAsync } from \"../async/MemoizedAsyncFunc\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { pingWin } from \"../fs/PathTo\"\nimport { isWin } from \"../platform/Platform\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\n\nexport const ping = memoizeAsync(\n  async (target: string) => {\n    const cmd = isWin ? pingWin() : \"ping\"\n    return stdout_(cmd, [isWin ? \"-n\" : \"-c\", \"1\", target], {\n      timeoutMs: 5 * secondMs\n    })\n  },\n  {\n    name: \"net.ping\",\n    maxSize: 255,\n    timeoutMs: ShortCommandTimeoutMs,\n    clearEveryMs: 10 * minuteMs\n  }\n)\n\nexport const ipv4Re = new RegExp(\n  \"\\\\b\" + times(4, () => \"[0-9]{1,3}\").join(\"\\\\.\") + \"\\\\b\"\n)\n\nexport const ipAddrFromPing = memoizeAsync(\n  async (target: string) => {\n    return opt(\n      await ping(target).catch(err => {\n        console.warn(\"failed to ping: \" + err)\n        return undefined\n      })\n    )\n      .filter(notBlank)\n      .flatMap(result => ipv4Re.exec(toS(result)))\n      .map(match => match[0])\n      .get()\n  },\n  {\n    name: \"net.ipAddrFromPing\",\n    maxSize: 255,\n    timeoutMs: ShortCommandTimeoutMs,\n    clearEveryMs: 10 * minuteMs\n  }\n)\n","import { uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { defer } from \"../../fe/Defer\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toA } from \"../../fe/toA\"\nimport { mkLogger } from \"../Logger\"\nimport { hasApt } from \"../OperatingSystem\"\nimport { stdoutResult_ } from \"../child/ChildProcess\"\nimport { splitLines } from \"../fs/CRLF\"\nimport { debianVersionToSemver } from \"../version/SemVer\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\n\nconst logger = defer(() => mkLogger(\"platform.Apt\"))\n\nexport async function aptInstalledVersion(\n  filename: string\n): PromiseMaybe<\n  { pkg: string; version: Maybe<string>; semver: Maybe<string> }[]\n> {\n  if (!hasApt()) return\n\n  const arr = []\n  // package is a reserved word (!!)\n  for (const pkg of toA(await dpkgSearch(filename))) {\n    const version = await aptCachePolicyVersion(pkg)\n    arr.push({ pkg, version, semver: debianVersionToSemver(version) })\n  }\n  return arr\n}\n\n// https://www.debian.org/doc/debian-policy/ch-controlfields.html\nconst DebPackageNameRe = /^[a-z][a-z\\d+\\-.]+/\n\nasync function dpkgSearch(nativePath: string): PromiseMaybe<string[]> {\n  if (!hasApt() || blank(nativePath)) return\n\n  // Case 1:\n\n  // # dpkg -S /usr/bin/heif-convert\n  // libheif-examples: /usr/bin/heif-convert\n\n  // Case 2:\n\n  // # dpkg -S /usr/bin/heif-convert\n  // (stderr): dpkg-query: no path found matching pattern /usr/bin/heif-convert\n\n  const result = await stdoutResult_(\"dpkg\", [\"-S\", nativePath], {\n    timeoutMs: commandTimeoutMs(),\n    ignoreExitCode: true,\n    ignoreStderr: true,\n    isIgnorableError: () => true\n  })\n\n  logger().debug(\"dpkg -S\", { nativePath, result })\n\n  return result.code !== 0\n    ? undefined\n    : uniq(splitLines(result.result).map(ea => DebPackageNameRe.exec(ea)?.[0]))\n}\n\nexport async function aptCachePolicyVersion(\n  packageName: string\n): PromiseMaybe<string> {\n  if (!hasApt() || blank(packageName)) return\n\n  // Case 1:\n\n  // # apt-cache policy libheif-examples\n  // N: Unable to locate package libheif-examples\n\n  // Case 2:\n\n  // # apt-cache policy libheif-examples\n  // libheif-examples:\n  //   Installed: 1.15.1-1\n  //   Candidate: 1.15.1-1\n  //   Version table:\n  //  *** 1.15.1-1 100\n  //         100 /var/lib/dpkg/status\n\n  const result = await stdoutResult_(\"apt-cache\", [\"policy\", packageName], {\n    timeoutMs: commandTimeoutMs(),\n    ignoreExitCode: true,\n    ignoreStderr: true,\n    isIgnorableError: () => true\n  })\n\n  logger().debug(\"apt-cache policy\", { packageName, result })\n\n  if (result.code !== 0) return\n\n  for (const line of splitLines(result.result)) {\n    const match = /^\\s*Installed: (.*)$/.exec(line)\n    if (match != null) {\n      return match[1]\n    }\n  }\n  return\n}\n","import { join } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { toS } from \"../../fe/toS\"\n\n// Expect __filename to be something like\n// '/home/mrm/src/photostructure/src/core/dist/core/platform/IsPacked.js' if\n// we're not web-packed.\n\nexport const isPacked = lazy(\n  () => !toS(__filename).includes(join(\"core\", \"platform\", \"IsPacked\"))\n)\n","import os from \"os\"\nimport process from \"process\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { ELECTRON_RUN_AS_NODE } from \"../env/EnvKeys\"\n\n// THIS IS USED BY EVERYONE IN CORE, so only rely on fe code!\n\nconst _platform = os.platform()\n\nexport const inspectFlag =\n  process.argv.includes(\"--inspect\") || isTrue(process.env.NODE_INSPECT)\n\nexport const isCI = isTrue(process.env[\"CI\"])\n\nexport const isWin = _platform === \"win32\" || _platform === \"cygwin\"\nexport const isWinPortable =\n  isWin && notBlank(process.env.PORTABLE_EXECUTABLE_DIR)\n\nexport const isMac = _platform === \"darwin\"\n\nexport const isLinux = _platform === \"linux\"\n\nexport const isLinux_x64 = isLinux && os.arch() === \"x64\"\nexport const isArm = null != /^arm\\b/i.exec(os.arch()) // \"arm\" on RPi, \"arm64\" on M1\nexport const isLinux_arm = isLinux && isArm\nexport const isLinuxAppImage =\n  isLinux && (notBlank(process.env.APPIMAGE) || notBlank(process.env.APPDIR))\nexport const isLinuxSnap = isLinux && notBlank(process.env.SNAP_USER_DATA)\n\nexport const isPosix = isMac || isLinux\n\nexport const isMainElectron = process.versions[\"electron\"] != null\n\nexport const isElectron =\n  isMainElectron || isTrue(process.env[ELECTRON_RUN_AS_NODE])\n\n/**\n * Compatible with electron-builder:\n */\nexport type Platform = \"win\" | \"mac\" | \"linux\"\n\nexport const platformName: Platform = isWin\n  ? \"win\"\n  : isMac\n  ? \"mac\"\n  : isLinux\n  ? \"linux\"\n  : (_platform as any) // < punt\n","import { lazy } from \"../../core/Lazy\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { PS_IS_DOCKER } from \"../env/EnvKeys\"\nimport { isLinux } from \"../platform/Platform\"\n\n// HEY FUTURE ME: no need to get clever here with checking for Alpine Linux or\n// /.dockerenv. KISS.\n\n// NOTE TO THE FUTURE: we used to parse out the owner from /proc/1/cgroup but\n// that was missing from UnRAID docker containers.\n\nexport const isDocker = lazy(() => isLinux && isTrue(process.env[PS_IS_DOCKER]))\n","import fs from \"fs\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isLinux, isLinux_arm, isMac, isWin } from \"../platform/Platform\"\n\n// this works in and out of docker containers:\nexport function containsRpiModel(cpuinfoPath = \"/proc/cpuinfo\") {\n  if (isWin || isMac) return false\n  try {\n    const contents = fs.readFileSync(cpuinfoPath).toString()\n    return null != contents.match(/^\\s*model\\s*:\\s*Raspberry Pi/im)\n  } catch {\n    return false\n  }\n}\n\nexport const isRaspberryPi = lazy(() => isLinux_arm && containsRpiModel())\n\n/**\n * This seems to only be set on Raspberry PIs:\n */\nexport const procDeviceModel = lazy(() => {\n  try {\n    return isLinux\n      ? // \"Raspberry Pi 4 Model B Rev 1.1\" on pi4\n        fs.readFileSync(\"/proc/device-tree/model\").toString()\n      : undefined\n  } catch {\n    return\n  }\n})\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { stripPrefix } from \"../../fe/String\"\nimport { camel2words } from \"../StringCase\"\n\nexport function negateFilterName(s: Maybe<string>) {\n  if (blank(s)) return undefined\n  // If we have any spaces in the string, assume it's already human-friendly.\n  const w = /\\s/.test(s)\n    ? s\n    : camel2words(s).replace(/\\bphoto structure\\b/gi, \"PhotoStructure\")\n  return w.match(/^not\\b/)\n    ? w.replace(/^not\\b/, \"\").trim()\n    : \"not \" + stripPrefix(w, \"is \")\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { entries, Valued, values } from \"../../fe/Object\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { negateFilterName } from \"./PredicateNames\"\nimport { SyncPredicate } from \"./SyncPredicates\"\n\nconst _logger = lazy(() => mkLogger(\"predicates.Predicates\"))\n\nexport interface Predicate<A> {\n  (a: A): boolean | null | Promise<boolean | null>\n}\n\nexport type PredicateValued<A> = Valued<Predicate<A> | SyncPredicate<A>>\n\nexport type PredicateBundle<A> = PredicateValued<A>[]\n\nexport class Predicates {\n  static async accepted<A>(\n    a: A,\n    ...predicates: PredicateValued<A>[]\n  ): Promise<boolean> {\n    for (const obj of predicates) {\n      for (const ea of values(obj)) {\n        if (false === (await ea(a))) return false\n      }\n    }\n    return true\n  }\n\n  static async rejected<A>(\n    a: A,\n    ...predicates: PredicateBundle<A>\n  ): Promise<boolean> {\n    return !(await Predicates.accepted(a, ...predicates))\n  }\n\n  static async explain<A>(a: A, ...predicates: PredicateBundle<A>) {\n    const accepted: string[] = []\n    const rejected: string[] = []\n    const notApplicable: string[] = []\n    for (const obj of predicates) {\n      for (const [name, ea] of entries(obj)) {\n        const result = await ea(a)\n        if (result === true) {\n          accepted.push(name)\n        } else if (result === false) {\n          rejected.push(name)\n        } else {\n          notApplicable.push(name)\n        }\n      }\n    }\n    return {\n      accepted,\n      rejected,\n      notApplicable\n    }\n  }\n\n  static async whyRejected<A>(\n    a: A,\n    ...predicates: PredicateBundle<A>\n  ): Promise<string | undefined> {\n    return negateFilterName(await Predicates.firstFalse(a, ...predicates))\n  }\n\n  static async firstFalse<A>(\n    a: A,\n    ...predicates: PredicateBundle<A>\n  ): Promise<string | undefined> {\n    for (const obj of predicates) {\n      for (const [k, v] of entries(obj)) {\n        try {\n          const result = await v(a)\n          if (false === result) {\n            return k\n          }\n        } catch (error) {\n          _logger().warn(\"firstFalse() caught from \" + k, { error })\n        }\n      }\n    }\n    return\n  }\n\n  static async logged<A>({\n    a,\n    logger,\n    msg,\n    predicates\n  }: {\n    a: A\n    logger: Logger\n    msg: string\n    predicates: PredicateBundle<A>\n  }) {\n    const { accepted, rejected } = await Predicates.explain(a, ...predicates)\n    return logger.tap({\n      msg,\n      result: isEmpty(rejected),\n      meta: { a, accepted, rejected }\n    })\n  }\n}\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { entries, Valued } from \"../../fe/Object\"\nimport { negateFilterName } from \"./PredicateNames\"\n\nexport interface SyncPredicate<A> {\n  (a: A): boolean | null\n}\n\nexport type SyncPredicateBundle<A> = Valued<SyncPredicate<A>>[]\n\nexport class SyncPredicates {\n  static firstFalse<A>(\n    a: A,\n    ...predicates: SyncPredicateBundle<A>\n  ): Maybe<string> {\n    for (const obj of predicates) {\n      for (const [k, v] of entries(obj)) {\n        const result = v(a)\n        if (false === result) {\n          return k\n        }\n      }\n    }\n    return\n  }\n\n  static firstTrue<A>(\n    a: A,\n    ...predicates: SyncPredicateBundle<A>\n  ): Maybe<string> {\n    for (const obj of predicates) {\n      for (const [name, ea] of entries(obj)) {\n        if (true === ea(a)) return name\n      }\n    }\n    return\n  }\n\n  static firstDefined<A>(\n    a: A,\n    ...predicates: SyncPredicateBundle<A>\n  ): Maybe<{ name: string; result: boolean }> {\n    for (const obj of predicates) {\n      for (const [name, ea] of entries(obj)) {\n        const result = ea(a)\n        if (result != null) return { name, result }\n      }\n    }\n    return\n  }\n\n  static accepted<A>(a: A, ...predicates: SyncPredicateBundle<A>): boolean {\n    return null == SyncPredicates.firstFalse(a, ...predicates)\n  }\n\n  static whyRejected<A>(\n    a: A,\n    ...predicates: SyncPredicateBundle<A>\n  ): string | undefined {\n    return negateFilterName(SyncPredicates.firstFalse(a, ...predicates))\n  }\n}\n","import { compactBlanks } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { fmtPct } from \"../../fe/Number\"\nimport { ellipsizePath } from \"../fs/Path\"\nimport { within } from \"../Number\"\n\n// \"ProgressEvent\" is part of lib.dom. Let's not collide.\n\nexport interface ProgressEvt {\n  path?: string\n  op: string\n  pct: number\n  elapsedMs?: number\n  done?: boolean\n}\n\nexport function progressEvtToS(pe: ProgressEvt): string {\n  const path = blank(pe.path)\n    ? null\n    : ellipsizePath({ p: pe.path, maxLength: 80 })\n  return compactBlanks([\n    path,\n    pe.op,\n    pe.done === true ? \"done\" : fmtPct(pe.pct)\n  ]).join(\": \")\n}\n\nexport type ProgressEvtWithPath = ProgressEvt &\n  Required<Pick<ProgressEvt, \"path\">>\n\nexport type ProgressEvtWithoutPct = Pick<ProgressEvt, \"path\" | \"op\">\n\nexport function isProgressEvt(o: any): o is ProgressEvt {\n  return o != null && notBlank(o.op) && within(0, 100, o.pct)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gte } from \"../../fe/Number\"\nimport { shim1 } from \"../Shim1\"\nimport { TTLMap } from \"../TTLMap\"\nimport { ee } from \"../event/EventEmitter\"\nimport { ProgressEvt, ProgressEvtWithPath, isProgressEvt } from \"./ProgressEvt\"\n\nexport const DefaultThrottleMs = 500\n\nexport const recentProgress = lazy(\n  () => new TTLMap<string, ProgressEvtWithPath>(15 * secondMs)\n)\n\nexport const recentDone = lazy(\n  () => new TTLMap<string, ProgressEvtWithPath>(2 * minuteMs)\n)\n\nexport function emitProgressEvt(pe: Maybe<ProgressEvt>) {\n  if (isProgressEvt(pe)) {\n    const done = true === pe.done\n    if (done) {\n      if (pe.path != null) recentDone().set(pe.path, pe as any)\n    }\n    // Throttle progress for any given file, unless it's done.\n    // Don't throttle progress without a file.\n    if (\n      done ||\n      pe.path == null ||\n      !gte(\n        recentProgress().lastSetOrGetTs(pe.path),\n        Date.now() - DefaultThrottleMs\n      )\n    ) {\n      void onProgressEvt(pe)\n      if (pe.path != null) recentProgress().set(pe.path, pe as any)\n    }\n  }\n}\n\nexport const onProgressEvt = shim1({\n  name: \"onProgressEvt\",\n  impl: async (pe: ProgressEvt) => {\n    ee().emit(\"progress\", pe)\n  }\n})\n","import { stringify } from \"../../fe/JSON\"\nimport { Maybe, MaybePromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0, pct } from \"../../fe/Number\"\nimport { rateLimited } from \"../RateLimited\"\nimport { EndableRanks, ending } from \"../async/Endable\"\nimport { EndableInterval } from \"../async/EndableInterval\"\nimport { thenMap } from \"../async/Promise\"\nimport { errorToS } from \"../error/Error\"\nimport { ProgressEvt } from \"./ProgressEvt\"\nimport { DefaultThrottleMs, emitProgressEvt } from \"./ProgressObserver\"\n\nexport class PullProgressObserver extends EndableInterval {\n  private readonly start = Date.now()\n  private done?: boolean\n\n  constructor(\n    readonly ctx: Pick<ProgressEvt, \"path\" | \"op\">,\n    readonly total: number,\n    readonly progress: () => Maybe<number> | MaybePromiseMaybe<number>,\n    readonly throttleMs: number = DefaultThrottleMs\n  ) {\n    super({\n      name: \"PullProgressObserver(\" + stringify(ctx) + \")\",\n      callback: () => this.onInterval(),\n      intervalMs: throttleMs,\n      rank: EndableRanks.first\n    })\n  }\n\n  readonly onInterval = rateLimited({\n    name: \"PullProgressObserver.onInterval\",\n    f: () =>\n      ending() ? this.end() : thenMap(this.progress(), ea => this.emit(ea)),\n    minCallDelayMs: this.throttleMs\n  })\n\n  observe<T>(p: Promise<T>): Promise<T> {\n    // we throw this promise chain away:\n    p.then(\n      () => this.completed(),\n      err => {\n        this.logger.warn(\"failed: \", err)\n        this.ctx.op += \" (failed: \" + errorToS(err, { maxLen: 128 }) + \")\"\n        void this.end()\n      }\n    )\n    return p\n  }\n\n  private emit(current: Maybe<number>) {\n    if (gt0(current)) {\n      emitProgressEvt({\n        ...this.ctx,\n        pct: pct(current, this.total),\n        elapsedMs: Date.now() - this.start,\n        done: this.done\n      })\n    }\n  }\n\n  completed() {\n    this.done = true\n    if (this.ended) return\n    this.emit(this.total)\n    void this.end()\n  }\n}\n","import { gte, pct } from \"../../fe/Number\"\nimport { ProgressEvtWithoutPct } from \"./ProgressEvt\"\nimport { emitProgressEvt } from \"./ProgressObserver\"\n\nexport class PushProgressObserver {\n  private readonly start = Date.now()\n  private current?: number\n  private done?: boolean\n  constructor(\n    readonly context: ProgressEvtWithoutPct,\n    readonly total: number\n  ) {}\n\n  toJSON() {\n    return undefined // not serializable\n  }\n\n  incrProgress(incremental: number) {\n    this.onProgress(incremental + (this.current ?? 0))\n  }\n\n  onProgress(current?: number) {\n    this.current = (current ?? this.current ?? 0) + 1\n    if (gte(this.current, this.total)) this.done = true\n    this.emit()\n  }\n\n  completed() {\n    this.done = true\n    this.current = this.total\n    this.emit()\n  }\n\n  emit() {\n    emitProgressEvt({\n      ...this.context,\n      pct: pct(this.current, this.total),\n      elapsedMs: Date.now() - this.start,\n      done: this.done\n    })\n  }\n}\n","import { BatchCluster, Parser, Task } from \"batch-cluster\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank, mapNotBlankOr, notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { Obj } from \"../../fe/Object\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { BatchClusterObserver } from \"../BatchClusterObserver\"\nimport { thenElapsed } from \"../Elapsed\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { ellipsize, ensureSuffix, stripPrefix } from \"../String\"\nimport { EndableRanks, ending } from \"../async/Endable\"\nimport { EndableWrapper } from \"../async/EndableWrapper\"\nimport { thenMap } from \"../async/Promise\"\nimport { until } from \"../async/until\"\nimport { execFile } from \"../child/ChildProcess\"\nimport { ee } from \"../event/EventEmitter\"\nimport { isWin } from \"../platform/Platform\"\nimport { Settings } from \"../settings/Settings\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\n\nconst Done = \"{ready}\"\n\nconst ConvertToCompressedJson = \" | ConvertTo-Json -Compress\"\n\nexport type Result = { stdout: string; stderr?: string; passed: boolean }\n\nexport interface PowerShellVersion {\n  Major: number\n  Minor: number\n  Build: number\n  Revision: number\n  MajorRevision: number\n  MinorRevision: number\n}\n\nexport function pwshQuote(s: string): string {\n  const s2 = s\n    .replace(/['`\"“”#]/g, ea => \"`\" + ea)\n    .replace(/\\0/g, \"`0\")\n    .replace(/\\n/g, \"`n\")\n    .replace(/\\r/g, \"`r\")\n    .replace(/\\t/g, \"`t\")\n    .replace(/\\v/g, \"`v\")\n  return '\"' + s2 + '\"'\n}\n\nfunction versionCommand() {\n  return [\n    `function prompt {\"${Done}\"}`,\n    ...mapNotBlankOr(\n      Settings.powerShellCulture.valueOrDefault,\n      ea => [\n        `[System.Threading.Thread]::CurrentThread.CurrentCulture = '${ea}'`,\n        `[System.Threading.Thread]::CurrentThread.CurrentUICulture = '${ea}'`\n      ],\n      []\n    )\n  ].join(\";\")\n}\n\nlater(() =>\n  ee().on(\"clearCache\", () => PowerShell.instance.prior()?.clearMockResults())\n)\n\nexport class PowerShell extends EndableWrapper {\n  static ensureInstance() {\n    const prior = this.instance()\n    return prior.ended ? this.instance.refresh() : prior\n  }\n  static readonly instance = lazy(() => {\n    if (!isWin) throw new Error(\"PowerShell isn't available on this platform\")\n    return new PowerShell()\n  })\n  private readonly bco: BatchClusterObserver<BatchCluster>\n  private readonly pwsh: BatchCluster\n  private readonly mockResults = new Map<string, Result>()\n\n  // always access through PowerShell.instance():\n  private constructor() {\n    super(\"PowerShell\", () => this.bco.end(), EndableRanks.postdb)\n    this.bco = new BatchClusterObserver(\n      \"PowerShell\",\n      new BatchCluster({\n        processFactory: () =>\n          execFile(\"powershell\", Settings.powerShellArgs.values),\n        logger: () => mkLogger(\"PowerShell\"),\n        versionCommand: versionCommand(),\n        pass: Done,\n        fail: \"Error\",\n        exitCommand: \"exit\",\n        maxProcs: Settings.powerShellProcs.valueOrDefault,\n        taskTimeoutMillis: commandTimeoutMs(),\n\n        maxIdleMsPerProcess: minuteMs,\n        cleanupChildProcs: false // we do this with the Pids class.\n      }),\n      EndableRanks.postdb // last to shut down.\n    )\n    Settings.powerShellProcs.watch(() =>\n      this.bco.t.setMaxProcs(Settings.powerShellProcs.valueOrDefault)\n    )\n    this.pwsh = this.bco.t\n  }\n\n  get lastStartError() {\n    return this.bco.lastStartError\n  }\n\n  get lastTaskError() {\n    return this.bco.lastTaskError\n  }\n\n  get ended() {\n    return this.pwsh.ended\n  }\n\n  versionPojo(): PromiseMaybe<PowerShellVersion> {\n    return this.executeJson(\"$PSVersionTable.PSVersion\")\n  }\n\n  version(): PromiseMaybe<string> {\n    return thenMap(\n      this.executeJson(\"$PSVersionTable.PSVersion\"),\n      ea => `${ea.Major}.${ea.Minor}.${ea.Build}`\n    )\n  }\n\n  get spawnedProcCount() {\n    return this.pwsh.spawnedProcCount\n  }\n\n  pushMockJsonResult(cmd: string, result: Result) {\n    this.pushMockResult(ensureSuffix(cmd, ConvertToCompressedJson), result)\n  }\n\n  pushMockResult(cmd: string, result: Result) {\n    this.mockResults.set(cmd, result)\n  }\n\n  clearMockResults() {\n    this.mockResults.clear()\n  }\n\n  async execute<T>(cmd: string, parser: Parser<T>): PromiseMaybe<T> {\n    if (this.pwsh.ended || ending()) {\n      this.logger.warn(\"execute() failed (ended)\", { cmd })\n      return\n    }\n\n    if (isTest && this.mockResults.has(cmd)) {\n      const f = this.mockResults.get(cmd)!\n      return parser(f.stdout, f.stderr, f.passed)\n    }\n\n    try {\n      const r = await thenElapsed(\n        this.pwsh.enqueueTask(\n          new Task(\n            cmd,\n            (stdout: string, stderr: string | undefined, passed: boolean) =>\n              parser(map(stdout, ea => stripPrefix(ea, cmd))!, stderr, passed)\n          )\n        )\n      )\n      return this.logger.tap({\n        msg: \"execute()\",\n        result: r.result,\n        meta: {\n          elapsedMs: r.elapsedMs,\n          cmd\n        }\n      })\n    } catch (err) {\n      this.logger.warn(\"execute() failed: \" + err, { cmd })\n      return\n    }\n  }\n\n  async executeJson(cmd: string): PromiseMaybe<any> {\n    const r = await this.execute(\n      ensureSuffix(cmd, ConvertToCompressedJson),\n      (stdout, stderr, passed) => ({ stdout, stderr, passed })\n    )\n    if (r == null) {\n      this.logger.warn(\"executeJson(): null result\", { cmd })\n      return\n    }\n    if (blank(r.stdout) || notBlank(r.stderr) || !r.passed) {\n      this.logger.warn(\"executeJson(): failed result\", { cmd, ...r })\n      return\n    }\n    try {\n      return JSON.parse(r.stdout)\n    } catch (err) {\n      const fixed = r.stdout.replace(/\\\\/g, \"\\\\\\\\\")\n      this.logger.info(\n        \"executeJson(): parsing failed, trying dub-whack fix...\",\n        { before: ellipsize(r.stdout), after: ellipsize(fixed) }\n      )\n      return JSON.parse(fixed)\n    }\n  }\n\n  async executeJsonToA(cmd: string): PromiseMaybe<Obj[]> {\n    return thenMap(this.executeJson(cmd), json =>\n      Array.isArray(json) ? json : [json]\n    )\n  }\n\n  /**\n   * @return the path to the command, if it's available on the PATH\n   */\n  async which(cmd: string): PromiseMaybe<string> {\n    // Note to Future Me: `where` (Windows' version of `which`) doesn't seem to\n    // find binaries reliably, and this prevents spawning a binary (double win!)\n    const json = await this.executeJson(\n      \"Get-Command -ErrorAction SilentlyContinue \" +\n        pwshQuote(cmd) +\n        \" | Select-Object -Property Source\"\n    )\n    return Array.isArray(json) ? json[0]?.Source : json?.Source\n  }\n}\n\n/**\n * @return the PowerShell version, or undefined on unsupported platforms.\n * @throws if PowerShell times out or has issues\n */\nexport async function checkPowerShell_(): Promise<string> {\n  const ps = PowerShell.instance()\n  if (ps.ended || ending()) return \"PowerShell ended\"\n  const version = await thenOrTimeoutError(ps.version(), commandTimeoutMs())\n  if (blank(version)) {\n    const err = await until(() => orElse(ps.lastStartError, ps.lastTaskError), {\n      timeoutMs: ShortCommandTimeoutMs,\n      intervalMs: 250\n    })\n    if (err != null) throw err\n    else throw new Error(\"(unknown error)\")\n  }\n  return version\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const AggregateTypes = strEnum(\"union\", \"intersection\")\nexport type AggregateType = StrEnumKeys<typeof AggregateTypes>\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\n// order here is the default sort order!\nexport const AssetFileSortCriteria = strEnum(\n  // more pixels are always better (this is quantized using variantSortCriteriaPower):\n  \"resolution\",\n  // prefer files in the library:\n  \"schemeIdx\",\n\n  // prefer files with a more accurate date:\n  \"capturedAtPrecision\",\n  // prefer files with more fields with metadata we care about:\n  \"metadataCoverage\",\n\n  // prefer files we can directly throw at the browser:\n  \"isBrowserSupported\",\n\n  // if they edit a file, we should prefer that newly edited version:\n  \"mtime\",\n\n  // If we have a burst files, prefer the \"burst cover\"\n  \"isCover\",\n\n  // If there are many copies of a file (image.jpg, image (1).jpg, image\n  // (2).jpg), prefer the one with the highest number (assuming that's the\n  // latest copy):\n  \"count\",\n\n  // help make things deterministic:\n  \"fileSize\",\n  // help make things deterministic:\n  \"basename\",\n  // help make things deterministic:\n  \"parentBasename\",\n  // just to make things deterministic:\n  \"uri\"\n)\n\nexport type AssetFileSortCriterion = StrEnumKeys<typeof AssetFileSortCriteria>\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { toBoolean } from \"../../fe/Boolean\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class BooleanSetting extends Setting<boolean> {\n  constructor(opts: SettingOpts<boolean>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toBoolean\n    })\n  }\n}\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class BoundedFloatSetting extends Setting<number> {\n  constructor(\n    readonly options: SettingOpts<number> & { min: number; max: number }\n  ) {\n    super({\n      ...options,\n      toEnv: notBlankToS,\n      fromEnv: (value: Maybe<string>) =>\n        opt(value)\n          .flatMap(parseFloat)\n          .map(ea => clamp(options.min, options.max, ea))\n          .get()\n    })\n  }\n  addToJSON() {\n    return {\n      \"minimum value\": this.options.min,\n      \"maximum value\": this.options.max\n    }\n  }\n}\n","import { notBlank, notBlankToS } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, toInt } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class BoundedIntegerSetting extends Setting<number> {\n  constructor(\n    readonly options: SettingOpts<number> & { min: number; max: number }\n  ) {\n    super({\n      ...options,\n      toEnv: notBlankToS,\n      fromEnv: (value: Maybe<string>) =>\n        opt(value)\n          .filter(notBlank)\n          .flatMap(toInt)\n          .map(ea => clamp(options.min, options.max, ea))\n          .get()\n    })\n  }\n\n  get min(): number {\n    return this.options.min\n  }\n\n  get max(): number {\n    return this.options.max\n  }\n\n  clamp(value: Maybe<number>) {\n    return clamp(this.min, this.max, value ?? this.min)\n  }\n\n  addToJSON() {\n    return {\n      \"minimum value\": this.options.min,\n      \"maximum value\": this.options.max\n    }\n  }\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const ColorDistanceFunctions = strEnum(\"cie76\", \"cie94\", \"ciede2000\")\nexport type ColorDistanceFunction = StrEnumKeys<typeof ColorDistanceFunctions>\n","export const DominantColorKmeansRunsDefault = 7\n\n// Results from running ImageHash.spec.ts with different values:\n\n// with 32 runs: (mean: 108ms, sum: 5810ms)\n// dominantColorScore { k: 60, mean: 8.1, sum: 485, sd: 1.9, max: 15, min: 4.8 }\n\n// with 16 runs: (mean: 62ms, sum: 3327ms),\n// dominantColorScore { k: 60, mean: 8.2, sum: 494, sd: 2, max: 16, min: 5 }\n\n// with 8 runs: (mean: 36ms, sum: 1958ms)\n// dominantColorScore { k: 60, mean: 8.5, sum: 510, sd: 2.1, max: 17, min: 5 }\n\n// with 7 runs: (mean: 31ms, sum: 1636ms)\n// dominantColorScore { k: 60, mean: 8.5, sum: 511, sd: 2.1, max: 16, min: 4.8 }\n\n// with 5 runs: (mean: 24ms, sum: 1165ms )\n// dominantColorScore { k: 60, mean: 8.7, sum: 519, sd: 2.2, max: 17, min: 5.1 }\n\n// with 4 runs: (mean: 23ms, sum: 1067ms)\n// dominantColorScore { k: 60, mean: 8.7, sum: 523, sd: 2.2, max: 17, min: 5.2 }\n\n// with 3 runs: (mean: 19ms, sum: 611ms)\n// dominantColorScore { k: 60, mean: 8.8, sum: 528, sd: 2.3, max: 17, min: 5.2 }\n","export const DominantColorPixelsDefault = 1024\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { decodeDuration, encodeDuration } from \"../date/DurationCodec\"\nimport { fmtFullDuration } from \"../date/DurationFormat\"\nimport { BaseSettingOpts, Setting, SettingOpts } from \"./Setting\"\n\nexport class DurationSetting extends Setting<number> {\n  constructor(opts: SettingOpts<string | number>) {\n    super({\n      ...(opts as any),\n      toEnv: encodeDuration,\n      fromEnv: decodeDuration\n    })\n  }\n\n  get valueOrDefault() {\n    // code is expecting this to be in millis.\n    return decodeDuration(super.valueOrDefault) as any\n  }\n\n  get value() {\n    // code is expecting this to be in millis.\n    return decodeDuration(super.value) as any\n  }\n\n  set value(o: any) {\n    super.userValue = decodeDuration(o)\n  }\n\n  get humanValue() {\n    return fmtFullDuration(this.value)\n  }\n\n  // the file value is the only one 8601-encoded:\n  get fileValue() {\n    return encodeDuration(super.fileValue) as any\n  }\n\n  set fileValue(o: any) {\n    super.fileValue = decodeDuration(o)\n  }\n}\n\nexport class OptionalDurationSetting extends Setting<Maybe<number>> {\n  constructor(opts: BaseSettingOpts<Maybe<string | number>>) {\n    super({\n      ...(opts as any),\n      toEnv: encodeDuration,\n      fromEnv: decodeDuration,\n      defaultValue: undefined\n    })\n  }\n\n  get valueOrDefault() {\n    return this.value ?? decodeDuration(this.defaultValue as any)!\n  }\n\n  get fileValue() {\n    return encodeDuration(super.fileValue) as any\n  }\n}\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { toFloat } from \"../../fe/Number\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class FloatSetting extends Setting<number> {\n  constructor(opts: SettingOpts<number>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toFloat\n    })\n  }\n}\n","import { isTrue } from \"../../fe/Boolean\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { fromEntries, pick } from \"../../fe/Object\"\nimport { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\nimport { Settings } from \"./Settings\"\n\n// Hey, so, why don't we just use Settings.forceSync?\n\n// BECAUSE, future me, sync might be doing multiple tasks simultaneously: the\n// call stack is the only place we can ensure tasks don't pollute any other\n// concurrent tasks.\n\nconst ForceContextKeys = strEnum(\n  /**\n   * If true, ignore all short-circuiting paths if we think the file or asset\n   * is already in sync.\n   */\n  \"forceSync\",\n  /**\n   * If true, don't build previews: we'll do it later.\n   */\n  \"skipPreviews\",\n  /**\n   * If true, always rebuild previews\n   */\n  \"forceRebuildPreviews\",\n  /**\n   * If true, don't build previews: we'll do it later.\n   */\n  \"skipAssetTagging\",\n  \"recountAllTags\"\n)\nexport type ForceContextKey = StrEnumKeys<typeof ForceContextKeys>\n\nexport type ForceContext = Partial<Record<ForceContextKey, boolean>> & {\n  retries?: number\n}\n\nexport type RequiredForceContext = Required<ForceContext>\n\nexport function pickForceContext<T extends ForceContext>(o: T): ForceContext {\n  return pick(o, ...ForceContextKeys.values)\n}\n\nexport function forceContextOrSetting(\n  ctx?: Maybe<ForceContext>\n): RequiredForceContext {\n  return fromEntries(\n    ForceContextKeys.values.map(k => [\n      k,\n      // defer to Settings if ctx is undefined, but remember that not all keys\n      // are settings!\n      ctx?.[k] ?? isTrue((Settings as any)[k]?.valueOrDefault)\n    ])\n  )\n}\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { toInt } from \"../../fe/Number\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class IntegerSetting extends Setting<number> {\n  constructor(opts: SettingOpts<number>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toInt\n    })\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { toA } from \"../../fe/toA\"\nimport { AppName } from \"../AppName\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { mkLogger } from \"../Logger\"\nimport { settingsToObj } from \"./Setting\"\nimport { persistedSystemSettings } from \"./Settings\"\nimport { readSystemSettings, writeSystemSettings_ } from \"./SettingsIO\"\nimport { SettingsToml } from \"./SettingsToml\"\n\nconst logger = lazy(() => mkLogger(\"settings.MergeConfigDirs\"))\n\nexport async function mergeUserDataDirs_() {\n  const cfgDir = configDir()\n  if (cfgDir == null) return\n\n  const current = PosixFile.for(cfgDir)\n\n  for (const prior of [\n    current.join(AppName()),\n    current.join(AppName().toLowerCase()),\n    current.parent().join(AppName().toLowerCase())\n  ]) {\n    try {\n      await mergeAndArchiveSystemSettingsDir_(prior, current)\n    } catch (err) {\n      logger().error(\"Failed to merge \" + prior + \" and \" + current, err)\n    }\n  }\n  logger().info(\"done\")\n}\n\nexport async function mergeAndArchiveSystemSettingsDir_(\n  priorConfigDir_: PosixFile,\n  currentConfigDir_: PosixFile\n) {\n  let log = mkLogger(\n    \"mergeAndArchiveSystemSettingsDir_(\" +\n      priorConfigDir_.baseWithGrandparent +\n      \" => \" +\n      currentConfigDir_.baseWithGrandparent +\n      \")\"\n  )\n  const priorResolvedConfigDir = await priorConfigDir_.resolve_()\n  const currentResolvedConfigDir = await currentConfigDir_.resolve_()\n  if (\n    priorResolvedConfigDir == null ||\n    currentResolvedConfigDir == null ||\n    currentResolvedConfigDir.nativePath === priorResolvedConfigDir.nativePath\n  ) {\n    log.info(\"no-op, missing or same directory\", {\n      priorResolvedConfigDir: priorResolvedConfigDir?.nativePath,\n      currentResolvedConfigDir: currentResolvedConfigDir?.nativePath\n    })\n    return\n  }\n  log = mkLogger(\n    \"mergeAndArchiveSystemSettingsDir_(\" +\n      priorResolvedConfigDir.baseWithGrandparent +\n      \" => \" +\n      currentResolvedConfigDir.baseWithGrandparent +\n      \")\"\n  )\n\n  if (!(await priorResolvedConfigDir.isDirectory())) {\n    log.info(\"no-op, prior directory doesn't exist\")\n    return\n  }\n  {\n    const prior = priorResolvedConfigDir.join(SettingsToml)\n    if (await prior.isNonEmptyFile()) {\n      const curr = currentResolvedConfigDir.join(SettingsToml)\n      // layer in any prior settings, but last one in wins:\n      await readSystemSettings(prior)\n      log.info(\n        \"read prior settings.toml\",\n        settingsToObj(persistedSystemSettings())\n      )\n      await readSystemSettings(curr)\n      log.info(\n        \"read current settings.toml\",\n        settingsToObj(persistedSystemSettings())\n      )\n      await writeSystemSettings_(curr)\n    }\n  }\n\n  {\n    // Copy any licenses over...\n    const srcDir = priorResolvedConfigDir.join(\"licenses\")\n    const destDir = currentResolvedConfigDir.join(\"licenses\")\n    for (const src of toA(await srcDir.childFiles())) {\n      const dest = destDir.join(src.base)\n      if (await dest.notExists()) {\n        try {\n          await src.copyFile_(dest)\n          log.info(\"Copied license \" + src.base)\n        } catch (err) {\n          log.warn(\"Failed to copy license \" + src.base, err)\n        }\n      }\n    }\n  }\n  // Archive the directory so we don't migrate it again:\n  const old = currentResolvedConfigDir.join(\"old\")\n  try {\n    const dest = await priorResolvedConfigDir.renameYMDHMS_({\n      subdir: old.nativePath\n    })\n    log.info(\"merged and archived to \" + dest)\n  } catch (err) {\n    log.warn(\"Failed to archive to \" + old, err)\n  }\n  return\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { hourMs, minuteMs } from \"../../fe/Date\"\nimport { gt0 } from \"../../fe/Number\"\nimport { entries } from \"../../fe/Object\"\nimport { ensureSuffix } from \"../../fe/String\"\nimport { mkLogger } from \"../Logger\"\nimport { mapGt0 } from \"../Number\"\nimport { picturesDir } from \"../dir/PicturesDir\"\nimport { ColorDistanceFunctions } from \"./ColorDistanceFunctions\"\nimport { DominantColorKmeansRunsDefault } from \"./DominantColorKmeansRunsDefault\"\nimport { DominantColorPixelsDefault } from \"./DominantColorPixelsDefault\"\nimport { Setting } from \"./Setting\"\nimport { Settings } from \"./Settings\"\nimport { TagInferenceSettingValues } from \"./TagInferenceSettingValues\"\n\nconst logger = lazy(() => mkLogger(\"settings.MetaSettings\"))\n\nfunction getSettingValue<T extends keyof typeof Settings>(\n  name: T,\n  arr: Setting<any>[]\n): (typeof Settings)[T][\"valueOrDefault\"] {\n  return (Settings[name].value ??\n    arr.find(ea => ea.name === name)?.value ??\n    Settings[name].defaultValue) as T\n}\n\nexport function handleMetaSettings(imported: Setting<any>[]) {\n  // Yes, we actually want valueOrDefault (so if we're rpi, we're true if\n  // unset), and we don't need getSettingValue here.\n  setQuickSyncMode(Settings.quickSyncMode.valueOrDefault)\n\n  if (getSettingValue(\"disableAllFilters\", imported)) {\n    disableAllFilters()\n  }\n\n  if (getSettingValue(\"strictDeduping\", imported)) {\n    setStrictDeduping()\n  }\n\n  if (getSettingValue(\"allowFilesystemSleep\", imported)) {\n    allowFilesystemSleep()\n  }\n\n  if (getSettingValue(\"optOut\", imported)) {\n    disableExternalNetworkRequests()\n  }\n}\n\nexport async function handleDeprecatedSettings() {\n  {\n    //\n    // scanMyPictures\n    //\n    if (isTrue(Settings.scanMyPictures.value)) {\n      Settings.scanMyPictures.unset()\n      const newPath = await picturesDir()\n      logger().info(\"Upgrading setting scanMyPictures to scanPaths\", {\n        priorValues: Settings.scanPaths.values,\n        newPath\n      })\n      Settings.scanPaths.push(newPath)\n    }\n  }\n\n  {\n    //\n    // assetSubdirectoryDatestampFormat\n    //\n    const prior = Settings.assetSubdirectoryDatestampFormat.value\n    Settings.assetSubdirectoryDatestampFormat.unset()\n    if (blank(Settings.assetPathnameFormat.value) && notBlank(prior)) {\n      const newValue = ensureSuffix(prior, \"/\") + \"BASE\"\n      logger().info(\n        \"Upgrading setting assetSubdirectoryDatestampFormat to assetPathnameFormat\",\n        { prior, newValue }\n      )\n      Settings.assetPathnameFormat.value = newValue\n    }\n  }\n\n  {\n    //\n    // syncIntervalHours\n    //\n    const prior = Settings.syncIntervalHours.value\n    Settings.syncIntervalHours.unset()\n    const newValue = mapGt0(prior, ea => ea * hourMs)\n\n    if (!Settings.syncNewIntervalMs.hasValue() && gt0(newValue)) {\n      logger().info(\n        \"Upgrading setting syncIntervalHours to syncNewIntervalMs\",\n        { prior, newValue }\n      )\n      Settings.syncNewIntervalMs.value = newValue\n    }\n\n    if (!Settings.syncChangedIntervalMs.hasValue() && gt0(newValue)) {\n      logger().info(\n        \"Upgrading setting syncIntervalHours to syncChangedIntervalMs\",\n        { prior, newValue }\n      )\n      Settings.syncChangedIntervalMs.value = newValue\n    }\n  }\n\n  {\n    //\n    // dbBackupIntervalMinutes\n    //\n    if (\n      Settings.dbBackupIntervalMinutes.hasValue() &&\n      !Settings.dbBackupIntervalMs.hasValue()\n    ) {\n      const newValue =\n        Settings.dbBackupIntervalMinutes.valueOrDefault * minuteMs\n      logger().info(\n        \"Upgrading setting dbBackupIntervalMinutes to dbBackupIntervalMs\",\n        { newValue }\n      )\n\n      Settings.dbBackupIntervalMs.value = newValue\n    }\n  }\n\n  {\n    //\n    // enableSiblingInference\n    //\n    if (\n      Settings.enableSiblingInference.hasValue() &&\n      !Settings.siblingInference.hasValue()\n    ) {\n      const newValue = Settings.enableSiblingInference.valueOrDefault\n        ? Settings.siblingInference.valueOrDefault\n        : TagInferenceSettingValues.never\n      logger().info(\n        \"Upgrading setting enableSiblingInference to siblingInference\",\n        { newValue }\n      )\n\n      Settings.siblingInference.value = newValue\n    }\n  }\n}\n\n// We use envValue here (rather than tmpValue) to forcefully ignore any env or\n// file overrides.\n\nexport function disableAllFilters() {\n  // We don't need to set this: this setting is why we're here!\n  // Settings.disableAllFilters.envValue = true\n\n  Settings.respectFileExtensions.envValue = false\n\n  Settings.requireMakeModel.envValue = false\n  Settings.rejectRatingsLessThan.envValue = -100\n\n  Settings.minImageDimension.envValue = 0\n  Settings.minVideoDimension.envValue = 0\n\n  Settings.minVideoDurationSec.envValue = 0\n  Settings.maxVideoDurationSec.envValue = 0\n\n  Settings.minAssetFileSizeBytes.envValue = 0\n  Settings.maxAssetFileSizeBytes.envValue = 0\n\n  Settings.validateJpegImages.envValue = false\n  Settings.validateRawImages.envValue = false\n  Settings.validateVideos.envValue = false\n}\n\nexport function setStrictDeduping() {\n  Settings.strictDeduping.envValue = true\n  Settings.useImageHashes.envValue = true\n  Settings.minExposureSettingsCoeffPct.envValue = 98\n  Settings.minImageCoeffPct.envValue = 95\n  Settings.imageHashFuzzyDateDelta.envValue = 1\n  Settings.imageHashDifferentMimetypesDelta.envValue = -10\n  Settings.imageHashGreyscaleDelta.envValue = 1\n}\n\nexport function allowFilesystemSleep() {\n  Settings.sharedStatePollMs.envValue = 0\n}\n\nconst quickSyncSettings = [\n  Settings.validateJpegImages,\n  Settings.validateRawImages,\n  Settings.validateVideos,\n  Settings.transcodeVideos,\n  Settings.previewMinimized,\n  Settings.previewProgressive,\n  Settings.previewSharpen,\n  Settings.useImageHashes,\n  Settings.enableSiblingInference\n]\n\nconst argonDefaults = {\n  argon2TimeCost: 8,\n  argon2MemoryCostMB: 64,\n  argon2Parallelism: 1\n} as const\nconst argonQuick = {\n  argon2TimeCost: 4,\n  argon2MemoryCostMB: 32,\n  argon2Parallelism: 1\n} as const\n\nexport function setQuickSyncMode(quick: boolean) {\n  for (const s of quickSyncSettings) {\n    if (quick) {\n      s.tmpValueIfUnset = false\n    } else {\n      s.tmpValue = undefined\n    }\n  }\n  const argon = quick ? argonQuick : argonDefaults\n  for (const [k, v] of entries(argon)) {\n    Settings[k].defaultValue = v\n  }\n  Settings.dominantColorPixels.defaultValue = quick\n    ? 256\n    : DominantColorPixelsDefault\n  Settings.dominantColorKmeansRuns.defaultValue = quick\n    ? 0\n    : DominantColorKmeansRunsDefault\n\n  Settings.dominantColorDeltaE.defaultValue = quick\n    ? ColorDistanceFunctions.cie76\n    : ColorDistanceFunctions.ciede2000\n}\n\nexport function disableExternalNetworkRequests() {\n  Settings.autoUpdateCheck.defaultValue = false\n  Settings.allowUserAgent.defaultValue = false\n  Settings.reportErrors.defaultValue = false\n}\n","export const MinValidYear = 1920\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { resolve } from \"../fs/Path\"\nimport { OptionalStringSetting } from \"./OptionalStringSetting\"\nimport { BaseSettingOpts, SettingOpts } from \"./Setting\"\n\nexport class OptionalFileSetting extends OptionalStringSetting {\n  constructor(\n    opts: BaseSettingOpts<Maybe<string>> & Partial<SettingOpts<Maybe<string>>>\n  ) {\n    super({\n      toEnv: ea => ea?.trim(),\n      fromEnv: ea => (blank(ea) ? undefined : resolve(ea)),\n      defaultValue: undefined,\n      ...opts\n    })\n  }\n}\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toFloat } from \"../../fe/Number\"\nimport { BaseSettingOpts, DefaultValued, Setting } from \"./Setting\"\n\nexport class OptionalFloatSetting extends Setting<Maybe<number>> {\n  constructor(\n    opts: BaseSettingOpts<Maybe<number>> & Partial<DefaultValued<Maybe<number>>>\n  ) {\n    super({\n      defaultValue: undefined,\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toFloat\n    })\n  }\n}\n","import { notBlankToS } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toInt } from \"../../fe/Number\"\nimport { BaseSettingOpts, Setting } from \"./Setting\"\n\nexport class OptionalIntegerSetting extends Setting<Maybe<number>> {\n  constructor(opts: BaseSettingOpts<Maybe<number>>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toInt,\n      defaultValue: undefined\n    })\n  }\n}\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport {\n  BaseSettingOpts,\n  Setting,\n  SettingConverters,\n  SettingOpts\n} from \"./Setting\"\n\nexport class OptionalStringSetting extends Setting<Maybe<string>> {\n  constructor(\n    opts: BaseSettingOpts<Maybe<string>> &\n      Partial<SettingOpts<Maybe<string>>> &\n      Partial<SettingConverters<string>>\n  ) {\n    super({\n      toEnv: ea => ea?.trim(),\n      fromEnv: ea => ea,\n      defaultValue: undefined,\n      ...opts\n    })\n  }\n\n  hasValue() {\n    return this.value != null\n  }\n}\n","import { DateTime } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { replaceAll, stripPrefix } from \"../../fe/String\"\nimport { mkLogger } from \"../Logger\"\nimport { countChars, splitKeep } from \"../String\"\nimport { Dated, datedToDateTime } from \"../date/Dated\"\nimport { datedToISO } from \"../date/FuzzyDate\"\nimport { hasZone } from \"../date/getZoneName\"\nimport { grandParentBasename, parentBasename } from \"../fs/Path\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { Settings } from \"./Settings\"\n\nconst logger = lazy(() => mkLogger(\"settings.PathToLibraryAsset\"))\n\nconst SingleQuote = \"′\"\n\nfunction esc(str: Maybe<string>): string {\n  return blank(str) ? \"\" : \"'\" + replaceAll(str, \"'\", SingleQuote) + \"'\"\n}\n\nfunction unesc(str: string) {\n  return replaceAll(str, SingleQuote, \"'\")\n}\n\nexport function pathToLibraryAsset(\n  capturedAt: Maybe<Dated>,\n  src: SimpleFile\n): Maybe<string[]> {\n  // If we can directly convert to DateTime (with toDateTime) we should do that,\n  // instead of converting back and forth with an ISO date string.\n  const dt =\n    datedToDateTime(capturedAt) ??\n    map(datedToISO(capturedAt), iso => DateTime.fromISO(iso))\n\n  if (dt == null || !dt.isValid) {\n    return logger().tap({\n      msg: \"pathToLibraryAsset(): failed to convert to a valid date\",\n      result: undefined,\n      meta: { capturedAt, src, dt }\n    })\n  }\n\n  const withZone = hasZone(capturedAt)\n\n  // A strung-together set of .replace may trip over prior substitutions, so we\n  // split the tokens into an array and handle each token exactly once.\n\n  // We don't want to strip quotes from this, as it will remove single-quoted\n  // literals:\n  const assetPathnameFormat = Settings.assetPathnameFormat.valueOrDefault\n\n  const tokens = splitKeep(\n    assetPathnameFormat,\n    /((?:GRAND)?PARENT|BASE|NAME|EXT|ISO)/g\n  )\n\n  for (let i = 0; i < tokens.length; i++) {\n    switch (tokens[i]) {\n      case \"GRANDPARENT\":\n        tokens[i] = esc(grandParentBasename(src))\n        break\n      case \"PARENT\":\n        tokens[i] = esc(parentBasename(src))\n        break\n      case \"BASE\":\n        tokens[i] = esc(src.base)\n        break\n      case \"NAME\":\n        tokens[i] = esc(src.name)\n        break\n      case \"EXT\":\n        tokens[i] = esc(stripPrefix(src.ext, \".\"))\n        break\n      case \"ISO\":\n        tokens[i] = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" + (withZone ? \"ZZ\" : \"\")\n        break\n      default:\n        if (countChars(tokens[i], \"'\") % 2 === 1) {\n          tokens[i] = replaceAll(tokens[i], \"'\", SingleQuote)\n        }\n    }\n  }\n\n  const formatted = unesc(dt.toFormat(tokens.join(\"\")))\n  const paths = formatted.split(\"/\")\n  return logger().tap({\n    msg: \"pathToLibraryAsset()\",\n    result: compactBlanks(paths),\n    meta: { capturedAt, src, dt, assetPathnameFormat, tokens }\n  })\n}\n","import { ensurePrefix } from \"../../fe/String\"\nimport { camel2snake, snake2camel } from \"../StringCase\"\nimport { SettingsName } from \"./SettingsName\"\n\nexport function nameFromEnv(name: string): string {\n  return snake2camel(name.replace(/^PS_/, \"\").toLowerCase())\n}\n\nexport function envFromName(name: SettingsName | string): string {\n  return ensurePrefix(camel2snake(name).toUpperCase(), \"PS_\")\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { filterInPlace, isEmpty, uniq } from \"../../fe/Array\"\nimport { ChangeListener } from \"../../fe/ChangeListener\"\nimport { shallowClone } from \"../../fe/Clone\"\nimport { eql } from \"../../fe/Eql\"\nimport { orList } from \"../../fe/FmtList\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Defined, map, mapOr } from \"../../fe/Maybe\"\nimport { Maybe, MaybeNull } from \"../../fe/MaybeTypes\"\nimport { Obj, StringValued, entries } from \"../../fe/Object\"\nimport { padding } from \"../../fe/Pad\"\nimport { pluralize } from \"../../fe/Pluralize\"\nimport { Thunk, tot } from \"../../fe/Thunk\"\nimport { toA } from \"../../fe/toA\"\nimport { CaseInsensitiveValued } from \"../CaseInsensitiveValued\"\nimport { wrap } from \"../String\"\nimport { env } from \"../env/Env\"\nimport { caseInsensitiveEnv } from \"../env/GetEnv\"\nimport { ee } from \"../event/EventEmitter\"\nimport { envFromName } from \"./PsEnvNames\"\nimport { LibraryCategories, SettingCategory } from \"./SettingCategory\"\nimport { wrapTomlToLines } from \"./TomlStringify\"\nimport { WrapComments } from \"./WrapComments\"\n\n// CAUTION! LIMIT DEPS TO FE AND BASE CLASSES! #NODEPLOOPS (NO DE PLOOPS!)\n\nexport interface BaseSettingOpts<T> {\n  aliases?: string[]\n  envAliases?: string[]\n  category: SettingCategory\n  description: string\n  exampleValue?: Thunk<Maybe<T>>\n  transient?: boolean // defaults to false\n  advanced?: Thunk<boolean>\n  deprecated?: boolean // be sure to add a migrator to MetaSettings!\n  sensitive?: boolean\n}\n\nexport interface SettingConverters<T> {\n  readonly toEnv: (value: Maybe<T>) => Maybe<string>\n  readonly fromEnv: (value: Maybe<string>) => Maybe<T>\n}\n\nexport interface DefaultValued<T> {\n  defaultValue: T | Thunk<T>\n}\n\nexport type SettingOpts<T> = BaseSettingOpts<T> & DefaultValued<T>\n\nexport interface SavedSetting {\n  key: string\n  value: any\n}\n\nexport function settingsToObj(arr: Setting[]): Obj {\n  const obj: Obj = {}\n  for (const ea of arr) {\n    if (ea.hasValue()) obj[ea.name] = ea.value\n  }\n  return obj\n}\n\nexport interface SettingState<T> {\n  user: Maybe<T>\n  env: Maybe<T>\n  file: Maybe<T>\n  tmp: Maybe<T>\n}\n\n/**\n * Supports env-overridden preferences that can be persisted to a file.\n *\n * 1. Setting an environment variable or command-line argument must not be\n *    persisted to the settings file, as that would become the default value.\n * 2. Settings file values should not override the command-line or environment's\n *    values, as that would cause the env or CLI value to be ignored.\n *\n * SO: we have to be able to distinguish between env or cli values and persisted\n * values.\n */\nexport class Setting<T = any> {\n  protected _name!: string\n  protected _names!: string[]\n  protected _key!: string\n  protected _keys!: string[]\n  protected _userValue: Maybe<T>\n  // This lets us only parse values out of the env when we actually need the\n  // value. We get circular dependency errors if we do this on construction\n  // time:\n  _envValue = lazy(() => this.readFromEnv())\n  protected _fileValue: Maybe<T>\n  protected _tmpValue: Maybe<T>\n  protected readonly watchers: ChangeListener<T>[] = []\n  protected optsOverrides: Partial<SettingOpts<T> & SettingConverters<T>> = {}\n\n  constructor(readonly opts: SettingOpts<T> & SettingConverters<T>) {}\n\n  getState(): SettingState<T> {\n    return {\n      user: this._userValue,\n      env: this.envValue,\n      file: this._fileValue,\n      tmp: this._tmpValue\n    }\n  }\n\n  dump() {\n    return {\n      name: this.name,\n      key: this.key,\n      ...this.getState(),\n      hasValue: this.hasValue(),\n      isUnset: this.isUnset(),\n      defaultValue: this.defaultValue\n    }\n  }\n\n  /**\n   * Used for testing: supports changing and restoring state without firing\n   * change observers.\n   */\n  setState(s: Partial<SettingState<T>>) {\n    if (s != null) {\n      this._userValue = s.user\n      this.envValue = s.env\n      this._fileValue = s.file\n      this._tmpValue = s.tmp\n    }\n  }\n\n  normalizeValue(v: Maybe<T>): Maybe<T> {\n    return v == null ? undefined : this.opts.fromEnv(this.opts.toEnv(v))\n  }\n\n  /**\n   * @return the value that should be persisted in a settings.toml. Ignores env\n   * and tmp values.\n   */\n  get fileValue(): Maybe<T> {\n    return this._userValue ?? this._fileValue\n  }\n\n  set fileValue(value: Maybe<T>) {\n    this.onChange(value, ea => (this._fileValue = ea))\n  }\n\n  get envValue(): Maybe<T> {\n    return this._userValue ?? this._envValue()\n  }\n\n  /**\n   * - Set the value for the current process and child processes.\n   * - Don't persist this value in the settings.toml.\n   */\n  set envValue(value: Maybe<T>) {\n    this.onChange(value, ea => {\n      this._envValue.set(ea)\n      this.addToEnv()\n    })\n  }\n\n  refreshEnvValue(args: { broadcastChange?: boolean } = {}) {\n    // if the env value doesn't change valueOrDefault, don't bother the watchers:\n    const prior = shallowClone(this.valueOrDefault)\n    this._envValue.unset()\n    if (true === args?.broadcastChange) this.maybeBroadcastChange(prior)\n  }\n\n  get tmpValue(): Maybe<T> {\n    return this._userValue ?? this._tmpValue\n  }\n\n  /**\n   * - Set the value for the current process (not child processes).\n   * - Don't persist this value in the settings.toml.\n   */\n  set tmpValue(value: Maybe<T>) {\n    this.onChange(value, ea => (this._tmpValue = ea))\n  }\n\n  /**\n   * @return the first set value from user, env, file, or tmp.\n   */\n  get value(): Maybe<T> {\n    return (\n      this._userValue ?? this._envValue() ?? this._fileValue ?? this._tmpValue\n    )\n  }\n\n  set value(value: MaybeNull<T>) {\n    this.userValue = value == null ? undefined : value\n  }\n\n  /**\n   * If there is a \"human-friendly\" version of the value, return that.\n   */\n  get humanValue(): Maybe<T | string> {\n    return this.value\n  }\n\n  set userValue(value: Maybe<T>) {\n    this.onChange(value, ea => (this._userValue = ea))\n  }\n\n  get valueOrThrow(): Defined<T> {\n    const v = this.value\n    if (v == null) {\n      throw new Error(\"Missing value for setting \" + this.name)\n    } else {\n      return v as any\n    }\n  }\n\n  hasValue() {\n    return this.value != null\n  }\n\n  isUnset() {\n    return this.value == null\n  }\n\n  /**\n   * Read the value from the given `Obj` or the ENV.\n   *\n   * THIS DOESN'T CHANGE ANY STATE. If you want to import from the env, use\n   * `importFromEnv`.\n   */\n  readFromEnv(obj?: StringValued): Maybe<T> {\n    const civ =\n      obj == null ? caseInsensitiveEnv() : new CaseInsensitiveValued(obj)\n    // Support PS_LOG_LEVEL and logLevel:\n    for (const k of [...this.keys, ...this.names]) {\n      const v = map(civ.get(k), ea => this.opts.fromEnv(ea))\n      if (v != null) return v\n    }\n    return\n  }\n\n  /**\n   * Should only be used directly by tests, as env shouldn't be wiggling around\n   * after a process starts.\n   */\n  setFromEnv(environment: StringValued = env()): Maybe<T> {\n    return (this.envValue = this.readFromEnv(environment))\n  }\n\n  setValueIfDefined(value: Maybe<T>) {\n    if (value != null) this.value = value\n  }\n\n  watchLater(l: ChangeListener<T>) {\n    this.watchers.push(l)\n  }\n\n  watch(l: ChangeListener<T>) {\n    this.watchLater(l)\n    // setImmediate allows the call to addListener() reference classes or\n    // instances that haven't been parsed yet:\n    setImmediate(() => this.broadcastChange())\n  }\n\n  unWatch(l: ChangeListener<T>) {\n    filterInPlace(this.watchers, ea => ea === l)\n  }\n\n  broadcastChange() {\n    const curr = this.valueOrDefault\n    for (const ea of this.watchers) {\n      ea(curr)\n    }\n    ee().emitDebounced(\"settingsChanged\")\n  }\n\n  /**\n   * @param mutateFunc may change this.value via one of the delegates\n   */\n  protected onChange(v: Maybe<T>, mutateFunc: (ea: Maybe<T>) => any) {\n    // We have to shallow clone prior if it's an array or object, because\n    // mutateFunc may modify prior directly, and then eql() will false-positive.\n    const prior = shallowClone(this.valueOrDefault)\n    mutateFunc(this.normalizeValue(v))\n    this.maybeBroadcastChange(prior)\n  }\n\n  protected maybeBroadcastChange(prior: T) {\n    if (!eql(this.valueOrDefault, prior)) this.broadcastChange()\n  }\n\n  /**\n   * This is the camelCasedVersionOfTheSettingName\n   */\n  get name(): string {\n    return this._name\n  }\n\n  get names(): string[] {\n    return this._names\n  }\n\n  // this is public so Settings can push field names down to instances\n  _setName(name: string) {\n    if (this._name != null) throw new Error(\"cannot set name twice\")\n    this._name = name\n    this._names = uniq([name, ...toA(this.opts.aliases)])\n    this._key = envFromName(name)\n    this._keys = uniq([\n      ...this._names.map(envFromName),\n      this._key,\n      ...toA(this.opts.envAliases)\n    ])\n  }\n\n  /**\n   * This is the environment variable name for this setting:\n   */\n  get key(): string {\n    return this._key\n  }\n\n  /**\n   * This is a list of all environment keys for this setting. It will always\n   * include `this.key`.\n   */\n  get keys(): string[] {\n    return this._keys\n  }\n\n  get altKeys(): string[] {\n    return this._keys.filter(ea => ea !== this._key)\n  }\n\n  get category(): SettingCategory {\n    return this.opts.category\n  }\n\n  get categoryType(): \"system\" | \"library\" {\n    return LibraryCategories.includes(this.category) ? \"library\" : \"system\"\n  }\n\n  get transient(): boolean {\n    return this.opts.transient === true\n  }\n\n  /**\n   * Is this setting an \"advanced\" option (and can be initially hidden)?\n   */\n  get advanced(): boolean {\n    return mapOr(\n      this.opts.advanced,\n      ea => ea(),\n      () => true\n    )\n  }\n\n  /**\n   * @return the env value encoding `this.valueOrDefault`\n   */\n  get envValueOrDefault(): Maybe<string> {\n    return this.opts.toEnv(this.valueOrDefault)\n  }\n\n  set tmpValueIfUnset(t: Maybe<T>) {\n    if (this.isUnset()) this.tmpValue = t\n  }\n\n  get defaultValue(): T {\n    return tot(this.optsOverrides.defaultValue) ?? tot(this.opts.defaultValue)\n  }\n\n  set defaultValue(t: T | Thunk<T>) {\n    const prior = shallowClone(this.valueOrDefault)\n    this.optsOverrides.defaultValue = t\n    this.maybeBroadcastChange(prior)\n  }\n\n  resetDefaultValue() {\n    this.optsOverrides.defaultValue = undefined\n  }\n\n  get exampleValue(): Maybe<T> {\n    return tot(this.optsOverrides.exampleValue ?? this.opts.exampleValue)\n  }\n\n  set exampleValue(t: Maybe<T>) {\n    this.optsOverrides.exampleValue = t as any\n  }\n\n  get valueOrDefault(): T {\n    return this.value ?? this.defaultValue\n  }\n\n  /**\n   * no-op if unset\n   */\n  addToEnvMaybe<SV extends StringValued>(obj?: SV, overrideValue?: T): SV {\n    const e: any = obj ?? env()\n    // If we don't have a value, let the child take the default, or the\n    // persisted value. This fixes\n    // https://gitlab.com/photostructure/photostructure/issues/202\n    const v = this.envValue ?? overrideValue\n    if (v != null) {\n      e[this.key] = this.opts.toEnv(v)\n    }\n    if (obj == null) {\n      caseInsensitiveEnv.unset()\n    }\n    return e as SV\n  }\n\n  toEnvValue(overrideValue?: T): Maybe<string> {\n    return this.opts.toEnv(overrideValue ?? this.valueOrDefault)\n  }\n\n  addToEnv<SV extends StringValued>(obj?: SV, overrideValue?: T): SV {\n    const e: any = obj ?? env()\n    const value = this.toEnvValue(overrideValue)\n    if (value != null) {\n      e[this.key] = value\n      if (obj == null) {\n        caseInsensitiveEnv.unset()\n      }\n    }\n    return e as SV\n  }\n\n  deleteFromEnv<SV extends StringValued>(obj?: SV): SV {\n    const cie =\n      map(obj, ea => new CaseInsensitiveValued(ea)) ?? caseInsensitiveEnv()\n    for (const ea of [...this.names, ...this.keys]) {\n      cie.delete(ea)\n    }\n    return cie.obj as SV\n  }\n\n  /**\n   * Removes tmp, env, and user-set values\n   */\n  unset() {\n    this.onChange(undefined, () => {\n      this._userValue = undefined\n      this._envValue.unset()\n      this._fileValue = undefined\n      this._tmpValue = undefined\n      this.optsOverrides = {}\n      this.deleteFromEnv()\n    })\n    return this\n  }\n\n  addToJSON(): Obj {\n    return {}\n  }\n\n  toJSON() {\n    return {\n      key: this.key,\n      value: this.value,\n      valueOrDefault: this.valueOrDefault\n    }\n  }\n\n  toCommentedLines() {\n    const title = this.name + \" or \" + this.key\n    const lines = wrap(\n      [\n        padding(\"-\", title.length),\n        title,\n        padding(\"-\", title.length),\n        \"\",\n        ...(this.opts.deprecated === true\n          ? [\n              \"NOTE: this setting has been deprecated and will be removed in a future version of PhotoStructure.\",\n              \"\"\n            ]\n          : []),\n        // make all newlines double-spaced:\n        `${this.opts.description.replace(/\\n+/g, \"\\n\\n\")}`\n      ],\n      WrapComments\n    )\n\n    function maybeAddList(key: string, arr: Maybe<string[]>) {\n      if (!isEmpty(arr)) {\n        lines.push(\n          ...wrap(\n            [\n              \"\",\n              (arr.length === 1 ? key : pluralize(key)) +\n                \": \" +\n                orList(arr.map(ea => stringify(ea)))\n            ],\n            WrapComments\n          )\n        )\n      }\n    }\n    maybeAddList(\"alias\", this.opts.aliases)\n    maybeAddList(\"environment alias\", this.altKeys)\n\n    for (const [key, value] of entries(this.addToJSON())) {\n      const v = Array.isArray(value)\n        ? orList(value.map(ea => stringify(ea)))\n        : stringify(value)\n      lines.push(...wrap([\"\", key + \": \" + v], WrapComments))\n    }\n\n    return lines\n  }\n\n  toEnvLine(value?: T): string {\n    return (\n      this.key +\n      \"=\" +\n      (map(value, ea => this.opts.toEnv(ea)) ?? this.envValueOrDefault)\n    )\n  }\n\n  toTomlLines(): string[] {\n    const lines: string[] = this.toCommentedLines()\n\n    wrapTomlToLines({\n      lines,\n      wrap: WrapComments,\n      key: \"example value\",\n      value: tot(this.exampleValue)\n    })\n\n    wrapTomlToLines({\n      lines,\n      wrap: WrapComments,\n      prepend: [\"Default value:\"],\n      key: this.name,\n      value: tot(this.defaultValue)\n    })\n\n    wrapTomlToLines({\n      lines,\n      key: this.name,\n      value: tot(this.fileValue)\n    })\n\n    return lines\n  }\n}\n","import { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\n\nexport const SettingCategories = strEnum(\n  // System settings:\n  \"Paths\",\n  \"Desktops\",\n  \"Filesystem\",\n  \"Cache\",\n  \"Logging\",\n  \"Networking\",\n  \"Processes\",\n  \"Security\",\n  \"Tools\",\n  // Library settings:\n  \"Auth\",\n  \"Color\",\n  \"Db\",\n  \"Deduping\",\n  \"Events\",\n  \"Filters\",\n  \"HealthChecks\",\n  \"Parsing\",\n  \"Previews\",\n  \"Privacy\",\n  \"Reporting\",\n  \"Sidecars\",\n  \"Subscriptions\",\n  \"Sync\",\n  \"Tagging\",\n  \"Updates\",\n  \"Video\",\n  \"Volumes\",\n  \"Web\"\n)\nexport type SettingCategory = StrEnumKeys<typeof SettingCategories>\n\nexport const LibraryCategories: ReadonlyArray<SettingCategory> = Object.freeze(\n  [\n    // we include reporting in the library because their email won't change\n    SettingCategories.Auth,\n    SettingCategories.Color,\n    SettingCategories.Db,\n    SettingCategories.Deduping,\n    SettingCategories.Events,\n    SettingCategories.Filters,\n    SettingCategories.HealthChecks,\n    SettingCategories.Parsing,\n    SettingCategories.Previews,\n    SettingCategories.Privacy,\n    SettingCategories.Reporting,\n    SettingCategories.Sidecars,\n    SettingCategories.Subscriptions,\n    SettingCategories.Sync,\n    SettingCategories.Tagging,\n    SettingCategories.Updates,\n    SettingCategories.Video,\n    SettingCategories.Volumes,\n    SettingCategories.Web\n  ].sort()\n)\n\n// System is everything not library:\nexport const SystemCategories: ReadonlyArray<SettingCategory> = Object.freeze(\n  SettingCategories.values.filter(ea => !LibraryCategories.includes(ea)).sort()\n)\n","import { BatchClusterOptions } from \"batch-cluster\"\nimport { delimiter } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { diff, uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { FitSizes } from \"../../fe/ImageSizes\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { entries, values } from \"../../fe/Object\"\nimport { strEnum } from \"../../fe/StrEnum\"\nimport { GB, KB, fmtBytes } from \"../../fe/Units\"\nimport { toS } from \"../../fe/toS\"\nimport { CaseInsensitiveMap } from \"../CaseInsensitiveMap\"\nimport { CaseInsensitiveValued } from \"../CaseInsensitiveValued\"\nimport { DefaultSensitiveEnvRegexPattern } from \"../DefaultSensitiveEnvRegexPattern\"\nimport { noColor } from \"../NoColor\"\nimport { isProd as _isProd } from \"../NodeEnv\"\nimport { PriorityClasses } from \"../PriorityClass\"\nimport { DefaultDateTimeFormats } from \"../date/DefaultDateTimeFormats\"\nimport { encodeDuration } from \"../date/DurationCodec\"\nimport { AutoVacuumModes } from \"../db/AutoVacuumModes\"\nimport { CheckpointTypes } from \"../db/CheckpointTypes\"\nimport { RepairModes } from \"../db/RepairModes\"\nimport { SynchronousModes } from \"../db/SynchronousModes\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { HealthCheckIds } from \"../health/HealthCheckIds\"\nimport { CropStrategies } from \"../img/CropStrategies\"\nimport { SharpFailOns } from \"../img/SharpFailOn\"\nimport { isElectron, isLinux, isMac, isWin } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { isRaspberryPi } from \"../platform/isRaspberryPi\"\nimport { DateTagFormats } from \"../tags/DateTagFormats\"\nimport {\n  DefaultCapturedAtTagsConst,\n  ProblematicCapturedAtTags\n} from \"../tags/DefaultCapturedAtTags\"\nimport { DefaultIncludedPreviewTags } from \"../tags/DefaultIncludedPreviewTags\"\nimport { DefaultLensMakes } from \"../tags/DefaultLensMakes\"\nimport { KeywordReparentingStrategies } from \"../tags/KeywordReparentingStrategies\"\nimport { NameTagFormats } from \"../tags/NameTagFormats\"\nimport { NameTagOrders } from \"../tags/NameTagOrders\"\nimport { channel } from \"../version/PhotoStructureVersion\"\nimport { UpdateChannels } from \"../version/UpdateChannels\"\nimport {\n  DefaultExcludedLinuxMountpointNames as DefaultExcludedLinuxMountpointBasenames,\n  DefaultExcludedLinuxMountpointPaths,\n  DefaultExcludedLinuxRoots\n} from \"../volumes/DefaultExcludedLinuxRoots\"\nimport { DefaultExcludedFilesystemTypes } from \"../volumes/DefaultIgnorableFilesystemTypes\"\nimport { HelmetPlugins } from \"../web/HelmetPlugins\"\nimport { cpuCount } from \"../work/CpuInfo\"\nimport { AggregateTypes } from \"./AggregateTypes\"\nimport { AssetFileSortCriteria } from \"./AssetFileSortCriteria\"\nimport { BooleanSetting } from \"./BooleanSetting\"\nimport { BoundedFloatSetting } from \"./BoundedFloatSetting\"\nimport { BoundedIntegerSetting } from \"./BoundedIntegerSetting\"\nimport { ColorDistanceFunctions } from \"./ColorDistanceFunctions\"\nimport { DominantColorKmeansRunsDefault } from \"./DominantColorKmeansRunsDefault\"\nimport { DominantColorPixelsDefault } from \"./DominantColorPixelsDefault\"\nimport { DurationSetting } from \"./DurationSetting\"\nimport { FloatSetting } from \"./FloatSetting\"\nimport { IntegerSetting } from \"./IntegerSetting\"\nimport { MinValidYear } from \"./MinValidYear\"\nimport { OptionalFileSetting } from \"./OptionalFileSetting\"\nimport { OptionalFloatSetting } from \"./OptionalFloatSetting\"\nimport { OptionalIntegerSetting } from \"./OptionalIntegerSetting\"\nimport { OptionalStringSetting } from \"./OptionalStringSetting\"\nimport { Setting } from \"./Setting\"\nimport {\n  LibraryCategories,\n  SettingCategories,\n  SystemCategories\n} from \"./SettingCategory\"\nimport { StringArraySetting } from \"./StringArraySetting\"\nimport { StringEnumSetting } from \"./StringEnumSetting\"\nimport { StringEnumsSetting } from \"./StringEnumsSetting\"\nimport { StringSetting } from \"./StringSetting\"\nimport { TagInferenceSettingValues } from \"./TagInferenceSettingValues\"\nimport { ffmpegScaleTypes } from \"./ffmpegScaleType\"\n\n// lazy so tests can isProd.set() us into production:\nexport const isProd = lazy(() => _isProd)\nconst isTest = () => !isProd()\n\n// WTH, amirite? This lets TypeScript not swoon over the Settings typings.\nfunction exposeNetworkWithoutAuth(): boolean {\n  return Settings.exposeNetworkWithoutAuth.valueOrDefault\n}\n\nexport const DefaultMaxEmbeddedBuffer = 250000\n\nfunction defaultLogLevel() {\n  return isProd() ? \"warn\" : \"info\"\n}\n\n// Most all Setting instances have keys that are prefixed with `PS_`, which let\n// them be used in environment variables without colliding with other\n// environment variables. The `PS_` prefix isn't needed otherwise.\n\n// Only Setting instances should be included in this namespace:\nexport const Settings = {\n  configDir: new OptionalStringSetting({\n    category: SettingCategories.Paths,\n    description: [\n      \"This is the system configuration directory. This can't be overridden in the system settings.toml, as it's used to _find_ the system settings.toml! This setting is here for documentation, and to allow the PS_CONFIG_DIR environment variable to override the default setting.\",\n      \"PhotoStructure's system configuration directory defaults to:\",\n      \"- Windows: %APPDATA%\\\\PhotoStructure (%APPDATA% is normally set to %HOME%/AppData/Roaming)\",\n      \"- macOS: ~/Library/Application Support/PhotoStructure\",\n      \"- Linux: ${XDG_CONFIG_DIR:$HOME/.config}/PhotoStructure.\"\n    ].join(\"\\n\"),\n    defaultValue: () => \"\", // < set by setSettingsDefaults()\n    advanced: () => false,\n    transient: true\n  }),\n\n  libraryDir: new OptionalFileSetting({\n    aliases: [\"libraryPath\", \"library\"],\n    category: SettingCategories.Paths,\n    description:\n      \"This is the absolute path to your PhotoStructure library. If missing, or set to an empty string, the welcome page will be shown when PhotoStructure launches. Use native file separators (so on windows, use back-slashes).\",\n    defaultValue: () => \"\", // < set by setSettingsDefaults()\n    advanced: () => false\n  }),\n\n  copyAssetsToLibrary: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description: `Should PhotoStructure copy photos and videos to your PhotoStructure Library? This setting holds the value for the welcome page's \"May PhotoStructure organize your photos and videos?\" section, and is called \"automatic organization\" on the website.\\nRead more about this setting here: https://photostructure.com/getting-started/automatic-library-organization/ .`,\n    defaultValue: true,\n    advanced: () => false\n  }),\n\n  // todo: add new \"organize\" StringEnumSetting that is \"copy\", \"move\", \"softlink\", \"hardlink\"\n\n  previewsDir: new StringSetting({\n    category: SettingCategories.Paths,\n    description: `This is the directory that PhotoStructure uses to store preview images. This defaults to the \".photostructure/previews\" directory inside your PhotoStructure library. Absolute paths here are supported, but if you keep your library and previews directory separated, take care when you open your library on different computers, as this setting needs to be adjusted for those computers as well.\\nNOTE: \"originalDirs\" is recommended instead of this setting; If you get \"previewsDir\" wrong, your library won't work. If you get \"originalsDir\" wrong, you just break full-screen asset zooming and playback for non-transcoded videos.\\nSee https://forum.photostructure.com/t/hybrid-photostructure-libraries/775 .`,\n    defaultValue: () => \".photostructure/previews\"\n  }),\n\n  originalsDir: new StringSetting({\n    aliases: [\"originalDir\"],\n    category: SettingCategories.Paths,\n    description: `This is the directory that PhotoStructure uses to store original images when \"copyAssetsToLibrary\" is enabled. Absolute paths are supported. Relative paths are evaluated from your libraryDir. This setting defaults to \".\", which is the same as your PhotoStructure library directory, unless you are on docker, and a /ps/originals directory exists.\\nIf you open your PhotoStructure library on a different computer, and that computer doesn't have access to your originals volume, full-screen zoom won't work, and non-transcoded videos will not play.\\nThis system setting needs to be set appropriately on different computers (it won't be set automatically!)\\nIf you have a large library and want to use an SSD, we recommend you set your libraryDir to your SSD, and use this setting to store your originals on a larger volume, rather than using the \"previewsDir\" setting.\\nSee https://forum.photostructure.com/t/hybrid-photostructure-libraries/775 and https://forum.photostructure.com/t/new-easy-mode-for-docker-coming-in-v2-1/1278/6?u=mrm .`,\n    defaultValue: \"\" // < set by setSettingsDefaults()\n  }),\n\n  scanAllDrives: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description:\n      \"Should PhotoStructure scan all folders on all drives available to this computer for photos and videos?\",\n    defaultValue: true,\n    advanced: () => false\n  }),\n\n  /**\n   * @deprecated\n   */\n  scanMyPictures: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description: `If set, PhotoStructure will automatically add your pictures directory to your \"scanPaths\" setting and then flip this setting back to false. Add your Pictures directory directly to your scanPaths setting instead.`,\n    defaultValue: false,\n    deprecated: true\n  }),\n\n  scanPaths: new StringArraySetting({\n    aliases: [\"scanPath\"],\n    category: SettingCategories.Paths,\n    description: `This holds an array of absolute paths to scan for assets. If you are setting this via an environment variable, you may use either standard PATH formatting, like \\`PS_SCAN_PATHS=\"/path/one:/path/two\"\\`, or use JSON encoding, like \\`PS_SCAN_PATHS='[\"/path/one\",\"/path/two\"]'\\`.`,\n    advanced: () => false\n  }),\n\n  argvScanPaths: new StringArraySetting({\n    category: SettingCategories.Paths,\n    description: `This holds an array of absolute paths provided on the command line to import. This overrides \"scanPaths\", and should always be scanned for changes. See https://forum.photostructure.com/t/1597/4 . For internal use only.`,\n    transient: true,\n    advanced: () => true\n  }),\n\n  // TODO:\n\n  // watchPaths: new StringArraySetting({\n  //   aliases: [\"watchPath\"],\n  //   category: SettingCategories.Paths,\n  //   description: `This holds an array of absolute paths to directories that should be watched for changes recursively. Files added, deleted, or updated will be synchronized immediately.`,\n  //   advanced: () => true\n  // }),\n\n  pidFile: new OptionalStringSetting({\n    category: SettingCategories.Paths,\n    envAliases: [\"PIDFILE\"],\n    description:\n      \"This is the absolute path to the PID file for the main process. This is optional and only used by PhotoStructure for Servers. Make sure the UID/GID that PhotoStructure runs as can read and write to this file.\",\n    exampleValue: () => \"/var/run/photostructure.pid\"\n  }),\n\n  cacheDir: new StringSetting({\n    category: SettingCategories.Paths,\n    description:\n      \"Where would you like PhotoStructure's scratch file directory? This must be a fast, local disk with several gigabytes free.\\nNote that if PS_FORCE_LOCAL_DB_REPLICA is enabled, the local DB replica will be stored in this directory while PhotoStructure is running: don't delete it!\\nIf this is set to /tmp PhotoStructure will write to a user-specific /tmp/.photostructure-cache-$UID directory.\",\n    defaultValue: () => \"\" // < set by setSettingsDefaults()\n  }),\n\n  //\n  // Cache\n  //\n\n  fsCacheSlowMs: new DurationSetting({\n    category: SettingCategories.Cache,\n    description: `If a cache entry takes longer than this value to compute, cache results for later reuse to the filesystem.\\nThe default is very short, under the assumption that cache filesystem read/writes are <10ms.\\nSet this to 0 to never cache to the filesystem.`,\n    defaultValue: () => (isTest() ? \"1\" : \"25\")\n  }),\n\n  imageCacheMs: new DurationSetting({\n    category: SettingCategories.Cache,\n    description:\n      \"Assets requiring conversion may need intermediary file storage as they are imported. These intermediary files only need to live as long as the import process for that asset. Too short of a time will result in this conversion work being re-done during import. Too long of a time will result in additional diskspace in your cache directory being consumed.\",\n    defaultValue: \"15m\"\n  }),\n\n  readdirCacheMs: new DurationSetting({\n    category: SettingCategories.Cache,\n    description:\n      \"readdir() can take a long time over slow network shares and when directories are very large. This setting controls how long to cache readdir results that are slow (which take >= .5 seconds). Too short of a time will result in low cache hit rates, and very slow imports for these problematic directories. Too long of a time will result in PhotoStructure not seeing changes made to these directories.\\nSet to 0 to disable readdir() caching.\",\n    defaultValue: \"5m\"\n  }),\n\n  readdirSizeCacheThresh: new IntegerSetting({\n    category: SettingCategories.Cache,\n    description: `If readdir() has more than this number of child elements, always cache it.\\nSet to 0 to disable readdir() caching.`,\n    defaultValue: () => (isTest() ? 32 : 1024)\n  }),\n\n  //\n  // LOGGING\n  //\n\n  quiet: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"If true, the main service won't emit lifecycle messages to stdout. Note that logStdout=true or logTail=true will override quiet=true.\",\n    defaultValue: false\n  }),\n\n  logLevel: new StringSetting({\n    envAliases: [\"PS_LOG\", \"LOG\", \"LOG_LEVEL\"],\n    category: SettingCategories.Logging,\n    description: `Determines which level of log messages are emitted to log files. May be \"debug\", \"info\", \"warn\", \"error\", \"fatal\", or several log level directives followed by a context (like \"debug:web\").`,\n    defaultValue: defaultLogLevel\n  }),\n\n  logDir: new StringSetting({\n    category: SettingCategories.Logging,\n    description: \"Determines the directory that log files will be written to.\",\n    defaultValue: () => \"\" // < set by setSettingsDefaults()\n  }),\n\n  logCompression: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description: \"Should log files be compressed as they are rotated?\",\n    defaultValue: () => isProd() // don't compress in test or dev so logtail is happy\n  }),\n\n  logWebRequests: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description: \"Write an access log for all web requests?\",\n    defaultValue: false\n  }),\n\n  logWebDir: new OptionalStringSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"Determines the directory that log files will be written to. If unset, will use logDir.\"\n  }),\n\n  logStdout: new BooleanSetting({\n    envAliases: [\"LOG_STDOUT\", \"PS_STDOUT\"],\n    category: SettingCategories.Logging,\n    description:\n      \"Log to stdout? This should be false unless you're running a service by hand.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  tailLogs: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"Output all logs from currently running PhotoStructure processes? This should be false unless you're running a service by hand.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  logColor: new BooleanSetting({\n    // we can't alias NO_COLOR, because according to no-color.org, it's true if\n    // it has _any_ value\n    category: SettingCategories.Logging,\n    description:\n      \"Output all logs with terminal escape codes to colorize output. If NO_COLOR=1 or TERM=dumb or TERM=unknown, this defaults to false. See https://no-color.org/ .\",\n    defaultValue: () => !noColor()\n  }),\n\n  logContextLimit: new IntegerSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"PhotoStructure will only log, at most, this number of elements or key/value pairs.\",\n    defaultValue: () => 64\n  }),\n\n  logSql: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"Log SQL queries to the default log level. **Enabling this negatively impacts performance.**.\\nThis defaults to false.\",\n    defaultValue: () => false\n  }),\n\n  logServer: new OptionalStringSetting({\n    category: SettingCategories.Logging,\n    description: `Format as hostname:port or ip_address:port.\\nIf set, processes will emit log entries, formatted as GELF and separated by null bytes, via TCP.\\nIf this is set, the default PS_LOG_LEVEL drops from \"error\" to \"info\".\\nSee https://docs.greylog.org/v1/docs/gelf .`,\n    exampleValue: () => \"localhost:12201\"\n  }),\n\n  logServerLevel: new StringSetting({\n    category: SettingCategories.Logging,\n    description: `This is the log level used to filter logs before sending them to \"PS_LOG_SERVER\".\\nIf unset, we'll use the value of \"PS_LOG_LEVEL\".`,\n    defaultValue: defaultLogLevel // < this is fixed by setSettingsDefault in SettingsDefaults.ts, as we can't reference ourself here.\n  }),\n\n  //\n  // Filesystem\n  //\n\n  useFsWatch: new BooleanSetting({\n    category: SettingCategories.Filesystem,\n    description: `If true, PhotoStructure will use the native filesystem watch APIs to detect file changes. This is the default and recommended setting. If false, PhotoStructure will poll the filesystem for changes instead. This is not recommended, but may be useful if you're running PhotoStructure on an OS or filesystem that doesn't support change notifications, like some network filesystems.\\nSee https://nodejs.org/api/fs.html#availability for more information.`,\n    defaultValue: () => true\n  }),\n\n  allowFilesystemSleep: new BooleanSetting({\n    category: SettingCategories.Filesystem,\n    description: `If true, PhotoStructure will set disable a handful of other settings which will allow the OS to put the filesystem to sleep when it's idle. This can save power, but can also cause PhotoStructure to miss file changes.\\nThis sets sharedStatePollMs=0 and dbFsLockStaleMs=0.`,\n    defaultValue: () => false\n  }),\n\n  statTimeoutMs: new DurationSetting({\n    category: SettingCategories.Filesystem,\n    description: `Filesystem traversal can be dangerous business with scratched CDROMs and old busted hard drives. To prevent PhotoStructure from getting \"stuck\" when trying to read these devices, it will timeout directory iteration if stat() or readdir() exceeds this value. The default of 30 seconds should cover most issues with spun-down hard drives and NAS/WAN latency.`,\n    defaultValue: () => \"30s\"\n  }),\n\n  watchDebounceMs: new DurationSetting({\n    category: SettingCategories.Filesystem,\n    description: `How long to wait for a file to \"settle down\" and stop changing before the file watcher notifies listeners that the file changed. Some applications (like PhotoStructure) use work-in-progress \"atomic\" writes, but many applications overwrite in-place, which can cause the file watcher to see incomplete results until the write process is complete.\\nThe default is 500ms (½ second) to handle slow remote NASes and slow-writing applications.\\nSet to 0 to disable.`,\n    defaultValue: () => \"500ms\"\n  }),\n\n  excludedFilesystemTypes: new StringArraySetting({\n    aliases: [\"ignoredFilesystemTypes\"],\n    category: SettingCategories.Filesystem,\n    description:\n      \"Volumes with these filesystem types will never be scanned or imported.\\nThese are only relevant to Linux and macOS systems.\",\n    defaultValue: () => DefaultExcludedFilesystemTypes\n  }),\n\n  excludedRootDirectories: new StringArraySetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"PhotoStructure won't descend into these root directories looking for assets.\",\n    defaultValue: () => DefaultExcludedLinuxRoots\n  }),\n\n  excludedMountpointPaths: new StringArraySetting({\n    aliases: [\"ignoredMountpoints\"],\n    category: SettingCategories.Filesystem,\n    description:\n      \"PhotoStructure won't descend into mountpoints that match these paths.\",\n    defaultValue: () => DefaultExcludedLinuxMountpointPaths\n  }),\n\n  excludedMountpointBasenames: new StringArraySetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"PhotoStructure won't descend into mountpoints that match these names.\",\n    defaultValue: () => DefaultExcludedLinuxMountpointBasenames\n  }),\n\n  validateMountpoints: new BooleanSetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"When true, PhotoStructure ignores volumes whose mountpoints do not exist. If any volumes are unhealthy, though, this may wedge volume handlers.\",\n    defaultValue: true\n  }),\n\n  mountpoints: new StringArraySetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"If set, this value will be used instead of the cross-platform mountpoints() method. Normally only for internal use.\"\n  }),\n\n  mountpointsTtlMs: new DurationSetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"How frequently should PhotoStructure scan for new volumes (so PhotoStructure can detect when drives are inserted or ejected)? Shorter than 10-15 seconds may cause issues on Windows. A value of 0 will cache indefinitely. This defaults to 15 minutes on Windows, which relies on polling. On Linux and macOS this is set to 0 because findmnt/gio and diskutil notify mountpoint changes without polling.\",\n    defaultValue: () => (isWin ? \"15m\" : \"0\") // docker should definitely be 0\n  }),\n\n  remoteFilesystemTypes: new StringArraySetting({\n    category: SettingCategories.Filesystem,\n    description: `Filesystems with these types should always be considered \"remote\".`,\n    defaultValue: [\"sshfs\", \"s3fs\"]\n  }),\n\n  retainFileBirthtimes: new BooleanSetting({\n    category: SettingCategories.Filesystem,\n    description: `Should PhotoStructure try to retain file \"birth\" times (also known as \"creation\" times) when it copies files? If enabled, note that this is a best-effort approach--Linux and some remote filesystems (like SMB) do not support this feature.`,\n    defaultValue: () => true\n  }),\n\n  //\n  // Volumes\n  //\n\n  volumeUuidFilePaths: new StringArraySetting({\n    category: SettingCategories.Volumes,\n    description:\n      'PhotoStructure will append these paths to all mountpoints to look for previously-set volume universally unique identifiers (UUIDs). The first item in this list that exists will be used, and if \"writeVolumeUuidFiles\" is true, the first item in this list will be used to write the volume UUID (which will be the partition UUID, if available, or a random UUID if not available). Windows users should use a forward slash as a path separator.',\n    defaultValue: () => [\".uuid\", \"System Volume Information/IndexerVolumeGuid\"]\n  }),\n\n  readVolumeUuidFiles: new BooleanSetting({\n    category: SettingCategories.Volumes,\n    description: `When true, PhotoStructure uses \".uuid\" files found in the root directory of volumes as the volume universally unique identifier (UUID), which supports cross-host and cross-OS library portability. Set this to false if you don't want PhotoStructure to read these \".uuid\" files.\\nNote that \"globally unique identifier,\" or \"GUID,\" is synonymous with \"UUID\" in this case. Microsoft tends to use the term \"GUID\" instead of \"UUID.\"\\nSee https://photostructure.com/faq/what-is-a-volume for more information.`,\n    defaultValue: true\n  }),\n\n  writeVolumeUuidFiles: new BooleanSetting({\n    category: SettingCategories.Volumes,\n    description: `When true, PhotoStructure (tries to) write files with universally unique identifiers into the root directory of volumes, which enables cross-host library portability. Set this to false if you don't want PhotoStructure to try to write these \".uuid\" files. See https://photostructure.com/faq/what-is-a-volume for more information.`,\n    defaultValue: true\n  }),\n\n  writeVolumeUuidMountpointBlocklist: new StringArraySetting({\n    category: SettingCategories.Volumes,\n    description: `Never try to write a volume UUID file to these directories.`,\n    defaultValue: [\"sshfs\", \"s3fs\"]\n  }),\n\n  volumeMetadataTtlMs: new DurationSetting({\n    category: SettingCategories.Filesystem,\n    description:\n      \"How frequently should PhotoStructure reload volume metadata (like bytes-free, which is used in a health check)? Values less than a minute are not necessary. A value of 0 will cache indefinitely.\",\n    defaultValue: \"15m\"\n  }),\n\n  //\n  // Networking\n  //\n\n  hostname: new OptionalStringSetting({\n    category: SettingCategories.Networking,\n    description:\n      \"If set, this overrides the local hostname. Useful under docker and when OSes change hostnames due to networking bugs (see macOS).\"\n  }),\n\n  localhost: new StringSetting({\n    category: SettingCategories.Networking,\n    description: `If \"exposeNetworkWithoutAuth\" is false, what value should PhotoStructure use for localhost? (Some firewalls are OK with \"127.0.0.1\", some require \"localhost\"). See https://letsencrypt.org/docs/certificates-for-localhost/ and https://photostructure.com/faq/troubleshooting/#windows-firewall-issues .`,\n    // See https://letsencrypt.org/docs/certificates-for-localhost/\n    // and https://tools.ietf.org/html/draft-ietf-dnsop-let-localhost-be-localhost-02\n    defaultValue: () => \"127.0.0.1\"\n  }),\n\n  httpPort: new IntegerSetting({\n    category: SettingCategories.Networking,\n    description: \"Network port for HTTP access to your PhotoStructure library.\",\n    defaultValue: 1787\n  }),\n\n  // TODO\n  // syncRpcPort: new IntegerSetting({\n  //   category: SettingCategories.Networking,\n  //   description: \"Localhost-bound port for sync to report status to web.\",\n  //   defaultValue: 1789\n  // }),\n\n  //\n  // Security\n  //\n\n  trustProxy: new StringSetting({\n    category: SettingCategories.Security,\n    description: `What reverse proxies should PhotoStructure \"trust\"? See <http://expressjs.com/en/guide/behind-proxies.html>.\\nThis setting should either be \"false\" (don't trust any proxies), \"loopback\", (only trust loopback/localhost), a single subnet (like \"192.168.1.0/24\"), or a comma-delimited set of subnets.`,\n    defaultValue: \"loopback\"\n  }),\n\n  exposeNetworkWithoutAuth: new BooleanSetting({\n    category: SettingCategories.Security,\n    description:\n      \"Normally the web service is only accessible to the computer running PhotoStructure. Setting this to true will expose your library to all computers on your network. You should own or trust all systems on that network, as there is no auth in PhotoStructure currently. Future versions of PhotoStructure will add authorization mechanisms, at which point this setting will be deleted.\\n**Don't enable this unless you know what you are doing**.\",\n    defaultValue: () => isDocker()\n  }),\n\n  cspReportOnly: new BooleanSetting({\n    category: SettingCategories.Security,\n    description:\n      \"DANGEROUS: do not enforce, and only report CSP violations. This should only be set to true temporarily to assist in debugging. See https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP .\",\n    defaultValue: () => false\n  }),\n\n  upgradeInsecureRequests: new BooleanSetting({\n    category: SettingCategories.Security,\n    description: `May PhotoStructure send the Upgrade-Insecure-Requests header? PhotoStructure will set the default to true automatically if it sees _any_ request is via https.\\nSet this explicitly to false if you access PhotoStructure via both http (inside your LAN) and https (outside your LAN).`,\n    defaultValue: () => false\n  }),\n\n  cspDirective: new OptionalStringSetting({\n    category: SettingCategories.Security,\n    description:\n      \"If you're seeing CSP errors with older browsers, add your externally-available base URL to this setting, and it will be appended to the CSP directives. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src .\",\n    exampleValue: () => \"https://myphotos.example.com\"\n  }),\n\n  disabledHelmetMiddleware: new StringEnumsSetting({\n    category: SettingCategories.Security,\n    description: `What Helmet middleware should PhotoStructure disable?\\nBy default, PhotoStructure enables all middleware, but if your reverse proxy is handling HTTP headers, you may want to remove some of Helmet's functionality.\\nDisable all middleware by using the value \"all\", but know that CSP management is handled by the \"cspDirective\" and \"cspReportOnly\" settings.\\nSee https://github.com/helmetjs/helmet#reference .`,\n    defaultValue: [],\n    strEnum: HelmetPlugins\n  }),\n\n  //\n  // Process management\n  //\n\n  // TODO:\n  // webProcs: new BoundedIntegerSetting({\n  //   category: SettingCategories.Processes,\n  //   description:\n  //     \"How many webservers should PhotoStructure spin up?\",\n  //   min: 1,\n  //   max: 8,\n  //   defaultValue: () => isTest() ? 2 : cpuInfo().length < 4 ? 1 : 2\n  // }),\n\n  shortProcessNames: new BooleanSetting({\n    category: SettingCategories.Processes,\n    description: `Should PhotoStructure name its own processes \"PhotoStructure\" + the name of the sub-process, or abbreviated \"phstr\"? This defaults to false on PhotoStructure for Desktops and true everywhere else.`,\n    defaultValue: () => !isElectron\n  }),\n\n  commandTimeoutMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"How long should PhotoStructure wait for a command that touches the filesystem (and doesn't do anything computationally expensive)? Note that external hard drives can take 10-15 seconds to spin up, and antivirus apps can hang for tens of seconds on slow machines, so values less than the default may result in undesired timeouts.\",\n    // There were filesystem timeout errors with 25 seconds:\n    defaultValue: () => \"24s\"\n  }),\n\n  minDelayBetweenSpawnMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"minDelayBetweenSpawnMillis\"],\n    description:\n      \"The shorter this time is, the faster PhotoStructure will ramp up parallelism at the start of a sync. Having a larger value here mitigates initial system load from forking. See https://photostructure.github.io/batch-cluster.js/classes/BatchClusterOptions.html#minDelayBetweenSpawnMillis .\",\n    defaultValue: () =>\n      encodeDuration(new BatchClusterOptions().minDelayBetweenSpawnMillis)!\n  }),\n\n  minDelayBetweenRetriesMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"minDelayBetweenSpawnMillis\"],\n    description:\n      \"If a task has an error, should we wait a bit before retrying? This may help temper error cascades.\",\n    defaultValue: () => \"250ms\"\n  }),\n\n  maxRetries: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"If a task has an error, how many times should we retry before giving up?\\nIf you have a flaky network, this can help ensure imports are comprehensive.\\nSet this to 0 to disable retries.\",\n    defaultValue: () => 1\n  }),\n\n  streamFlushMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"streamFlushMillis\"],\n    description:\n      \"See https://photostructure.github.io/batch-cluster.js/classes/BatchClusterOptions.html#streamFlushMillis .\",\n    defaultValue: () => (isMac ? \"100ms\" : isWin ? \"200ms\" : \"30ms\")\n  }),\n\n  exiftoolProcsPerChild: new OptionalIntegerSetting({\n    category: SettingCategories.Processes,\n    description: `Each PhotoStructure process spins up an ExifTool when needed. Note that the \"web\" and \"sync\" services use exiftool, so the total number of exiftool processes will be several times larger than this value. If this is unset, this will default to roughly 50% of the number of supported concurrent imports.`\n  }),\n\n  sensitiveEnvRegExp: new StringSetting({\n    category: SettingCategories.Processes,\n    description: `PhotoStructure spawns several external processes, including \"exiftool\" and \"ffmpeg\".\\nPhotoStructure filters out environment keys  that are likely to contain sensitive information (like API access tokens or passwords) from these child processes so they aren't accidentally logged or accessible by external tools.\\nThis regex is applied case-insensitively.`,\n    defaultValue: () => DefaultSensitiveEnvRegexPattern\n  }),\n\n  syncExitTimeoutMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    description: `Wait at most this time for sync to shut down cleanly. This needs to be long enough to possibly copy the library database back to the remote filesystem if your library is stored on a network drive. Set to 0 to disable this timeout.`,\n    defaultValue: \"2m\"\n  }),\n\n  // TODO: delete this #smpfy\n  probationMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"Normally when subsystems crash, PhotoStructure restarts them after a delay. Unfortunately, if there is a persistent error, this means PhotoStructure keeps trying something that won't ever work; it looks busy, but it's just busy failing. To prevent this situation, PhotoStructure will shut down if there are high error rates within 2 minutes of starting. (2 minutes should be long enough to spin up the web process, sync process, and import at least one pending file). Setting this to 0 will prevent PhotoStructure from exiting due to high error rates.\",\n    defaultValue: \"2m\"\n  }),\n\n  minTimeBetweenServiceRestartsMs: new DurationSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"If a service (like web or sync) is restarted due to an error, how many milliseconds must elapse before another restart is allowed? This helps prevent system load due to service flapping.\",\n    defaultValue: \"7s\"\n  }),\n\n  fatalErrorRatePerMinute: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"If PhotoStructure sees errors at a higher rate per minute than this setting, PhotoStructure will shut down. If this value is too high, PhotoStructure may look busy, but it's just busy failing. If this value is set too low, temporary errors (due to network flakiness or USB hiccups) might shut down PhotoStructure needlessly.\",\n    defaultValue: 20\n  }),\n\n  minDiskFreeGb: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure will pause processing if the GB free on the disk that your library is stored on drops below this value. The value provided here will be multiplied by 1000^3. Note that many OSes will corrupt themselves when disks fill up, and SSDs can fail as they approach full capacity. A value of less than 8 may be unsafe (due to hibernation and OS update files).\\nSet this value to 0 to disable free disk space health checks.\",\n    defaultValue: 16\n  }),\n\n  cpuBusyPercent: new BoundedIntegerSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"cpuLoadPercent\"],\n    description: `This setting is a rough goal for PhotoStructure to load the system during library synchronization. A higher value here will allow PhotoStructure to run more tasks in parallel, but may impact your system's responsiveness.\\nUnder normal circumstances, setting this to any value over 100 will result in full CPU saturation, and is not recommended, as it will cause spurious timeouts leading to some percentage of failed imports.\\nWhile syncing, PhotoStructure will not dequeue sync file jobs if the current system busy percent exceeds this value.\\nSetting this value to 0 will run the sync process in \"single-process mode\"--no external worker processes will be spun up by the \"sync\" process, and file imports will be done serially.`,\n    defaultValue: 75,\n    min: 0,\n    max: 500 // the very high in case cpu count is borked on some hardware and the user really wants to get work done\n  }),\n\n  timeoutThrottleCoeff: new FloatSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"When timeouts are detected, PhotoStructure throttles back concurrency automatically, with the assumption that some system is currently being overwhelmed and that less load should result in fewer failures due to timeouts.\\nSpecifically, concurrency will be set to 1 / current rate of timeouts per minute over the past several minutes.\\nThrottling will be more aggressive as this value approaches 0. For example a value of 0.1 will be very aggressive throttling. A value of 8 will only slow down sync after many soft timeouts.\\nDisable throttling by setting to 0.\",\n    defaultValue: 1\n  }),\n\n  maxConcurrentImports: new OptionalIntegerSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"maxSyncFileJobs\"],\n    advanced: () => true,\n    description: `How many imports can PhotoStructure schedule concurrently? This will be clamped between 1 and 32.\\nIf not set, a sensible value will be computed based on \"cpuLoadPercent\".\\nIf set explicitly, this and \"sharpThreadsPerProcess\" will override \"cpuLoadPercent\" and \"maxConcurrentImportsWhenRemote\" settings.`\n  }),\n\n  maxConcurrentImportsWhenRemote: new IntegerSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"maxSyncFileJobsWhenRemote\"],\n    description: `How many concurrent files can be imported if the library is on a remote volume? This defaults to 2 to try to avoid overwhelming HDD I/O on the remote NAS. If this is larger than (cpus.length * cpuLoadPercent) or max child processes given available memory, this value will be ignored.`,\n    defaultValue: 2\n  }),\n\n  sharpThreadsPerProcess: new BoundedIntegerSetting({\n    category: SettingCategories.Processes,\n    aliases: [\"sharpThreadsPerJob\"],\n    advanced: () => true,\n    description: `How many image processing threads can be spun per process?\\nIf set to 0 (the default), PhotoStructure will pick an optimal value based on available memory and CPU cores.`,\n    min: 0,\n    max: 8, // we don't get faster throughput with > 8 gfx threads\n    defaultValue: 0\n  }),\n\n  processPriority: new StringEnumSetting({\n    category: SettingCategories.Processes,\n    description: `By default, PhotoStructure runs child processes with a \"below normal\" priority, so your system remains usable while imports run. Changing this value to \"normal\" or \"above normal\" may speed up imports but cause your system to be unresponsive. Changing this value to \"idle\" may prevent imports from running at all.\\nFor Linux and macOS systems, see https://en.wikipedia.org/wiki/Nice_%28Unix%29 .\\nFor Windows, see https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.processpriorityclass?view=netframework-4.8 .`,\n    defaultValue: () => PriorityClasses.BelowNormal,\n    strEnum: PriorityClasses\n  }),\n\n  maxMemoryMb: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure will restart services if they use more than this value (measured in megabytes, or 1,000,000 bytes). Note that this is not the allocated memory. See maxRssMemoryMb for total allocated.\\nSet to 0 to deactivate this check.\",\n    defaultValue: () => 2048\n  }),\n\n  maxTasksPerProcess: new BoundedIntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure will recycle threads and worker processes after they handle this number of requests. Smaller values may reduce overall memory pressure. Larger values amortize startup costs over fewer restarts.\",\n    defaultValue: () => (isTest() ? 50 : 500),\n    min: 1,\n    max: 5000\n  }),\n\n  //\n  // Auth\n  //\n\n  enableArchive: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, the \"Archive\" button in Asset views will be visible and enabled for all visitors.`,\n    defaultValue: () => true\n  }),\n\n  enableDelete: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, the \"Delete\" button in Asset views will be visible and enabled for all visitors.\\nThis is a temporary setting until PhotoStructure enforces authentication/authorization.`,\n    defaultValue: () => true\n  }),\n\n  enableEmptyTrash: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, the \"Empty Trash\" button will be enabled for all visitors.\\nUntil PhotoStructure has visitor user levels, if you don't trust all your users, disable this!\\nThis setting is disabled by default if exposeNetworkWithoutAuth is true.\\nThis is a temporary setting until PhotoStructure enforces authentication/authorization.`,\n    defaultValue: () => !exposeNetworkWithoutAuth()\n  }),\n\n  enableRemove: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, the \"Remove asset\" button in Asset views will be visible and enabled for all visitors.\\nThis is a temporary setting until PhotoStructure enforces authentication/authorization.`,\n    defaultValue: () => true\n  }),\n\n  enableRemoveAssets: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, the \"Remove Assets\" buttons will be visible and enabled for all visitors.\\nUntil PhotoStructure has visitor user levels, if you don't trust all your users, disable this!\\nThis setting is disabled by default if exposeNetworkWithoutAuth is true.\\nThis is a temporary setting until PhotoStructure enforces authentication/authorization.`,\n    defaultValue: () => !exposeNetworkWithoutAuth()\n  }),\n\n  argon2TimeCost: new IntegerSetting({\n    category: SettingCategories.Auth,\n    description: `PhotoStructure encrypts user passwords with Argon2. This value sets the Argon2 \"time\" cost parameter.`,\n    // NOTE! Keep in sync with MetaSettings.setQuickSyncMode:\n    defaultValue: 8\n  }),\n\n  argon2MemoryCostMB: new IntegerSetting({\n    category: SettingCategories.Auth,\n    description: `PhotoStructure encrypts user passwords with Argon2. This value sets the Argon2 \"memory\" cost parameter, and is specified in megabytes. Each parallel thread will consume this amount of RAM: don't exceed your system memory.`,\n    // NOTE! Keep in sync with MetaSettings.setQuickSyncMode:\n    defaultValue: 64\n  }),\n\n  argon2Parallelism: new IntegerSetting({\n    category: SettingCategories.Auth,\n    description: `PhotoStructure encrypts user passwords with Argon2. This value sets the Argon2 \"parallelism\" parameter. RAM consumption will be ((this value) × argon2MemoryCost) KB of RAM: don't exceed your system memory.`,\n    // NOTE! Keep in sync with MetaSettings.setQuickSyncMode:\n    defaultValue: 1\n  }),\n\n  //\n  // DB\n  //\n\n  // Use primary/replica terminology:\n\n  forceLocalDbReplica: new BooleanSetting({\n    category: SettingCategories.Paths, // NOT .Db! The location may be local or remote depending on configuration.\n    description:\n      \"Libraries on remote filesystems can suffer from bad performance and inconsistent transactions due to slow file I/O and missing file locking mechanics. When opening libraries on remote filesystems, or if this setting is `true`, PhotoStructure will copy the library database to the `cacheDir` and perform I/O against this local replica. Changes made to the local db replica are then periodically copied back to the remote library.\\nIf you've overridden this value in the past, know that v23.5 and after should automatically set this to the correct value for you.\\nFor more details, see https://forum.photostructure.com/t/whats-force-local-db-replica/837 and https://photostructure.com/about/2023-release-notes/#-sqlite-improvements .\",\n    defaultValue: () => false\n  }),\n  dbRetries: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"If SQLITE_BUSY is encountered, how many times should an operation be retried before giving up?\",\n    advanced: () => true,\n    defaultValue: 20\n  }),\n\n  // From https://sqlite.org/pragma.html#pragma_optimize\n\n  // \"Long-running applications might also benefit from setting a timer to run\n  // \"PRAGMA optimize\" every few hours.\"\n\n  dbBackupRetentionCount: new BoundedIntegerSetting({\n    aliases: [\"dbBackupsCount\"],\n    category: SettingCategories.Db,\n    description:\n      \"How many prior backups should PhotoStructure retain? These will typically be 10-500 MB, depending on the size of your library.\\nWe don't retain that many backups by default because they get stale pretty quickly, as they fall out of sync with your filesystem and previews directory contents.\",\n    advanced: () => true,\n    defaultValue: 3,\n    max: 128,\n    min: 1\n  }),\n\n  dbAutoVacuumMode: new StringEnumSetting({\n    category: SettingCategories.Db,\n    description:\n      \"SQLite can auto-vacuum your library database, which ensures the database stays performant. If this is set to NONE, PhotoStructure will periodically run vacuum and optimizations from the sync process. For details, https://sqlite.org/pragma.html#pragma_auto_vacuum .\",\n    advanced: () => true,\n    strEnum: AutoVacuumModes,\n    defaultValue: AutoVacuumModes.INCREMENTAL\n  }),\n\n  dbWalCheckpointType: new StringEnumSetting({\n    category: SettingCategories.Db,\n    description:\n      \"The write-ahead log of your PhotoStructure library database is checkpointed periodically.\\n- Choosing 0 will disable SQLite's built-in automatic PASSIVE checkpointing.\\n- PASSIVE, FULL, RESTART, and TRUNCATE values will enable.\\nSee https://sqlite.org/pragma.html#pragma_wal_checkpoint .\",\n    strEnum: CheckpointTypes,\n    defaultValue: CheckpointTypes.TRUNCATE\n  }),\n\n  dbWalAutoCheckpoint: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"The write-ahead log of your PhotoStructure library database is checkpointed periodically by the sync subprocess.\\n- Choosing 0 will disable SQLite's built-in automatic PASSIVE checkpointing.\\nSee https://sqlite.org/pragma.html#pragma_wal_autocheckpoint .\",\n    defaultValue: 1000\n  }),\n\n  dbInvalidFKThreshold: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"When PhotoStructure runs a database recovery, it will check for foreign key violations. If there are fewer than this number of invalid rows, PhotoStructure will drop those rows, with the hope that the next sync will finish the recovery.\\nSet this to 0 to disable this recovery step, which will make any foreign key violation fatal.\",\n    defaultValue: 64\n  }),\n\n  dbSynchronousMode: new StringEnumSetting({\n    category: SettingCategories.Db,\n    description: `Change SQLite's synchronous mode.\\n\"OFF\" will cause data corruption. \"FULL\" and \"EXTRA\" may be required if you're seeing dataloss.\\nSee https://sqlite.org/pragma.html#pragma_synchronous .`,\n    strEnum: SynchronousModes,\n    defaultValue: SynchronousModes.NORMAL\n  }),\n\n  dbRepairMode: new StringEnumSetting({\n    category: SettingCategories.Db,\n    description: `PhotoStructure will automatically attempt to repair library databases that don't pass validation tests. SQLite has two repair strategies:\\n- \"dump\", which will recover from minor errors and normally retains the current schema\\n- \"recover\", which will recover as much data as possible from corrupt db. Unfortunately, this can result in an invalid and unusable schema, which is why PhotoStructure defaults to \"dump\".\\nNote that PhotoStructure validates the schema after a repair, and will report via logs and the health check system if there are any issues.`,\n    strEnum: RepairModes,\n    defaultValue: RepairModes.dump\n  }),\n\n  maxBusyDbMs: new DurationSetting({\n    category: SettingCategories.Db,\n    description:\n      \"SQLite supports concurrent readers but concurrent writers may collide, causing a LOCKED or BUSY error. PhotoStructure will retry the db operation for maxBusyDbMs milliseconds. This defaults to 45 seconds to accommodate slow hard drive spinups and VACUUM write locks.\",\n    advanced: () => true,\n    defaultValue: () => \"45s\"\n  }),\n\n  dbBusyTimeoutMs: new DurationSetting({\n    category: SettingCategories.Db,\n    description:\n      \"SQLite can time out requests if the db file is unavailable. PhotoStructure will retry those requests (up to `maxBusyDbMs`). A shorter time may help overall throughput, but may require more work done in retry logic. A longer time may be better for slower machines and slower disks. Note that setting this value to be lower than disk I/O latency (~1ms-100ms) will cause all database queries to fail.\",\n    advanced: () => true,\n    defaultValue: () => \"2s\"\n  }),\n\n  dbBackupIntervalMs: new DurationSetting({\n    category: SettingCategories.Db,\n    description:\n      \"How frequently should PhotoStructure backup your library database?\",\n    advanced: () => true,\n    defaultValue: () => (isTest() ? \"15s\" : \"30m\")\n  }),\n\n  // We're using a bounded float so we can get fractional minutes for test, and\n  // users don't have to think in milliseconds.\n  dbBackupIntervalMinutes: new BoundedFloatSetting({\n    category: SettingCategories.Db,\n    description: `This setting was replaced by \"dbBackupIntervalMs\".`,\n    min: isTest() ? 0.5 : 1, // < force a backup in the middle of the SyncService and ModelDbUpdater tests to exercise pause-for-vacuum\n    max: 60 * 24,\n    advanced: () => true,\n    defaultValue: () => (isTest() ? 0.5 : 30)\n  }),\n\n  dbPageSizeBytes: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"This value will be used for SQLite's page_size PRAGMA. A default of 4k should be OK. This must be a power of 2. See https://sqlite.org/pragma.html#pragma_page_size for more information.\",\n    advanced: () => true,\n    defaultValue: 4096\n  }),\n\n  dbCacheSizeMb: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"This value will be used for SQLite's cache_size PRAGMA. The cache_size pragma should ideally be set such that the whole DB can be in memory. Note that PhotoStructure automatically increases this value to accommodate your library as it gets larger, if there is sufficient memory, so this setting is only a lower bound. See https://sqlite.org/pragma.html#pragma_cache_size for more information.\",\n    advanced: () => true,\n    defaultValue: 128\n  }),\n\n  dbBatchSelectSize: new BoundedIntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"How many objects can be selected at at time? The default should be fine. (Exposed for performance tests).\",\n    advanced: () => true,\n    defaultValue: 128,\n    min: 1,\n    max: 900\n  }),\n\n  dbBatchUpsertSize: new BoundedIntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"How many objects can be upserted at at time? The default should be fine. (Exposed for performance tests).\",\n    advanced: () => true,\n    defaultValue: 16,\n    min: 1,\n    max: 500\n  }),\n\n  dbForceRecover: new BooleanSetting({\n    category: SettingCategories.Db,\n    aliases: [\"dbForceRebuild\"],\n    transient: true,\n    description:\n      \"SQLite databases can sometimes be repaired with SQLite's .recover tooling. Set this to true to have PhotoStructure attempt a .recover on startup.\\nThis can take a while to perform, especially on large libraries or slow computers: don't set this value to true normally.\\nSee https://sqlite.org/recovery.html .\",\n    defaultValue: () => false\n  }),\n\n  dbBackupRemoteOnSuspend: new BooleanSetting({\n    aliases: [\"backupRemoteDbOnSuspend\"],\n    category: SettingCategories.Db,\n    description:\n      \"Run a database backup when system suspend is requested and the database is on a remote volume.\",\n    defaultValue: () => true\n  }),\n\n  // dbFtsTokenizer: new StringSetting({\n  //   category: SettingCategories.Db,\n  //   description: `PhotoStructure uses SQLite's full-text search index to support queries. The value provided here will be fed to the \"tokenize\" option. You may want to try the new \"trigram\" tokenizer, if you want substring tag path matches. Restart PhotoStructure to make this take affect.`,\n  //   defaultValue: \"unicode61\"\n  // }),\n\n  //\n  // Files\n  //\n\n  trySoftDeletes: new BooleanSetting({\n    category: SettingCategories.Auth,\n    description: `If true, \"Empty Trash\" will _try_ to move files into the \"Trash can\" or \"Recycle bin\", when possible. If moving a file into the trash can fails (due to permissions or filesystem functionality), the file will be \"hard\" deleted (or \"unlinked\"). This setting defaults to false on docker.`,\n    defaultValue: () => (isTest() ? true : !isDocker())\n  }),\n\n  //\n  // Health checks\n  //\n\n  skipHealthCheckIds: new StringEnumsSetting({\n    category: SettingCategories.HealthChecks,\n    description:\n      \"List of health check IDs to skip. Note that windows skips the 'proc-not-superuser' check by default, as most people on Windows run as an admin user.\",\n    defaultValue: isWin ? [\"proc-not-superuser\"] : [],\n    strEnum: HealthCheckIds\n  }),\n\n  //\n  // Video\n  //\n\n  ffmpegHwaccel: new StringSetting({\n    category: SettingCategories.Video,\n    description: `FFmpeg supports both software and hardware encoders. Valid values include \"auto\" (which should \"just work\" for everyone), \"h264_nvenc\" for GPUs, \"cuda\" for NVIDIA GPUs, \"dxva2\" or \"d3d11va\" for Windows, or use \"disable\" to omit this argument.\\nRun \"ffmpeg -hwaccels\" to see supported acceleration methods.\\nNote that some hardware acceleration is only relevant for a handful of video codecs, so what might help for one transcode may not for another.\\nNote that PhotoStructure will automatically retry \"disable\" if there are hwaccel errors.\\nSee https://forum.photostructure.com/t/hardware-accelerated-encoding-transcoding/166>, https://trac.ffmpeg.org/wiki/HWAccelIntro , and <https://github.com/NVIDIA/nvidia-docker for more details.`,\n    defaultValue: \"disable\"\n  }),\n\n  ffmpegThreads: new OptionalIntegerSetting({\n    category: SettingCategories.Video,\n    advanced: () => true,\n    description: `When transcoding videos, what value should we give to \"ffmpeg -threads\"?\\nNote that there are vanishing returns here: there's a substantial benefit to 2 threads versus 1 thread, but 4 vs 8 threads only fractionally improves transcode time while increasing CPU time linearly. The default is clamp(1, 6, ($CPU_COUNT * $cpuBusyPercent) / 4).`\n  }),\n\n  ffmpegAvcTranscodeArgs: new StringArraySetting({\n    category: SettingCategories.Video,\n    aliases: [\"ffmpegTranscodeArgs\"],\n    description: `The following are the default arguments added to transcode requests made to ffmpeg, when ffmpeg is available. The following arguments will follow \"ffmpeg -loglevel error -threads T -i INPUT_FILE_PATH\" (where T is replaced by ~half the available CPU threads, and INPUT_FILE_PATH is the full native pathname to the source video).\\nIf your videos are in high colorspace like bt2020, you may want to remove the \"-vf\" and \"colorspace=all=bt709:iall=bt709:itrc=srgb\" options, but this may cause rendering issues on SDR displays. See https://forum.photostructure.com/t/1003/3 for more details.\\nCAUTION: this is an advanced setting. Invalid values may cause videos that require transcoding to not be imported, or not be viewable on some browsers.`,\n    defaultValue: [\n      \"-c:a\",\n      \"aac\",\n      \"-c:v\",\n      \"libx264\",\n      // pix_fmt and profile are required by firefox (!!)\n      \"-pix_fmt\",\n      \"yuv420p\",\n      // https://www.canva.dev/blog/engineering/a-journey-through-colour-space-with-ffmpeg/\n      \"-vf\",\n      \"colorspace=all=bt2020:iall=bt601-6-625:fast=1\",\n      \"-color_range\",\n      \"1\",\n      \"-colorspace\",\n      \"1\",\n      \"-color_primaries\",\n      \"1\",\n      // See\n      // https://forum.photostructure.com/t/trouble-transcoding-iphone8-video-possibly-stalling-progress-of-library-import/1003/3?u=mrm\n      // and\n      // https://medium.com/invideo-io/talking-about-colorspaces-and-ffmpeg-f6d0b037cc2f\n      // \"-color_trc\", \"smpte2084\", \"-color_primaries\", \"bt2020\",\n      // https://ffmpeg.org/ffmpeg-filters.html#colorspace\n      // https://ffmpeg.org/ffmpeg-formats.html#Options-11\n\n      // https://discord.com/channels/818905168107012097/818907922767544340/872836920948961381\n      // Zirro — 08/05/2021 A suggestion in case you haven't heard of it - you\n      // might want to look into using -movflags +faststart as part of the\n      // default ffmpeg transcoding arguments. It places the moov atom which\n      // contains essential metadata for streaming the video at the start rather\n      // than the end of the MP4 file. Otherwise browsers (and other streaming\n      // clients) have to download the whole file before they can start playing\n      // it, sometimes delaying playback significantly. The option is widely\n      // used and recommended, so I don't believe there are any concerns with\n      // regards to compatibility from using it. ( for the curious, looks like\n      // there's been some movement on supporting more pixel formats in Firefox\n      // within recent months:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1459526 )\n      \"-movflags\",\n      \"+faststart\"\n      // \"-profile:v\",\n      // \"high\"\n    ]\n  }),\n\n  transcodeMaxDim: new IntegerSetting({\n    category: SettingCategories.Video,\n    description: `If a video that needs transcoding exceeds this setting's value, the transcoded version will be downsampled such that the long side will equal this setting. A value of 1920 is good for 1080p, and 1280 would transcode to 720p resolution.\\nSet this to 0 to disable this setting.`,\n    defaultValue: 1920\n  }),\n\n  transcodeFrameRate: new OptionalIntegerSetting({\n    category: SettingCategories.Video,\n    description: `If set, transcoded videos will be bounded to this framerate. Videos that are lower than this framerate will retain their original (lower) framerate.\\nNote that framerate reduction does not reduce the final transcoded video size linearly: it may only reduce file sizes by ~20% to go from 60 FPS to 30 FPS.\\nUnset this or set to 0 to disable bounded framerates.`,\n    exampleValue: () => 30\n  }),\n\n  ffmpegScaleType: new StringEnumSetting({\n    category: SettingCategories.Video,\n    description: `What style of resize works for your version of ffmpeg?\\n\"vf\" will use \"-vf scale=WxH\"\\n\"s\" will use \"-s WxH\".\\nThe default should be fine: only very old versions should use \"s\".`,\n    strEnum: ffmpegScaleTypes,\n    defaultValue: \"vf\"\n  }),\n\n  transcodeTimeoutBps: new IntegerSetting({\n    category: SettingCategories.Video,\n    description: `PhotoStructure sets asset file processing timeouts to avoid getting \"stuck\" when importing problematic files. This setting is the expected worst-case for transcoding, in source video file bytes processed per second. Set this value to 0 to disable video transcode timeouts.`,\n    defaultValue: 50_000\n  }),\n\n  transcodeVideos: new BooleanSetting({\n    aliases: [\"transcodeVideo\"],\n    category: SettingCategories.Video,\n    description: `Should videos that are not in a browser-supported format be transcoded during import? Note that this is a plus-only feature. FFmpeg must be installed. Note that this *dramatically* slows down imports, and *dramatically* increases the disk space your library will need to use, but allows you to see videos that aren't directly supported by your browser. If this is set to false, your browser will only render videos directly supported by your OS.`,\n    defaultValue: true\n  }),\n\n  transcodeBitrateQVGA: new IntegerSetting({\n    category: SettingCategories.Video,\n    description:\n      \"What max bitrate should PhotoStructure encode QVGA (320 × 240) videos? Videos with resolutions between QVGA and UHD will use an interpolated value between these two settings, and will not exceed the encoded bitrate of the original video. This value is in kilobytes per second.\",\n    defaultValue: 800\n  }),\n\n  transcodeBitrateUHD: new IntegerSetting({\n    category: SettingCategories.Video,\n    description:\n      \"What max bitrate should PhotoStructure encode UHD (3840 × 2160) videos? Videos with resolutions between QVGA and UHD will use an interpolated value between these two settings, and will not exceed the encoded bitrate of the original video. This value is in kilobytes per second.\",\n    defaultValue: 18_000\n  }),\n\n  doNotTranscodeMimeTypes: new StringArraySetting({\n    category: SettingCategories.Video,\n    description: `Videos are transcoded when the \"transcodeVideos\" is set to true and is not one of the following MIME types.\\nSee https://www.iana.org/assignments/media-types/media-types.xhtml#video for a complete list.\\nIf you are setting this via an environment variable, you can separate the values either like a PATH (like \"video/quicktime:video/mp4\") or use JSON encoding (like \"['video/quicktime','video/mp4']\").`,\n    defaultValue: () => [\n      \"video/quicktime\",\n      \"video/mp4\",\n      \"video/mpv\",\n      \"video/mp2t\"\n    ]\n  }),\n\n  doNotTranscodeVideoCodecs: new StringArraySetting({\n    category: SettingCategories.Video,\n    description: `Videos are transcoded when the \"transcodeVideos\" is set to true and is not one of the following video codecs. The video codec may be stored in the \"VideoCodec\", \"CompressorID\", or \"CompressorName\" tags.`,\n    defaultValue: () => [\"avc1\"] // CompressorID: \"hvc1\" is HEVC.\n  }),\n\n  doNotTranscodeAudioCodecs: new StringArraySetting({\n    category: SettingCategories.Video,\n    description: `Videos are transcoded when the \"transcodeVideos\" is set to true and is not one of the following audio codecs. The audio codec is stored in the \"AudioCodec\" tag.`,\n    defaultValue: () => [\"mp4a\", \"sowt\"]\n  }),\n\n  //\n  // TOOLS\n  //\n\n  enableSIMD: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `Should PhotoStructure enable SIMD extensions when running image operations? This defaults to false on macOS and Raspberry Pis due to instability on those platforms.`,\n    // isTest() to make the result consistent across CI:\n    defaultValue: () => (isRaspberryPi() ? false : true)\n  }),\n\n  enableVipsCache: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `Should PhotoStructure enable VIPS caching, which may help speed up image operations? Note that this increases memory usage, and cache hit rates are low.`,\n    defaultValue: () => false\n  }),\n\n  showFileInFolderUsesThunar: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `If we're on Linux, should we use Thunar (via dbus) to \"show file in folder\"?`,\n    defaultValue: false\n  }),\n\n  showFileInFolderUsesFileUri: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `Does the showFileInFolderCommand expect a file: URI to the file? If this is false, the native path will be appended instead.`,\n    exampleValue: () => true,\n    defaultValue: () => isLinux\n  }),\n\n  showFileInFolderCommand: new StringArraySetting({\n    category: SettingCategories.Tools,\n    description: `If set, the first argument will be used as a command (or path to command), and the subsequent arguments (if present) will be used as arguments. The native path to the file or the file: URI will be appended, based on the value given to the \"showFileInFolderUsesFileUri\" setting. If this is set to an empty array, the default tool for your platform will be used instead: \"nautilus -s\" on linux, \"open -R\" on mac, and \"explorer /select\" on Windows.\\nThis is provided to support Linux desktops that don't use Gnome.`,\n    defaultValue: []\n  }),\n\n  dcraw_emuPath: new StringSetting({\n    category: SettingCategories.Tools,\n    description: `This should be the absolute, native path to the \"dcraw_emu\" binary on this system. If this is set to \"dcraw_emu\", PhotoStructure will search your $PATH. See https://www.libraw.org/docs/Samples-LibRaw.html .`,\n    defaultValue: \"dcraw_emu\"\n  }),\n\n  ffmpegPath: new StringSetting({\n    category: SettingCategories.Tools,\n    description: `This should be the absolute, native path to the \"ffmpeg\" binary on this system. If this is set to \"ffmpeg\", PhotoStructure will search your $PATH. See https://photostructure.com/getting-started/video-support/ .`,\n    defaultValue: \"ffmpeg\"\n  }),\n\n  heifConvertPath: new StringSetting({\n    category: SettingCategories.Tools,\n    description: `This should be the absolute, native path to the \"heif-convert\" binary on this system. If this is set to \"heif-convert\", PhotoStructure will search your $PATH. See https://photostructure.com/getting-started/heif-support/ .`,\n    defaultValue: \"heif-convert\"\n  }),\n\n  powerShellArgs: new StringArraySetting({\n    category: SettingCategories.Tools,\n    description: `The following are the default arguments added to spin up PowerShell on Windows devices.\\nSee https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_exe?view=powershell-5.1 for all arguments that PowerShell.exe accepts.\\nSee https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-5.1 for a description of Bypass.\\nSee https://forum.photostructure.com/t/eliminate-powershell-profile-and-execution-policy-related-errors/184 for more details about why this needs to be configurable.\\n(Versions prior to v1.0.0 only specified \"-NoLogo\").`,\n    defaultValue: [\"-NoLogo\", \"-NoProfile\", \"-ExecutionPolicy\", \"Bypass\"]\n  }),\n\n  powerShellCulture: new StringSetting({\n    category: SettingCategories.Tools,\n    description:\n      \"If set to a non-blank value, PhotoStructure on Windows machines will set PowerShell's `[System.Threading.Thread]::CurrentThread.CurrentCulture` to this value. This allows PhotoStructure to parse PowerShell output reliably.\",\n    defaultValue: () => \"en-US\"\n  }),\n\n  powerShellProcs: new IntegerSetting({\n    category: SettingCategories.Tools,\n    description:\n      \"How many PowerShell child processes may each PhotoStructure process run? Defaults to max(2, (maxCpus() / 4)).\",\n    defaultValue: () => 2\n  }),\n\n  toolPaths: new StringArraySetting({\n    category: SettingCategories.Tools,\n    description: `These paths are appended to the PATH to ensure PhotoStructure can find and run external tools like ffmpeg. Use your operating system's separator to separate paths (\":\" for mac and linux, \";\" for windows).`,\n    defaultValue: () => [] // < set by setSettingsDefaults()\n  }),\n\n  //\n  // Electron\n  //\n\n  autoHideMenuBar: new BooleanSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"If true, PhotoStructure for Desktops on Windows and Linux will auto hide the menu bar unless the Alt key is pressed.\",\n    defaultValue: false\n  }),\n\n  hideOnLaunch: new BooleanSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"If true, PhotoStructure for Desktops will not open the main window when launched. The tray icon will still be visible.\\nThis setting is ignored by PhotoStructure for Server editions.\",\n    defaultValue: false\n  }),\n\n  pauseSyncOnBattery: new BooleanSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"If true, PhotoStructure for Desktops will pause sync when the system is on battery power.\\nThis setting is ignored by PhotoStructure for Server editions.\",\n    defaultValue: false\n  }),\n\n  //\n  // Updates\n  //\n\n  updateChannel: new StringEnumSetting({\n    category: SettingCategories.Updates,\n    description:\n      'TL:DR; keep this on \"stable\". This setting controls which builds of PhotoStructure you are eligible to update to, and on desktops, this upgrade is automated.\\nPlease note that \"prealpha\" and \"alpha\" builds may not even launch, and \"beta\" builds have not been thoroughly tested. See https://forum.photostructure.com/t/alpha-beta-stable-and-latest-what-should-you-use/274 for details.',\n    defaultValue: () => (isTest() ? \"stable\" : channel()),\n    strEnum: UpdateChannels\n  }),\n\n  autoUpdateCheck: new BooleanSetting({\n    category: SettingCategories.Updates,\n    description: `While running, PhotoStructure will check periodically for updates.\\nSee https://forum.photostructure.com/t/new-in-v2023-10-automated-photostructure-version-checking/1956 for details.\\nSet this to \"false\" to disable automatic update checking.`,\n    defaultValue: true\n  }),\n\n  //\n  // Privacy\n  //\n\n  allowUserAgent: new BooleanSetting({\n    category: SettingCategories.Privacy,\n    description: `Can PhotoStructure include a User-Agent header that includes  basic installation information when it makes external requests, like for the version update check?\\nSee https://forum.photostructure.com/t/new-in-v2023-10-automated-photostructure-version-checking/1956 for details.`,\n    defaultValue: true\n  }),\n\n  optOut: new BooleanSetting({\n    aliases: [\"doNotTrack\"],\n    envAliases: [\"DNT\", \"GPC\"],\n    category: SettingCategories.Privacy,\n    description: `If set to true, your library will not originate external network requests.\\nThis is a \"meta\" setting that currently sets \"reportErrors=false\", \"autoUpdateCheck=false\", and \"allowUserAgent=false\".This setting will be kept up to date with any other feature that could result in an external network request (like, for example, reverse geocoding).\\nTechnically speaking, this is **not** the same as \"DNT\" (Do Not Track) or \"GPC\" (Global Privacy Control), because PhotoStructure, Inc. **never shares or sells any user telemetry or data** (so \"DNT\" is always _technically_ true!), but we check and respect both DNT and GPC as aliases for this setting.\\nSee https://photostructure.com/legal/privacy/ for more details about PhotoStructure's privacy policies.`,\n    defaultValue: false\n  }),\n\n  //\n  // Reporting\n  //\n\n  email: new OptionalStringSetting({\n    category: SettingCategories.Reporting,\n    description:\n      \"If set, this email will be used for license subscriptions and added to error reports, so we can contact you to help debug the issue. It is not required. Setting a value here does not subscribe you to any marketing emails.\",\n    exampleValue: () => \"email@example.com\",\n    advanced: () => false\n  }),\n\n  reportErrors: new BooleanSetting({\n    category: SettingCategories.Reporting,\n    description:\n      \"If true, PhotoStructure will send crash reports when it encounters errors. Crash reports may include the path to the file that caused an error, system metadata, and recent log messages.\",\n    defaultValue: true,\n    advanced: () => false\n  }),\n\n  maxErrorsPerDay: new IntegerSetting({\n    category: SettingCategories.Reporting,\n    description:\n      \"Set this to zero to remove all bugs in PhotoStructure.\\nHUR HUR #DADJOKE\\nIf your system generates more than this number of errors in the course of a day, the subsequent error reports will not be reported.\",\n    defaultValue: 3\n  }),\n\n  //\n  // Web settings\n  //\n\n  minStreamCorrPct: new BoundedIntegerSetting({\n    category: SettingCategories.Web,\n    description: `Streams (shown on the asset page) are coalesced when the dice coefficient of their contents are greater than this value. A value of 100 requires streams to match exactly. A value of ~50 allows streams with a couple differences to be considered the \"same\" stream.`,\n    defaultValue: () => 50,\n    max: 100,\n    min: 1\n  }),\n\n  lazyLoadExtraVh: new IntegerSetting({\n    category: SettingCategories.Web,\n    description: `PhotoStructure only loads photos as they come close to the viewport. This setting determines what \"close to the viewport\" means, and is measured in \"vh\" units, or percentage points of your visitor's browsers view height.\\nThe default is 50, so approximately the next 50% of the screen will be pre-loaded before the user scrolls.\\nIf you have fast hardware and fast network, you could try bumping this up to 200.\\nIf you have very slow network, you might want to set this to 0.`,\n    defaultValue: 50\n  }),\n\n  hiddenHomeTags: new StringArraySetting({\n    category: SettingCategories.Web,\n    description: `The given root tags will be omitted from the home page. (Valid values include \"When\", \"Camera\", \"Lens\", \"Type\", \"Fs\", and \"Keyword\").`,\n    defaultValue: () => [\"Type\"]\n  }),\n\n  openGraphTargetWidth: new IntegerSetting({\n    category: SettingCategories.Web,\n    description:\n      \"When generating OpenGraph header metadata, include the preview image closest to this number of pixels wide.\\nSee https://forum.photostructure.com/t/image-thumbnail-in-link-preview/1950 for details.\",\n    defaultValue: 800\n  }),\n\n  placeholderThumbs: new BooleanSetting({\n    category: SettingCategories.Web,\n    description:\n      \"Render missing asset previews as placeholder images (only useful for customer support).\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  fastForwardEmptyTags: new BooleanSetting({\n    category: SettingCategories.Web,\n    description: `When browsing tags in the UI, should tags that only have one child tag and no direct assets be skipped, or \"fast-forwarded,\" over? See https://forum.photostructure.com/t/volume-id-shows-as-a-tag/754/5 for context.`,\n    defaultValue: true\n  }),\n\n  defaultHomepagePath: new StringEnumSetting({\n    category: SettingCategories.Web,\n    description: `Should the /site.webmanifest send you to \"/splash\", or just directly to the home page, \"/tag\"?\\n(IMHO /splash is more fun, but it slows down getting to the home page).`,\n    strEnum: strEnum(\"/tag\", \"/splash\"),\n    defaultValue: () => \"/tag\"\n  }),\n\n  // TODO:\n\n  // sessionTimeoutHours: new BoundedIntegerSetting({\n  //   category: SettingCategories.Web,\n  //   description:\n  //     \"How long should unused HTTP sessions exist before requiring visitors to log back in? This defaults to 180 days, just to maximize convenience.\",\n  //   defaultValue: 24 * 30 * 6,\n  //   max: 24 * 365,\n  //   min: 1\n  // }),\n\n  //\n  // Sync\n  //\n\n  syncReportsDir: new StringSetting({\n    category: SettingCategories.Sync,\n    description: `Detailed reports for every sync are stored in this directory, which defaults to \".photostructure/sync-reports\" within your PhotoStructure library. Absolute paths here are supported.`,\n    defaultValue: () => \".photostructure/sync-reports\"\n  }),\n\n  syncReportMaxRows: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"Some software can't open large CSVs, so PhotoStructure will start a new sync report if the rows exceed this value. Excel and LibreOffice can open million-row CSVs, so that's our default.\",\n    defaultValue: () => 1_000_000\n  }),\n\n  quickSyncMode: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should PhotoStructure disable a bunch of features to make imports faster? Note that this disables image validation, video transcoding, image hashing (required for good deduplication), metadata inference, and more efficient preview encoding. It is true by default on Raspberry Pis and false everywhere else.`,\n    defaultValue: () => isRaspberryPi()\n  }),\n\n  taskTimeoutMs: new DurationSetting({\n    category: SettingCategories.Sync,\n    aliases: [\"taskTimeoutMillis\"],\n    description:\n      \"What's the longest time it can validly take to fetch a file SHA, generate image previews for an asset, compute an image hash, or extract tags for a file?\\nOn a reasonable server and disk, these tasks should take a handful of seconds, but the default allows for a (busy!) RPi on a slow, remote disk to not timeout.\",\n    defaultValue: () => \"2m\"\n  }),\n\n  // it's \"scanPaths\", so \"scan\" should match here (rather than the \"sync\" prefix):\n  scanLibraryFirst: new BooleanSetting({\n    aliases: [\"syncLibraryFirst\"],\n    category: SettingCategories.Sync,\n    description:\n      \"Should PhotoStructure scan your library before all other paths are synchronized?\\nThis defaults to true if you are using automatic organization, to make sure existing files in your library are in sync with your library database. This prevents additional copies of the same SHA being copied into your library directory if you have automatic organization enabled.\",\n    defaultValue: true\n  }),\n\n  scanLibraryLast: new BooleanSetting({\n    aliases: [\"syncLibraryLast\"],\n    category: SettingCategories.Sync,\n    description:\n      \"Should PhotoStructure scan your library after all other paths are synchronized?\",\n    defaultValue: false\n  }),\n\n  progressRetentionDays: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"How many days of sync progress should we keep around in the database before it's removed?\",\n    defaultValue: 180\n  }),\n\n  progressStaleDays: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When sync starts, it tries to pick up where it was previously, but this doesn't make sense if the prior work was done a while ago, as it is more likely that the filesystem has changed since.\",\n    defaultValue: 6\n  }),\n\n  copyToLibraryMimeTypes: new StringArraySetting({\n    category: SettingCategories.Sync,\n    description: `When \"automatic organization\" is enabled, files whose mimetypes are included in this list will be copied into your originals directory.\\nNote that MIME types can include an asterisk to do glob-matching.\\nSee the related system setting \"copyAssetsToLibrary\".\\nA list of MIME types are here: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types .`,\n    defaultValue: () => [\"image/*\", \"video/*\"]\n  }),\n\n  onlyNativeFileCopy: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should PhotoStructure skip the built-in file copy code, and only use the \"OS native\" file copy mechanism?\\nPhotoStructure is typically faster than native file copies by 2x or more.\\nIf true, PhotoStructure will use \"cp\" on macOS and Linux, and PowerShell \"Copy-Item\" on Windows.`,\n    defaultValue: false\n  }),\n\n  verifyFileCopies: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should PhotoStructure verify all file copies by comparing SHAs of the source and destination? This shouldn't be necessary on most OSes and filesystems, and slows down library imports.`,\n    defaultValue: true\n  }),\n\n  assetPathnameFormat: new StringSetting({\n    category: SettingCategories.Sync,\n    description: `If you opt into \"automatic organization\" (see the setting \"copyAssetsToLibrary\"), they will be copied into <originals directory>/<result of assetPathnameFormat>.\\n- See the originalsDir system setting for what your <originals directory> is (it defaults to your library root directory).\\n- Please encode this path with forward-slashes, even if you're on Windows.\\n- If any patterns resolve to including forward-slashes, know that will be interpreted as subdirectories.\\n- If you want to add a static path, escape the pathname with single quotes (like \"'photos'/y/MM/dd\").\\n- The result of this will always be interpreted as a relative path from your PhotoStructure originals directory.\\n- Use token \"BASE\" as a shorthand for the original basename (\"photo.jpg\" for \"/path/to/photo.jpg\").\\n- Use token \"NAME\" as a shorthand for the original filename, without the file extension (\"photo\" for \"/path/to/photo.jpg\").\\n- Use token \"PARENT\" as a shorthand for the original file's parent directory name (\"to\" for \"/path/to/photo.jpg\").\\n- Use token \"GRANDPARENT\" as a shorthand for the original file's grandparent directory name (\"path\" for \"/path/to/photo.jpg\").\\n- Use token \"EXT\" for the filename's extension without the \".\" prefix (like \"jpg\" for \"/path/to/photo.jpg\").\\n- Use token \"ISO\" as a shorthand for \"yyyy-MM-dd'T'HH:mm:ss.SSSZZ\".\\n- You can escape other static text by wrapping with single quotes.\\n- For other tokens, see https://moment.github.io/luxon/#/formatting?id=table-of-tokens .\\n- See https://forum.photostructure.com/t/how-to-change-the-naming-structure/1184/2?u=mrm for more details.`,\n    defaultValue: \"y/y-MM-dd/BASE\"\n  }),\n\n  writeSourceTagToLibraryCopies: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should PhotoStructure write to the \"Source\" tag add metadata to assets copied into your library that includes the path where the file was originally found? This defaults to false to prevent adding sidecars to every file in your library.`,\n    defaultValue: false\n  }),\n\n  /**\n   * @deprecated\n   */\n  assetSubdirectoryDatestampFormat: new StringSetting({\n    category: SettingCategories.Sync,\n    envAliases: [\"PS_ASSET_SUBDIR_FORMAT\"],\n    description: `This setting has been replaced by \"assetPathnameFormat\".\\nIf this setting is provided, and assetPathnameFormat is _not_ provided, we will give assetPathnameFormat the value of this setting + \"/BASE\".`,\n    defaultValue: \"\",\n    deprecated: true\n  }),\n\n  startPaused: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"Should processing be paused by default when PhotoStructure starts? You'll have to manually resume processing via the system tray or nav menu.\",\n    defaultValue: false\n  }),\n\n  /**\n   * @deprecated\n   */\n  syncIntervalHours: new OptionalIntegerSetting({\n    category: SettingCategories.Sync,\n    description: `This setting has been replaced by \"syncNewIntervalMs\" and \"syncChangedIntervalMs\".`,\n    deprecated: true\n  }),\n\n  syncNewIntervalMs: new DurationSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"This value controls both how often the sync process discovers new files for any given volume.\\nNote that this value is the duration between the last completion time and when the next sync should be scheduled.\\nWARNING: Setting this value to a small value will mean PhotoStructure is constantly scanning your disks, which will add wear and tear and possibly reduce the lifespan of your storage media.\",\n    defaultValue: \"1d\"\n  }),\n\n  syncChangedIntervalMs: new DurationSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"This value controls both how often the sync process discovers new or changed files for any given volume.\\nNote that this value is the duration between the last completion time and when the next sync should be scheduled.\\nWARNING: Setting this value to a small value will mean PhotoStructure is constantly scanning your disks, which will add wear and tear and possibly reduce the lifespan of your storage media.\",\n    defaultValue: \"7d\"\n  }),\n\n  retryEnqueued: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `After finishing a directory sync, should PhotoStructure look at recent sync-reports and retry files that are \"stuck\" in \"enqueued\" state?\\nThis shouldn't be necessary, but it's a backstop to ensure syncs are comprehensive.`,\n    defaultValue: true\n  }),\n\n  forceRebuildLibrary: new BooleanSetting({\n    category: SettingCategories.Sync,\n    aliases: [\"rebuild\"],\n    description:\n      \"When set, all files in your library will be re-imported (caution: slow!).\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  dropWorkQueues: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, all files will be visited, even if the asset seems in sync with the filesystem.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  forceSync: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, all files will be visited, even if the asset seems in sync with the filesystem.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  forceRebuildPreviews: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, previews and transcoded videos will always be rebuilt.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  noModelUpdates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, skip any pending library database updates (only used for tests).\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  exitWhenDone: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, the sync process will exit after jobs are completed (used internally and for tests).\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  overwriteOriginal: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should changes made through the UI, like rotations, captions, and keywords, overwrite the original file? This is potentially dangerous, as your original may be lost if the disk has errors, or there are issues in rewriting the file contents. If this is set to false, the original file will be retained in the same directory. \"image.jpg\" will be stored as \"image_original.jpg\".`,\n    defaultValue: false\n  }),\n\n  maxDuplicatePathElements: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"How many times can a given path element exist in a directory before it is considered within an infinite filesystem loop, and should be skipped from import?\",\n    defaultValue: 7\n  }),\n\n  noAssetFileUpdates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should outdated AssetFiles be ignored on startup? (Only used for tests).`,\n    defaultValue: false,\n    transient: true\n  }),\n\n  noAssetUpdates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should outdated Assets be ignored on startup? (Only used for tests).`,\n    defaultValue: false,\n    transient: true\n  }),\n\n  resyncAssetOnVisit: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should Assets be automatically re-synchronized whenever their info panel is viewed? This can make sure Assets are in-sync with the filesystem, but this can slow down current imports, and add load to slower computers. This defaults to true only if the current machine has >= 8 CPUs.`,\n    defaultValue: () => (isTest() ? true : cpuCount() >= 8)\n  }),\n\n  excludeNoMediaAssetsOnRebuild: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should previously-imported assets that are found to have *any* files in NoMedia directories be excluded from your library?`,\n    defaultValue: () => true\n  }),\n\n  //\n  // Sidecars\n  //\n\n  matchSidecarsCaseInsensitively: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will look for sidecar files that match file basenames (with or without the file extension), regardless of case (for example: \"IMAGE.XMP\" will be a sidecar for \"image.jpg\").\\nIf set to false, sidecars must match case (so only \"image.jpg.xmp\" and \"image.xmp\" will match for \"image.jpg\").`,\n    defaultValue: true\n  }),\n\n  matchSidecarsFuzzily: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will look for sidecar files that match the basename of the asset, plus some common suffixes (like \"-edit\", \"-edited\", or variant copies, like \"-2\").\\nThis setting only impacts .XMP, .MIE, and .EXIF sidecars.\\nNote that PhotoStructure always matches .JSON files fuzzily, as that is required to handle Google Takeouts properly.`,\n    defaultValue: false\n  }),\n\n  defaultSidecarType: new StringSetting({\n    category: SettingCategories.Sidecars,\n    description: `What type of sidecar file do you want to generate for non-destructive edits?\\n- \"XMP\" is a popular and well-adopted format.\\n-\"MIE\" is defined at https://exiftool.org/TagNames/MIE.html .\\n- \"EXIF\" and \"EXV\" should only be used if required, as they have substantial limitations.\\nCase is preserved.`,\n    defaultValue: \"xmp\"\n  }),\n\n  writeMetadataToSidecarsIfImage: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will write metadata changes made to images into sidecars. If set to false, PhotoStructure will overwrite original images with metadata changes.`,\n    defaultValue: true\n  }),\n\n  sidecarTagBlocklist: new StringArraySetting({\n    category: SettingCategories.Sidecars,\n    description: `Many applications don't read metadata from sidecars, which can make some tags, like Orientation or Rating, not seem to work properly in other applications. This setting is ignored if writeMetadataToSidecarsIfImage, writeMetadataToSidecarsIfVideo, and writeMetadataToSidecarsIfSidecarExists are all set to false.`,\n    defaultValue: () => [\"Orientation\"]\n  }),\n\n  writeMetadataToSidecarsIfVideo: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will write metadata changes made to videos into sidecars. If set to false, PhotoStructure will overwrite original videos with metadata changes. This defaults to false, as most software does not use sidecars except for images.`,\n    defaultValue: false\n  }),\n\n  writeMetadataToSidecarsIfSidecarExists: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will write metadata changes into sidecars if the file already has a sidecar and the tag is not in the sidecarTagBlocklist.`,\n    defaultValue: true\n  }),\n\n  // mergeLibrarySidecars: new BooleanSetting({\n  //   category: SettingCategories.Sidecars,\n  //   description: `If this and \"copyAssetsToLibrary\" are set to true, PhotoStructure will merge tag values found in variations into a single sidecar per asset. `,\n  //   defaultValue: true\n  // }),\n\n  // TODO: noMediaAssetAction (hide in library, exclude from library, trash from filesystem)\n\n  //\n  // Deduping\n  //\n\n  strictDeduping: new BooleanSetting({\n    category: SettingCategories.Deduping,\n    description: `How strict should PhotoStructure de-duplicate files? If this is false, we consider files to be equivalent if sufficient metadata matches (even if the image hash is different). If this is true, we will always compare image hashes. NOTE: This will most likely cause RAW and JPEG pairs to not always merge to the same asset, especially if your camera uses extensive computational imagery. ALSO NOTE: If this is true, \"useImageHashes\" will be forced to true, and the \"*corr*\" and \"*coeffPct\" settings will be set to 95.`,\n    defaultValue: false\n  }),\n\n  assetAggregation: new StringEnumSetting({\n    category: SettingCategories.Deduping,\n    description: `How should assets be aggregated?\\n- \"union\" will allow asset file variants to join an asset if they match *any* existing variant.\\n- \"intersection\" will only allow asset file variants to join an asset if they match *all* existing variants.\\nVersions prior to 2.1 defaulted to \"union\" behavior.`,\n    defaultValue: AggregateTypes.intersection,\n    strEnum: AggregateTypes\n  }),\n\n  useImageHashes: new BooleanSetting({\n    category: SettingCategories.Deduping,\n    description: `Building image hashes slows down imports, but supports more robust asset merging heuristics, and allows for dominant color tagging and browsing. If you set this from false to true, and you'd previously imported new assets, you may want to rebuild your library to re-aggregate your assets.`,\n    defaultValue: true\n  }),\n\n  checkBasenameMatches: new BooleanSetting({\n    category: SettingCategories.Deduping,\n    description: `Most cameras take JPG/RAW pairs with matching basenames (so \"P01234\" for \"P01234.JPG\"). When PhotoStructure is trying to find matching assets for a given file, may it check assets that have matching basename file variants?\\nNote that image hash and other asset file comparisons will still be performed before determining a given asset is a match.`,\n    defaultValue: true\n  }),\n\n  allowFuzzyDateImageHashMatches: new BooleanSetting({\n    category: SettingCategories.Deduping,\n    description: `For images that don't have a reliable precise captured-at time (say, from \"stat\" or datestamp from pathname), can we aggregate assets purely by exact image hash matches?\\nSee https://forum.photostructure.com/t/deduplicate-shenanigans/1732/11 for more details.`,\n    defaultValue: false\n  }),\n\n  minMatchesWithoutImageHashes: new IntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `If \"useImageHashes\" is true, this is ignored. This is a \"backstop\" that allows files to be aggregated together if their metadata is equal \"enough.\" As of Sept 2022, there are 5 metadata classes to match: \"cameraId\", \"lensId\", \"imageId\", \"exposureSettings\", and \"geohash\". All of these \"classes\" pull from several individual tags. Note that if any of these classes _don't_ match, the files will always be considered to be from different assets.`,\n    defaultValue: 3\n  }),\n\n  maxContemporaryAdoptionAssets: new IntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `To handle photos and videos with \"fuzzy\" captured-at times (those that are missing second, minute, hour, or even day resolution), how many previously-imported assets with nearby captured-at times should PhotoStructure look for in your library to find an adoption candidate?\\nMonitor the \"sync.AssetFileFinder.assetByCapturedAtOrImageHash\" timer to see how long adoption is taking on your machine.\\nHigher values will slow down imports, but may result in more accurate de-duplication results.`,\n    defaultValue: 512\n  }),\n\n  // UUIDTags: new StringArraySetting({\n  //   category: SettingCategories.Deduping,\n  //   description: `What tags should be used to extract a \"UUID\" that PhotoStructure can trust for asset aggregation?\\nSee https://forum.photostructure.com/t/support-for-iphone-live-photos/87/6 for details.`,\n  //   defaultValue: () => [\"ContentIdentifier\", \"MediaGroupUUID\"]\n  // }),\n\n  datesBeforeAreEstimated: new StringSetting({\n    category: SettingCategories.Deduping,\n    description: `PhotoStructure automatically interprets captured-at timestamps before this ISO-formatted datestamp as \"estimated.\" PhotoStructure also considers timestamps whose minutes, seconds, and milliseconds are all 0 as \"estimated.\"\\nWhen assets have an estimated captured-at time, tighter image correlation is required to prevent different images as being incorrectly aggregated into the same asset.\\nThe default value is the release date for the Nikon Coolpix 950, which was one of the first prosumer digital cameras with ~2MP resolution.`,\n    defaultValue: \"1999-02-15\"\n  }),\n\n  // Note for future me: \"coefficient\" versus \"correlation\":\n\n  // Correlation relates to how well a set of points fit a line.\n  // https://en.wikipedia.org/wiki/Correlation\n\n  // \"Similarity coefficient\" is referenced in Jaccard Similarity, which is\n  // why I went with \"coefficient\" here.\n  // https://en.wikipedia.org/wiki/Jaccard_index\n\n  minExposureSettingsCoeffPct: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description:\n      \"This is the minimum similarity coefficient between exposure setting values two images must be to be considered equivalent. Many cameras actually report different exposure setting values between JPG and RAW: values within 90% of each other should avoid false-positives.\",\n    defaultValue: () => 90,\n    max: 100,\n    min: 0\n  }),\n\n  minImageCoeffPct: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `This setting controls how aggressively images are merged with each other, and is the minimum image hash similarity coefficient for images to be considered equivalent when their date is accurate, their mimetypes match, and are in color.\\nThis value is applied when the captured-at date has a non-zero minute, second, or millisecond, and was captured after \"datesBeforeAreEstimated,\" so the timestamp is considered to have high precision.\\n100 (or 100%) requires exact image correlation is not recommended due to causing false negative matches.\\nA value of less than 50% is fairly low image correlation, and can lead to false positive matches.`,\n    defaultValue: () => 70,\n    max: 100,\n    min: 0\n  }),\n\n  imageHashFuzzyDateDelta: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `This setting's value is added to \"minImageCoeffPct\" and \"minColorCoeffPct\" when captured-at dates have low precision. It defaults to a positive value so we are more strict about merging images with inaccurate dates. Set to 0 to disable this delta.`,\n    defaultValue: () => 12,\n    max: 100,\n    min: -100\n  }),\n\n  imageHashDifferentMimetypesDelta: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `This setting's value is added to \"minImageCoeffPct\" and \"minColorCoeffPct\" when file mimetypes don't match. It defaults to a negative value because RAW and JPEG formats frequently raster slightly different image hashes, requiring a more lax threshold to match JPG+RAW pairs. Set to 0 to disable this delta.`,\n    defaultValue: () => -15, // this is pretty high, but RAW+JPG pairs are often quite different\n    max: 100,\n    min: -100\n  }),\n\n  imageHashGreyscaleDelta: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `This setting's value is added to \"minImageCoeffPct\" when either image is essentially greyscale. It defaults to a positive value so we are more strict about merging greyscale images. We also don't have color correlation to help us, so a more strict threshold is warranted.`,\n    defaultValue: () => 10,\n    max: 100,\n    min: -100\n  }),\n\n  // imageHashBlur: new BooleanSetting({\n  //   category: SettingCategories.Deduping,\n  //   description: `PhotoStructure can apply a light blur between the dominant color pixel resample and the final image hash downsample, which can improve image hash matching of noisy or high frequency images. This adds 5-100ms to building image hashes.\\nSet to 0 to disable this blurring step.`,\n  //   defaultValue: true\n  // }),\n\n  minColorCoeffPct: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description:\n      \"Given two sets of dominant colors, this is the average percent that those sets correlate with eachother. A higher number requires stronger dominant color correlation. 100 (or 100%) requires exact dominant color correlation. A value of less than 50% indicates fairly low correlation of dominant colors, and can lead to false positives.\",\n    defaultValue: () => 73,\n    max: 100,\n    min: 0\n  }),\n\n  greyscaleColorThreshold: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `Many \"black and white\" images, which scanned, actually include color information, especially if the source has yellowed with age. PhotoStructure determines if an image is \"greyscale\" if the standard deviation of a* plus the standard deviation of b* values is less than this value. By only looking at standard deviation, we can categorize sepia photos as \"greyscale.\" Smaller values are stricter.`,\n    defaultValue: 3,\n    max: 128,\n    min: 0\n  }),\n\n  gpsErrorMeters: new IntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `What's the maximum number of meters between GPS fixpoints that should be considered equivalent locations? Note that JPG+RAW pairs from smartphones frequently have different GPS locations due to one being recorded from a rough WiFi fix, and another from aGPS.\\nGPS position error is ~10-100m. Cellular position error is ~500-750m.`,\n    defaultValue: 500\n  }),\n\n  minCapturedAtPrecisionDifferentMimetypes: new IntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `Some cameras store JPEG+RAW pairs with slightly different captured-at times (!!). To ensure these are merged properly, we need to allow for these discrepancies. This setting controls how many milliseconds of difference we allow between captured-at times for different mimetypes. Set to 0 to disable this feature.`,\n    defaultValue: () => 1500\n  }),\n\n  minCapturedAtPrecisionStat: new IntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `If a captured-at time is low quality (using the mtime or birthtime of the file), what should PhotoStructure use as the \"minimum\" precision for that time? This is used to determine how much \"fuzziness\" to allow when comparing captured-at times during assert aggregation. Set to 0 to disable this feature.`,\n    defaultValue: () => minuteMs\n  }),\n\n  fuzzyDatePrecisionCoeff: new FloatSetting({\n    category: SettingCategories.Deduping,\n    description: `When comparing \"captured-at\" dates that aren't from reliable metadata tags, what coefficient should be applied to the inferred precision of those dates? Larger values will mean PhotoStructure will consider these \"fuzzy\" dates to be less precise, and expand the date range when searching for matching assets. Set to 1 to disable this feature.`,\n    defaultValue: 2\n  }),\n\n  // TODO: FINISH! See core/img/ImageDataHash.ts\n\n  // useImageDataHashes: new BooleanSetting({\n  //   category: SettingCategories.Deduping,\n  //   description: `Should PhotoStructure match files using a cryptographic hash of the image data (without metadata)? This will allow files with the same image content to match after metadata changes, but takes longer to compute.`,\n  //   defaultValue: true\n  // }),\n\n  // imageDataHashTags: new StringArraySetting({\n  //   category: SettingCategories.Deduping,\n  //   description: `Should PhotoStructure save image data cryptographic hashes into files copied into your library? These values must be valid tag names. When writing, PhotoStructure will write into the first tag that doesn't already have a value (to avoid clobbering prior values).\\nSet to an empty array to disable this feature.`,\n  //   defaultValue: [\n  //     \"DocumentId\",\n  //     \"OriginalDocumentID\",\n  //     \"BurstUUID\",\n  //     \"BurstId\",\n  //     \"CameraBurstID\",\n  //     \"MediaGroupUUID\",\n  //     \"InstanceId\"\n  //   ]\n  // }),\n\n  //\n  // Color\n  //\n\n  dominantColorPixels: new BoundedIntegerSetting({\n    category: SettingCategories.Color,\n    aliases: [\"modePixels\"],\n    description: `PhotoStructure downsamples images to contain this number of pixels, converts each pixel into CIELAB space, and then runs k-means clustering to extract dominant colors. Larger values will be slower to process, but will result in more accurate dominant colors. Smaller values will be faster, but may result in inaccurate dominant colors.`,\n    defaultValue: DominantColorPixelsDefault,\n    max: 4096,\n    min: 256\n  }),\n\n  dominantColorDeltaE: new StringEnumSetting({\n    aliases: [\"delta_e\"],\n    category: SettingCategories.Color,\n    description: `What delta_e algorithm should PhotoStructure use to determine color differences? cie76 is quick but inaccurate. cie94 is more accurate than cie76 but 6x more computationally expensive than cie76. ciede2000 is best, but 4-6x more expensive than cie94.`,\n    defaultValue: ColorDistanceFunctions.ciede2000,\n    strEnum: ColorDistanceFunctions\n  }),\n\n  dominantColorKmeansRuns: new BoundedIntegerSetting({\n    category: SettingCategories.Color,\n    aliases: [\"modeRuns\"],\n    description: `PhotoStructure uses k-means clustering to extract dominant colors from your images.\\nLarger values will allow PhotoStructure to run k-means with more random seeds and different pre-merged k values, which should result in higher quality results.\\nUsing 0 will revert to posterizing the image and using the top-n colors, which is fast and deterministic, but has lower quality results.\\nChanging this value will subtly change many image's dominant color lists.\\nThis defaults to 0 run when \"quickSyncMode\" is enabled.`,\n    defaultValue: DominantColorKmeansRunsDefault,\n    max: 64,\n    min: 0\n  }),\n\n  dominantColorMergeThreshold: new BoundedIntegerSetting({\n    category: SettingCategories.Color,\n    description: `The best dominant color cluster centroids may be quite similar. PhotoStructure will merge centroids if their Δe is less than this value. Larger values will result in more different dominant colors, but those may not be as accurate.`,\n    defaultValue: 10,\n    max: 32,\n    min: 0\n  }),\n\n  dominantColorGreyThreshold: new BoundedIntegerSetting({\n    category: SettingCategories.Color,\n    aliases: [\"modeGrey\"],\n    description: `May PhotoStructure ignore pixels that are greyscale, or \"desaturated,\" when looking for dominant colors? Larger values will result in only saturated colors being considered for dominant colors. A pixel color will be removed if its absolute a* and b* values in CIELAB space sum to less than this value.\\nSet this to 0 to include greys in dominant colors, but note that this tends to reduce image deduplication effectiveness, as most natural-tone images contain a good deal of greyscales, which results in false matches.`,\n    defaultValue: 11,\n    max: 80,\n    min: 0\n  }),\n\n  //\n  // Shared-state events\n  //\n\n  sharedStateDir: new OptionalStringSetting({\n    category: SettingCategories.Events,\n    description:\n      \"PhotoStructure uses a set of JSON files to relay messages between processes (rather than an RPC mesh, socket, or named pipe, whose device types isn't supported on some filesystem types). This directory must be readable and writable.\",\n    defaultValue: () => \"\" // < set by setSettingsDefaults()\n  }),\n\n  sharedStatePollMs: new DurationSetting({\n    category: SettingCategories.Events,\n    description: `The \"sharedStateFile\" is watched for changes using your OS'es filesystem watch functionality: for most setups, this will result in almost instantaneous event propagation. Some filesystems don't support filesystem watching, or miss file edits, so we _also_ manually check for file changes every \"sharedStatePollMs\" milliseconds. This defaults to 7 seconds, but know that this will prevent the \"PS_CONFIG_DIR\" hard drive from spinning down and going to sleep.\\nSee the \"allowFilesystemSleep\" for other related settings.\\nSet this setting to 0 to disable state polling.`,\n    defaultValue: () => \"7s\"\n  }),\n\n  sharedStateTaskTimeoutMs: new DurationSetting({\n    category: SettingCategories.Events,\n    description: `How long should PhotoStructure wait for shared-state tasks to be completed before timing out and giving up?`,\n    defaultValue: () => \"5m\"\n  }),\n\n  //\n  // Previews\n  //\n\n  previewQuality: new BoundedIntegerSetting({\n    aliases: [\"jpegQuality\"],\n    category: SettingCategories.Previews,\n    description:\n      \"JPEG output quality for previews. Smaller values produce smaller images with lower quality. The default value of 80 strikes a balance that has almost no noticeable compression artifacts, yet still compresses images reasonably well. Depending on image content, values less than 50-70 can produce noticeable artifacts.\",\n    defaultValue: () => 80,\n    max: 100,\n    min: 10\n  }),\n\n  previewProgressive: new BooleanSetting({\n    category: SettingCategories.Previews,\n    aliases: [\"progressive\", \"jpegProgressive\"],\n    description: `Should preview JPEGs be progressively encoded? If set, thumbnails will take ~15% longer to generate, but FHD/QHD/UHD previews will be smaller.`,\n    defaultValue: true\n  }),\n\n  previewMinimized: new BooleanSetting({\n    aliases: [\"jpegMinimized\"],\n    category: SettingCategories.Previews,\n    description: `Should preview JPEGs be optimized? If set, preview generation can take 50% longer, but can result in up to ~30% smaller images. This saves disk space and network transport time.\\nThis setting controls the \"mozjpeg\" option: see https://sharp.pixelplumbing.com/api-output#jpeg for details.\\nThis automatically defaults to true if at least 4 CPU cores are present.`,\n    defaultValue: () => (isTest() ? true : cpuCount() >= 4)\n  }),\n\n  dcrawEmuArgs: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `What options do you want to pass to dcraw_emu? Note that \"-T -o 1 -j -Z -\" will always be added (as we need TIFF, sRGB, raw pixels send to stdout). The \"-h\" arg will be added if the preview image needed is less than half the resolution of the original.\\nRun \"dcraw_emu\" with no arguments to get usage help.\\n\"-q 1\" sets interpolation quality to \"0\".\\n\"-H 2\" turns on highlight blending.\\n\"-w\" uses the camera-set white balance.\\nNote: changing these values can dramatically (> 10x!) increase the time it takes to render RAW images.`,\n    defaultValue: [\"-q\", \"0\", \"-w\"]\n  }),\n\n  iccProfileMappings: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `Maps an original image profile to a filename stored in the \"icc\" directory. See that directory's _info.md for more information about this settings.`,\n    defaultValue: [\n      \"Display P3:DisplayP3Compat-v2-magic.icc\",\n      \"Adobe RGB:AdobeCompat-v2.icc\"\n    ]\n  }),\n\n  squareThumbStrategy: new StringEnumSetting({\n    category: SettingCategories.Previews,\n    description:\n      'When PhotoStructure crops images and videos to square thumbnails, it needs to crop non-square images to a square. The default, \"attention,\" focuses on faces and higher image energy, but is more expensive than simply cropping to the center of the image (which is faster, but will mean less-nice cropping, where faces are chopped in half). More details are available here: https://sharp.pixelplumbing.com/api-resize .',\n    defaultValue: CropStrategies.attention,\n    strEnum: CropStrategies\n  }),\n\n  videoFrameAtSec: new FloatSetting({\n    category: SettingCategories.Previews,\n    description: `When capturing a frame from videos for thumbnails, how many seconds should be passed over before capturing a frame? A value of 0 means capture from the start of the video. Frequently, though, videos start out of focus, so we default to 1.5 for better frame clarity.\\nNote that if a video is shorter than this value, the frame will be captured from the middle of the video.`,\n    defaultValue: 1.5\n  }),\n\n  // TODO: add this to the settings page:\n  previewSharpen: new BooleanSetting({\n    aliases: [\"sharpen\"],\n    category: SettingCategories.Previews,\n    description: `Should previews be sharpened? This can make the images \"pop\" a bit more, but almost doubles the time it takes to make the thumbnails.`,\n    defaultValue: false\n  }),\n\n  // TODO: add this to the settings page:\n  previewResolutions: new StringEnumsSetting({\n    category: SettingCategories.Previews,\n    description:\n      \"This controls the resolutions that PhotoStructure creates for every asset. Note that resolutions will be skipped if there already is a preview value with <= 2.5x pixel count, so even though there are a lot of sizes here, you'll only see 3-4 images on your disk per asset.\\nSee https://en.wikipedia.org/wiki/Graphics_display_resolution for a description of these resolution codes.\",\n    defaultValue: diff(FitSizes.values, [\"uhd8k\", \"uhd5k\"]),\n    strEnum: FitSizes\n  }),\n\n  embeddedPreviews: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `For larger source images that are greater than 15MP, what embedded image preview tags should be used when present? Using these embedded images speeds up image preview generation, but if the embedded image doesn't match the full-sized image, the image preview will be incorrect.\\nSet this to an empty array to disable using embedded previews.`,\n    defaultValue: [\"PreviewImage\", \"PreviewTIFF\", \"JpgFromRaw\", \"JpgFromRaw2\"]\n  }),\n\n  embeddedThumbnails: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `Should embedded image thumbnails be used when available? This speeds up image hashing, but if the embedded image thumbnail doesn't match the full-sized image, the image hash will be incorrect.\\nSet this to an empty array to disable using embedded previews.`,\n    defaultValue: [\"ThumbnailImage\", \"ThumbnailTIFF\"]\n  }),\n\n  maxEmbeddedBuffer: new IntegerSetting({\n    category: SettingCategories.Previews,\n    description: `PhotoStructure tries to use embedded images for preview generation to minimize work. For smaller images, we can directly pipe the buffer from the embedded image into our image pipeline, but for larger images, it can be faster to use an intermediary file stored on the cache drive. Larger values will reduce disk I/O but increase memory and CPU consumption. Set this to 0 to force all previews to be written to the cache dir.\\nThis defaults to ${fmtBytes(\n      DefaultMaxEmbeddedBuffer * 4\n    )} on Windows due to slow disk I/O on that platform.`,\n    defaultValue: () => (isWin ? 4 : 1) * DefaultMaxEmbeddedBuffer\n  }),\n\n  skipPreviews: new BooleanSetting({\n    category: SettingCategories.Previews,\n    description: `Only used for tests.`,\n    advanced: () => true,\n    defaultValue: false\n  }),\n\n  variantSortCriteria: new StringEnumsSetting({\n    category: SettingCategories.Previews,\n    aliases: [\"assetFileSortCriteria\"],\n    description: `How should PhotoStructure pick the \"best\" asset file variant for a given asset? You may reorder the default fields. Only \"resolution\", \"fileSize\", \"mtime\", \"schemeIdx\", \"isCover\", \"count\", and \"isBrowserSupported\" are understood: other field names will be ignored. Details about these fields are here: https://photostructure.com/faq/what-do-you-mean-by-dedupe/#how-does-photostructure-pick-which-file-to-show .`,\n    strEnum: AssetFileSortCriteria\n  }),\n\n  variantSortCriteriaPower: new BoundedFloatSetting({\n    category: SettingCategories.Previews,\n    description: `Variant sort criteria \"resolution\" and \"fileSize\" are scaled down to ignore irrelevant differences. Scalars are raised to this power to reduce them, so a value of 1 means the criterion is unchanged from the \"raw\" value. Smaller values for this setting let _larger_ differences be ignored.`,\n    defaultValue: () => 1 / 6,\n    max: 1,\n    min: 1e-6\n  }),\n\n  includePreviewTags: new BooleanSetting({\n    category: SettingCategories.Previews,\n    description: `By default, PhotoStructure strips all metadata from preview images. This both saves space, and reduces disk I/O during preview generation. If this setting is enabled, all \"includedPreviewTags\" will be restored in preview images that are more than 1 megapixel. If this setting is enabled, each preview image will be written to twice (once for the image and once for the metadata), so imports will be slower.`,\n    defaultValue: false\n  }),\n\n  includedPreviewTags: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `If \"includePreviewTags\" is true, what tags should PhotoStructure retain when building preview images? A partial list of tags is here: https://photostructure.github.io/exiftool-vendored.js/interfaces/Tags.html . Note that not all files contain all (or even some!) of those tags.\\n- \"capturedAt\" is a special meta-tag which will retain whatever tag contains the \"best\" time that PhotoStructure could find that encoded the date and time when the image was captured, and will store that value in DateTimeOriginal.\\n- \"exposureSettings\" is a special meta-tag that will retain shutter time (ExposureTime), aperture (FNumber), and ISO (ISOSpeed) metadata (but may be encoded with different values).\\n- including \"GPSLatitude\" and \"GPSLongitude\" will mean previews will contain location metadata if the source image had location metadata.`,\n    defaultValue: () => DefaultIncludedPreviewTags\n  }),\n\n  //\n  // Filters\n  //\n\n  disableAllFilters: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"Setting this to true will force all other filter settings to their most permissive value. Note that this also disables file validation tests and the file SHA blocklist, so corrupt files and previously removed files will be attempted to be imported as well.\\nIf you have to resort to using this setting, please consider hopping onto the PhotoStructure Forum or PhotoStructure Discord and describe your situation.\",\n    defaultValue: false\n  }),\n\n  excludeGlobsAdd: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `This setting adds glob patterns for files and directories that should be excluded from your library.\\nThese patterns will be added to PhotoStructure's default set of (several hundred!) exclusion globs.\\nSee https://forum.photostructure.com/t/1458 for details.`,\n    exampleValue: () => [\"**/tmp/\"],\n    defaultValue: () => []\n  }),\n\n  excludeGlobsOmitDefaults: new BooleanSetting({\n    aliases: [\"omitDefaultExcludeGlobs\", \"disableIgnorableFilters\"],\n    category: SettingCategories.Filters,\n    description: `Setting this to true will omit ALL default exclusion globs, and is equivalent to providing all default exclusion globs to the \"excludeGlobsOmit\" setting. You're then free to add whatever exclusion globs you want, using the \"excludeGlobsAdd\" setting.`,\n    defaultValue: false\n  }),\n\n  excludeGlobsOmit: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `PhotoStructure has several hundred default \"exclusion globs\" to avoid scanning system and application directories and otherwise irrelevant directories and files.\\nIf you don't like one or two of them, add them here, and they will be removed from the excluded globs list.\\nIf you don't want ANY of the default exclusion globs, see \"excludeGlobsOmitDefaults\".\\nSee https://forum.photostructure.com/t/1458 for details.`,\n    defaultValue: () => []\n  }),\n\n  globsCaseInsensitive: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Should \"globs\" match case-insensitively?`,\n    defaultValue: true\n  }),\n\n  respectFileExtensions: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Normally PhotoStructure uses file extensions (like .JPEG or .MP4) to perform initial file filtering, rather than examining the content of the file to determine the file format (or \"mimetype\"). If you have files that don't use valid file extensions, you can set this to false, but know that file imports will be slower.`,\n    defaultValue: true\n  }),\n\n  requireMakeModel: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"PhotoStructure can require images to have EXIF tags for Make and Model. This prevents unwanted preview images from other photo apps and screenshots from being imported. If you have images you want in your library that don't have these tags, set this to false. Note that this is ignored for video files, as those files seldom have Make and Model set (and would prevent most video files from being imported).\",\n    defaultValue: false\n  }),\n\n  rejectRatingsLessThan: new IntegerSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"Files with a metadata rating that is less than this value will not be imported into your library. Set to -100 to disable this filter.\",\n    defaultValue: 0\n  }),\n\n  keywordBlocklist: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `Any asset that contains any of these keywords will be excluded from your library. Set this to an empty array to disable this feature.`,\n    defaultValue: [\"private\"]\n  }),\n\n  minImageDimension: new IntegerSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum number of pixels an image's dimensions must meet or exceed to be imported? Note that this value is applied to both the height and width of the image. The default comes from the VGA standard of 640x480. If this is set to 0, no minimum resolution filter will be applied to photos.\",\n    defaultValue: 480\n  }),\n\n  minVideoDimension: new IntegerSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum number of pixels a video's dimensions must meet or exceed to be imported? Note that this value is applied to both the height and width of the video. The default comes from the QVGA standard of 320x240. If this is set to 0, no minimum resolution filter will be applied to videos.\",\n    defaultValue: 240\n  }),\n\n  minVideoDurationSec: new OptionalFloatSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum number of seconds for a video to be imported? If this is set to 0 or unset, no minimum duration limit will be applied.\",\n    defaultValue: 2\n  }),\n\n  maxVideoDurationSec: new OptionalIntegerSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the maximum length a video can be and still be imported? If this is set to 0 or unset, no maximum duration limit will be applied.\"\n  }),\n\n  minAssetFileSizeBytes: new IntegerSetting({\n    aliases: [\"minAssetSizeBytes\", \"minAssetSize\", \"minFileSizeBytes\"],\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum photo or video size you want imported into your library?\\nThis setting can prevent small GIFs and screenshots from being imported.\\nValues less than 1000 will be ignored.\\nA 20-year-old 1600x1200 JPEG at 50% quality is more than 150k, so 50k is a very conservative default.\",\n    defaultValue: 50 * KB\n  }),\n\n  maxAssetFileSizeBytes: new IntegerSetting({\n    aliases: [\"maxAssetSizeBytes\", \"maxAssetSize\", \"maxFileSizeBytes\"],\n    category: SettingCategories.Filters,\n    description:\n      \"What's the maximum photo or video size you want imported into your library? (This can prevent movies from being pulled into and filling up your library). A value of 0 will disable this filter.\",\n    defaultValue: 0.5 * GB\n  }),\n\n  // TODO: add this to the settings page:\n  validateJpegImages: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Should JPEG photos be validated before importing? If a JPEG has any decoding errors, and this setting is true, that file will not be imported into your library. Enabling this feature slows down imports.`,\n    defaultValue: true\n  }),\n\n  imageFailOn: new StringEnumSetting({\n    category: SettingCategories.Filters,\n    description: `How sensitive should PhotoStructure be with warnings or errors when loading images?\\nUse \"none\" to try loading images with best efforts, even if the file may be corrupt.\\nUse \"warning\" to be conservative--any defects in the image will prevent it from being imported. \\nThe default, \"truncated,\" will allow images with minor encoding defects to be imported.`,\n    defaultValue: SharpFailOns.truncated,\n    strEnum: SharpFailOns\n  }),\n\n  // TODO: add this to the settings page:\n  validateRawImages: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Should raw-format images (like NEF, CR2, ARW, and ORF) be validated before importing? If an image has any decoding errors, and this setting is true, that file will not be imported into your library.\\nNote that more recent cameras may use a raw encoding that isn't supported yet (like CR3), but PhotoStructure may still be able to import those files if full-resolution embedded images are present.\\nSee the Enabling this feature slows down imports.`,\n    defaultValue: true\n  }),\n\n  validateMimetypeSkiplist: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `If a file's mimetype matches any of these values, it will be imported without being validated. This is useful for files from cameras that may render RAW image formats that are not supported by LibRaw (yet). Note that this setting is case-insensitive.`,\n    defaultValue: () => [\"image/x-panasonic-rw2\"]\n  }),\n\n  // TODO: add this to the settings page:\n  validateVideos: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Should videos be validated before importing? If a video has any decoding errors, and this setting is true, that file will not be imported into your library. Enabling this feature slows down imports, as videos must be fully decoded (or \"played\") to be validated.`,\n    defaultValue: () => false\n  }),\n\n  validationErrorBlocklist: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `If any of the following patterns match a validation error found in a photo or video, and *doesn't* match any of the patterns in the validationErrorAllowlist, the file will be considered corrupt and not be imported into your library.\\nNote the patterns are case-insensitive, will be converted into a regular expression, and only need to partially match the error message, so, for example, a value of \"caution\" will ignore any error message that contains the string (not the word!) \"caution\".\\nAlso see \"validationErrorAllowlist\".`,\n    defaultValue: () => [\n      \"cannot decode\",\n      \"cannot determine format of input stream\",\n      \"corrupt\", // matches \"data corrupted\"\n      \"error while decoding\", // ffmpeg from truncations\n      // \"error\", maybe too lax?\n      \"failed\", // not specific enough?\n      \"invalid\",\n      \"not a jpeg file\", // Not a JPEG file\n      \"not raw file\",\n      \"nothing was written into output file\",\n      \"partial file\",\n      \"premature end of .*?file\", // Premature end of JPEG file\n      \"unsupported file format\" // corrupt or invalid RAW files\n    ]\n  }),\n\n  validationErrorAllowlist: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `All validation errors that match any of these values they will be ignored, EVEN IF they match a \"validationErrorBlocklist\" pattern, so all of these patterns should be specific enough to not cause false-negatives.\\nNote the patterns are case-insensitive, will be converted into a regular expression, and only need to partially match the error message.\\nAlso see \"validationErrorBlocklist\".`,\n    defaultValue: () => [\n      \"warning: ignored non-standard exif\",\n      \"invalid SOS parameters for sequential jpeg\",\n      \"referenced qt chapter track not found\",\n      \"non monotonically increasing dts\" // don't care about timestamps\n    ]\n  }),\n\n  //\n  // Parsing\n  //\n\n  capturedAtTags: new StringArraySetting({\n    category: SettingCategories.Parsing,\n    description: `The following tags are examined to determine when a file was captured at.\\nThe tag with the oldest valid value is returned: order here doesn't matter.\\nIf none of these tags have a valid datetime stamp, PhotoStructure will fall back to \"capturedAtTagsFallback\" tags.\\nSee https://photostructure.com/faq/captured-at/ for details.`,\n    defaultValue: DefaultCapturedAtTagsConst as any // TODO SITS TYPING\n  }),\n\n  useMWG: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `Enable Metadata Working Group composite tag reading and writing. See https://exiftool.org/TagNames/MWG.html for details.`,\n    defaultValue: true\n  }),\n\n  capturedAtTagsFallback: new StringArraySetting({\n    category: SettingCategories.Parsing,\n    description: `If none of the \"capturedAtTags\" have a valid value, PhotoStructure will fallback to look at these tags. These tags are only \"fallbacks\" as they sometimes contain spurious values.\\nSee https://photostructure.com/faq/captured-at/ for details.`,\n    defaultValue: ProblematicCapturedAtTags as any\n  }),\n\n  badDates: new StringArraySetting({\n    category: SettingCategories.Parsing,\n    description: `The following ISO values will be ignored when extracting a file's captured-at time. See https://forum.photostructure.com/t/photostructure-ignored-the-date-metadata-of-some-photos-marked-them-as-taken-in-2002/340/8 and https://forum.photostructure.com/t/incorrect-date-assigned-to-photo/419 .`,\n    defaultValue: () => [\"2002-12-08T12:00:00\"]\n  }),\n\n  defaultVideosToUTC: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `Should video created-at times be assumed to be in UTC? Most cameras use UTC (even if the timezone is set in the camera!). Set this to false to revert to pre-v2.1 behavior.`,\n    defaultValue: () => true\n  }),\n\n  defaultCopyright: new OptionalStringSetting({\n    category: SettingCategories.Parsing,\n    description: `If PhotoStructure doesn't find a value for Copyright in a source image or source video, it will apply the given string as the copyright holder.\\nThis has no default.`\n  }),\n\n  likeRating: new IntegerSetting({\n    category: SettingCategories.Parsing,\n    description: `What's the minimum \"rating\" for an asset to be considered \"liked\"?\\nKnow that metadata \"ratings\" are stored in both EXIF and XMP \"Rating\" and \"RatingPercent\" tags. Ratings are typically encoded as a value between -1 and 5 (where -1 is used by some DAMs to mark \"rejected\").\\nPhotoStructure will prefer the XMP Rating tag.\\nIf the only tag with a rating is a \"RatingPercent\", it will be converted to a 5-point scale.\\nIf you want only ratings of 5 to be considered a \"liked\" asset, set this to 5.\\nThis value will be used when assets are liked via the PhotoStructure UI.\\nNote that PhotoStructure doesn't import assets with a negative Rating (to respect the \"rejected\" rating).`,\n    defaultValue: () => 3\n  }),\n\n  lensMakes: new StringArraySetting({\n    category: SettingCategories.Parsing,\n    description: `Used to extract and parse lens metadata (useful when Google Takeout has stripped metadata).`,\n    defaultValue: () => DefaultLensMakes\n  }),\n\n  extraDateTimeFormats: new StringArraySetting({\n    category: SettingCategories.Parsing,\n    description: `These formats are used to parse datetime strings in EXIF metadata and in file pathnames. See https://moment.github.io/luxon/#/formatting?id=table-of-tokens for a description of these tokens.`,\n    defaultValue: () => DefaultDateTimeFormats\n  }),\n\n  fuzzyDateParsing: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, PhotoStructure will first attempt to parse datetime strings with strict ISO-compliant parsers, and then use additional, \"fuzzy\" datetime parsers. When disabled, only ISO-compliant parsers are used.`,\n    defaultValue: true\n  }),\n\n  fuzzyYearParsing: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, PhotoStructure will use directories starting with a number that looks year-like (four digits, 1826-the present) to infer the captured-at time, if all other date parsers have failed. Note that setting this to true \"forces\" the \"fuzzyDateParsing\" setting to be true.\\nTo elaborate: PhotoStructure first looks for metadata with a date, then looks for an ISO-compliant YMD timestamp in the filename or path, and then, if \"fuzzyDateParsing\" or this setting is enabled, a YMD or YM datestamp, and then finally, if this setting is enabled, it looks for a directory that begins with a number that is between 1826-2020.`,\n    defaultValue: false\n  }),\n\n  twoDigitCutoffYear: new IntegerSetting({\n    category: SettingCategories.Parsing,\n    description: `If \"yy\" is used in extraDateTimeFormats, and a year is only 2 digits, what threshold value should be used to consider the date to be in the 1900s vs 2000s?\\nAs an example, a value of \"50\" would make \"49\" be interpreted as 1949, and \"50\" as 2050.\\nSee https://moment.github.io/luxon/api-docs/index.html#settingstwodigitcutoffyear for details.\\nThis defaults to 3 years in the future (modulus 100) and is updated automatically.`,\n    defaultValue: () => (new Date().getFullYear() + 3) % 100\n  }),\n\n  minValidYear: new IntegerSetting({\n    category: SettingCategories.Parsing,\n    description: `If PhotoStructure encounters a year that is less than this value, it will consider that source to be invalid and look elsewhere for the captured-at date for that given file.\\nFor what it's worth, 1826 is the first year a photograph was captured (see https://en.wikipedia.org/wiki/History_of_photography ), and KODAK Brownies were available in 1900 (see https://en.wikipedia.org/wiki/Kodak_Brownie ).\\nYou should set this to the earliest year you expect to find in your library.`,\n    defaultValue: MinValidYear\n  }),\n\n  useStatToInferDates: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, and the \"captured-at\" time isn't found in metadata, PhotoStructure will also look for the captured-at datetime encoded in the file \"birthtime\" (on Windows), or the lesser value of \"mtime\" and \"ctime\" (on macOS and Linux). Note that these values are not very reliable, as file transfers and backups frequently don't retain these values correctly.`,\n    defaultValue: true\n  }),\n\n  usePathsToInferDates: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, and the \"captured-at\" time isn't found in metadata, PhotoStructure will also look for the captured-at datetime encoded in file paths.`,\n    defaultValue: true\n  }),\n\n  useLibraryDirsToInferDates: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, and the \"captured-at\" time isn't found in metadata, PhotoStructure will also look for the captured-at datetime encoded in file paths *for files that are in your PhotoStructure library. This defaults to false, as prior versions of PhotoStructure may have placed files into incorrect datestamped directories.`,\n    defaultValue: false\n  }),\n\n  backfillTimezones: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `Should we try to backfill timezones for date-times that don't have them? If set to true, and {@link defaultVideosToUTC} is also true, we'll try backfilling timezones for date-times that are UTC, as well.\\nSetting this to false removes **all** timezone inference--only those date-times with an explicit offset will have a defined timezone.\\nPrior versions of exiftool-vendored would use the file's \".tz\" as a backstop even if this was set to false.\\nAs of version 2023.10, this now defaults to true, as it's more likely to be what people expect.`,\n    defaultValue: true\n  }),\n\n  inferTimezoneFromDatestamps: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `We always look at {@link Tags.TimeZone}, {@link Tags.OffsetTime}, {@link Tags.TimeZoneOffset}, {@link Tags.OffsetTimeOriginal}, {@link Tags.OffsetTimeDigitized}, and GPS metadata to infer the timezone.\\nIf these strategies fail, and this is enabled, we'll try to infer the timezone from non-UTC datestamps included in the {@link capturedAtTags} and {@link capturedAtTagsFallback} settings.\\nThis defaults to true as of version 2023.10.`,\n    defaultValue: true\n  }),\n\n  /**\n   * @deprecated\n   */\n  enableSiblingInference: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `This setting has been replaced by the \"siblingInference\" setting. \"true\" is equivalent to \"auto\", and \"false\" is equivalent to \"never\".`,\n    defaultValue: true,\n    deprecated: true\n  }),\n\n  siblingInference: new StringEnumSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, and the \"captured-at\" time, Make, or Model isn't found in metadata, PhotoStructure will try to use nearby files to \"fill in the blanks.\" If this is set to \"auto\", this is disabled automatically for slow directories. If this is set to \"always\", even files in slow directories will have tag inference, when necessary. Set to \"never\" to disable.`,\n    strEnum: TagInferenceSettingValues,\n    defaultValue: TagInferenceSettingValues.auto\n  }),\n\n  siblingInferenceBasenameCoeff: new FloatSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum case-insensitive Sørensen–Dice similarity index between file basenames, without the extension, to be used for sibling inference?\\n0 will accept all siblings, 1 will only accept exact matches.\",\n    defaultValue: 0.6 // tests fail with 0.65\n  }),\n\n  writeInferredTagsToLibraryCopies: new BooleanSetting({\n    category: SettingCategories.Parsing,\n    description: `When enabled, inferred metadata will be stored as _actual_ metadata in the library copy.`,\n    defaultValue: true\n  }),\n\n  //\n  // Tagging\n  //\n\n  recountAllTags: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should all tags be recounted? PhotoStructure normally only recounts tags that have had assets recently added or removed, unless there are more than 20 changed tags.`,\n    defaultValue: false,\n    transient: true\n  }),\n\n  tagCamera: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with cameras' make and model?`,\n    defaultValue: true\n  }),\n\n  tagLens: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with lens' make and model?`,\n    defaultValue: true\n  }),\n\n  tagFullLensModel: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should PhotoStructure tag assets with the full lens model (like \"Canon EF-M 15-45mm f/3.5-6.3 IS STM\") or a just the lens information (\"15-45mm f/3.5-6.3\")? (If you change this value, you'll need to \"Rebuild\" your library to make the setting take effect).`,\n    defaultValue: true\n  }),\n\n  tagYMD: new StringEnumSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with \"When > Year\" (the \"y\" option), or \"When > Year > Month\" (the \"ym\" option), or \"When > Year > Month > Day\" (the \"ymd\" option)? Setting this to \"\" will disable date tagging.`,\n    defaultValue: DateTagFormats.ym,\n    strEnum: DateTagFormats\n  }),\n\n  tagDateFromStat: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should PhotoStructure tag assets with a date if the captured at time was only found in filesystem metadata? Filesystem metadata is not as reliable as EXIF metadata, as it can be changed arbitrarily when files are backed up.`,\n    defaultValue: () => (isTest() ? false : true)\n  }),\n\n  tagKeywordsFromPath: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with keywords extracted from file pathnames?`,\n    defaultValue: true\n  }),\n\n  tagKeywordsFromMetadata: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with keywords extracted from file metadata, as well as sidecar metadata?`,\n    defaultValue: true\n  }),\n\n  keywordTags: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure should look in the following tags for keywords. Note that these values are case-sensitive.`,\n    defaultValue: () => [\n      \"CatalogSets\",\n      \"Categories\",\n      \"HierarchicalSubject\",\n      \"Keywords\",\n      \"LastKeywordXMP\",\n      \"Subject\",\n      \"TagsList\",\n      \"XPKeywords\"\n    ]\n  }),\n\n  keywordReparenting: new StringEnumSetting({\n    category: SettingCategories.Tagging,\n    description: `How should PhotoStructure handle hierarchical keywords?\\nIf this is set to \"move\", PhotoStructure will try to put hierarchical keywords into their \"correct\" root tag, like \"Who,\" \"Album,\" or \"Where.\"\\nIf this is set to \"retain,\" PhotoStructure will always place hierarchical keywords under the \"Keyword\" root tag.\\nIf this is set to \"copy,\" PhotoStructure will add both the \"correct\" root tag _and_ the \"Keyword\" tag. For example, \"Person|Doe|Jane\" will be tagged as \"Who|Doe|Jane\" as well as \"Keyword|Person|Doe|Jane\".\\nSee https://forum.photostructure.com/t/prefix-for-keywords-tag/499 for details.`,\n    defaultValue: KeywordReparentingStrategies.move,\n    strEnum: KeywordReparentingStrategies\n  }),\n\n  rootTagAlbumsAliases: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List hierarchical tag roots that PhotoStructure should interpret to be album names. This is matched case-insensitively.`,\n    defaultValue: () => [\"Album\", \"Albums\"]\n  }),\n\n  rootTagKeywordsAliases: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List hierarchical tag roots that PhotoStructure should interpret to be keywords. This is matched case-insensitively.`,\n    defaultValue: () => [\"Keyword\", \"Keywords\", \"Tag\", \"Tags\"]\n  }),\n\n  rootTagWhoAliases: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    aliases: [\"tagWhoSynonyms\"],\n    description: `When hierarchical tag values are found with any of these root names PhotoStructure will replace the root with \"Who\".\\nFor example, using default values, \"People/Jane Doe\" will be replaced with \"Who/Jane Doe\" (or \"Who/Doe/Jane\", if tagNamesFormatter=\"family/given\").\\nDigicam uses \"People\". This is matched case-insensitively.`,\n    defaultValue: () => [\"Person\", \"People\", \"Face\", \"Faces\"]\n  }),\n\n  keywordDelimiters: new OptionalStringSetting({\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure splits apart keywords, by default, when they are delimited by a comma or semicolon. For example, \"car, blue, tree\" will be interpreted as having the keywords \"car\", \"blue\", and \"tree\".\\nNote that some software doesn't encode lists of keywords properly, so we have to include the comma and semicolon by default to handle these cases: but this makes keywords that contain a comma be split incorrectly. If the files in your library don't have this encoding issue, you can replace this setting with just an empty string to disable splitting.\\nSee https://forum.photostructure.com/t/incorrect-handling-of-keywords-with-comma/992 for more discussion.\\nAfter changing this value, you must force-resync your library for the changes to take affect.`,\n    defaultValue: \",;\"\n  }),\n\n  keywordPathSeparators: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure interprets keywords as hierarchical if a path separator character is found in a keyword. This allows for tags like \"Family/Einstein/Albert\", \"Flora|Fruit|Orange\", \"Objects⊃Tools⊃Hammer\", or \"Fauna>Oceanic>Pelican\". By default, these separators are the forward-slash, vertical-bar, and greater-than characters. If you don't want to interpret keywords as hierarchical, change this value to an empty string (\"\"). After changing this value, you must force-resync your entire library for the changes to take affect.`,\n    defaultValue: \"/|>⊃\" // 20200307: thought about and discarded the idea of including \"›\" and \"»\". \"⸧\" isn't in iOS. 20201201: Also deleted \"≻\".\n  }),\n\n  tagFileType: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    aliases: [\"tagType\"],\n    description: `Should assets be tagged with their file type (like \"Type/Image/JPEG\")?`,\n    defaultValue: true\n  }),\n\n  tagJsonFaces: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Google Takeout provides .json sidecars that may contain the names of the people (or pets) found in the image. Should PhotoStructure import these tags under \"Who\"?.`,\n    defaultValue: true\n  }),\n\n  tagFaceRegions: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Picasa and other software supports embedding face names within \"RegionInfo.RegionList.Name\" metadata. If this setting is enabled, and \"RegionInfo.RegionList.Type\" is \"Face\", PhotoStructure will import these tags under \"Who\".`,\n    defaultValue: true\n  }),\n\n  whoTags: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    aliases: [\"tagWhoNames\"],\n    description: `This is a list of tags that will be examined for strings or string arrays. All values associated to these fields will be interpreted as names. Note that \"dotted notation\" is supported.`,\n    defaultValue: [\n      \"People\",\n      \"PersonInImage\",\n      \"PersonInImageWDetails.PersonName\",\n      \"PersonInImageName\",\n      \"RegionInfoMP.Regions.PersonDisplayName\"\n    ]\n  }),\n\n  tagNamesFormatter: new StringEnumSetting({\n    category: SettingCategories.Tagging,\n    description: `How should PhotoStructure format the \"Who\" tags for assets whose files are tagged with \"people\" strings?\\n- \"as-is\" will tag names directly to \"Who\", so, \"Who/Albert Einstein\".\\n- \"family/given\" will tag \"Who/Einstein/Albert\" (for regions that provide given names first).\\n- \"family/fullname\" will tag \"Who/Einstein/Albert Einstein\".\\nThe default is \"as-is,\" because discerning given and family names aren't reliably inferable.\\nSee https://en.wikipedia.org/wiki/Personal_name#Name_order .`,\n    defaultValue: NameTagFormats[\"as-is\"],\n    strEnum: NameTagFormats\n  }),\n\n  tagNamesDefaultFamily: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If a name is missing a family name, if this value is not blank, it will be provided as a default. If this value is blank, the name tag will be Who/given. Note that this setting is only used if \"tagNamesFormatter\" is set to \"family/given\".`,\n    defaultValue: \"-\"\n  }),\n\n  tagNamesCapitalizedAsFamily: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Assume uppercased names are family names (this is common practice in geneology).`,\n    defaultValue: true\n  }),\n\n  tagNamesOrder: new StringEnumSetting({\n    category: SettingCategories.Tagging,\n    description: `How should PhotoStructure parse people's names? Note that this setting is only used if \"tagNamesFormatter\" is set to \"family/given\". See https://en.wikipedia.org/wiki/Personal_name#Name_order .`,\n    defaultValue: \"western\",\n    strEnum: NameTagOrders\n  }),\n\n  tagNamesSurnamePrefixes: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List all family name prefixes to be considered part of the family name. These are matched case-insensitively. This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: () => [\n      \"A\",\n      \"D’\",\n      \"Da\",\n      \"De la\",\n      \"De las\",\n      \"De\",\n      \"Del\",\n      \"Della\",\n      \"Den\",\n      \"Des\",\n      \"Di\",\n      \"Du\",\n      \"La\",\n      \"Las\",\n      \"Le\",\n      \"Li\",\n      \"Lo\",\n      \"Mc\",\n      \"Mac\",\n      \"op de\",\n      \"ten\",\n      \"ter\",\n      \"Van ‘t\",\n      \"van de\",\n      \"van der\",\n      \"van\",\n      \"von der\",\n      \"von\",\n      \"z\",\n      \"zu\"\n    ]\n  }),\n\n  tagNamesSurnames: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List all family names you expect in tags that are not single words that are found at the end of a tagged name. Hyphenated family names (like \"Ocasio-Cortez\") do not need to be listed here: only compound family names, and if your language doesn't separate family names with whitespace. In the latter case, either include all family names, or include all givenNames (whatever's easier for you). This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: () => []\n  }),\n\n  tagNamesGiven: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List all given names you expect in tags that are not single words. Hyphenated given names (like \"Rose-Ann\") do not need to be listed here. If your language doesn't separate family names and given names with whitespace, either include all given names, or include all familyNames (whatever's easier for you). This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: () => []\n  }),\n\n  // TODO:\n\n  // tagNamesGivenIgnored: new StringArraySetting({\n  //   category: SettingCategories.Tagging,\n  //   description: `These given names will always be ignored. This setting is case-insensitive.`,\n  //   defaultValue: () => []\n  // }),\n\n  // tagNamesFamilyIgnoredPrefixes: new StringArraySetting({\n  //   category: SettingCategories.Tagging,\n  //   description: `These strings will be stripped from family names, so \"Michelle LaVaughn Obama (née Robinson)\" doesn't get interpreted as having a maiden name of \"née Robinson\". This setting is case-insensitive.`,\n  //   defaultValue: () => [\"née\", \"nee\"]\n  // }),\n\n  tagNamesFamilySurrounds: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `This setting contains pairs of characters. When name portions are surrounded by these pairs, the contents will be added as a family name. As an example, if you use the default \"()\", then \"Michelle LaVaughn (Robinson) Obama\" will be name tagged with both \"Who/Robinson/Michelle LaVaughn\" and \"Who/Obama/Michell LaVaugn\". This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: [\"()\"]\n  }),\n\n  tagNamesGivenSurrounds: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `This setting contains pairs of characters. When name portions are surrounded by these pairs, the contents will be added to the end of the given name with the surrounds retained. As an example, if you use the defaults of \"[]\" and double-quotes, then \"Joe \"Joey\" Smith\" will be name tagged with Who/Smith/Joe \"Joey\". This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: [\"[]\", '\"\"']\n  }),\n\n  tagNamesLexical: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Assume any name with a comma is in \"lexical name order\", which is always \"lastname, given name(s)\". If the given name is found to be \"sr.\", \"senior\", \"jr.\", or \"junior\", the name will be considered to be in western order ($givenNames $familyName, $modifier), and the $modifier will be added to the $givenNames. If this is set to false, commas are ignored.`,\n    defaultValue: true\n  }),\n\n  excludedRootTags: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `Keywords starting with the given roots will be omitted from your PhotoStructure library. Changing this value requires a library rebuild.`,\n    defaultValue: () => [\"http:\", \"https:\", \"file:\"]\n  }),\n\n  tagDisplayNameFS: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `What should PhotoStructure call the \"root\" tag for browsing by filesystem paths? Note that this value is only for the UI, and will update the \"_displayName\" of the /fs/ tag: this value won't change the URL path from be \"/tag/fs/.../\". Reasonable options that have been suggested include \"Folder\", \"Directory\", \"Drive\", \"File\", \"Path\", \"Volume\", or \"Computer\".`,\n    defaultValue: \"Folder\"\n  }),\n\n  tagDisplayNameFSRoot: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `On POSIX systems, how should PhotoStructure reference the \"root\" directory (/)? \"/\" is a bit confusing, so \"root\" may be less confusing? Also see \"tagDisplayNameFSRootWithHostname\".`,\n    defaultValue: \"root\"\n  }),\n\n  tagDisplayNameFSRootWithHostname: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `On non-docker hosts (which typically don't have reliable hostnames), should the root directory tag have the hostname appended?`,\n    defaultValue: () => (isTest() ? true : !isDocker())\n  }),\n\n  tagDisplayNameFSLabels: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should PhotoStructure use volume labels, if available, as display names for filesystem tags? As an example, instead of showing \"Folder / D:\", you'd see \"Folder / Photo backup #3\" (or whatever the label D: has).`,\n    defaultValue: true\n  }),\n\n  tagAlbumFilenames: new StringArraySetting({\n    aliases: [\"tagAlbumJsonFilenames\"],\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure will look for files in the same directory with these names for album metadata. This can be JSON, XMP, MIE, or EXIF encoded, and is case-sensitive.\\nSet this to an empty array (\"[]\") to disable this feature.`,\n    defaultValue: [\"metadata.json\"]\n  }),\n\n  tagAlbumTitle: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If you have enabled \"tagAlbumFromJson\", what's the name of the field encoded in the album file? Object hierarchies are separated with a \".\".`,\n    defaultValue: \"albumData.title\"\n  }),\n\n  tagAlbumTitleHierarchies: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `If true, album titles will be split as hierarchical keywords. If false, album titles will not be split, and all albums will be under the \"Albums\" root tag.`,\n    defaultValue: false\n  }),\n\n  tagAlbumDescription: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If you have enabled \"tagAlbumFromJson\", what's the name of the field encoded in the album file? Object hierarchies are separated with a \".\".`,\n    defaultValue: \"albumData.description\"\n  }),\n\n  tagAlbumDate: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If you have enabled \"tagAlbumFromJson\", what's the name of the field encoded in the album file? Object hierarchies are separated with a \".\".`,\n    defaultValue: \"albumData.date\"\n  }),\n\n  tagAlbumsExcluded: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `For \"metadata.json\" albums, some are automatically generated. If the title or description includes any given string, it will be ignored.`,\n    defaultValue: [\"Album for automatically uploaded content\"]\n  }),\n\n  omitAncestorTags: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure's hierarchical tags assume implicit inheritance: that is, if you tag an asset with \"nature/sky\", \"nature\" is implicitly assumed.\\nIf this setting is true, PhotoStructure will omit tags that are already inferred from deeper descendant tags--that is, if an asset is tagged with \"nature/sky\" and \"nature\", and this setting is true, the \"nature\" tag will be omitted.`,\n    defaultValue: true\n  }),\n\n  // TODO:\n  // tagColor: new BooleanSetting({\n  //   name: \"tagColor\",\n  //   key: \"PS_TAG_COLOR\",\n  //   category: SettingCategories.Tagging,\n  //   description: `Should assets be tagged with their dominant color (like \"Color/Yellow\")?`,\n  //   defaultValue: true,\n  //   persisted: true\n  // }),\n\n  //\n  // Subscriptions\n  //\n\n  subscriptionTimeoutMs: new DurationSetting({\n    category: SettingCategories.Subscriptions,\n    description: `How long can PhotoStructure spend trying to gather system metadata and validating subscription licenses? This is fairly short, as the user is presumably waiting for PhotoStructure to spin up. If you have a slow system, you may want to increase this value.`,\n    defaultValue: () => \"7s\"\n  }),\n\n  pickPlanOnWelcome: new BooleanSetting({\n    category: SettingCategories.Subscriptions,\n    description: `If set to true, the welcome page flow will redirect to https://account.photostructure.com/plans to have you pick between a \"PLUS\" and \"LITE\" plan. If set to false, the welcome page will continue directly to the settings page with a \"LITE\" plan. You can still upgrade to a paid plan later from the main menu or the about page, even if this is false.`,\n    defaultValue: true\n  }),\n\n  coupon: new OptionalStringSetting({\n    category: SettingCategories.Subscriptions,\n    description: `Coupon to automatically apply during subscription setup. This value will be ignored if you've already gone through the subscription setup flow.\\nThe example value is a valid coupon code: thanks for reading!)\\nNote that you can apply a coupon after your free trial starts by visiting https://account.photostructure.com .`,\n    exampleValue: () => \"RTFM15\"\n  }),\n\n  autoRefreshLicense: new BooleanSetting({\n    category: SettingCategories.Subscriptions,\n    description: `PhotoStructure uses cryptographically signed licenses to locally store your current plan subscription status. These licenses are only valid for the current subscription period, and must be refreshed when your subscription renews or converts from a free trial to a paid subscription. To minimize the hassle of license renewals, PhotoStructure can automatically renew expired licenses in the background.\\nIf the current license has expired and this value is true, PhotoStructure will make one secure POST request to https://account.photostructure.com/ that contains several lossy one-way hashes of current system metadata. We hash all identifying metadata to only 15 characters to alleviate any privacy concerns. If your plan subscription is active, a new license will be added to your library.\\nSet this to false and set the \"reportErrors\" setting to false if you don't want PhotoStructure \"phoning home\" for any reason.\\nNote that if this is disabled, license renewals will require manual intervention: click \"Upgrade\" from the main menu, pick your plan, authenticate, and the license will automatically refresh.`,\n    defaultValue: true\n  }),\n\n  license: new OptionalStringSetting({\n    category: SettingCategories.Subscriptions,\n    sensitive: true,\n    description: `Subscription licenses are normally saved automatically into both your library and system configuration directories. This setting just provides users with an alternative way to provide a license, if it's more convenient. Any value provided to this setting will be considered in addition to existing license files when PhotoStructure is trying to find the \"best\" license available.`\n  })\n}\n\n// First set everyone's name:\nfor (const [k, v] of entries(Settings)) {\n  v._setName(k)\n}\n\n/**\n * Force the given path-separated paths to be the suggested values on the\n * welcome page.\n */\nexport const SuggestedDirsEnvKey = \"SUGGESTED_DIRS\"\n\n// Only exported for testing:\nexport function withDefaultPaths(paths: Maybe<string>): string {\n  const arr = (blank(paths) ? \"\" : paths).split(delimiter)\n  if (isDocker()) {\n    arr.unshift(\"/opt/photostructure/tools/bin\")\n  }\n  arr.push(...Settings.toolPaths.valueOrDefault)\n  return uniq(arr).filter(notBlank).join(delimiter)\n}\n\n// use getEnv(), not env().PATH, because Windows can use \"Path\"\nexport const pathWithDefaults = lazy(() => withDefaultPaths(getEnv(\"PATH\")))\n\nexport const allSettings = lazy(() => {\n  return sortBy(values(Settings), settingsSorter)\n})\n\nexport const persistedSettings = lazy(() => {\n  return allSettings().filter(ea => !ea.transient)\n})\n\nexport const transientSettings = lazy(() => {\n  return allSettings().filter(ea => ea.transient)\n})\n\nexport const persistedSystemSettings = lazy(() => {\n  return persistedSettings().filter(ea =>\n    SystemCategories.includes(ea.category)\n  )\n})\n\nexport const persistedLibrarySettings = lazy(() => {\n  return persistedSettings().filter(ea =>\n    LibraryCategories.includes(ea.category)\n  )\n})\n\nfunction settingsSorter(s: Setting<any>) {\n  return [\n    s.categoryType === \"system\" ? 0 : 1,\n    SettingCategories.indexOf(s.category) ?? SettingCategories.length + 1,\n    s.advanced,\n    s.name\n  ]\n}\n\nconst SettingsByNameOrKey = lazy(() => {\n  const settings = new CaseInsensitiveMap<Setting>()\n  for (const s of persistedSettings()) {\n    // Support both logLevel, log_level, and PS_LOG_LEVEL:\n    for (const ea of s.names) {\n      settings.set(ea, s)\n    }\n    for (const ea of s.keys) {\n      settings.set(ea, s)\n    }\n  }\n  return settings\n})\n\nexport function getSettingByNameOrKey(s: string) {\n  return SettingsByNameOrKey().get(toS(s).toLowerCase())\n}\n\nexport const ciSettings = lazy(\n  () => new CaseInsensitiveValued(Settings, (_, s) => [...s.names, ...s.keys])\n)\n\n// later(() => {\n//   if (isTest) {\n//   caseInsensitiveEnv.watchLater(() =>\n//     values(Settings).forEach(ea => ea.refreshEnvValue())\n//   )\n// })\n","import { lazy } from \"../../core/Lazy\"\nimport { isProd, isTest } from \"../NodeEnv\"\nimport { defaultCacheDir } from \"../dir/CacheDir\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { DefaultDockerLibraryDir } from \"../dir/DefaultDockerLibraryDir\"\nimport {\n  defaultLibraryDir,\n  defaultOriginalsDir\n} from \"../dir/DefaultLibraryDir\"\nimport { defaultLogDir_ } from \"../dir/LogDir\"\nimport { defaultPicturesDir } from \"../dir/PicturesDir\"\nimport { isEnvTrue } from \"../env/GetEnv\"\nimport { DefaultSharedStateDir } from \"../event/DefaultSharedStateDir\"\nimport { useFsWatch } from \"../fs/BaseFile\"\nimport { DefaultPaths, DefaultPosixPaths } from \"../fs/DefaultPaths\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { maxCpus } from \"../work/MaxCpus\"\nimport { Settings } from \"./Settings\"\n\n// This file was extracted to prevent Settings-related dependency loops.\n\n// Note that we're actually changing .opts.defaultValue here--it's the \"real\"\n// default.\n\nexport const setSettingsDefaults = lazy(() => {\n  Settings.configDir.opts.defaultValue = configDir\n\n  Settings.logDir.opts.defaultValue = defaultLogDir_\n\n  Settings.logServerLevel.opts.defaultValue = () =>\n    Settings.logLevel.valueOrDefault\n\n  Settings.cacheDir.opts.defaultValue = defaultCacheDir\n\n  Settings.sharedStateDir.opts.defaultValue = () =>\n    DefaultSharedStateDir()?.nativePath\n\n  Settings.toolPaths.opts.defaultValue = () =>\n    (isEnvTrue(\"SETTINGS_IO_TEST\" as any)\n      ? DefaultPosixPaths\n      : DefaultPaths) as string[]\n\n  Settings.libraryDir.opts.exampleValue = () =>\n    isProd && isDocker()\n      ? DefaultDockerLibraryDir\n      : isTest\n      ? \"/home/test/Pictures\"\n      : defaultPicturesDir()\n\n  Settings.libraryDir.opts.defaultValue = defaultLibraryDir\n\n  Settings.originalsDir.opts.defaultValue = defaultOriginalsDir\n\n  Settings.scanPaths.opts.exampleValue = () => [defaultPicturesDir()]\n\n  Settings.powerShellProcs.opts.defaultValue = () =>\n    Math.max(2, Math.round(maxCpus() / 4))\n\n  // This breaks a deploop between Settings and BaseFile:\n  Settings.useFsWatch.watch(useFsWatch)\n})\n","import { lazy } from \"../../core/Lazy\"\nimport { compact, isNotEmpty, mapNotEmpty, toNotEmpty } from \"../../fe/Array\"\nimport { sort } from \"../../fe/ArraySort\"\nimport { blank, firstNotBlank, toNotBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { eql } from \"../../fe/Eql\"\nimport { shortStack } from \"../../fe/Error\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { orList } from \"../../fe/FmtList\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map, mapOr } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { entries, values } from \"../../fe/Object\"\nimport { padding } from \"../../fe/Pad\"\nimport { trimRight } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { capitalize, wrap } from \"../String\"\nimport { camel2snake } from \"../StringCase\"\nimport { version } from \"../Version\"\nimport {\n  libraryDataDirPosixFile,\n  setupLibraryDataDir_\n} from \"../dir/LibraryDirs\"\nimport { errorToS } from \"../error/Error\"\nimport { ee } from \"../event/EventEmitter\"\nimport { BaseFile } from \"../fs/BaseFile\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { baseVersion } from \"../version/PhotoStructureVersion\"\nimport { handleDeprecatedSettings, handleMetaSettings } from \"./MetaSettings\"\nimport { Setting, settingsToObj } from \"./Setting\"\nimport { LibraryCategories, SystemCategories } from \"./SettingCategory\"\nimport {\n  Settings,\n  ciSettings,\n  getSettingByNameOrKey,\n  persistedLibrarySettings,\n  persistedSettings,\n  persistedSystemSettings\n} from \"./Settings\"\nimport { setSettingsDefaults } from \"./SettingsDefaults\"\nimport { SettingsToml } from \"./SettingsToml\"\nimport { systemSettingsFile } from \"./SystemSettings\"\nimport { readTomlFile_ } from \"./Toml\"\nimport { valueToS } from \"./ValueToS\"\nimport { WrapComments } from \"./WrapComments\"\n\nconst logger = lazy(() => mkLogger(\"settings.SettingsIO\"))\n\nexport function librarySettingsFile(\n  libraryDir?: Maybe<string | PosixFile>\n): Maybe<PosixFile> {\n  return libraryDataDirPosixFile(libraryDir)?.join(SettingsToml)\n}\n\nexport const readSettings = lazy(async () => {\n  await readSystemSettings()\n  if (libraryHasSettings()) {\n    await readLibrarySettings()\n  }\n}, minuteMs)\n\n// Called by Service.setup:\nexport async function readSystemSettings(\n  settingsFile: Maybe<string | SimpleFile> = systemSettingsFile()\n) {\n  if (settingsFile == null) return\n  return _readSettings(BaseFile.for(settingsFile))\n}\n\nexport async function envOrSavedLibraryDir() {\n  return Settings.libraryDir.valueOrDefault ?? savedLibraryDir()\n}\n\nexport async function savedLibraryDir(): PromiseMaybe<string> {\n  try {\n    return toNotBlank(\n      (await readTomlFile_(systemSettingsFile()))?.[Settings.libraryDir.name]\n    )\n  } catch {\n    return\n  }\n}\n\nexport async function systemSettingsVersion(): PromiseMaybe<string> {\n  return readSettingsVersion(systemSettingsFile())\n}\n\nexport async function librarySettingsVersion(\n  libraryDir?: Maybe<string>\n): PromiseMaybe<string> {\n  return map(librarySettingsFile(libraryDir), ea => readSettingsVersion(ea))\n}\n\n// MUST BE CALLED AFTER SYSTEM SETTINGS HAVE BEEN READ\nexport async function maybeUpgradeSystemSettings() {\n  // write system settings if they are missing or outdated.\n  if (version !== (await systemSettingsVersion())) {\n    await writeSystemSettings_()\n  }\n}\n\nexport async function maybeUpgradeLibrarySettings() {\n  if (libraryHasSettings() && version !== (await librarySettingsVersion())) {\n    await writeLibrarySettings_()\n  }\n}\n\nexport const libraryHasSettings = lazy(() => _libraryHasSettings())\n\n// we don't want to unset this, as it is watched by HealthCheck--and .unset()\n// will set it to null, and then immediately set it to true as soon as someone\n// calls it again.\nlibraryHasSettings.unset = () => {\n  logger().error(\"libraryHasSettings.unset() is invalid\", shortStack())\n}\n\nfunction onSettingsChange() {\n  // we don't want to unset this, as it is watched by HealthCheck--and\n  // .unset() will set it to null, and then immediately set it to true\n  // again.\n  libraryHasSettings.refresh()\n}\n\nlater(() => {\n  ee().on(\"clearCache\", onSettingsChange)\n  ee().on(\"settingsChanged\", onSettingsChange)\n  Settings.libraryDir.watchLater(onSettingsChange)\n})\n\n// This needs to be sync for WebService and MenuItems:\nexport function _libraryHasSettings(libraryDir?: string): boolean {\n  const lsf = librarySettingsFile(libraryDir)\n  return logger().tap({\n    msg: \"_libraryHasSettings\",\n    result: lsf?.clear().existsSync() ?? false,\n    level: \"info\",\n    meta: {\n      libraryDir,\n      settings: Settings.libraryDir.valueOrDefault,\n      librarySettingsFile: lsf?.nativePath\n    }\n  })\n}\n\nconst VersionRE = /^# PhotoStructure v(?<version>\\d+\\.\\d+\\.\\d+(?:-\\S+)?)$/i\n\nasync function readSettingsVersion(\n  file: Maybe<string | SimpleFile>\n): PromiseMaybe<string> {\n  if (blank(file)) return\n  const match = await BaseFile.for(file).firstMatchingLine(VersionRE)\n  return match?.groups?.version\n}\n\nasync function writeToml_(file: PosixFile, settings: Setting<any>[]) {\n  if (file == null) {\n    logger().warn(\"writeToml(): null file, failed to write settings\", {\n      file,\n      settings\n    })\n    return\n  }\n  const wip = await file.clear().isNonEmpty()\n  const dest = wip ? file.wip() : file\n  await _writeToml_(dest, settings)\n  logger().info(\"writeToml(): wrote settings\", {\n    dest,\n    file,\n    nonDefaults: settingsToObj(settings),\n    wip\n  })\n\n  if (wip) {\n    const a = await readTomlFile_(dest)\n    const b = await readTomlFile_(file)\n    if (!eql(a, b)) {\n      logger().info(\"Archiving prior, different contents\", { dest, file })\n      await file.renameYMDHMS_({ subdir: \"old\" })\n      await dest.unwip_()\n    } else {\n      logger().info(\"Equivalent contents\", { dest, file, a, b })\n      await dest.unlink()\n    }\n  }\n}\n\n// This is lazy so that SettingIO.spec can force version to an expected value:\nexport const versionForSettings = lazy(() => version)\n\nasync function _writeToml_(\n  file: BaseFile,\n  settings: Setting<any>[]\n): Promise<void> {\n  // const priorValues: JsonMap = {}\n  // for (const ea of priors) {\n  //   const prior = await readTomlFile(ea)\n  //   logger().info(\"writeToml(): importing \" + ea, prior)\n  //   assignFields(priorValues, prior)\n  // }\n  // logger().info(\"writeToml(): final prior values:\", priorValues)\n\n  const lines: string[] = [padding(\"#\", 80)]\n  lines.push(\n    ...wrapComments(\n      \"\",\n      \"Howdy!\",\n      \"\",\n      `These are ${settings[0].categoryType} settings for PhotoStructure.`,\n      \"\",\n      \" - Please shut down PhotoStructure before editing this file.\",\n      \"\",\n      \" - PhotoStructure has TWO settings files! See\",\n      \"   https://photostructure.com/getting-started/advanced-settings/#omg-why-2\",\n      \"   to see why.\",\n      \"\",\n      ` - NOTE: lines starting with a \"#\" are commented out.`,\n      \"\",\n      ` - To override a setting, uncomment the line by removing the \"# \" from`,\n      `   the beginning of the line, and change the value.`,\n      \"\",\n      ` - All duration settings end with \"Duration\" or \"Ms\" (for milliseconds).`,\n      `   See https://photostructure.com/getting-started/advanced-settings#duration`,\n      `   for details.`,\n      \"\",\n      ` - See https://photostructure.com/settings/ for more documentation.`,\n\n      \"Thanks for using PhotoStructure! Visit https://forum.photostructure.com/ if you find any bugs or have any questions, ideas, or feedback. We'd love to hear from you.\",\n      \"\",\n      \"-- \", // old email signature!\n      \"\",\n      // DON'T EDIT THIS! WE USE IT TO CHECK THE VERSION! See `VersionRE` above\n      \"PhotoStructure v\" + versionForSettings()\n    )\n  )\n\n  lines.push(\"\", \"\")\n\n  let priorCat = \"\"\n  for (const setting of settings) {\n    const cat = `${capitalize(\n      setting.categoryType\n    )}.${setting.category.toLowerCase()}`\n\n    if (cat !== priorCat) {\n      priorCat = cat\n      lines.push(\n        \"\",\n        padding(\"#\", 78),\n        \"#\",\n        \"# Settings for \" + cat + \":\",\n        \"#\",\n        \"\",\n        \"\"\n      )\n    }\n    lines.push(...setting.toTomlLines())\n    lines.push(\"\", \"\")\n  }\n\n  await file.writeText_(\"\\n\" + lines.map(trimRight).join(\"\\n\") + \"\\n\\n\")\n  ee().emitDebounced(\"settingsChanged\")\n}\n\nexport async function writeSystemSettings_(\n  dest: Maybe<string | SimpleFile> = systemSettingsFile()\n): PromiseMaybe<PosixFile> {\n  const pf = PosixFile.forMaybe(dest)\n  if (pf != null) await writeToml_(pf, persistedSystemSettings())\n  return pf\n}\n\nexport function writeAllSettings_(dest: string | SimpleFile) {\n  return writeToml_(PosixFile.for(dest), persistedSettings())\n}\n\nexport function readLibrarySettings(libraryDir?: string) {\n  return _readSettings(librarySettingsFile(libraryDir))\n}\n\n/**\n * @throws if there are errors\n */\nexport async function writeLibrarySettings_(\n  libraryDir?: string\n): PromiseMaybe<PosixFile> {\n  await setupLibraryDataDir_(\n    firstNotBlank(libraryDir, Settings.libraryDir.value)!\n  )\n  const file = librarySettingsFile(libraryDir)\n  logger().info(\"writeLibrarySettings()\", { file })\n  if (file != null) {\n    await writeToml_(file, persistedLibrarySettings())\n    libraryHasSettings.refresh()\n  }\n  return file\n}\n\nexport async function _readSettings(\n  f: Maybe<BaseFile>\n): Promise<Setting<any>[]> {\n  if (f == null) return []\n  const log = logger().addContext(\".importFileSettings(\" + f?.nativePath + \")\")\n  try {\n    const result = await importFileSettings_(f)\n    if (isNotEmpty(result.warnings)) {\n      log.warn(\"Problems during import\", result.warnings)\n    }\n    return result.settings\n  } catch (err) {\n    log.error(\"Cannot read: \" + errorToS(err))\n    return []\n  }\n}\n\nexport async function importFileSettings_(\n  f: BaseFile\n): Promise<{ settings: Setting<any>[]; warnings?: string[] }> {\n  const log = logger().addContext(\".importFileSettings_(\" + f.nativePath + \")\")\n  const st = await f.stat()\n  if (st == null) {\n    return { settings: [], warnings: [\"Cannot read\"] }\n  }\n  if (st.size === 0) {\n    // empty file is OK?\n    return { settings: [], warnings: [\"Cannot read empty file\"] }\n  }\n  const tomlMap = await readTomlFile_(f)\n  if (tomlMap == null) {\n    return { settings: [], warnings: [\"No settings found\"] }\n  }\n\n  const warnings: string[] = []\n\n  const settings = compact(\n    entries(tomlMap).map(([key, value]) => {\n      const s = getSettingByNameOrKey(key)\n      if (s == null) {\n        warnings.push(\n          `Failed to import \"${key}\"${mapOr(\n            ciSettings().lookupNearest(key),\n            ea => `: did you mean \"${ea.key}\"?`,\n            \"\"\n          )}`\n        )\n      } else {\n        if (null == s.normalizeValue(value)) {\n          warnings.push(`Invalid value for \"${key}\": ${stringify(value)}`)\n        } else {\n          s.fileValue = value\n          return s\n        }\n      }\n      return undefined\n    })\n  )\n  log.info(\"loaded\", {\n    settings: settingsToObj(settings),\n    warnings: toNotEmpty(warnings)\n  })\n  handleMetaSettings(settings)\n  await handleDeprecatedSettings()\n  return { settings, warnings }\n}\n\nconst UnclearableSettings = lazy(\n  () =>\n    new Set(\n      [\n        Settings.httpPort,\n        Settings.license,\n        Settings.logStdout,\n        Settings.logLevel\n      ].map(ea => ea.key)\n    )\n)\n\nexport async function clearLibraryDirSetting() {\n  await readSystemSettings()\n  Settings.libraryDir.unset()\n  await writeSystemSettings_()\n}\n\n/**\n * Force all in-memory settings to default values.\n */\nexport function clearSettings() {\n  for (const ea of values(Settings)) {\n    // don't reset LOG, NODE_ENV, or random ports!\n    if (!UnclearableSettings().has(ea.key)) ea.unset()\n  }\n  ee().emit(\"settingsChanged\")\n  // we're not emitting clearCache here--use nukeSettings() if you need that.\n  // (see PathToLibraryAsset for an example why)\n}\n\n/**\n * Force all in-memory Settings to default values, and delete both system and\n * library settings.\n *\n * Only useful for tests.\n */\nexport async function nukeSettings() {\n  clearSettings()\n  await PosixFile.forMaybe(systemSettingsFile())?.unlink(\"trace\")\n  await PosixFile.forMaybe(librarySettingsFile())?.unlink(\"trace\")\n  ee().emit(\"clearCache\")\n  setSettingsDefaults.refresh()\n  return\n}\n\nfunction wrapComments(...lines: string[]): string[] {\n  return flatten(lines.map(ea => wrap(ea, WrapComments)))\n}\n\nexport async function writeEnv(\n  file: BaseFile,\n  settings: Setting<any>[]\n): Promise<void> {\n  const lines: string[] = []\n  lines.push(\n    ...wrapComments(\n      \"\",\n      `Welcome to PhotoStructure! These are the settings for version ${baseVersion()}.`,\n      \"\",\n      \"Please see https://photostructure.com/environment-variables for more information about using environment variables with PhotoStructure.\",\n      \"\",\n      `As of version 2.1, \".env\" files (like this one) can be imported by PhotoStructure, but requires extra configuration. See https://photostructure.com/faq/environment-variables/#PS_ENV_FILE for details.`\n    )\n  )\n  lines.push(\"\", \"\")\n  lines.push(\n    ...wrapComments(\n      \"\",\n      \"The following settings categories are stored in the system settings.toml:\",\n      \"\",\n      ...sort([...SystemCategories]).map(ea => \"* System.\" + ea),\n      \"\",\n      `The following settings categories are stored in the library settings.toml:`,\n      \"\",\n      ...sort([...LibraryCategories]).map(ea => \"* Library.\" + ea),\n      \"\",\n      \"Please visit https://forum.photostructure.com if you find anything that may be a bug or have any questions, ideas, or feedback. We'd love to hear from you!\"\n    )\n  )\n  lines.push(\"\", \"\")\n  lines.push(\n    ...wrapComments(\n      `-------------`,\n      `PS_CONFIG_DIR`,\n      `-------------`,\n      \"\",\n      `If the environment variable PS_CONFIG_DIR is set, PhotoStructure will use that value as your system configuration directory.`,\n      \"\",\n      `This is an advanced setting--we recommend using the default value, if possible.`,\n      \"\",\n      `If the PS_CONFIG_DIR environment variable is not set, the default is specific to your operating system:`,\n      \"\",\n      `- On Docker: \"/ps/config\" if that bind-mount exists, otherwise \"/ps/library/.photostructure/docker-config\".`,\n      \"\",\n      `- On Linux: firstNonBlank([$XDG_DATA_HOME, $XDG_CONFIG_HOME, \"$HOME/.config\"]) + \"/PhotoStructure\"`,\n      \"\",\n      `- On macOS: \"$HOME/Library/Application Support/PhotoStructure\"`,\n      \"\",\n      `- On Windows: \"$APPDATA/PhotoStructure\" ($APPDATA is normally set to $HOME/AppData/Roaming)`\n    )\n  )\n  lines.push(\"\", \"\")\n  lines.push(\n    ...wrapComments(\n      `-----------`,\n      `PS_ENV_FILE`,\n      `-----------`,\n      \"\",\n      \"If set, PhotoStructure will attempt to read the .env file specified by this environment variable.\",\n      \"\",\n      \"This must be a full pathname.\",\n      \"\",\n      \"Any value set by this file will override values in settings.toml files.\",\n      \"\",\n      \"See https://photostructure.com/faq/environment-variables/#alternative-coming-in-v21-support-for-env-files for details.\"\n    )\n  )\n  lines.push(\"\", \"\")\n\n  let priorCat = \"\"\n  settings.forEach(setting => {\n    const cat = `${capitalize(\n      setting.categoryType\n    )}.${setting.category.toLowerCase()}`\n\n    if (cat !== priorCat) {\n      priorCat = cat\n      lines.push(\n        \"\",\n        padding(\"#\", 78),\n        \"#\",\n        \"# Settings for \" + cat + \":\",\n        \"#\",\n        \"\"\n      )\n    }\n\n    const name = `${setting.key} or ${setting.name}`\n\n    const extra: any = { ...setting.addToJSON() }\n    mapNotEmpty(setting.altKeys, arr => (extra.aliases = orList(arr)))\n\n    const extraLines = entries(extra).map(\n      ([k, v]) =>\n        `${capitalize(camel2snake(k)).replace(/_+/g, \" \")}: ${valueToS(v)}`\n    )\n\n    if (isNotEmpty(extraLines)) extraLines.push(\"\")\n\n    lines.push(\n      ...wrapComments(\n        padding(\"-\", name.length),\n        name,\n        padding(\"-\", name.length),\n        \"\",\n        ...(setting.opts.deprecated === true\n          ? [\n              \"NOTE: this setting has been deprecated and will be removed in a future version of PhotoStructure.\",\n              \"\"\n            ]\n          : []),\n        setting.opts.description.replace(/\\n+/g, \"\\n\\n\"),\n        \"\",\n        ...(setting.transient\n          ? [\n              `This setting is transient and only set via environment variables.`,\n              \"\\n\"\n            ]\n          : []),\n        ...extraLines,\n        `${setting.key}=${stringify(\n          toS(setting.opts.toEnv(setting.fileValue ?? setting.defaultValue))\n        )}`\n      )\n    )\n    lines.push(\"\", \"\")\n  })\n\n  await file.writeText_(lines.map(ea => trimRight(ea)).join(\"\\n\"))\n}\n","export const SettingsToml = \"settings.toml\"\n","import { delimiter } from \"path\"\nimport {\n  compact,\n  compactBlankish,\n  isEmpty,\n  isNotEmpty,\n  uniq\n} from \"../../fe/Array\"\nimport { notBlankToS } from \"../../fe/Blank\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toA } from \"../../fe/toA\"\nimport {\n  BaseSettingOpts,\n  DefaultValued,\n  Setting,\n  SettingConverters\n} from \"./Setting\"\n\nexport function _join(arr: Maybe<string[]>): Maybe<string> {\n  return arr == null ? undefined : stringify(arr)\n}\n\nfunction _split(s: Maybe<string>): Maybe<string[]> {\n  const str = notBlankToS(s)\n  if (str == null) return\n  if (str.startsWith(\"[\") && str.endsWith(\"]\")) {\n    try {\n      return compact(toA(JSON.parse(str)).map(notBlankToS))\n    } catch {\n      //\n    }\n  }\n  // broken pipe kept for backward compatibility:\n  for (const ea of [\"¦\", delimiter]) {\n    if (str.includes(ea)) {\n      return compactBlankish(str.split(ea))\n    }\n  }\n  return [str]\n}\n\nexport function splitStringArray(s: Maybe<string>): Maybe<string[]> {\n  return map(_split(s), compactBlankish)\n}\n\nexport class StringArraySetting extends Setting<string[]> {\n  constructor(\n    opts: BaseSettingOpts<string[]> &\n      Partial<DefaultValued<string[]>> &\n      Partial<SettingConverters<string[]>>\n  ) {\n    super({\n      defaultValue: [],\n      fromEnv: splitStringArray as any,\n      toEnv: _join,\n      ...opts\n    })\n  }\n\n  protected toValidValue(s: Maybe<string>): Maybe<string> {\n    return notBlankToS(s)\n  }\n\n  protected toValidValues(arr: Maybe<string[]>): Maybe<string[]> {\n    return arr == null ? undefined : uniq(arr.map(ea => this.toValidValue(ea)))\n  }\n\n  push(...values: string[]) {\n    if (isEmpty(values)) return\n    this.value = this.toValidValues(uniq([...toA(this.value), ...toA(values)]))\n  }\n\n  has(value: string) {\n    return toA(this.values).includes(value as any)\n  }\n\n  /**\n   * valueOrDefault for arrays\n   *\n   * @todo replace callers with valueOrDefault? This method as it stands isn't\n   * safe, as it could be modified by a caller.\n   */\n  get values(): string[] {\n    return this.value ?? this.defaultValue\n  }\n\n  set values(arr: Maybe<string[]>) {\n    this.userValue = this.toValidValues(arr)\n  }\n\n  /**\n   * @return if `this.values` is an empty array. Note that this.values delegates to this.defaultValue if this.value is nullish.\n   */\n  isEmpty() {\n    return isEmpty(this.values)\n  }\n\n  isNotEmpty() {\n    return isNotEmpty(this.values)\n  }\n}\n","import { StrEnum } from \"../../fe/StrEnum\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class StringEnumSetting<T extends string> extends Setting<T> {\n  readonly strEnum: StrEnum<T>\n  constructor(opts: SettingOpts<T> & { strEnum: StrEnum<T> }) {\n    super({\n      toEnv: s => opts.strEnum.getCI(s),\n      fromEnv: s => opts.strEnum.getCI(s),\n      ...opts\n    })\n    this.strEnum = opts.strEnum\n    // NOTE: do not compactBlanks! A blank may be a valid value!\n    const dv = this.defaultValue\n    // Allow defaultValue to be undefined:\n    if (!this.strEnum.has(dv)) {\n      throw new Error(\n        `${this.strEnum.values}, doesn't include defaultValue, ${opts.defaultValue}`\n      )\n    }\n  }\n  addToJSON() {\n    return { \"valid values\": this.strEnum.values }\n  }\n}\n","import { compact, uniq } from \"../../fe/Array\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { StrEnum } from \"../../fe/StrEnum\"\nimport { BaseSettingOpts } from \"./Setting\"\nimport { StringArraySetting, splitStringArray } from \"./StringArraySetting\"\n\nfunction parseStringEnum<T extends string>(\n  str: Maybe<string>,\n  strEnum: StrEnum<T>\n): Maybe<T[]> {\n  return compact(splitStringArray(str)?.map(ea => strEnum.getCI(ea)))\n}\n\nexport class StringEnumsSetting<T extends string> extends StringArraySetting {\n  readonly strEnum: StrEnum<T>\n  constructor(\n    opts: BaseSettingOpts<string[]> & {\n      defaultValue?: T[]\n      strEnum: StrEnum<T>\n    }\n  ) {\n    super({\n      toEnv: arr => map(arr, ea => stringify(uniq(ea))),\n      fromEnv: s => parseStringEnum(s, opts.strEnum),\n      defaultValue: opts.defaultValue ?? opts.strEnum.values,\n      ...opts\n    })\n    this.strEnum = opts.strEnum\n  }\n\n  protected override toValidValue(s: string): Maybe<T> {\n    return this.strEnum.getCI(s)\n  }\n\n  override addToJSON() {\n    return { \"valid values\": this.strEnum.values }\n  }\n}\n","import { notBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { trimQuotes } from \"../String\"\nimport { Setting, SettingOpts } from \"./Setting\"\n\nexport class StringSetting extends Setting<string> {\n  constructor(opts: SettingOpts<string>) {\n    super({\n      toEnv: trim,\n      fromEnv: trim,\n      ...opts\n    })\n  }\n\n  hasValue() {\n    return notBlank(this.value)\n  }\n}\nfunction trim(s: Maybe<string>) {\n  return s == null ? undefined : trimQuotes(s)\n}\n","import { join } from \"path\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { SettingsToml } from \"./SettingsToml\"\n\nexport function systemSettingsFile(): Maybe<string> {\n  return map(configDir(), ea => join(ea, SettingsToml))\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const TagInferenceSettingValues = strEnum(\"never\", \"always\", \"auto\")\nexport type TagInferenceSettingValue = StrEnumKeys<\n  typeof TagInferenceSettingValues\n>\n","import { JsonMap, parse } from \"@iarna/toml\"\nimport { readFile, readFileSync, writeFile } from \"fs-extra\"\nimport { blank, mapNotBlank } from \"../../fe/Blank\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { Obj } from \"../../fe/Object\"\nimport { debom } from \"../Buffers\"\nimport { mkLogger } from \"../Logger\"\nimport { dumbquote } from \"../String\"\nimport { joinLines } from \"../fs/CRLF\"\nimport { SimpleFileOrString, toNativePath_ } from \"../fs/SimpleFile\"\nimport { isFileSync } from \"../fs/StatSync\"\nimport { stringifyToml } from \"./TomlStringify\"\n\nfunction parseToml(s: Maybe<string>) {\n  return blank(s) ? undefined : parse(dumbquote(s))\n}\n\nfunction parseTomlBuffer(buf: Buffer) {\n  return parseToml(debom(buf))\n}\n\nexport function readTomlFileSync(\n  file: Maybe<SimpleFileOrString>\n): Maybe<JsonMap> {\n  const nativePath = mapNotBlank(file, toNativePath_)\n  if (nativePath == null) return\n  try {\n    return isFileSync(nativePath)\n      ? parseTomlBuffer(readFileSync(nativePath))\n      : undefined\n  } catch (error) {\n    mkLogger(\"settings.Toml\").warn(\"readTomlFileSync() failed\", {\n      nativePath,\n      error\n    })\n    return\n  }\n}\n\nexport async function readTomlFile_(\n  file: Maybe<SimpleFileOrString>\n): PromiseMaybe<JsonMap> {\n  return mapNotBlank(file, async ea =>\n    parseTomlBuffer(await readFile(toNativePath_(ea)))\n  )\n}\n\nexport function writeTomlFile_(file: SimpleFileOrString, data: Obj) {\n  return writeFile(toNativePath_(file), joinLines(...stringifyToml(data)))\n}\n","import { blank } from \"../../fe/Blank\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { Obj, entries } from \"../../fe/Object\"\nimport { wrap } from \"../../fe/String\"\nimport { toA } from \"../../fe/toA\"\nimport { splitLines } from \"../fs/CRLF\"\nimport { WrapComments } from \"./WrapComments\"\n\nexport function stringifyToml(obj: Obj) {\n  return splitLines(...entries(obj).map(([k, v]) => kvToToml(k, v)))\n}\n\nfunction kvToToml(k: string, v: any) {\n  // We add 2 spaces here to make long array values wrap:\n  return k + \" = \" + stringify(v, undefined, 2)\n}\n\nexport function wrapTomlToLines(args: {\n  lines: string[]\n  wrap?: typeof WrapComments\n  key: Maybe<string>\n  value: any\n  prepend?: string[]\n}) {\n  if (blank(args.key) || args.value == null) return args.lines\n  const lines = [...toA(args.prepend), kvToToml(args.key, args.value)]\n  if (args.lines.length > 0) lines.unshift(\"\")\n  args.lines.push(...wrap(lines, args.wrap))\n  return args.lines\n}\n","import { orList } from \"../../fe/FmtList\"\nimport { stringify } from \"../../fe/JSON\"\n\nexport function valueToS(v: any): string {\n  return 1 < 2\n    ? stringify(v, undefined, 2) //  just use stringify, it's valid TOML.\n    : Array.isArray(v)\n    ? orList(v.map(ea => stringify(ea)))\n    : stringify(v)\n}\n","import { keys } from \"../../fe/Object\"\nimport { equalsIgnoreCase } from \"../String\"\nimport { env } from \"../env/Env\"\nimport { IgnorableEnvKeys } from \"../env/EnvKeys\"\nimport { ciSettings } from \"./Settings\"\n\nexport function verifyPsEnvSettings(\n  e = env(),\n  minDiceCoeff = 0.25\n): { envKey: string; msg: string }[] {\n  const result = []\n  for (const envKey of keys(e).filter(ea => {\n    const key = ea.toUpperCase()\n    return key.startsWith(\"PS_\") && !IgnorableEnvKeys.includes(key)\n  })) {\n    const envValue: any = e[envKey]\n    const exact = ciSettings().lookup(envKey)\n    if (exact != null) {\n      // verify that the value will be used:\n      const parsed = exact.value.opts.fromEnv(envValue)\n      if (parsed == null) {\n        result.push({\n          envKey,\n          msg: `The value \"${e[envKey]}\" isn't valid for this ${exact.value.constructor.name}.`\n        })\n      }\n    } else {\n      const closest = ciSettings().lookupNearest(envKey, minDiceCoeff)\n      if (closest == null) {\n        result.push({ envKey, msg: `No setting was found like \"${envKey}\"` })\n      } else if (!equalsIgnoreCase(closest.key, envKey)) {\n        result.push({\n          envKey,\n          msg: `Did you mean setting \"${closest.value.key}\"?`\n        })\n      }\n    }\n  }\n  return result\n}\n","export const WrapComments = { maxLineLen: 78, prefix: \"# \" }\n","import { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\n\nexport const ffmpegScaleTypes = strEnum(\"vf\", \"s\")\nexport type ffmpegScaleType = StrEnumKeys<typeof ffmpegScaleTypes>\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { extractFloat } from \"../Number\"\n\nexport function extractBitrateKbps(tags: {\n  AvgBitrate?: string\n  MaxDataRate?: string\n}): Maybe<number> {\n  for (const ea of [\"AvgBitrate\", \"MaxDataRate\"] as const) {\n    const result = parseBitrateKbps(tags[ea])\n    if (result != null) return result\n  }\n  return\n}\n\n// MB/s or Kbps\n\nconst units = [\n  { pat: \"mb/s\", fac: 1024 },\n  { pat: \"mbps\", fac: 1024 },\n  { pat: \"kb/s\", fac: 1 },\n  { pat: \"kbps\", fac: 1 }\n] as const\n\nfunction parseBitrateKbps(s: Maybe<string>): Maybe<number> {\n  const f = extractFloat(s)\n  if (f == null) return\n  const lc = toS(s).toLowerCase()\n  for (const ea of units) {\n    if (lc.includes(ea.pat)) return f * ea.fac\n  }\n  return\n}\n","import { stripCopySuffixFromName, stripDSC } from \"../fs/FuzzyNames\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { isString, trimLeftPadding } from \"../String\"\n\n/**\n * Pull out the basename, remove prefixes like \"IMG_\", \"VID_\", and \"MOV_\",\n * strip any count suffixes, then downcase.\n */\nexport function bname(f: SimpleFile | string, stripCounts = true): string {\n  let name = isString(f) ? f : f.name\n  if (stripCounts) {\n    name = stripCopySuffixFromName(name)\n  }\n  name = trimLeftPadding(stripDSC(name))\n  return name.toLowerCase().normalize()\n}\n","import { Tags, offsetMinutesToZoneName } from \"exiftool-vendored\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isEmpty, uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { eql } from \"../../fe/Eql\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { pick } from \"../../fe/Object\"\nimport { MaybeSyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { toS } from \"../../fe/toS\"\nimport { leastBy, max } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { stripPrefix, uniqPath } from \"../String\"\nimport { AssetFileCapturedAtFields } from \"../asset-file/IAssetFile\"\nimport { firstDefinedLater } from \"../async/Later\"\nimport { fmtMs } from \"../date/Date\"\nimport {\n  Dated,\n  datedOverlap,\n  datedToDateTime,\n  datedToPrecisionMs,\n  datedToStartDateTime,\n  datedToStartTs\n} from \"../date/Dated\"\nimport { datedToMillis } from \"../date/DatedToMillis\"\nimport {\n  datedToEXIF,\n  datedToISO,\n  datedToOffsetMinutes,\n  setZone\n} from \"../date/FuzzyDate\"\nimport { extractDateFromPath, parseDated } from \"../date/FuzzyDateParser\"\nimport { getMillisecond } from \"../date/GetDateField\"\nimport { hasTime } from \"../date/HasTime\"\nimport {\n  datedToLocal,\n  datedToLocalSec,\n  localIsFuzzy,\n  localToDateTime\n} from \"../date/Localtime\"\nimport { fmtOffsetMinutes, isValidZone } from \"../date/Timezone\"\nimport { isValidDate } from \"../date/ValidDate\"\nimport { getZoneName, hasZone } from \"../date/getZoneName\"\nimport { containedByNativePath } from \"../fs/Path\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { toNativePath_ } from \"../fs/SimpleFile\"\nimport { statSync } from \"../fs/StatSync\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { Settings } from \"../settings/Settings\"\nimport { bname } from \"./Bname\"\nimport { extMimetype } from \"./FileTypes\"\nimport { ParsedTags } from \"./ParsedTags\"\nimport {\n  extractStatBname as extractStatBnameTime,\n  extractStatPathTime,\n  inferCapturedAtFromSiblings\n} from \"./TagInference\"\nimport { WithCapturedAt } from \"./WithCapturedAt\"\n\nconst logger = lazy(() => mkLogger(\"tags.CapturedAt\"))\n\nexport interface CapturedAtWithTz extends Pick<Tags, \"tz\" | \"tzSource\"> {\n  capturedAt: CapturedAt\n}\n\n/**\n * Should a captured-at source be considered high-quality enough to be stored\n * with copies?\n */\nexport function capturedAtSrcFromTags(src: string): boolean {\n  return toS(src).toLowerCase().includes(\"tags\")\n}\n\nexport function capturedAtSrcFromStat(src: string): boolean {\n  src = toS(src).toLowerCase()\n  // We're copying over the tags, so we don't need those:\n  return src.includes(\"stat\") && !src.includes(\"+\") // < not \"bname+stat\"\n}\n\nexport type CapturedAtJson = Omit<ReturnType<CapturedAt[\"toJSON\"]>, \"_ctor\">\n\nexport class CapturedAt {\n  readonly nativePath: string\n  readonly date: Dated\n  readonly src: string\n  readonly local: Maybe<number>\n  readonly offset: Maybe<number>\n  readonly precisionMs: Maybe<number>\n  readonly mtime: Maybe<number>\n\n  static fromAssetFile(af: AssetFileCapturedAtFields) {\n    return map(\n      localToDateTime(af.capturedAtLocal, af.capturedAtOffset),\n      date =>\n        new CapturedAt({\n          nativePath: af.nativePath,\n          date,\n          src: af.capturedAtSrc,\n          mtime: af.mtime,\n          precisionMs: af.capturedAtPrecisionMs,\n          offset: af.capturedAtOffset,\n          local: af.capturedAtLocal\n        })\n    )\n  }\n\n  static for(args: CapturedAtJson) {\n    return new CapturedAt(args)\n  }\n\n  private constructor(args: CapturedAtJson) {\n    this.nativePath = toNativePath_(args.nativePath)\n    this.date = args.date\n    this.src = args.src\n    this.local =\n      (args.local === 0 ? undefined : args.local) ?? datedToLocal(this.date)\n    this.offset = args.offset ?? datedToOffsetMinutes(this.date)\n    let precisionMs =\n      (args.precisionMs === 0 ? undefined : args.precisionMs) ??\n      datedToPrecisionMs(this.date)\n    if (capturedAtSrcFromStat(this.src)) {\n      precisionMs = Math.max(\n        Settings.minCapturedAtPrecisionStat.valueOrDefault,\n        precisionMs\n      )\n    }\n    this.precisionMs = precisionMs\n    this.mtime = datedToMillis(args.mtime) ?? statSync(this.nativePath)?.mtimeMs\n  }\n\n  toJSON() {\n    return {\n      // \"_ctor\" is magick! see ../fe/JSON.\n      _ctor: CapturedAt.name,\n      ...pick(\n        this,\n        \"nativePath\",\n        \"date\",\n        \"src\",\n        \"local\",\n        \"offset\",\n        \"precisionMs\",\n        \"mtime\"\n      )\n    }\n  }\n\n  static fromJSON(obj: ReturnType<CapturedAt[\"toJSON\"]>): CapturedAt {\n    return new CapturedAt(obj)\n  }\n\n  spread(p: Partial<CapturedAt>): CapturedAt {\n    return new CapturedAt({ ...this.toJSON(), ...p })\n  }\n\n  toISOString() {\n    return datedToISO(this.date)\n  }\n\n  toExifString() {\n    return datedToEXIF(this.date)\n  }\n\n  exifOffsetMinutes() {\n    return this.offset == null ? undefined : fmtOffsetMinutes(this.offset)\n  }\n\n  get isFromTags() {\n    return capturedAtSrcFromTags(this.src)\n  }\n\n  get isInferred() {\n    return !capturedAtSrcFromTags(this.src) && !capturedAtSrcFromStat(this.src)\n  }\n\n  get isFuzzy() {\n    const l = this.local\n    return !this.isFromTags || l == null || localIsFuzzy(l)\n  }\n\n  toString() {\n    return stringify({\n      nativePath: this.nativePath,\n      date: this.toISOString(),\n      src: this.src\n    })\n  }\n\n  toISOStringWithPrecision() {\n    return (\n      datedToISO(this.date, true, this.precisionMs) +\n      (this.precisionMs == null ? \"\" : \" (±\" + fmtMs(this.precisionMs) + \")\")\n    )\n  }\n\n  hasTz() {\n    return hasZone(this.date) || this.offset != null\n  }\n\n  isUTC() {\n    return this.offset === 0\n  }\n\n  hasTime() {\n    return hasTime(this.date)\n  }\n\n  hasMillis() {\n    return gt0(getMillisecond(this.date))\n  }\n\n  toMillis() {\n    return datedToMillis(this.date)\n  }\n\n  get isValid() {\n    return isValidDate(this.date)\n  }\n\n  get zoneName() {\n    return offsetMinutesToZoneName(this.offset) ?? getZoneName(this.date)\n  }\n\n  toAssetFileFields(): Maybe<AssetFileCapturedAtFields> {\n    const capturedAtLocal = this.local\n    return capturedAtLocal == null || this.mtime == null\n      ? undefined\n      : {\n          nativePath: this.nativePath,\n          mtime: this.mtime,\n          capturedAtLocal,\n          capturedAtOffset: this.offset,\n          capturedAtPrecisionMs: this.precisionMs, // < NOT clamped or fuzzy!\n          capturedAtSrc: this.src\n        }\n  }\n\n  asExifTag(): {\n    SubSecDateTimeOriginal?: string\n    DateTimeOriginal?: string\n    OffsetTime?: string\n  } {\n    const OffsetTime = map(this.offset, fmtOffsetMinutes)\n    const value = this.toExifString()\n    return this.hasMillis()\n      ? { SubSecDateTimeOriginal: value, OffsetTime }\n      : { DateTimeOriginal: value, OffsetTime }\n  }\n\n  fuzzyPrecisionMs() {\n    return (\n      (this.isFuzzy ? Settings.fuzzyDatePrecisionCoeff.valueOrDefault : 1) *\n      (this.precisionMs ?? secondMs)\n    )\n  }\n\n  /**\n   * Return the localtime, minus the precision of this current time.\n   */\n  localBoundaries(args?: { delta?: number }): Maybe<{\n    start: number\n    end: number\n  }> {\n    const delta = (args?.delta ?? 0) + this.fuzzyPrecisionMs()\n    const d = datedToStartDateTime(this.date) ?? datedToDateTime(this.date)\n    if (d == null) {\n      logger().warn(\"localBoundaries() failed\", {\n        date: this.date,\n        args,\n        d,\n        path: this.nativePath\n      })\n      return\n    }\n    return {\n      start: datedToLocal(d.minus(delta)),\n      end: datedToLocal(d.plus(delta))\n    }\n  }\n\n  /**\n   * Taking into account `precisionMsIs `other`\n   */\n  overlaps(that: Maybe<CapturedAt>) {\n    if (that == null) return false\n    if (this.local === that.local) return true\n\n    const thisMime = extMimetype(this.nativePath)\n    const thatMime = extMimetype(that.nativePath)\n    const min =\n      thisMime === thatMime\n        ? 0\n        : Settings.minCapturedAtPrecisionDifferentMimetypes.valueOrDefault\n\n    const aPrecisionMs = Math.max(min, this.fuzzyPrecisionMs())\n    const bPrecisionMs = Math.max(min, that.fuzzyPrecisionMs())\n    return logger().tap({\n      msg: \"overlaps()\",\n      result:\n        this.local === that.local ||\n        datedOverlap({\n          a: this.date,\n          b: that.date,\n          aPrecisionMs,\n          bPrecisionMs\n        }).aOverlapsB,\n      meta: { a: this, b: that, aPrecisionMs, bPrecisionMs }\n    })\n  }\n}\n\nexport function bestCapturedAt(arr: Maybe<CapturedAt>[]): Maybe<CapturedAt> {\n  // Always take the value from the newest file (in case the date was updated).\n  // Prefer tags, then paths. Ignore stat, which is not trustworthy.\n  const sorted = sortBy(arr, ea => -(ea?.mtime ?? 0))\n  return (\n    sorted.find(ea => ea.src.includes(\"tags\")) ??\n    sorted.find(ea => ea.src.includes(\"bname+stat\")) ??\n    sorted.find(ea => ea.src.includes(\"path+stat\")) ??\n    sorted.find(ea => ea.src.includes(\"bname\")) ??\n    sorted.find(ea => ea.src.includes(\"path\")) ??\n    sorted.find(ea => ea.src.includes(\"siblings\")) ??\n    sorted.find(ea => ea.src.includes(\"stat\")) ??\n    sorted[0] // should never happen\n  )\n}\n\nfunction cannotUseDateFromPath(f: PosixFile, skipInference: boolean): boolean {\n  return (\n    f == null ||\n    skipInference ||\n    !Settings.usePathsToInferDates.valueOrDefault ||\n    (!Settings.useLibraryDirsToInferDates.valueOrDefault &&\n      containedByNativePath({\n        ancestor: Settings.libraryDir.value,\n        descendant: f.nativePath,\n        acceptSelf: true\n      }))\n  )\n}\n\n/**\n * @param skipInference if the file is a temporary scratch file (like a screenshot from a\n * video or a raw image capture), and more expensive extraction heuristics\n * should be skipped.\n */\n// no deps on posixfile because posixfile depends on tag parsing\nexport async function extractCapturedAt(\n  f: PosixFile,\n  tags: Maybe<ParsedTags & Partial<WithCapturedAt>>,\n  skipInference: boolean = false\n): PromiseMaybe<CapturedAt> {\n  const mtime = await f.mtimeMs()\n\n  async function from(\n    src: string,\n    result: MaybeSyncOrAsync<{\n      src?: string\n      date: Maybe<Dated>\n      precisionMs?: number\n    }>\n  ): PromiseMaybe<CapturedAt> {\n    const r = await result\n    return r == null || r.date == null || !isValidDate(r?.date)\n      ? undefined\n      : CapturedAt.for({\n          nativePath: f.nativePath,\n          date: r.date,\n          local: datedToLocal(r.date),\n          src: uniqPath([src, r.src]),\n          mtime,\n          precisionMs: r.precisionMs,\n          offset: datedToOffsetMinutes(r.date)\n        })\n  }\n\n  const skipPathInference = cannotUseDateFromPath(f, skipInference)\n\n  const result = await firstDefinedLater<CapturedAt>(\n    () => tags?.capturedAt,\n    () => from(\"tags\", capturedAtFromTags(tags)),\n    () => tags?.inferred?.capturedAt,\n\n    () =>\n      skipPathInference\n        ? undefined\n        : from(\"bname+stat\", extractStatBnameTime(f)),\n    () =>\n      skipPathInference ? undefined : from(\"path+stat\", extractStatPathTime(f)),\n    () =>\n      skipInference\n        ? undefined\n        : from(\"siblings\", inferCapturedAtFromSiblings(f)),\n    () =>\n      skipPathInference\n        ? undefined\n        : from(\"bname\", capturedAtFromBasename(f, tags)),\n    () => (skipPathInference ? undefined : from(\"path\", capturedAtFromPath(f))),\n    () =>\n      !Settings.useStatToInferDates.valueOrDefault\n        ? undefined\n        : from(\"stat\", capturedAtFromStat(f))\n  )\n\n  return logger().tap({\n    level: LogLevels.debug,\n    msg: \"extractCapturedAt()\",\n    result\n  })\n}\n\nexport function capturedAtFromTags(\n  t: Maybe<Tags>\n): Maybe<{ date: Dated; src: string; precisionMs?: number }> {\n  // Try to use a \"good\" tag first, but if that fails, try the \"problematic\"\n  // tags in order\n  return (\n    _capturedAtFromTags(t, Settings.capturedAtTags.values) ??\n    _capturedAtFromTags(t, OverrideUTCZoneTags) ??\n    _capturedAtFromTags(t, Settings.capturedAtTagsFallback.values)\n  )\n}\n\nconst OverrideUTCZoneTags = [\"DateTimeUTC\", \"GPSDateTime\"]\n\nexport function _capturedAtFromTags(\n  t: Maybe<Tags>,\n  keys: string[]\n): Maybe<{ date: Dated; src: string; precisionMs?: number }> {\n  if (t == null || isEmpty(keys)) return\n\n  const arr: {\n    localSec: number\n    date: Dated\n    src: string\n    precisionMs: number\n    rawValue: Maybe<string>\n  }[] = []\n\n  // We want the earliest date with the best precision. To do that, we get the\n  // least date (which may be quite coarse, like year-only). We then find the\n  // least date that overlaps with that date with the best precision and least\n  // local value.\n\n  for (const key of keys) {\n    let date = (t as any)[key]\n    let src = key\n    if (isValidDate(date)) {\n      if (\n        isValidZone(t.tz) &&\n        (!hasZone(date) || OverrideUTCZoneTags.includes(src))\n      ) {\n        date = setZone(date, t.tz) ?? date\n        const tzSource = blank(t.tzSource)\n          ? \"\"\n          : \" from \" + stripPrefix(t.tzSource, \"from \")\n        src = src + ` (TZ ${t.tz}${tzSource})`\n      }\n      arr.push({\n        localSec: datedToLocalSec(date),\n        date,\n        src,\n        precisionMs: datedToPrecisionMs(date),\n        rawValue: (t as any)[key]?.rawValue\n      })\n    }\n  }\n\n  const least = leastBy(arr, ea => datedToStartTs(ea.date))\n  if (least == null) return\n\n  const overlapsWithLeast = arr.filter(\n    ea =>\n      eql(ea.date, least.date) ||\n      (ea.precisionMs <= least.precisionMs &&\n        datedOverlap({\n          a: ea.date,\n          b: least.date,\n          aPrecisionMs: ea.precisionMs,\n          bPrecisionMs: least.precisionMs\n        }).aOverlapsB)\n  )\n\n  // We want the earliest date with the best precision.\n\n  const earliest = leastBy(overlapsWithLeast, ea => [\n    // Strip off the seconds, minutes, and hours (to handle timezones)\n    Math.floor(ea.localSec / 1_00_00_00),\n\n    // prefer dates with zones\n    hasZone(ea.date) ? 0 : 1,\n\n    // best precision wins\n    ea.precisionMs,\n\n    // prefer longer dates (!!): they are expected to be more precise, as they\n    // will include either/and milliseconds and/or timezone. This should stay\n    // at pretty much the bottom of the heuristics, though, as it is fuzzy.\n    -1 * (ea.rawValue?.length ?? 0),\n\n    ea.src // < for determinism\n  ])\n\n  logger().debug(\"capturedAtFromTags()\", { least, overlapsWithLeast, earliest })\n\n  return earliest\n}\n\nexport function capturedAtFromBasename(\n  f: PosixFile,\n  t: Maybe<Pick<Tags, \"tz\">>\n): Maybe<{ date: Dated; precisionMs?: number }> {\n  if (!Settings.usePathsToInferDates.valueOrDefault) return\n  for (const input of uniq([bname(f, true), bname(f, false)])) {\n    const date = parseDated({ input, defaultZone: t?.tz })\n    if (date != null) {\n      return {\n        date,\n        precisionMs: max([datedToPrecisionMs(date), secondMs])\n      }\n    }\n  }\n  return\n}\n\nexport function capturedAtFromPath(\n  f: PosixFile\n): Maybe<{ date: Maybe<Dated> }> {\n  if (!Settings.usePathsToInferDates.valueOrDefault) return\n  return {\n    date: extractDateFromPath(f.pathsForDateParsing)\n  }\n}\n\nexport async function capturedAtFromStat(\n  f: PosixFile\n): PromiseMaybe<{ date: Maybe<Dated> }> {\n  if (!Settings.useStatToInferDates.valueOrDefault) return\n  return { date: await f.minStatDate() }\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const DateTagFormats = strEnum(\"y\", \"ym\", \"ymd\", \"\")\nexport type DateTagFormat = StrEnumKeys<typeof DateTagFormats>\n","import { Tags } from \"exiftool-vendored\"\n\ntype TagKeys = keyof Tags | \"creationTime\" | \"photoTakenTime\" | \"HistoryWhen\"\n\nexport const IgnoredCapturedAtTags = [\n  \"creationTime\", // Google Photos upload time\n  \"HistoryWhen\", // is when history records happen, NOT when the file was captured!\n  \"MediaModifyDate\", // is the last media edit time\n  \"MetadataDate\", // is the last time the _metadata was edited_. See https://forum.photostructure.com/t/combining-images/524/8 for details\n  \"SubSecTime\", // is fractional seconds (not the full date and time) for ModifyDate\n  \"TrackModifyDate\"\n] as const satisfies readonly TagKeys[]\n\n/**\n * These tags should only be used if \"standard\" captured-at tags have no valid\n * values. The first valid ExifDateTime value will be used.\n */\nexport const ProblematicCapturedAtTags = [\n  // (called DateTimeDigitized by the EXIF spec)\n  // https://forum.photostructure.com/t/incorrect-date-assigned-to-photo/419\n  // and\n  // https://forum.photostructure.com/t/photostructure-ignored-the-date-metadata-of-some-photos-marked-them-as-taken-in-2002/340\n  // Note that this tag may have an incorrect zone offset (it may incorrectly\n  // be UTC or local system time), so it's \"problematic\".\n  \"SubSecCreateDate\",\n  \"SubSecMediaCreateDate\",\n  \"SubSecModifyDate\",\n\n  \"CreateDate\",\n  \"MediaCreateDate\", // < may have incorrect timezone like CreateDate\n  \"ModifyDate\", // is called DateTime by the EXIF spec, and may be the last edit time, or the actual captured-at (see the QuickTake DC50 example)\n  \"DateTime\",\n  \"DateTimeCreated\", // composite tag, sometimes has wrong timezone.\n\n  \"photoTakenTime\", // < Google Takeout (not really reliable, though)\n\n  \"TrackCreateDate\", // < may not have correct timezone\n\n  \"CreationTime\" // < set by some screenshot software, and _MAY INCLUDE DATETIME!_ . May be rendered as \"Wed 16 Jun 2021 03:34:46 PM PDT\"\n] as const satisfies readonly Exclude<\n  TagKeys,\n  (typeof IgnoredCapturedAtTags)[number] // < prevents duplicate keys\n>[]\n\nexport const DefaultCapturedAtTagsConst = [\n  // By the specification, DateTimeOriginal should be the time of the\n  // shutter actuation, and CreateDate should be the time that the file\n  // was written to the memory card (but not all mfrs follow the spec)\n  // http://u88.n24.queensu.ca/exiftool/forum/index.php?topic=2568.0\n\n  // https://exiftool.org/TagNames/EXIF.html\n\n  \"CreationDate\", // only found on iPhone movies, but they include timezone offsets, which we really want. See https://exiftool.org/forum/index.php?topic=12837.msg69410#msg69410\n\n  \"DateTimeOriginal\", // date/time when original image was taken. Quicktime:DateTimeOriginal will also include the timezone offset.\n  \"SubSecDateTimeOriginal\", // (fractional seconds for DateTimeOriginal)\n\n  \"DateTimeDigitized\",\n\n  \"OriginalCreateDateTime\",\n\n  \"DigitalCreationDateTime\" // composite tag\n] as const satisfies readonly Exclude<\n  TagKeys,\n  | (typeof IgnoredCapturedAtTags)[number] // < prevents duplicate keys\n  | (typeof ProblematicCapturedAtTags)[number] // < prevents duplicate keys\n>[]\n","import { ExifTags } from \"./ExifTags\"\n\nexport const DefaultIncludedPreviewTags: (keyof ExifTags)[] = [\n  \"AttributionName\",\n  \"AttributionURL\",\n  \"capturedAt\",\n  \"Copyright\",\n  \"exposureSettings\",\n  \"GPSLatitude\",\n  \"GPSLongitude\",\n  \"License\",\n  \"Make\",\n  \"Model\",\n  // NO: \"Orientation\", because we always raster correctly-rotated images\n  \"Permits\",\n  \"Prohibits\",\n  \"Rating\",\n  \"Requires\",\n  // NO: \"Rotation\", because we always raster correctly-rotated images.\n  \"Source\"\n]\n\n// OriginalDirectory and OriginalFilename are obscure GettyImagesGIFT XMP tags\n","// https://en.wikipedia.org/wiki/List_of_photographic_equipment_makers#Manufacturers_of_cameras_or_lenses_and_filters\n// Don't use this directly! Use Settings.lensMakes!\nexport const DefaultLensMakes = [\n  \"7artisans\",\n  \"Bower\",\n  \"Canon\",\n  \"Carl Zeiss\",\n  \"Cosina\",\n  \"Fuji\",\n  \"Fujifilm\",\n  \"Goerz\",\n  \"Hasselblad\",\n  \"Hirox\",\n  \"Hoya\",\n  \"Kodak\",\n  \"Konica\",\n  \"Leica\",\n  \"Leidolf\",\n  \"Lensbaby\",\n  \"Lumix\",\n  \"Meike\",\n  \"Meopta\",\n  \"Minolta\",\n  \"Neewer\",\n  \"Nikon\",\n  \"Olympus\",\n  \"Opteka\",\n  \"Panasonic\",\n  \"Pentacon\",\n  \"Pentax\",\n  \"Ricoh\",\n  \"Rodenstock\",\n  \"Rokinon\",\n  \"Ross\",\n  \"Samsung\",\n  \"Samyang\",\n  \"Seiko\",\n  \"Sigma\",\n  \"Silor\",\n  \"Soligor\",\n  \"Sony\",\n  \"Sunpak\",\n  \"Tamron\",\n  \"Tiffen\",\n  \"Tokina\",\n  \"Topcon\",\n  \"Venus\",\n  \"Voigtländer\",\n  \"Wray\",\n  \"Yongnuo\",\n  \"Zeiss\",\n  \"Zhong Yi\",\n  \"Zuiko\"\n]\n","import { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toGt0f } from \"../../fe/Number\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { readRawTags } from \"./ExifTool\"\nimport { isVideoMimeType } from \"./MimeTypes\"\nimport { WithDuration } from \"./WithDuration\"\n\nexport function extractDurationSec(t: Maybe<WithDuration>): Maybe<number> {\n  // We only extract duration for videos. ExifTool sometimes returns\n  // `Duration: 1s` for Canon RAW CR3 images, which is odd.\n\n  // TODO: when we support LivePhotos, we'll need to add a check for HEIC/HEIF\n  // here:\n  return isVideoMimeType(t?.MIMEType)\n    ? [t?.duration, t?.Duration, t?.MediaDuration, t?.TrackDuration].find(\n        toGt0f\n      )\n    : undefined\n}\n\nexport async function extactDuration(\n  pathOrFile: Maybe<string | PosixFile>\n): PromiseMaybe<number> {\n  if (pathOrFile == null) return\n  const pf = PosixFile.for(pathOrFile)\n  return extractDurationSec(await readRawTags(pf, false))\n}\n","import {\n  defaultVideosToUTC,\n  ExifDateTime,\n  ExifTool,\n  ResourceEvent,\n  Tags,\n  WriteTags\n} from \"exiftool-vendored\"\nimport _path from \"path\"\nimport process from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks, isNotEmpty } from \"../../fe/Array\"\nimport { blank, mapNotBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, MaybePromiseMaybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { MultiMap } from \"../../fe/MultiMap\"\nimport {\n  assignFields,\n  assignUndefinedFields,\n  definedValues,\n  entries,\n  fromEntries,\n  keys,\n  omit,\n  pick,\n  values\n} from \"../../fe/Object\"\nimport { gt } from \"../../fe/Primitive\"\nimport { isString, stripSuffix } from \"../../fe/String\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { GB } from \"../../fe/Units\"\nimport { time } from \"../async/PromiseTimer\"\nimport { thenOrTimeout } from \"../async/ThenOrTimeout\"\nimport {\n  BatchClusterObserver,\n  batchClusterOptions\n} from \"../BatchClusterObserver\"\nimport { setZone } from \"../date/FuzzyDate\"\nimport { parseDated } from \"../date/FuzzyDateParser\"\nimport { eqlAsync } from \"../Eql\"\nimport { FileCache } from \"../fs/FileCache\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFileOrString, toNativePath_ } from \"../fs/SimpleFile\"\nimport { nativePathIsFile } from \"../fs/Stat\"\nimport { mkLogger } from \"../Logger\"\nimport { safeUUID } from \"../math/UUID\"\nimport { isTest } from \"../NodeEnv\"\nimport { assignNullishFields, pluckCaseInsensitive } from \"../Object\"\nimport { isWorkerService } from \"../ServiceNames\"\nimport { Settings } from \"../settings/Settings\"\nimport { shim1 } from \"../Shim1\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { includesIgnoreCase, startsWithIgnoreCase } from \"../String\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { maxConcurrentImports } from \"../work/MaxCpus\"\nimport { CapturedAt, extractCapturedAt } from \"./CapturedAt\"\nimport { extractDurationSec } from \"./Duration\"\nimport { ExifTags } from \"./ExifTags\"\nimport {\n  cameraIdFromTags,\n  imageIdFromTags,\n  lensIdFromLensInfo\n} from \"./ExifUid\"\nimport { isExifUnset } from \"./ExifUnset\"\nimport { extractExposureSettings } from \"./ExposureSettings\"\nimport { isVideoExt } from \"./FileTypes\"\nimport { getInferredHistoricValues } from \"./History\"\nimport { maybeInferTimezone } from \"./InferTimezone\"\nimport { JsonSidecarTags, readJsonSidecar } from \"./JsonSidecar\"\nimport { extractLensMakeModel } from \"./LensMakeModel\"\nimport { extractMakeAndModel, make, model } from \"./MakeModel\"\nimport {\n  isImageMimeType,\n  isVideoMimeType,\n  normalizeMimetype\n} from \"./MimeTypes\"\nimport { extractRotation } from \"./Orientation\"\nimport { ParsedTags } from \"./ParsedTags\"\nimport { extractRating } from \"./Rating\"\nimport { mimetypeCache, readMimeType } from \"./ReadMimeType\"\nimport { extractSizeInfoFromFile } from \"./SizeInfo\"\nimport { canInferForDir, inferMakeAndModel } from \"./TagInference\"\nimport { TimedTags } from \"./TimedTags\"\nimport { extractTitleDescription } from \"./TitleDescription\"\nimport { WithSidecars } from \"./WithSidecars\"\n\nconst logger = lazy(() => mkLogger(\"tags.ExifTool\"))\n\nlet _addInstanceIdsToTags = false\n\nexport function addInstanceIdsToTags(b: boolean) {\n  _addInstanceIdsToTags = b\n}\n\nexport function setExifToolProcs(i: number) {\n  // used only in tests, and we want children to inherit this value:\n  Settings.exiftoolProcsPerChild.envValue = i\n  return shutdownExiftool()\n}\n\nfunction maxProcs() {\n  // thread sub-processes only do one thing at a time, so they only need 1 exiftool:\n  return isTest\n    ? 8\n    : isWorkerService()\n    ? 2\n    : Settings.exiftoolProcsPerChild.value ??\n      Math.ceil(maxConcurrentImports() / 3)\n}\n\nconst _exiftool = lazy(() => {\n  // BatchClusterObserver will renice, track and clean up child exiftool processes:\n  return new BatchClusterObserver(\n    \"ExifTool\",\n    new ExifTool({\n      useMWG: Settings.useMWG.valueOrDefault,\n      backfillTimezones: Settings.backfillTimezones.valueOrDefault,\n      inferTimezoneFromDatestamps: false, // < we'll handle it in InferTimezone\n      defaultVideosToUTC: Settings.defaultVideosToUTC.valueOrDefault,\n      isIgnorableError: error => {\n        return logger().tap({\n          msg: \"isIgnorableError()\",\n          result: startsWithIgnoreCase(toS(error).trim(), \"warning:\"),\n          meta: { error, toS: toS(error) }\n        })\n      },\n      // TODO: FINISH: includeImageDataMD5: Settings.useImageDataHashes.valueOrDefault,\n      ...batchClusterOptions(maxProcs(), \"tags.exiftool\")\n    })\n  ).t\n})\n\nexport function exiftool(): ExifTool {\n  const et = _exiftool()\n  return et.ended ? _exiftool.refresh() : et\n}\n\nexport async function exiftoolVersion_(): PromiseMaybe<string> {\n  return thenOrTimeout(exiftool().version(), ShortCommandTimeoutMs, () => {\n    throw new Error(\"ExifTool timed out\")\n  })\n}\n\n/**\n * If this process hasn't started exiftool, don't bother.\n */\nexport function exiftoolVersionMaybe() {\n  return map(_exiftool.prior(), et =>\n    et.ended\n      ? undefined\n      : thenOrTimeout(et.version(), commandTimeoutMs(), () => {\n          throw new Error(\"ExifTool timed out\")\n        })\n  )\n}\n\n// Primarily for tests:\nexport function shutdownExiftool(gracefully: boolean = false) {\n  return map(_exiftool.clear(), ea => ea.end(gracefully))\n}\n\n/**\n * @throws on error\n */\nexport function extractBinaryTag(\n  tagname: string,\n  src: string,\n  dest: string\n): Promise<void> {\n  return exiftool().extractBinaryTag(tagname, src, dest)\n}\n\n// Only exported for tests\nexport const tagsCache = lazy(\n  () =>\n    new FileCache<Maybe<ExifTags>>({\n      name: \"tags.parsed\",\n      maxSize: 256,\n      timeoutMs: minuteMs\n    })\n)\n\n// Only exported for tests\nexport const rawTagsCache = lazy(\n  () =>\n    new FileCache<Maybe<TimedTags>>({\n      name: \"tags.raw\",\n      maxSize: 256,\n      timeoutMs: minuteMs\n    })\n)\n\nexport function clearTagsCache() {\n  tagsCache.prior()?.clear()\n  rawTagsCache.prior()?.clear()\n  mimetypeCache.prior()?.clear()\n}\n\n// These are fields that aren't in the Tags interface.\nconst IgnoredNonTypedFields = {\n  ExifToolVersion: undefined,\n  RAFVersion: undefined, // ? wha?\n  Directory: undefined,\n  ExifByteOrder: undefined,\n  FileAccessDate: undefined,\n  FileCreateDate: undefined,\n  FileIndex2: undefined,\n  FileInfoVersion: undefined,\n  FileInodeChangeDate: undefined,\n  FileModifyDate: undefined,\n  FilePermissions: undefined\n}\n\nexport const IgnoredTypedFields: Tags = {\n  Duration: undefined, // < See https://forum.photostructure.com/t/videos-duration-wildly-inaccurate/999/2\n  MediaDuration: undefined,\n  TrackDuration: undefined,\n  FileFormat: undefined,\n  FileIndex: undefined,\n  FileName: undefined,\n  FileNumber: undefined,\n  FileNumberMemory: undefined,\n  FileNumberSequence: undefined,\n  FileSize: undefined,\n  FileType: undefined,\n  FileTypeExtension: undefined,\n  FileVersion: undefined,\n  MIMEType: undefined,\n  SourceFile: undefined\n}\n\nexport const IgnoredSidecarFields = [\n  \"errors\",\n  ...(keys(IgnoredNonTypedFields) as any),\n  ...keys(IgnoredTypedFields)\n] as const satisfies readonly (keyof ExifTags)[]\n\nasync function readSidecarTags(f: PosixFile) {\n  return omit(await readRawTags(f, false), ...(IgnoredSidecarFields as any))\n}\n\nexport async function sidecarEql(a: PosixFile, b: PosixFile): Promise<boolean> {\n  return (\n    (await eqlAsync(a.sha(), b.sha())) ||\n    (await eqlAsync(readSidecarTags(a), readSidecarTags(b)))\n  )\n}\n\n/**\n * Fetch the ExifTags for the given file, including sidecar and sibling inferred\n * metadata.\n */\nexport function readTags(\n  pathOrFile: Maybe<SimpleFileOrString>\n): MaybePromiseMaybe<ExifTags> {\n  return pathOrFile == null ? undefined : _readTags(toNativePath_(pathOrFile))\n}\n\nexport const _readTags = shim1({\n  name: \"tags.readTags\",\n  impl: async (nativePath: string) => {\n    const f = PosixFile.for(nativePath)\n    return parseTags(f, await readRawTags(f))\n  },\n  cache: tagsCache\n})\n\nexport async function cachedTags(pathOrFile: SimpleFileOrString) {\n  return tagsCache().get(toNativePath_(pathOrFile))\n}\n\n// Convenience methods:\n\nexport async function readCapturedAt(\n  pathOrFile: SimpleFileOrString\n): PromiseMaybe<CapturedAt> {\n  return (await readTags(pathOrFile))?.capturedAt\n}\n\nexport async function readRawField<K extends keyof Tags>(\n  pathOrFile: SimpleFileOrString,\n  tagName: K\n): PromiseMaybe<Tags[K]> {\n  try {\n    const result = await exiftool().readRaw(toNativePath_(pathOrFile), [\n      \"-\" + tagName\n    ])\n    return pluckCaseInsensitive(result, tagName)\n  } catch (err) {\n    logger().info(\"readRawField failed\", err)\n    return\n  }\n}\n\nexport async function readRotation(\n  pathOrFile: SimpleFileOrString\n): PromiseMaybe<number> {\n  // We want to pick up rotation from a sidecar, if present:\n  return extractRotation(await readRawTags(pathOrFile, true))\n}\n\n/**\n * ExifTool writes \"file.jpg_original\" files. Rename them to\n * \"file_original_06.jpg\" so the file extension isn't bogus.\n */\nexport async function moveOriginal(\n  src: PosixFile,\n  suffix = \"_original\"\n): PromiseMaybe<PosixFile> {\n  return src\n    .sibling(src.base + suffix)\n    .saveIfNewOrDelete(src.name + suffix + src.ext)\n}\n\nexport async function overwriteTags_(src: PosixFile, tags: WriteTags) {\n  try {\n    await time(\"tag.overwriteTags()\", async () => {\n      await exiftool().write(src.nativePath, tags, await writeTagArgs(src))\n      src.clearThisAndParent() // < this may be a new file\n    })\n  } catch (error) {\n    logger().throw(\"failed to overwrite tags to \" + src, { error, tags })\n  }\n}\n\nexport async function deleteAllTags_(src: PosixFile, dest: PosixFile) {\n  await time(\"tag.deleteAllTags()\", async () => {\n    const args = [\"-all=\"]\n    if (src.eql(dest)) {\n      args.push(\"-overwrite_original\")\n    } else {\n      args.push(\"-o\", dest.nativePath)\n    }\n    await exiftool().write(src.nativePath, {}, args)\n    dest.clear()\n  })\n}\n\nexport async function writeTagArgs(dest: PosixFile) {\n  // See https://forum.photostructure.com/t/manually-editing-capture-time-title-and-description-caption/104/9?u=mrm\n\n  // TODO: https://exiftool.org/ExifTool.html#QuickTimeUTC\n  // (\"Error: Warning: Tag 'api' is not defined\")\n  const args = []\n  if (Settings.overwriteOriginal.valueOrDefault)\n    args.push(\"-overwrite_original\")\n  if (gt(await dest.size(), 2 * GB)) {\n    // https://exiftool.org/ExifTool.html#LargeFileSupport\n    args.push(\"-api LargeFileSupport=1\")\n  }\n  return args\n}\n\n/**\n * Figure out where we should stuff this tag\n */\nexport async function writeTagDest(\n  src: PosixFile,\n  tagName: keyof WriteTags,\n  srcMimeType?: string\n): Promise<PosixFile> {\n  // if it's blocklisted, no need to check anything else:\n  if (\n    includesIgnoreCase(\n      Settings.sidecarTagBlocklist.values,\n      stripSuffix(tagName, \"#\") // < handle `Orientation#`\n    )\n  ) {\n    return logger().tap({\n      msg: \"writeTagDest(): blocklisted tag, not writing to sidecar\",\n      result: src,\n      meta: {\n        src,\n        tagName\n      }\n    })\n  }\n  const mt = srcMimeType ?? (await readMimeType(src))\n  const sidecar = await src.sidecar()\n  const writeMetadataToSidecarsIfImage =\n    isImageMimeType(mt) &&\n    Settings.writeMetadataToSidecarsIfImage.valueOrDefault\n\n  const writeMetadataToSidecarsIfVideo =\n    isVideoMimeType(mt) &&\n    Settings.writeMetadataToSidecarsIfVideo.valueOrDefault\n\n  const writeMetadataToSidecarsIfSidecarExists =\n    Settings.writeMetadataToSidecarsIfSidecarExists.valueOrDefault &&\n    (await sidecar.exists())\n\n  const useSidecar =\n    writeMetadataToSidecarsIfImage ||\n    writeMetadataToSidecarsIfVideo ||\n    writeMetadataToSidecarsIfSidecarExists\n\n  return logger().tap({\n    msg: \"writeTagDest()\",\n    result: useSidecar ? sidecar : src,\n    meta: {\n      src,\n      tagName,\n      mimetype: mt,\n      writeMetadataToSidecarsIfImage,\n      writeMetadataToSidecarsIfVideo,\n      writeMetadataToSidecarsIfSidecarExists\n    }\n  })\n}\n\nexport function writeTags_(\n  src: PosixFile,\n  tags: WriteTags,\n  srcMimeType?: string\n): Promise<void> {\n  return time(\"tags.writeTags\", async () => {\n    // multiple tags may mean multiple destinations. YAY\n    const path2entries = new MultiMap<string, [keyof WriteTags, any]>()\n    for (const [k, v] of entries(tags)) {\n      const dest = await writeTagDest(src, k, srcMimeType)\n      path2entries.add(dest.nativePath, [k, v])\n    }\n\n    for (const [dest, tagEntries] of path2entries.entriesArray()) {\n      const f = PosixFile.for(dest)\n      const t = fromEntries(tagEntries)\n      logger().info(\"writeTags()\", { src, dest, t })\n      await exiftool().write(f.nativePath, t, await writeTagArgs(f))\n      if (!Settings.overwriteOriginal.valueOrDefault) {\n        await moveOriginal(f)\n      }\n      // This may be a new file, or an existing file--either way, the parent\n      // directory should be re-scanned:\n      f.clearThisAndParent()\n    }\n  })\n}\n\n/**\n * Return the raw, unparsed tags for `bf`, and merge tags from any sidecars.\n */\nexport async function readRawTags(\n  f: SimpleFileOrString,\n  includeSidecars = true\n): PromiseMaybe<TimedTags & WithSidecars & ParsedTags> {\n  const pf = PosixFile.for(f)\n  if (pf.isSidecar()) includeSidecars = false\n\n  if (await pf.isEmptyFile(64)) {\n    rawTagsCache().delete(pf.nativePath)\n    logger().debug(\n      \"readRawTags(\" + pf + \"): !nativePathIsFile(), returning null.\"\n    )\n    return\n  }\n\n  const fileTags = await _readRawTags(pf.nativePath)\n  if (fileTags == null || !includeSidecars) return fileTags\n\n  logger().debug(\"readRawTags()\", {\n    pf,\n    pickedFileTags: pick(\n      fileTags,\n      \"tz\",\n      \"tzSource\",\n      ...(Settings.capturedAtTags.values as any)\n    )\n  })\n\n  const file2tags: [PosixFile, PromiseMaybe<TimedTags | JsonSidecarTags>][] = []\n\n  for (const ea of await pf.jsonSidecars()) {\n    file2tags.push([ea, readJsonSidecar(ea, fileTags.tz)])\n  }\n\n  for (const ea of await pf.existingExifSidecars()) {\n    file2tags.push([ea, _readRawTags(ea.nativePath)])\n  }\n\n  // we shallow clone here to prevent messing up the _readRawTags cache:\n  const result: TimedTags & WithSidecars & ParsedTags = {\n    original: {},\n    MIMEType: mapNotBlank(fileTags.MIMEType, normalizeMimetype),\n    ...fileTags\n  }\n\n  const histories: ResourceEvent[] = []\n\n  for (const [sidecar, p] of file2tags) {\n    if (p == null) continue\n    const sidecarTags = await p\n    if (sidecarTags == null) continue\n    const safeTags = omit(sidecarTags, ...IgnoredSidecarFields)\n    if (isNotEmpty(values(safeTags))) {\n      ;(result.sidecars ??= []).push(sidecar.base)\n\n      histories.push(...toA((sidecarTags as any)[\"History\"]))\n\n      // store overwritten values:\n      assignNullishFields(result.original, pick(result, ...keys(safeTags)))\n\n      // sidecar values win:\n      assignFields(result, safeTags)\n\n      logger().debug(\"readRawTags() sidecar had values\", {\n        sidecar: sidecar.base\n      })\n    } else {\n      logger().debug(\"readRawTags() sidecar was empty\", {\n        sidecar: sidecar.base\n      })\n    }\n  }\n\n  result.inferred = getInferredHistoricValues(histories)\n  assignNullishFields(result, result.inferred)\n\n  logger().debug(\"readRawTags() final\", {\n    pf,\n    inferred: result.inferred,\n    pickedResult: pick(\n      result,\n      \"tz\",\n      \"tzSource\",\n      ...(Settings.capturedAtTags.values as any)\n    )\n  })\n\n  return result\n}\n\n/**\n * This doesn't handle sidecars. You want `readRawTags`.\n */\nexport const _readRawTags = shim1({\n  name: \"tags.readRawTags\",\n  cache: rawTagsCache,\n  impl: async (nativePath: string) => {\n    if (!(await nativePathIsFile(nativePath))) {\n      logger().debug(\"_readRawTags(): !nativePathIsFile(), returning null.\", {\n        nativePath\n      })\n      rawTagsCache().delete(nativePath)\n      return\n    }\n\n    logger().debug(\"_readRawTags() not cached, reading now.\", { nativePath })\n\n    // We need to read the whole file to get video duration. [] disables the\n    // [\"-fast\"]:\n    const args = isVideoExt(_path.extname(nativePath)) ? [] : undefined\n\n    const t = await time(\"tag.read()\", () =>\n      exiftool()\n        .read(nativePath, args)\n        .catch(error => {\n          logger().warn(\"ExifTool failed to read\", { nativePath, error })\n          return undefined\n        })\n    )\n    if (t == null) return\n\n    logger().debug(\"_readRawTags()\", {\n      nativePath,\n      pickedTags: pick(\n        t,\n        \"tz\",\n        \"tzSource\",\n        ...(Settings.capturedAtTags.values as any)\n      )\n    })\n\n    t.MIMEType = mapNotBlank(t.MIMEType, normalizeMimetype)\n\n    // PERF: no maps here as there are tons of fields.\n    for (const key of keys(t)) {\n      const v = t[key]\n      if (typeof v === \"string\") {\n        if (v === \"0000:00:00\" || v === \"0000:00:00 00:00:00\") {\n          delete t[key]\n        }\n      }\n    }\n\n    const problems = compactBlanks(\n      [t.Error, ...(t.errors ?? []), t.Warning].map(toS)\n    )\n    if (isNotEmpty(problems)) {\n      ;(t as any)[\"problems\"] = problems\n    }\n    if (_addInstanceIdsToTags) (t as any)[\"__instance\"] = safeUUID()\n    return t as TimedTags\n  }\n})\n\n/**\n * NOT FOR PUBLIC CONSUMPTION only exposed for tests\n */\nexport async function parseTags(f: PosixFile, t: Maybe<TimedTags>) {\n  return t == null ? undefined : time(\"tag.parseTags()\", () => _parseTags(f, t))\n}\n\nasync function _parseTags(f: PosixFile, t: TimedTags): PromiseMaybe<ExifTags> {\n  try {\n    const nativePath = f.nativePath\n    const m = (t.MIMEType = mapNotBlank(t.MIMEType, normalizeMimetype))\n    if (blank(m)) {\n      logger().debug(\"No mimetype for \" + nativePath)\n      return\n    }\n    // easy assigning additional fields from the ExifTags interface.\n\n    // under-lay inferred values as a backstop for missing values in `t`:\n    const a = { ...((t as any).inferred ?? {}), ...t } as ExifTags\n    a.inferred ??= {}\n    a.original ??= {}\n\n    if (Settings.fuzzyDateParsing.valueOrDefault) {\n      for (const k of [\n        ...Settings.capturedAtTags.values,\n        ...Settings.capturedAtTagsFallback.values\n      ]) {\n        const v = (a as any)[k]\n        if (isString(v)) {\n          const fuzzy = parseDated({\n            input: v,\n            includeDate: true,\n            includeFuzzyDate: true\n          })\n          if (fuzzy != null) {\n            logger().debug(\"parseTags() fuzzy date\", { fuzzy, k, v })\n            ;(a as any)[k] = fuzzy\n          }\n        }\n      }\n    }\n\n    const skipSiblingInference = !(await canInferForDir(f.parent()))\n\n    const tzMeta = await maybeInferTimezone(f, a, skipSiblingInference)\n\n    logger().debug(\"parseTags()\", { tzMeta, skipSiblingInference })\n\n    if (tzMeta?.tz != null) {\n      const keepLocalTime =\n        a.tzSource === defaultVideosToUTC ? false : undefined\n      // We don't set timezones for all dates: they may be in a different tz\n      // (due to subsequent edits or whatever)\n      for (const k of [\n        ...Settings.capturedAtTags.values,\n        ...Settings.capturedAtTagsFallback.values\n      ]) {\n        const v = (a as any)[k]\n        if (v instanceof ExifDateTime) {\n          ;(a as any)[k] = setZone(v, tzMeta.tz, { keepLocalTime }) ?? v\n        }\n      }\n\n      // save the prior values:\n      assignUndefinedFields(a.original, a, \"tz\", \"tzSource\")\n      // and adopt the new tzMeta values:\n      assignFields(a, tzMeta)\n      assignFields(a.inferred, tzMeta)\n    }\n\n    const mm = skipSiblingInference\n      ? extractMakeAndModel(a)\n      : await inferMakeAndModel(f, a)\n\n    // Only add \"Make\" and \"Model\" to original/inferred if it's not a simple\n    // make() and model() cleanup:\n    if (mm.Make !== make(a.Make)) {\n      a.original.Make = a.Make\n      a.inferred.Make = mm.Make\n    }\n    if (mm.Model !== model(mm.Make, a.Model)) {\n      a.original.Model = a.Model\n      a.inferred.Model = mm.Model\n    }\n\n    if (\n      !blank(Settings.defaultCopyright.valueOrDefault) &&\n      isExifUnset(a.Copyright)\n    ) {\n      a.Copyright = Settings.defaultCopyright.valueOrDefault\n    }\n\n    const lensMakeModel = extractLensMakeModel(a)\n\n    // CAPTURED-AT MUST BE AFTER TZ INFERENCE!\n    const capturedAt = await extractCapturedAt(f, a, skipSiblingInference)\n    if (capturedAt == null) {\n      logger().info(\"No capturedAt for \" + f)\n      return\n    }\n    if (!skipSiblingInference && capturedAt.isInferred) {\n      a.inferred.capturedAt = capturedAt\n    }\n    const exposureSettings = extractExposureSettings(a)\n\n    const sizeInfo = await extractSizeInfoFromFile(f, a)\n    if (sizeInfo == null) {\n      logger().info(\"No size info for \" + nativePath)\n      return\n    }\n\n    const obj = {\n      ...mm,\n      mimetype: m,\n      capturedAt,\n      exposureSettings,\n      ...extractTitleDescription(a),\n      ...lensMakeModel,\n      cameraId: cameraIdFromTags(a),\n      imageId: imageIdFromTags(a),\n      lensId: lensIdFromLensInfo({\n        ...lensMakeModel,\n        ...pick(a, \"LensSerialNumber\")\n      }),\n      ...sizeInfo,\n      duration: extractDurationSec(a),\n      tz: a.tz,\n      rating: extractRating(a)\n    }\n\n    if (isTest) {\n      ;(obj as any).__parsedBy__ = process.pid\n    }\n    const result = {\n      ...a,\n      ...obj // < needs to be after ...a to override ImageHeight and ImageWidth\n    }\n    logger().debug(\"parsedTags\", {\n      nativePath,\n      skipInference: skipSiblingInference,\n      ...obj,\n      inferred: a.inferred,\n      original: a.original,\n      pickedResult: pick(\n        result,\n        \"capturedAt\",\n        \"tz\",\n        \"tzSource\",\n        \"Make\",\n        \"Model\"\n      )\n    })\n    return definedValues(result) as ExifTags\n  } catch (error) {\n    logger().warn(\"parseTags() failed\", { error })\n    return\n  }\n}\n","import { Tags } from \"exiftool-vendored\"\nimport { lazy } from \"../../core/Lazy\"\nimport { includesAny } from \"../../fe/Array\"\nimport { blank, blankish } from \"../../fe/Blank\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { MultiMap } from \"../../fe/MultiMap\"\nimport { approximates, gt0, isNumber, toFixed } from \"../../fe/Number\"\nimport {\n  Valued,\n  compactBlankValues,\n  fromEntries,\n  isEmptyObj,\n  keys,\n  pick,\n  values\n} from \"../../fe/Object\"\nimport { parseJSON } from \"../../fe/ParseMaybe\"\nimport { firstDefinedThunk } from \"../../fe/Thunk\"\nimport { ExposureSettings } from \"../../fe/api/ExposureSettings\"\nimport { toS } from \"../../fe/toS\"\nimport { intersection, least } from \"../Array\"\nimport { geohash } from \"../GeoHash\"\nimport { extractFloat, extractFraction } from \"../Number\"\nimport { sortIgnoreCase, splitFirst } from \"../String\"\nimport { Settings } from \"../settings/Settings\"\nimport { LensInfo, LensTags, extractLensMakeModel } from \"./LensMakeModel\"\n\nexport const ImageNumberSynonyms = [\n  // ImageNumber and ShutterCount are synonyms (and used interchangeably):\n  \"ImageNumber\",\n  \"ShutterCount\",\n  \"ShutterCount2\",\n  \"ShutterCount3\"\n] as const\n\n// See https://forum.photostructure.com/t/jpeg-raw-bundles/265/5?u=mrm\n\nexport const CameraSerialNumberSynonyms = [\n  \"CameraSerialNumber\",\n  \"SerialNumber\",\n  \"BodySerialNumber\",\n  \"InternalSerialNumber\"\n] as const\n\n// export const TagSynonyms = [ImageNumberSynonyms, CameraSerialNumberSynonyms]\n\nconst TagSynonymGroups = [ImageNumberSynonyms, CameraSerialNumberSynonyms]\n\nexport const Tag2SynonymGroup = lazy(() => {\n  const result = new Map<string, string>()\n  for (const arr of TagSynonymGroups) {\n    const name = arr[0]\n    for (const ea of arr) {\n      result.set(ea, name)\n    }\n  }\n  return result\n})\nexport const Tag2Synonyms = lazy(() => {\n  const result = new Map<string, readonly string[]>()\n  for (const arr of TagSynonymGroups) {\n    for (const ea of arr) {\n      result.set(ea, arr)\n    }\n  }\n  return result\n})\n\nexport const zeroesRe = /^[\\s0]*1?$/\n\n/**\n * Ignore values that are blank or like \"000000000000\" or \"000000000001\"\n */\nfunction rubbish(o: any) {\n  return (\n    o == null ||\n    blankish(o) ||\n    (isNumber(o) && (o === 0 || o === 1)) ||\n    zeroesRe.exec(toS(o)) != null\n  )\n}\n\nexport function stringifyExifUid(\n  result: [string, number | string][]\n): Maybe<string> {\n  const arr = result == null ? [] : result.filter(([, v]) => !blank(v))\n  return arr.length === 0 ? undefined : stringify(fromEntries(arr))\n}\n\nfunction normalizeString(s: any): string {\n  // some values look bonkers, like \"            LENS    123\"\n  return toS(s).trim().replace(/\\s+/g, \" \")\n}\n/**\n * Remove rubbish values and only retain uniq values for tag synonym groups\n *\n * Only exposed for tests\n */\nexport function renderExifUidId(obj: any) {\n  const uniqSynonymValues = new MultiMap<string, string>()\n  const result: [string, number | string][] = []\n  for (const key of sortIgnoreCase(keys(obj))) {\n    if (rubbish(obj[key])) continue\n    const v = obj[key]\n    const s = normalizeString(obj[key])\n    // normalize all values to a trimmed string\n    // first value for a synonym group?\n    const group = Tag2SynonymGroup().get(key)\n    if (group != null) {\n      if (\n        uniqSynonymValues.includes(group, v) ||\n        uniqSynonymValues.includes(group, s)\n      ) {\n        continue\n      } else {\n        uniqSynonymValues.add(group, v)\n      }\n    }\n    result.push([key, gt0(v) ? v : s])\n  }\n  return stringifyExifUid(result)\n}\n\nfunction splitToEntry(keyColonValue: string): Maybe<[string, string]> {\n  // v1.1 encoded tuples as `${key}:${value}` strings.\n  const arr = splitFirst(keyColonValue, \":\")\n  return arr.length === 2 ? arr : undefined\n}\n\nexport function decodeExifUid(\n  s: Maybe<string>\n): Maybe<Valued<number | string>> {\n  if (blank(s)) return\n  const obj = parseJSON(s)\n  if (obj == null) {\n    // single values may be a colon-separated string\n    return fromEntries([splitToEntry(s)])\n  }\n  if (Array.isArray(obj)) {\n    // v1.1 encoded multiple values as a JSON-encoded array\n    return fromEntries(obj.map(splitToEntry))\n  }\n  // v2.1 encodes tuples as an object\n  return compactBlankValues(obj)\n}\n\nexport type InequalFields = {\n  aKey: string\n  aValue: number | string\n  bKey: string\n  bValue: number | string\n}\n\nexport function findInequalFields(\n  a: Maybe<string>,\n  b: Maybe<string>\n): Maybe<InequalFields> {\n  const aObj = decodeExifUid(a)\n  const bObj = decodeExifUid(b)\n  if (aObj == null || bObj == null || a === b) return\n\n  // check non-synonym'ed fields:\n  const commonSimpleFields = intersection(keys(aObj), keys(bObj)).filter(\n    ea => !Tag2SynonymGroup().has(ea)\n  )\n\n  // any direct non-matches?\n  for (const key of commonSimpleFields) {\n    // allow either aVal or bVal to be coerced to string (so disable eqeqeq)\n    const aValue = aObj[key]\n    const bValue = bObj[key]\n    if (normalizeString(aValue) !== normalizeString(bValue)) {\n      return { aKey: key, aValue, bKey: key, bValue }\n    }\n  }\n\n  // For each synonym group, as long as there's one match, or one side has no values, we're fine.\n  for (const group of TagSynonymGroups) {\n    const aPick = pick(aObj, ...group)\n    if (isEmptyObj(aPick)) continue\n    const bPick = pick(bObj, ...group)\n    if (isEmptyObj(bPick)) continue\n\n    const aValues = values(aPick).map(toS)\n    const bValues = values(bPick).map(toS)\n\n    if (includesAny(aValues, bValues)) continue\n\n    // Pick the least-valued key for each for determinism\n    const aKey = least(keys(aPick))!\n    const bKey = least(keys(bPick))!\n    return { aKey, aValue: aObj[aKey], bKey, bValue: bObj[bKey] }\n  }\n\n  return\n}\n\nfunction whyDefinedNotApproximate({\n  a,\n  b,\n  field,\n  desc,\n  parser\n}: {\n  a: Partial<ExposureSettings>\n  b: Partial<ExposureSettings>\n  field: keyof ExposureSettings\n  desc: string\n  parser: (input: any) => Maybe<number>\n}): Maybe<string> {\n  const i = parser(a[field])\n  const j = parser(b[field])\n  const minCoeff = Settings.minExposureSettingsCoeffPct.valueOrDefault / 100\n  return i == null || j == null || approximates(i, j, minCoeff)\n    ? undefined\n    : \"Different \" + desc + \": \" + a[field] + \" ≠ \" + b[field]\n}\n\n/**\n * @return a message with a mismatch if both a and b have a defined field but\n * they don't match.\n */\nexport function whyExposureSettingsNotSimilar(\n  a: Maybe<Partial<ExposureSettings>>,\n  b: Maybe<Partial<ExposureSettings>>\n): Maybe<string> {\n  if (a == null || b == null) return\n  return firstDefinedThunk([\n    () =>\n      whyDefinedNotApproximate({\n        a,\n        b,\n        field: \"focalLength\",\n        desc: \"focal length\",\n        parser: extractFloat\n      }),\n    () =>\n      whyDefinedNotApproximate({\n        a,\n        b,\n        field: \"aperture\",\n        desc: \"aperture\",\n        parser: extractFloat\n      }),\n    () =>\n      whyDefinedNotApproximate({\n        a,\n        b,\n        field: \"shutterSpeed\",\n        desc: \"shutter speed\",\n        parser: extractFraction\n      }),\n    () =>\n      whyDefinedNotApproximate({\n        a,\n        b,\n        field: \"iso\",\n        desc: \"ISO\",\n        parser: extractFloat\n      })\n  ])\n}\n\nexport function cameraIdFromTags(t: Tags): Maybe<string> {\n  return renderExifUidId(pick(t, ...CameraSerialNumberSynonyms))\n}\n\nexport function lensIdFromTags(t: LensTags & Pick<Tags, \"LensSerialNumber\">) {\n  return lensIdFromLensInfo({\n    ...extractLensMakeModel(t),\n    ...t\n  })\n}\n\n/**\n * Prevents re-extracting lens make and model\n */\nexport function lensIdFromLensInfo(\n  info: Partial<LensInfo> & Pick<Tags, \"LensSerialNumber\">\n): Maybe<string> {\n  // DON'T USE LensID! It doesn't match between JPG and RAW images!\n  const obj: any = pick(info, \"LensSerialNumber\")\n  if (info != null && !blank(info.lensMake) && !blank(info?.lensInfo)) {\n    // Lens models are TERRIBLE: Nikon gives TOTALLY different values between\n    // JPG and RAW pairs: so if something terse, like lensInfo, is available,\n    // use that instead. \"mli\" means \"make+lensInfo\". It's our own tag, so we\n    // can call it whatever we want.\n    obj.mli = `${info.lensMake.toLowerCase()}/${info.lensInfo}`\n  }\n  return renderExifUidId(obj)\n}\n\nexport function imageIdFromTags(t: Tags): Maybe<string> {\n  return renderExifUidId(\n    pick(t, ...ImageNumberSynonyms, \"BurstUUID\", \"RunTimeValue\")\n  )\n}\n\nexport function uidGeoHash(\n  lat: Maybe<number>,\n  lon: Maybe<number>\n): Maybe<string> {\n  // Note that 52 bits gives ~.5m resolution. Unfortunately, some cameras (like\n  // Google Pixels) will add slightly different GPS values to JPG/RAW pairs, so we\n  // downsample the geohash here.\n\n  // https://en.wikipedia.org/wiki/Decimal_degrees says 4 decimals get me to ~10m.\n  // Good enough.\n  return geohash(toFixed(lat, 4), toFixed(lon, 4))\n}\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\n\nconst NotSetRe = /undefined|null|none|n\\/a|unknown/i\nexport function isExifUnset(s: any): s is undefined {\n  return s == null || blank(s) || NotSetRe.test(toS(s))\n}\n\nexport function toExifDefined<T>(s: T): Maybe<T> {\n  return isExifUnset(s) ? undefined : s\n}\n","import { Tags } from \"exiftool-vendored\"\nimport { lazy } from \"../../core/Lazy\"\nimport { firstNotBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, toFloat, toInt } from \"../../fe/Number\"\nimport { reqValuedOrElse } from \"../../fe/Object\"\nimport { ExposureSettings } from \"../../fe/api/ExposureSettings\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { firstNonZero } from \"../Number\"\n\nconst logger = lazy(() => mkLogger(\"tags.ExposureSettings\"))\n\nexport function extractExposureSettings(t: Tags): Maybe<ExposureSettings> {\n  const exposureSettings = {\n    focalLength: t.FocalLength,\n    iso: firstNonZero(t.ISO, t.ISOSpeed, t.SonyISO),\n    aperture: firstNonZero(\n      t.FNumber,\n      t.Fnumber,\n      t.ApertureValue,\n      t.Aperture,\n      t.SonyFNumber\n    ),\n    // firstNotBlank rejects numbers, so we have to cast to string:\n    shutterSpeed: firstNotBlank(\n      toS(t.ExposureTime),\n      toS(t.ShutterSpeed),\n      toS(t.ShutterSpeedValue),\n      toS(t.SonyExposureTime)\n    )\n  }\n  logger().debug(\"extracted from \" + t.FileName, { exposureSettings })\n  return reqValuedOrElse(exposureSettings)\n}\n\nexport function exposureTimeToFloat(i: number | string) {\n  if (gt0(i)) return i\n  // Handle 1/100 or 1/32.4\n  const [j, k] = toS(i)\n    .split(\"/\")\n    .map(ea => toInt(ea))\n  return gt0(j) && gt0(k) ? j / k : undefined\n}\n\nexport function focalLengthToInt(i: number | string) {\n  const f = toFloat(i)\n  return gt0(f) ? Math.round(f) : undefined\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const ExtTypes = strEnum(\n  \"Sharp\",\n  \"HEIF\",\n  \"RawImage\",\n  \"Video\",\n  \"Sidecar\",\n  \"AssetFile\",\n  \"Exif\",\n  \"SupportedByCurrentBrowser\",\n  \"SupportedByOldBrowser\"\n)\n\nexport type ExtType = StrEnumKeys<typeof ExtTypes>\n","import { lazy } from \"../../core/Lazy\"\nimport { uniq } from \"../../fe/Array\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { MultiMap } from \"../../fe/MultiMap\"\nimport { entries, values } from \"../../fe/Object\"\nimport { splitLast } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { SidecarFiletypes, normalizeExt } from \"../fs/FileExt\"\nimport { JpegExts } from \"../fs/JpegExts\"\nimport { MaybeFileish } from \"../fs/MaybeFileish\"\nimport { ExtType, ExtTypes } from \"./ExtType\"\n\nexport const BrowserFiletypes = {\n  // \"audio/mpeg\": [\"mp2\", \"mp3\", \"mpga\"],\n\n  \"application/javascript\": [\"js\"],\n  \"application/toml\": [\"toml\"],\n  \"application/manifest+json\": [\"webmanifest\"],\n  \"application/xml\": [\"xml\"],\n\n  \"image/vnd.microsoft.icon\": [\"ico\"],\n\n  \"font/ttf\": [\"ttf\"],\n  \"font/woff2\": [\"woff2\"],\n\n  \"text/css\": [\"css\"],\n  \"text/html\": [\"html\", \"htm\"],\n  \"text/plain\": [\"txt\"],\n  \"text/x-scss\": [\"scss\"]\n}\n\n// 20230907: we don't query sharp.format for these, as we don't expect people\n// to recompile sharp with a custom libvips--and it makes core consumers (like\n// account) then require sharp (!!)\nexport const SharpImageFiletypes = {\n  \"image/jpeg\": JpegExts,\n  \"image/gif\": [\"gif\"],\n  \"image/png\": [\"png\"],\n  \"image/svg+xml\": [\"svg\"],\n  \"image/tiff\": [\"tif\", \"tiff\"],\n  \"image/webp\": [\"webp\"]\n} as const\n\n/**\n * @see https://en.wikipedia.org/wiki/High_Efficiency_Image_File_Format\n */\nexport const HeifFiletypes = {\n  \"image/avif\": [\"avif\"],\n  \"image/heic\": [\"heic\"],\n  \"image/heif\": [\"heif\"]\n}\n\nexport const RawImageFiletypes = {\n  // TODO:\n\n  // \"arq\",\n  // \"gpr\", gopro raw\n  // \"mef\", mamiya raw\n\n  \"image/x-adobe-dng\": [\"dng\"],\n\n  \"image/x-canon-cr2\": [\"cr2\"],\n  \"image/x-canon-cr3\": [\"cr3\"],\n  \"image/x-canon-crw\": [\"crw\"],\n\n  \"image/x-epson-erf\": [\"erf\"],\n\n  \"image/x-fuji-raf\": [\"raf\"],\n  \"image/x-fujifilm-raf\": [\"raf\"],\n\n  \"image/x-kodak-dcr\": [\"dcr\"],\n  \"image/x-kodak-k25\": [\"k25\"],\n  \"image/x-kodak-kdc\": [\"kdc\"],\n\n  \"image/x-hasselblad-3fr\": [\"3fr\"],\n\n  \"image/x-mamiya-mef\": [\"mef\"],\n\n  \"image/x-minolta-mrw\": [\"mrw\"],\n\n  \"image/x-nikon-nef\": [\"nef\"],\n  \"image/x-nikon-nrw\": [\"nrw\"],\n\n  \"image/x-olympus-orf\": [\"orf\"],\n\n  \"image/x-panasonic-raw\": [\"rwl\"],\n  // This is not always supported by libRaw yet (as of 2023-10-09), but we\n  // include it, as this mimetype is shared by several panasonic raw formats.\n  // https://www.libraw.org/node/2710\n  \"image/x-panasonic-rw2\": [\"rw2\"],\n\n  \"image/x-pentax-pef\": [\"pef\", \"dng\"],\n\n  // used by LEICA and Panasonic:\n  \"image/x-raw\": [\"raw\"],\n\n  \"image/x-samsung-srw\": [\"srw\"],\n\n  // \"image/x-sigma-x3f\": [\"x3f\"], // not supported by libraw as of 2022-01-16\n\n  \"image/x-sony-arw\": [\"arw\"],\n  \"image/x-sony-sr2\": [\"sr2\"],\n  \"image/x-sony-srf\": [\"srf\"]\n} as const\n\nexport const VideoFiletypes = {\n  \"video/3gpp\": [\"3gp\", \"3gpp\"],\n  \"video/3gpp2\": [\"3g2\"],\n  \"video/mp2t\": [\"mts\", \"ts\"],\n  \"video/mp4\": [\"mp4\"],\n  \"video/mpeg\": [\"m2v\", \"mpeg\", \"mpg\"],\n  \"video/quicktime\": [\"mov\", \"qt\"],\n  \"video/vnd.avi\": [\"avi\"],\n  \"video/webm\": [\"webm\"],\n  \"video/x-m4v\": [\"m4v\"],\n  \"video/x-mng\": [\"mng\"],\n  \"video/x-ms-asf\": [\"asf\"],\n  \"video/x-ms-wmv\": [\"wmv\"]\n} as const\n\nexport const AllFiletypes = {\n  ...BrowserFiletypes,\n  ...SidecarFiletypes,\n  ...SharpImageFiletypes,\n  ...RawImageFiletypes,\n  ...VideoFiletypes\n} as const\n\nexport const AssetFiletypes = {\n  ...SharpImageFiletypes,\n  ...HeifFiletypes,\n  ...RawImageFiletypes,\n  ...VideoFiletypes\n} as const\n\nexport const ExifFiletypes = {\n  ...AssetFiletypes,\n  ...SidecarFiletypes\n} as const\n\nconst Ext2mime = lazy(() => {\n  const result = {} as Record<string, string>\n  for (const [mime, exts] of entries(AllFiletypes)) {\n    for (const ext of exts) {\n      result[ext] = mime\n    }\n  }\n  return result\n})\n\nconst ExtAliases = lazy(() => {\n  const result = {} as Record<string, string[]>\n  for (const exts of values(AllFiletypes)) {\n    for (const ext of exts) {\n      result[ext] = exts as string[]\n    }\n  }\n  return result\n})\n\nexport const AllFileExts = lazy(() =>\n  uniq(flatten(values(AllFiletypes) as string[][]))\n)\n\nexport const AssetFileExts = lazy(() =>\n  uniq(flatten(values(AssetFiletypes) as string[][]))\n)\n\nexport function extMimetype(ext: MaybeFileish): Maybe<string> {\n  return Ext2mime()[normalizeExt(ext) ?? \"\"]\n}\n\nexport function mimetypeExt(mime: Maybe<string>): Maybe<string> {\n  return (AllFiletypes as any)[toS(mime).trim().toLowerCase()]?.[0]\n}\n\nexport function getExtAliases(ext: MaybeFileish): Maybe<string[]> {\n  return ExtAliases()[normalizeExt(ext) ?? \"\"]\n}\n\nexport const OldBrowserMimetypes = [\n  \"image/gif\",\n  \"image/jpeg\",\n  \"image/png\"\n] as const\n\nexport const CurrentBrowserMimetypes = [\n  ...OldBrowserMimetypes,\n  \"image/svg+xml\",\n  \"image/webp\",\n  \"video/mp4\",\n  \"video/webm\"\n] as const\n\nconst ext2types = lazy(() => {\n  const m = new MultiMap<string, ExtType>()\n\n  for (const { exts, type } of [\n    { exts: SharpImageFiletypes, type: ExtTypes.Sharp },\n    { exts: HeifFiletypes, type: ExtTypes.HEIF },\n    { exts: RawImageFiletypes, type: ExtTypes.RawImage },\n    { exts: VideoFiletypes, type: ExtTypes.Video },\n    { exts: SidecarFiletypes, type: ExtTypes.Sidecar },\n    { exts: AssetFiletypes, type: ExtTypes.AssetFile },\n    { exts: ExifFiletypes, type: ExtTypes.Exif }\n  ]) {\n    for (const ext of flatten(values(exts))) {\n      m.add(ext as any, type)\n    }\n  }\n\n  for (const mimetype of OldBrowserMimetypes) {\n    for (const ext of AllFiletypes[mimetype] ?? []) {\n      m.add(ext, ExtTypes.SupportedByOldBrowser)\n    }\n  }\n\n  for (const mimetype of CurrentBrowserMimetypes) {\n    for (const ext of AllFiletypes[mimetype] ?? []) {\n      m.add(ext, ExtTypes.SupportedByCurrentBrowser)\n    }\n  }\n\n  return m\n})\n\nexport function equivalentExts(\n  pathlike1: MaybeFileish,\n  pathlike2: MaybeFileish\n) {\n  const ext1 = normalizeExt(pathlike1)\n  const ext2 = normalizeExt(pathlike2)\n  if (ext1 == null || ext2 == null) return false\n  if (ext1 === ext2) return true\n  return getExtAliases(ext1)?.includes(ext2) ?? false\n}\n\nexport function extTypes(ext: MaybeFileish): Maybe<ExtType[]> {\n  const e = normalizeExt(ext)\n  return e == null ? undefined : ext2types().get(e)\n}\n\nexport function isExtType(ext: MaybeFileish, extType: ExtType): boolean {\n  return extTypes(ext)?.includes(extType) ?? false\n}\n\nexport function mimeRootType(ext: MaybeFileish): Maybe<\"image\" | \"video\"> {\n  const arr = extTypes(ext)\n  return arr == null\n    ? undefined\n    : arr.includes(ExtTypes.Sharp) || arr.includes(ExtTypes.RawImage)\n    ? \"image\"\n    : arr.includes(ExtTypes.Video)\n    ? \"video\"\n    : undefined\n}\n\nexport function isRawImageExt(ext: MaybeFileish): boolean {\n  return isExtType(ext, ExtTypes.RawImage)\n}\nexport function isSharpExt(ext: MaybeFileish): boolean {\n  return isExtType(ext, ExtTypes.Sharp)\n}\nexport function isVideoExt(ext: MaybeFileish): boolean {\n  return isExtType(ext, ExtTypes.Video)\n}\nexport function isAssetFileExt(ext: MaybeFileish): boolean {\n  return isExtType(ext, ExtTypes.AssetFile)\n}\nexport function isExifExt(ext: MaybeFileish): boolean {\n  return isExtType(ext, ExtTypes.Exif)\n}\nexport function isSupportedByCurrentBrowserExt(ext: MaybeFileish): boolean {\n  return isExtType(ext, ExtTypes.SupportedByCurrentBrowser)\n}\nexport function isSupportedByOldBrowserExt(ext: MaybeFileish): boolean {\n  return isExtType(ext, ExtTypes.SupportedByOldBrowser)\n}\n\nexport function stripExt(\n  base: string,\n  extType: ExtType = ExtTypes.AssetFile\n): string {\n  const ext = splitLast(base, \".\")\n  return isExtType(ext, extType) ? base.slice(0, -(ext.length + 1)) : base\n}\n","import { ExifDateTime, ResourceEvent, Tags, WriteTags } from \"exiftool-vendored\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isEmpty, isNotEmpty } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank, mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { eql } from \"../../fe/Eql\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { isNumber } from \"../../fe/Number\"\nimport {\n  assignFields,\n  entries,\n  isEmptyObj,\n  maybeCall,\n  pick\n} from \"../../fe/Object\"\nimport { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\nimport { isString } from \"../../fe/String\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { AppNameVersion } from \"../AppName\"\nimport { parseJSON } from \"../JSON\"\nimport { mkLogger } from \"../Logger\"\nimport { isFirstCharAZ, startsWithIgnoreCase } from \"../String\"\nimport { datedToMillis } from \"../date/DatedToMillis\"\nimport { luxonTzOffsetToOffsetMinutes } from \"../date/Timezone\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { toNativePath_ } from \"../fs/SimpleFile\"\nimport { Settings } from \"../settings/Settings\"\nimport { ExifTags } from \"./ExifTags\"\nimport { _readRawTags, overwriteTags_ } from \"./ExifTool\"\n\nexport const Actions = strEnum(\"infer\", \"set\", \"add\", \"delete\")\nexport type Action = StrEnumKeys<typeof Actions>\n\nexport function mkHistoryRecords(\n  action: Action,\n  tags: Maybe<Tags | WriteTags>\n): ResourceEvent[] {\n  return entries(tags ?? {}).map(([key, value]) =>\n    mkHistoryRecord({ action, key, value })\n  )\n}\n\nexport function mkHistoryRecord({\n  action,\n  key,\n  value,\n  ts\n}: {\n  action: Action\n  key: string\n  value: any\n  ts?: number\n}): ResourceEvent {\n  return {\n    Action: action,\n    Changed: toS(key).replace(/[#+]$/, \"\"), // < strip any \"#\" or \"+\" suffix\n    Parameters: stringify(maybeCall(value, \"toJSON\") ?? value),\n    When: ExifDateTime.fromMillis(ts ?? Date.now()),\n    SoftwareAgent: AppNameVersion()\n  }\n}\n\nexport const InferAction = \"infer\"\n\nconst logger = lazy(() => mkLogger(\"tags.History\"))\n\nexport function tagsContainHistory(\n  t: Maybe<Tags>,\n  predicate: (ea: ResourceEvent) => boolean\n): boolean {\n  if (t == null || t.History == null || isString(t.History)) return false\n\n  const h = t.History\n  if (Array.isArray(h)) {\n    return h.some(predicate)\n  } else {\n    return predicate(h)\n  }\n}\n\nexport function getInferredHistoricValues(\n  history: Maybe<ResourceEvent | ResourceEvent[]>\n): Partial<Record<keyof ExifTags, any>> {\n  if (history == null) return {}\n  const arr = toA(history)\n  if (isEmpty(arr)) return {}\n  const oldestFirst = sortBy(\n    arr.filter(\n      ea =>\n        startsWithIgnoreCase(ea.SoftwareAgent, \"PhotoStructure\") &&\n        ea.Action === Actions.infer\n    ),\n    ea =>\n      datedToMillis(mapNotBlank(ea.When, str => ExifDateTime.from(str))) ??\n      Date.now()\n  )\n  const result: any = {}\n  for (const ea of oldestFirst.reverse()) {\n    const k = ea.Changed\n    if (notBlank(k) && !(k in result)) {\n      result[k] = valueFromResourceEvent(ea)\n    }\n  }\n  return result\n}\n\nexport function valueFromResourceEvent(re: ResourceEvent) {\n  if (re?.Parameters == null) return\n  if (isNumber(re?.Parameters)) return re.Parameters\n  const s = toS(re)\n  if (blank(s)) return\n  return parseJSON(re.Parameters) ?? re.Parameters\n}\n\nexport function inferredToTags(\n  inferred: Maybe<Partial<ExifTags>>\n): Maybe<Tags> {\n  if (inferred == null) return\n  const result: Tags = {}\n  for (const [k, v] of entries(inferred)) {\n    if (isFirstCharAZ(k)) {\n      ;(result as any)[k] = v\n    }\n  }\n  if (\"duration\" in inferred) result.Duration = inferred.duration\n  if (\"title\" in inferred) result.Title = inferred.title\n  if (\"description\" in inferred) result.Description = inferred.description\n  if (\"rating\" in inferred) result.Rating = inferred.rating\n\n  assignFields(result, inferred.capturedAt?.asExifTag())\n\n  const tz = luxonTzOffsetToOffsetMinutes(\n    inferred.tz ?? inferred.capturedAt?.zoneName,\n    inferred.capturedAt?.toMillis()\n  )\n  if (tz != null) {\n    result.OffsetTime = tz\n  }\n  return result\n}\n\n/**\n * @param inferred the result from readTags().inferred\n */\nexport async function ensureInferredHistoryRecords(\n  src: PosixFile,\n  sidecar: PosixFile | string,\n  inferred: Maybe<Tags>\n): PromiseMaybe<ResourceEvent[]> {\n  const historyRecords = mkHistoryRecords(Actions.infer, inferred)\n  const additionalTags =\n    (Settings.writeInferredTagsToLibraryCopies.valueOrDefault\n      ? inferredToTags(inferred)\n      : undefined) ?? {}\n\n  if (Settings.writeSourceTagToLibraryCopies.valueOrDefault) {\n    additionalTags.Source = src.nativePath\n  }\n  logger().debug(\"ensureInferredHistoryRecords()\", {\n    sidecar,\n    historyRecords,\n    additionalTags\n  })\n\n  return ensureHistoryRecords(sidecar, historyRecords, additionalTags)\n}\n\nexport async function ensureHistoryRecords(\n  sidecar: Maybe<PosixFile | string>,\n  historyRecords: ResourceEvent[],\n  additionalTags?: Maybe<Tags | WriteTags>\n): PromiseMaybe<ResourceEvent[]> {\n  if (sidecar == null || blank(sidecar)) {\n    logger().warn(\"ensureHistoryRecords(): no-op: empty path\", { sidecar })\n    return\n  }\n  const sidecarPath = toNativePath_(sidecar)\n  const prior = await _readRawTags(sidecarPath)\n  const newHistoryRecords = toA(historyRecords).filter(hr => {\n    if (hr.Action !== Actions.infer) return true\n    const p1 = pick(hr, \"Changed\", \"Parameters\")\n    return !tagsContainHistory(prior, ea =>\n      eql(p1, pick(ea, \"Changed\", \"Parameters\"))\n    )\n  })\n  const tagsToWrite = { ...(additionalTags ?? {}) }\n  if (isNotEmpty(newHistoryRecords)) {\n    ;(tagsToWrite as any)[\"History+\"] = newHistoryRecords\n  }\n  if (isEmptyObj(tagsToWrite)) {\n    logger().debug(\"ensureHistoryRecords(): no-op: nothing to write\", {\n      sidecar,\n      historyRecords,\n      newHistoryRecords,\n      additionalTags,\n      tagsToWrite\n    })\n    return\n  }\n\n  logger().debug(\"ensureHistoryRecords(): write\", {\n    sidecar,\n    tagsToWrite,\n    historyRecords,\n    additionalTags\n  })\n\n  const sidecarFile = PosixFile.for(sidecar)\n\n  await overwriteTags_(sidecarFile, tagsToWrite)\n\n  // clear filesystem caches:\n  sidecarFile.clearThisAndParent()\n\n  return newHistoryRecords\n}\n","import tz_lookup from \"@photostructure/tz-lookup\"\nimport { defaultVideosToUTC, ExifDateTime, Tags } from \"exiftool-vendored\"\nimport { Zone } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toDated } from \"../date/Dated\"\nimport { datedToISO } from \"../date/FuzzyDate\"\nimport { parseDateTime } from \"../date/FuzzyDateParser\"\nimport {\n  isValidZone,\n  normalizeZone,\n  normalizeZoneOffsetMinutes\n} from \"../date/Timezone\"\nimport { isValidDate } from \"../date/ValidDate\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { validLat, validLon } from \"../GeoHash\"\nimport { mkLogger } from \"../Logger\"\nimport { eqlSubset } from \"../Object\"\nimport { Settings } from \"../settings/Settings\"\nimport { bname } from \"./Bname\"\nimport { DefaultCapturedAtTagsConst } from \"./DefaultCapturedAtTags\"\nimport { nearestSiblingTzOffset } from \"./TagInference\"\n\nconst logger = lazy(() => mkLogger(\"tags.InferTimezone\"))\n\nexport async function maybeInferTimezone(\n  f: PosixFile,\n  t: Tags,\n  skipSiblingInference: boolean\n): PromiseMaybe<Pick<Tags, \"tz\" | \"tzSource\">> {\n  return logger().tap({\n    msg: \"maybeInferTimezone()\",\n    result: await _maybeInferTimezone(f, t, skipSiblingInference)\n  })\n}\n\nasync function _maybeInferTimezone(\n  f: PosixFile,\n  t: Tags,\n  skipSiblingInference: boolean\n): PromiseMaybe<Pick<Tags, \"tz\" | \"tzSource\">> {\n  {\n    // If we have GPS, let that override everything else.\n    const zone = zoneFromLatLon(t)\n    if (zone != null && isValidZone(zone)) {\n      const result = {\n        tz: zone.name,\n        tzSource: \"GPSLatitude/GPSLongitude\"\n      }\n      return eqlSubset(result, t) ? undefined : result\n    }\n  }\n\n  if (isValidZone(t.tz) && t.tzSource !== defaultVideosToUTC) {\n    return\n  }\n\n  if (Settings.inferTimezoneFromDatestamps.valueOrDefault) {\n    for (const tagname of compactBlanks([\n      ...Settings.capturedAtTags.values,\n      ...Settings.capturedAtTagsFallback.values\n    ])) {\n      const edt = (t as any)[tagname]\n      // some timestamps include \"+00:00\" _but they don't mean it_\n      if (\n        edt instanceof ExifDateTime &&\n        isValidZone(edt.zone) &&\n        edt.zone !== \"UTC\"\n      ) {\n        return {\n          tz: edt.zone,\n          tzSource: \"infer:tag.\" + tagname + \".zone\"\n        }\n      }\n    }\n  }\n  if (!skipSiblingInference) {\n    const result = inferTzOffsetMinutesFromFilename(f, t)\n    if (result != null) return result\n  }\n  if (!skipSiblingInference) {\n    const result = await nearestSiblingTzOffset(f)\n    if (result != null) {\n      return {\n        tz: result.zoneName,\n        tzSource: \"infer:nearestSibling:\" + result.base\n      }\n    }\n  }\n  return\n}\n\nexport function zoneFromLatLon(\n  tags: Pick<Tags, \"GPSLatitude\" | \"GPSLongitude\"> = {}\n): Maybe<Zone> {\n  const lat = tags.GPSLatitude\n  const lon = tags.GPSLongitude\n  if (!validLat(lat) || !validLon(lon)) {\n    return logger().tap({\n      msg: \"zoneFromLatLon(): invalid lat/lon\",\n      result: undefined,\n      meta: {\n        lat,\n        lon\n      }\n    })\n  }\n  try {\n    const zoneName = tz_lookup(lat, lon)\n    const zone = normalizeZone(zoneName)\n    return logger().tap({\n      msg: \"zoneFromLatLon()\",\n      result: zone,\n      meta: {\n        lat,\n        lon,\n        zoneName\n      }\n    })\n  } catch (error) {\n    return logger().tap({\n      msg: \"zoneFromLatLon(): invalid lat/lon\",\n      result: undefined,\n      meta: {\n        lat,\n        lon,\n        error\n      }\n    })\n  }\n}\n\nexport type CapturedAtTags = Pick<\n  Tags,\n  Exclude<(typeof DefaultCapturedAtTagsConst)[number], \"photoTakenTime\">\n>\n\nexport function inferTzOffsetMinutesFromFilename(\n  f: PosixFile,\n  tags: Pick<Tags, \"tzSource\" | \"tz\"> & CapturedAtTags\n): Maybe<{ tz: string; tzSource: string }> {\n  const basenameDT = parseDateTime([bname(f.name, true), bname(f.name, false)])\n  if (basenameDT == null || !isValidDate(basenameDT)) {\n    return\n  }\n\n  // It's unclear if the duration always perturbs the filename.\n\n  // const durationMin = Math.round((extractDurationSec(tags) ?? 0) / 60)\n  // if (durationMin > 0) {\n  //   basenameDT = basenameDT.minus({ minutes: durationMin })\n  // }\n\n  for (const tagname of Settings.capturedAtTags.values) {\n    const dt = toDated((tags as any)[tagname])\n    if (dt == null || isValidDate(dt)) continue\n\n    const rawTzoffsetMinutes = Math.round(\n      (basenameDT.diff(dt, \"minutes\").as(\"minutes\") * 15) / 15\n    )\n    // Sometimes the filename is off by a minute or two, so rawTzoffsetMinutes is ~7 or something.\n    const normalizedOffsetMinutes =\n      normalizeZoneOffsetMinutes(rawTzoffsetMinutes)\n\n    // If the offset minutes is 0, we can't safely assume it was taken in UTC\n    // (some tags are always stored in UTC, regardless of the\n    // local-at-capture-time timezone)\n    const z =\n      normalizedOffsetMinutes === 0\n        ? undefined\n        : normalizeZone(normalizedOffsetMinutes)\n    if (z != null) {\n      return logger().tap({\n        msg: \"inferTzOffsetMinutesFromFilename(\" + f.name + \")\",\n        result: {\n          tz: z.name,\n          tzSource: \"infer:filename (diff with \" + tagname + \")\"\n        },\n        meta: {\n          dt: datedToISO(dt),\n          rawTzoffsetMinutes,\n          normalizedOffsetMinutes\n        }\n      })\n    }\n  }\n  return\n}\n\n// export function inferTzOffsetMinutesFromFilename(\n//   tags: Pick<Tags, \"FileName\" | \"tzSource\" | \"tz\"> & CapturedAtTags\n// ): PromiseMaybe<CapturedAtWithTz> {\n//   const firstWithZone = DefaultCapturedAtTags.find(ea => {\n//     const val = tags[ea]\n//     const z = getZoneName(val)\n//     // If it's UTC and tzSource is\n//     if (z != null\n//     if (hasZone(val))\n//   })\n//   const basenameDT = toDateTime(\n//     parseDateTime([bname(basename, true), bname(basename, false)], \"UTC\")\n//   )\n//   if (basenameDT == null || basenameDT.isValid !== true) {\n//     logger()\n//     return\n\n//   const caDT = toDateTime(date)\n//   if (caDT == null || caDT.isValid !== true) return\n\n//   const durationMin = Math.round((extractDurationSec(tags) ?? 0) / 60)\n//   const rawTzoffsetMinutes =\n//     basenameDT.diff(caDT, \"minutes\").as(\"minutes\") - durationMin\n//   const z = normalizeZone(rawTzoffsetMinutes)\n\n//   if (z == null) {\n\n//   }\n//   logger().debug(\n//     \"maybeFixTimezone(): trying to infer zone offset implied by filename\",\n//     {\n//       basenameDT,\n//       capturedAtDT: caDT,\n//       durationMin,\n//       rawTzoffsetMinutes,\n//       normalizedZone: z\n//     }\n//   )\n//   if (z != null) {\n//     return utcToZone(caDT, z.name)\n//   }\n// }\n","import { ExifDateTime, Tags, UnsetZone } from \"exiftool-vendored\"\nimport { compactBlanks, mapNotEmpty } from \"../../fe/Array\"\nimport { toNotBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { isNumber, mapInt, toInt } from \"../../fe/Number\"\nimport { compactValues } from \"../../fe/Object\"\nimport { thenMap } from \"../../fe/Promise\"\nimport { toA } from \"../../fe/toA\"\nimport { first } from \"../Array\"\nimport { validLat, validLon } from \"../GeoHash\"\nimport { Dated } from \"../date/Dated\"\nimport { parseDated } from \"../date/FuzzyDateParser\"\nimport { normalizeZone } from \"../date/Timezone\"\nimport { PosixFile } from \"../fs/PosixFile\"\n\nexport type JsonSidecarTags = Pick<\n  Tags,\n  \"Title\" | \"Description\" | \"GPSLatitude\" | \"GPSLongitude\" | \"GPSAltitude\"\n> & {\n  /**\n   * This is when the photo was uploaded to Google Photos:\n   */\n  creationTime?: Dated\n  /**\n   * This is the time the photo was last modified within Google Photos:\n   */\n  modificationTime?: Dated\n  /**\n   * This isn't remotely correct. I'm expecting 2019:01:08 17:28:44.740313\n   * (local, UTC-10:00) but I get something like Jan 9, 2019, 3:14:38 AM UTC\n   * (expecting 3:28:44 UTC)\n   */\n  photoTakenTime?: Dated\n  imageViews?: number\n  peopleNames?: string[]\n  favorited?: boolean\n  // https://forum.photostructure.com/t/handle-egregious-google-takeout-metadata-butchering/1029/2\n  googlePhotosOrigin?: boolean\n}\n\n/*\n\n{\n  \"title\": \"title from JSON!\",\n  \"description\": \"Description from JSON, hurray.\",\n  \"imageViews\": \"0\",\n  \"creationTime\": {\n    \"timestamp\": \"1547019276\",\n    \"formatted\": \"Jan 9, 2019, 7:34:36 AM UTC\"\n  },\n  \"modificationTime\": {\n    \"timestamp\": \"1555097007\",\n    \"formatted\": \"Apr 12, 2019, 7:23:27 PM UTC\"\n  },\n  \"favorited\": true,\n  \"people\": [{\n    \"name\": \"John Doe\"\n  }, {\n    \"name\": \"Jane Doe\"\n  }],\n  \"geoData\": {\n    \"latitude\": 20.927258333333334,\n    \"longitude\": -156.69559722222223,\n    \"altitude\": 34.0,\n    \"latitudeSpan\": 0.0,\n    \"longitudeSpan\": 0.0\n  },\n  \"geoDataExif\": {\n    \"latitude\": 20.927258333333334,\n    \"longitude\": -156.69559722222223,\n    \"altitude\": 34.0,\n    \"latitudeSpan\": 0.0,\n    \"longitudeSpan\": 0.0\n  },\n  \"photoTakenTime\": {\n    \"timestamp\": \"1547003678\",\n    \"formatted\": \"Jan 9, 2019, 3:14:38 AM UTC\"\n  }\n}\n\n*/\n\nfunction parseTimestamp(\n  ea: Maybe<{ timestamp?: string; formatted?: string }>,\n  defaultZone: Maybe<string>\n): Maybe<Dated> {\n  if (ea == null) return\n\n  const unixtime = toInt(ea?.timestamp)\n  if (isNumber(unixtime)) {\n    const zone = normalizeZone(ea?.formatted)\n    const edt = ExifDateTime.fromMillis(unixtime * 1000, {\n      rawValue: ea.formatted,\n      zone: zone ?? defaultZone ?? UnsetZone\n    })\n    if (true === edt?.isValid) return edt\n  }\n\n  return parseDated({ input: ea.formatted, defaultZone })\n}\n\n/**\n * JSON sidecar from Google Takeouts.\n */\nexport async function readJsonSidecar(\n  jsonFile: PosixFile,\n  defaultZone?: Maybe<string>\n): PromiseMaybe<JsonSidecarTags> {\n  return thenMap(jsonFile.readJson<any>(\"info\"), j => {\n    return compactValues({\n      Title: toNotBlank(j.title),\n      Description: toNotBlank(j.description),\n      GPSLatitude: first([j.geoData?.latitude, j.geoDataExif?.latitude], lat =>\n        validLat(lat) ? lat : undefined\n      ),\n      GPSLongitude: first(\n        [j.geoData?.longitude, j.geoDataExif?.longitude],\n        lon => (validLon(lon) ? lon : undefined)\n      ),\n      GPSAltitude: first([j.geoData?.altitude, j.geoDataExif?.altitude], alt =>\n        isNumber(alt) ? alt : undefined\n      ),\n      favorited: map(j.favorited, isTrue),\n      peopleNames: mapNotEmpty(\n        [...toA(j.people), ...toA(j.person)],\n        (arr: any[]) => compactBlanks(arr.map(ea => ea.name))\n      ),\n      creationTime: parseTimestamp(j.creationTime, defaultZone),\n      modificationTime: parseTimestamp(j.modificationTime, defaultZone),\n      photoTakenTime: parseTimestamp(j.photoTakenTime, defaultZone),\n      imageViews: mapInt(j.imageViews, i => i),\n      // https://forum.photostructure.com/t/handle-egregious-google-takeout-metadata-butchering/1029\n      googlePhotosOrigin: true\n    })\n  })\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const KeywordReparentingStrategies = strEnum(\"move\", \"copy\", \"retain\")\nexport type KeywordReparentingStrategy = StrEnumKeys<\n  typeof KeywordReparentingStrategies\n>\n","import { BinaryField, Tags } from \"exiftool-vendored\"\nimport { XMLParser } from \"fast-xml-parser\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact, compactBlankish, compactBlanks, uniq } from \"../../fe/Array\"\nimport { blank, mapNotBlank } from \"../../fe/Blank\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { pick } from \"../../fe/Object\"\nimport { toA } from \"../../fe/toA\"\nimport { remove } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { escapeRegExp } from \"../RegExp\"\nimport { isString } from \"../String\"\nimport { Settings } from \"../settings/Settings\"\n\nconst logger = lazy(() => mkLogger(\"tags.KeywordTags\"))\n\n// \"delimiters\" separate individual tags:\nexport const delimRe = lazy(() =>\n  mapNotBlank(\n    Settings.keywordDelimiters.valueOrDefault,\n    ea => new RegExp(`\\\\s*[${escapeRegExp(ea)}]\\\\s*`)\n  )\n)\nSettings.keywordDelimiters.watchLater(() => delimRe.unset())\n\nexport function splitKeyword(s: string) {\n  const re = delimRe()\n  return re == null ? [s] : compactBlanks(s.split(re))\n}\n\nexport function splitKeywords(s: string | string[] | BinaryField): string[] {\n  if (s == null || s instanceof BinaryField) {\n    return []\n  }\n  return compactBlanks(\n    Array.isArray(s) ? flatten(s.map(splitKeywords)) : splitKeyword(s)\n  )\n}\n// \"path separators\" separate tags hierarchical levels. If this is blank,\n// hierarchical paths are disabled (unless encoded as a hierarchy in the EXIF as\n// XML)\nexport const pathSepRe = lazy(() =>\n  mapNotBlank(\n    Settings.keywordPathSeparators.valueOrDefault,\n    ea => new RegExp(`\\\\s*[${escapeRegExp(ea)}]\\\\s*`)\n  )\n)\nSettings.keywordPathSeparators.watch(() => pathSepRe.unset())\ninterface Category {\n  Category?: Category[]\n  _: string\n}\nfunction catToS(c: Maybe<string | Category>): string[][] {\n  if (c == null) {\n    return []\n  } else if (isString(c)) {\n    return blank(c) ? [] : [[c]]\n  } else {\n    return flatten(\n      toA(c.Category)\n        .map(catToS)\n        .map(paths => paths.map(path => compact([c._, ...path])))\n    )\n  }\n}\nconst BlankCategoryRE = /^\\(?none\\)?$/i\n// only exposed for tests\n\nexport function parseCategories(s: Maybe<string>): Maybe<string[][]> {\n  if (blank(s) || BlankCategoryRE.exec(s) != null) return\n  try {\n    const xml = new XMLParser({ textNodeName: \"_\" }).parse(s)\n    return flatten(toA(xml?.Categories?.Category).map(catToS))\n  } catch (err) {\n    logger().warn(\"parseCategories() failed:\", { err, s })\n    return\n  }\n}\n\nexport function rawTagKeywords(t: Maybe<Tags>): (string | string[])[] {\n  const result: (string | string[])[] = []\n  if (t != null) {\n    const kwtags = [...Settings.keywordTags.values]\n    if (kwtags.includes(\"Categories\")) {\n      remove(kwtags, \"Categories\")\n      const ea = parseCategories(t.Categories)\n      if (ea != null) result.push(...ea)\n    }\n    for (const key of kwtags) {\n      const ea = (t as any)[key]\n      // If it's already an array, don't split again:\n      result.push(...(Array.isArray(ea) ? ea : splitKeywords(ea)))\n    }\n  }\n  return logger().tap({\n    msg: \"rawTagKeywords()\",\n    result: compactBlankish(uniq(result)),\n    meta: {\n      t:\n        t == null ? undefined : pick(t, ...(Settings.keywordTags.values as any))\n    }\n  })\n}\n","import { Tags } from \"exiftool-vendored\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compactBlanks, uniq } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { map, mapOr } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { sigFigs, toFloat } from \"../../fe/Number\"\nimport { entries } from \"../../fe/Object\"\nimport { toS } from \"../../fe/toS\"\nimport { first, greatestBy } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { Settings } from \"../settings/Settings\"\nimport { make } from \"./MakeModel\"\n\nexport interface LensInfo {\n  lensMake: string\n  lensModel: string\n  lensInfo?: string\n}\n\nconst logger = lazy(() => mkLogger(\"tags.LensMakeModel\"))\n\nconst KnownLensBrands = {\n  nikkor: \"Nikon\",\n  \"m.zuiko\": \"Olympus\",\n  zuiko: \"Olympus\"\n} as const\n\nexport type LensTags = Pick<\n  Tags,\n  | \"Make\"\n  | \"Lens\"\n  | \"LensType\"\n  | \"LensType2\"\n  | \"LensType3\"\n  | \"LensID\"\n  | \"LensSpec\"\n  | \"LensInfo\"\n  | \"LensMake\"\n  | \"LensModel\"\n> & { DNGLensInfo?: string }\n\nconst ZeissBatisHackRe = /^zeiss batis (?<f>[\\d.]+)\\/(?<mm>[\\d.]+)(?<etc>.*)/i\n\nexport function extractLensMakeModel(t: LensTags): Maybe<LensInfo> {\n  const lensMake = make(t.LensMake)\n  const Make = make(t.Make)\n\n  const results: LensInfo[] = []\n\n  // \"LensID\" can be quite descriptive, like \"Olympus M.Zuiko Digital ED\n  // 12-100mm F4.0 IS Pro\", but it's also sometimes \"Unknown 7-21mm\"\n\n  // \"LensModel\" is typically shorter than \"LensID\", but still has some\n  // branding, ** and may be different between JPG and RAW images **\n\n  // \"LensInfo\" is typically perfect for short: \"4-6mm f/1.8-2.4\" but sometimes is \"24-105mm f/?\"\n\n  // \"Lens\" doesn't always include aperture: \"28.0 - 135.0 mm\"\n\n  // \"LensType\" is a grab bag of randomness: \"E-Mount, T-Mount, Other Lens or no\n  // lens\", \"n/a\", \"G VR\", \"Canon EF 50mm f/1.4 USM or Other Lens\". I'll only\n  // use if it we can extract a length and aperture from the value.\n\n  const lensInfo = first(\n    [t.LensInfo, t.DNGLensInfo, t.LensSpec, t.LensModel, t.LensID],\n    justLengthAndAperture\n  )\n\n  const lensModels = uniq([\n    t.LensModel,\n    t.LensID,\n    t.LensSpec,\n    t.LensInfo,\n    t.LensType,\n    t.LensType2,\n    t.LensType3,\n    t.Lens\n  ])\n\n  logger().debug(\"extractLensMakeModel\", { lensMake, lensInfo, lensModels })\n\n  for (const lensModel of lensModels) {\n    {\n      // Hack for \"ZEISS Batis 2/40 CF\", which means \"40mm f/2\"\n      const g = ZeissBatisHackRe.exec(lensModel)?.groups as {\n        f: string\n        mm: string\n        etc: string\n      }\n      if (g != null) {\n        results.push({\n          lensMake: \"Zeiss\",\n          lensModel: `Batis ${g.mm}mm F${g.f} ${g.etc.trim()}`.trim(),\n          lensInfo: `${g.mm}mm f/${g.f}`\n        })\n      }\n    }\n\n    const hasLengthAndAperture = justLengthAndAperture(lensModel) != null\n\n    if (!hasLengthAndAperture) continue\n    if (notBlank(lensMake)) {\n      results.push({\n        lensMake,\n        lensModel,\n        lensInfo\n      })\n    }\n\n    const lcLensModel = lensModel.toLowerCase()\n\n    for (const [k, replacementLensMake] of entries(KnownLensBrands)) {\n      if (lcLensModel.includes(k)) {\n        results.push({\n          lensMake: replacementLensMake,\n          lensModel,\n          lensInfo\n        })\n      }\n    }\n\n    for (const mfg of compactBlanks([lensMake, ...Settings.lensMakes.values])) {\n      // Some camera bodies don't encode a LensMake, and include the make in the\n      // model name. If a lens includes a make, use that for lensMake, and strip of lensMake from the lensModel:\n      if (lensModel.toLowerCase().includes(mfg.toLowerCase())) {\n        results.push({\n          lensMake: mfg,\n          lensModel,\n          lensInfo\n        })\n      }\n    }\n\n    // Is it a Nikon \"VR\" lens?\n    if (lcLensModel.startsWith(\"vr \") && Make === \"Nikon\") {\n      results.push({\n        lensMake: \"Nikon\",\n        lensModel,\n        lensInfo\n      })\n    }\n\n    // mrm 20211229: I don't think this is safe:\n    // if (lcLensModel.startsWith(\"unknown\") && notBlank(t.Make)) {\n    //   // Assume the lens is built-in\n    //   makes.push(\"unknown\")\n    //   return {\n    //     lensMake: t.Make,\n    //     lensModel: cleanUpModel(lensModel),\n    //     lensInfo\n    //   }\n    // }\n  }\n\n  for (const ea of results) {\n    const replacement = (KnownLensBrands as any)[ea.lensMake.toLowerCase()]\n    ea.lensMake = replacement ?? ea.lensMake\n    ;(ea.lensModel = cleanBogusPrecision(\n      ea.lensModel.replace(new RegExp(\"\\\\b\" + ea.lensMake + \"\\\\b\", \"i\"), \"\")\n    )),\n      (ea.lensInfo = map(ea.lensInfo, cleanBogusPrecision))\n  }\n\n  return greatestBy(results, ea => [\n    // Avoid, if we can, model names like \"RF 50mm F1.2L USM or other Canon RF\n    // Lens\" or \"EF 17-40mm f/4L USM or Sigma Lens\"\n    null == ea.lensModel.match(/\\bor\\b/i),\n    ea.lensModel.length\n  ])\n}\n\nfunction nonZeroish(s: Maybe<string>): s is string {\n  return s != null && s.match(/^0+$/) == null\n}\n\nconst mmRangeRE = /([\\d. -]+)\\s?mm\\b/i\nconst apertureRE = /\\bf\\/?([\\d.\\-]+)/i\n\nexport function justLengthAndAperture(s: Maybe<string>): Maybe<string> {\n  if (blank(s) || toS(s).toLowerCase().includes(\"unknown\")) return\n  // normalizeLensModel(\n  //   s.replace(/\\b(AF-S|CF|DG|Digital|DI|DX|E|ED|HSM|LM|OIS|Pro|R|XF)\\b/gi, \"\")\n  // )\n\n  // Handle \"22mm\" and \"EF 12 - 123.3 mm\" and remove any spaces:\n  s = s.replace(/\\s+/g, \" \").trim()\n  const mm = mmRangeRE.exec(s)?.[1].replace(/\\s/g, \"\")\n  const aperture = apertureRE.exec(s)?.[1]\n  return nonZeroish(mm) && nonZeroish(aperture)\n    ? cleanBogusPrecision(`${mm}mm f/${aperture}`)\n    : undefined\n}\n\nexport function cleanBogusPrecision(s: string, significant = 3): string {\n  return s\n    .replace(/\\d+\\.\\d+/g, m =>\n      mapOr(toFloat(m), ea => String(sigFigs(ea, significant)), m)\n    )\n    .replace(/\\s+/g, \" \")\n    .trim()\n}\n\nexport function normalizeLensModel(model: string): string {\n  return cleanBogusPrecision(model)\n    .replace(/(\\d) - (\\d)/g, (_, m1, m2) => `${m1}-${m2}`)\n    .replace(/(\\d)\\s+mm\\b/, (_, m1) => m1 + \"mm\")\n    .replace(/\\s+f\\/?(\\d)/i, (_, m1) => \" f/\" + m1)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { map, mapOr } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { Valued, compactValues, entries } from \"../../fe/Object\"\nimport { toS } from \"../../fe/toS\"\nimport { escapeRegExp } from \"../RegExp\"\nimport { stripQuotes } from \"../String\"\nimport { intToRoman } from \"../math/RomanNumerals\"\nimport { RareTags } from \"./ExifTags\"\nimport { isExifUnset, toExifDefined } from \"./ExifUnset\"\n\n// HEURISTICS AHOY!\n\nfunction replaceAll(s: string, re: RegExp, replacement = \"\"): string {\n  const str = s.replace(re, replacement)\n  return str === s ? s : replaceAll(str, re, replacement)\n}\n\nconst CamelCasedCos = [\n  \"BenQ\",\n  \"GoPro\",\n  \"HTC\",\n  \"LG\",\n  \"NEC\",\n  \"OnePlus\",\n  \"Sony\",\n  \"TrueHDR\"\n]\nconst Lower2Camel = new Map(CamelCasedCos.map(ea => [ea.toLowerCase(), ea]))\n\nexport function companyCased(str: string): string {\n  const s = str.trim()\n  const m = Lower2Camel.get(s.toLowerCase())\n  return m != null\n    ? m\n    : s.length < 4\n    ? s\n    : s.toLowerCase().replace(/(?:^|\\s|-)\\S/g, c => c.toUpperCase())\n}\n\ntype NamedPattern = [RegExp, string]\n\nclass Constants {\n  readonly ignorables = [\n    \"ag\",\n    \"camera\",\n    \"co\",\n    \"company\",\n    \"computer\",\n    \"corp\",\n    \"corporation\",\n    \"digital\",\n    \"elec\",\n    \"electric\",\n    \"electronics\",\n    \"fototechnic\",\n    \"global\",\n    \"gmbh\",\n    \"group\",\n    \"imaging\",\n    \"inc\",\n    \"international\",\n    \"ltd\",\n    \"optical\",\n    \"photo\",\n    \"products\",\n    \"solutions\",\n    \"system\",\n    \"technologies\",\n    \"technology\",\n    \"techwin\"\n  ].join(\"|\")\n\n  readonly ignorableSep = \"[\\\\s\\\\.,_-]*\"\n\n  readonly IgnorableMakePatterns = new RegExp(\n    `${this.ignorableSep}(?:${this.ignorables})${this.ignorableSep}$`,\n    \"i\"\n  )\n\n  readonly IgnorableModelPatterns = [\n    // Some camera models (like Motorola's Droid X) end in a hex serial\n    // number. We don't need that:\n    /[\\da-f]{24,}$/i,\n    // Some camera models have a version number (!!):\n    /\\(v\\d(?:\\d?[^\\d\\n\\r\\u2028\\u2029]\\d+|\\d{2,}(?:[^\\d\\n\\r\\u2028\\u2029]\\d+)?)\\)\\w?$/i,\n    // Some digital cameras are less sure of themselves, and need to reassert\n    // their digital camera-ness:\n    /digital camera$/i,\n    /zoom camera$/i\n  ]\n\n  // https://www.gsmarena.com has some original files and a ton of model\n  // lists, like https://www.gsmarena.com/samsung-phones-9.php\n\n  readonly samsungPatterns: NamedPattern[] = [\n    [/^PL150 /, \"PL150\"],\n    [\n      /^SCH-I545|SHV-E300|SGH-I337|SGH-M919|SPH-L720|SCH-R970|SGH-N045|GT-I950/i,\n      \"Galaxy S4\"\n    ],\n    [/^SGH-i537|GT-I9295/, \"Galaxy S4 Active\"],\n    [/^GT-S50\\S+|SM-G90/, \"Galaxy S5\"],\n    [/^SM-G870A/, \"Galaxy S5 Active\"],\n    [/^SM-A30\\S+/, \"Galaxy A3\"],\n    [/^SM-A530/, \"Galaxy A8\"],\n    [/^SM-A700\\S+/, \"Galaxy A7\"],\n    [/^SM-A730/, \"Galaxy A8+\"],\n    [/^SM-G920\\S+/, \"Galaxy S6\"],\n    [/^SM-G925\\S+/, \"Galaxy S6 Edge\"],\n    [/^SM-G928/, \"Galaxy S6 Edge+\"],\n    [/^SM-G930\\S+/, \"Galaxy S7\"],\n    [/^SM-G935\\S+/, \"Galaxy S7 Edge\"],\n    [/^SM-G950/, \"Galaxy S8\"],\n    [/^SM-G955/, \"Galaxy S8+\"],\n    [/^SM-G960/, \"Galaxy S9\"],\n    [/^SM-G965/, \"Galaxy S9+\"],\n    [/^SM-G970/, \"Galaxy S10e\"],\n    [/^SM-G973|SM-G977|SC-03|SCV41/, \"Galaxy S10\"],\n    [/^SM-G975|SC-04|SC-05|SCV42/, \"Galaxy S10+\"],\n    [/^SM-G98[01]/, \"Galaxy S20\"],\n    [/^SM-G98[56]/, \"Galaxy S20+\"],\n    [/^SM-G988/, \"Galaxy S20 Ultra\"],\n    [/^SM-J510\\S+/, \"Galaxy J5\"],\n    [/^SM-N900/, \"Galaxy Note 3\"],\n    [/^SM-N910/, \"Galaxy Note 4\"],\n    [/^SM-N920/, \"Galaxy Note 5\"],\n    [/^SM-N930/, \"Galaxy Note 7\"],\n    [/^SM-N950/, \"Galaxy Note 8\"],\n    [/^SM-F936/, \"Galaxy Z Fold 4\"],\n    [/^SM-F721/, \"Galaxy Z Flip 4\"],\n    [/^SM-G991/, \"Galaxy S21\"],\n    [/^SM-G996/, \"Galaxy S21+\"],\n    [/^SM-G998/, \"Galaxy S21 Ultra\"],\n    [/^SM-S901/, \"Galaxy S22\"],\n    [/^SM-S906/, \"Galaxy S22+\"],\n    [/^SM-S908/, \"Galaxy S22 Ultra\"],\n    [/^SM-S911/, \"Galaxy S23\"],\n    [/^SM-S916/, \"Galaxy S23+\"],\n    [/^SM-S918/, \"Galaxy S23 Ultra\"],\n    [/^SM-A245/, \"Galaxy A24 4G\"],\n    [/^SM-E146B/, \"Galaxy F14\"],\n    [/^SM-F711/, \"Galaxy Z Flip 3\"],\n    [/^SM-F721/, \"Galaxy Z Flip 4\"],\n    [/^SM-F936/, \"Galaxy Z Fold 4\"],\n    [/^SM-E546B/, \"Galaxy F54\"],\n    [/^SM-X700|SM-X706/, \"Galaxy Tab S8\"],\n    [/^SM-X800|SM-X806/, \"Galaxy Tab S8+\"],\n    [/^SM-X900|SM-X906/, \"Galaxy Tab S8 Ultra\"],\n    [/SM-T509/, \"Galaxy Tab A7\"]\n  ]\n\n  readonly lgPatterns: NamedPattern[] = [\n    // https://en.wikipedia.org/wiki/LG_G2#Model_variants\n    [/LG-D80[0-35]|LS98|VS98|L-01F/, \"G2\"],\n    [/D85|F400|LS990|US990|VS985/, \"G3\"],\n    [/H81\\d|F500|LS991|US991|VS986/, \"G4\"],\n    [/H850|H858|VS987|H820|LS992|H830|US992|H860N/, \"G5\"],\n    [/H87[0-3]|LS993|AS993|US997|VS998/, \"G6\"],\n    [/^(LM-)?G71/i, \"G7\"] // LM-G710N\n  ]\n\n  readonly onePlusPatterns: NamedPattern[] = [\n    // https://www.gsmarena.com/oneplus-phones-95.php\n    [/A0001/, \"One\"],\n    [/A100\\d/, \"X\"],\n    [/A20\\d\\d/, \"2\"],\n    [/A30\\d\\d/, \"3(T)\"],\n    [/A40\\d\\d/, \"4\"],\n    [/A500\\d/, \"5\"],\n    [/A501\\d/, \"5T\"],\n    [/A600\\d/, \"6\"],\n    [/A601\\d/, \"6T\"],\n    [/GM1900|GM1901|GM1903/, \"7\"],\n    [/GM1910|GM1911|GM1913|GM1915|GM1917/, \"7 Pro\"],\n    [/HD1900|HD1901|HD1903|HD1905|HD1907/, \"7T\"],\n    [/HD1910|HD1911|HD1913/, \"7T Pro\"],\n    [/HD1925/, \"7T Pro 5G\"],\n    [/IN2010|IN2011|IN2013|IN2015|IN2017|IN2019/, \"8\"],\n    [/IN2020|IN2021|IN2023|IN2025/, \"8 Pro\"],\n    [/LE2115|LE2113|LE2111/, \"9\"],\n    [/LE2121|LE2125|LE2123|LE2120/, \"9 Pro\"],\n    [/LE2101/, \"9r\"],\n    [/CPH2389/, \"Nord N300\"],\n    [/CPH2415|CPH2413|CPH2417/, \"10T\"],\n    [/NE2210|NE2211|NE2213|NE2215|NE2217/, \"10 Pro\"],\n    [/PGP110/, \"Ace Pro\"],\n    [/PHB110|CPH2449|CPH2447|CPH2451/, \"11\"]\n  ]\n\n  readonly CommonNamesByMake: Valued<NamedPattern[]> = {\n    Samsung: this.samsungPatterns,\n    LG: this.lgPatterns,\n    OnePlus: this.onePlusPatterns\n  }\n}\n\n// TODO: does this need to be lazy'ed? I think I did it to avoid regex parsing\n// at startup, but that's probably not a big deal.\nconst i = lazy(() => new Constants())\n\nconst GoProRe = /\\bgopro\\b/i\n\nfunction goProMakeMaybe(tags: RareTags) {\n  return GoProRe.test(toS(tags.HandlerDescription)) ||\n    GoProRe.test(toS(tags.CompressorName))\n    ? \"GoPro\"\n    : undefined\n}\n\nexport function extractMakeAndModel(tags: Maybe<RareTags>): {\n  Make?: string\n  Model?: string\n} {\n  if (tags == null) return {}\n  const Make =\n    make(tags.Make) ??\n    makeFromSoftware(tags.Software) ??\n    makeFromSoftware(tags.CreatorTool) ??\n    goProMakeMaybe(tags)\n\n  const Model = model(\n    Make,\n    // DON'T USE DeviceModel or DeviceManufacturer: those are from the ICC profile!\n    toExifDefined(tags.Model) ??\n      // Really old cameras, like QuickTake 200, use \"CameraModelName\" instead\n      // of Model.\n      toExifDefined(tags.CameraModelName) ??\n      toExifDefined(tags.CameraModel)\n  )\n\n  return compactValues({ Make, Model }) ?? {}\n}\n\nexport function make(rawMake: Maybe<string>): Maybe<string> {\n  if (isExifUnset(rawMake)) return\n  let s = stripQuotes(rawMake)\n  // https://en.wikipedia.org/wiki/HP_Inc.\n  if (/Hewlett[- ]Packard/i.test(s)) return \"HP\"\n  s = replaceAll(s, i().IgnorableMakePatterns)\n  s = s.replace(/\\s+app on Apple iDevice$/i, \"\")\n  s = s.replace(/\\bLGE\\b/, \"LG\")\n  s = s.replace(/\\bEastman Kodak\\b/i, \"Kodak\")\n  s = companyCased(s)\n  s = s.replace(/^OM$/i, \"OM System\")\n  return s\n}\n\n// Only emit files that have a .Software value:\n\n// exiftool -r -if '$Software' -Software ~/src/test-images\n\nconst SoftwarePatterns = {\n  Acer: /^Acer\\b/i,\n  Canon: /^(Canon|CanoScan)\\b/i,\n  Daisy: /^Exif Daisy\\b/i,\n  Fujifilm: /Digital Camera FinePix\\b/i,\n  GE: /Digital Camera GE\\b/i,\n  Kodak: /\\bKodak\\b/i,\n  Kyocera: /^Kyocera|SAMURAI\\b/i,\n  LG: /^(LGE_SW|LG Electronics)\\b/i,\n  Minolta: /^(Minolta|DiMAGE|DYNAX|MAXXUM|ALPHA SWEET)\\b/i,\n  Nikon: /^(Nikon|COOLPIX)\\b/i,\n  Olympus: /^OLYMPUS\\b/i,\n  OnePlus: /^OnePlus/i,\n  Pentax: /^(Optio|PENTAX)\\b/i,\n  Ricoh: /^RICOH\\b/i,\n  RIM: /^(Rim Exif Version|BlackBerry)/i\n}\n\n/**\n * @param rawSoftware the value from `.Software`. Some (ancient) devices that\n * don't emit a `.Make` value will emit a `.Software` value that lets us infer\n * the Make.\n */\nexport function makeFromSoftware(rawSoftware: Maybe<string>): Maybe<string> {\n  if (blank(rawSoftware)) return\n  for (const [k, v] of entries(SoftwarePatterns)) {\n    if (v.test(rawSoftware)) return k\n  }\n  return\n}\n\n// < Digimax U-CA 5, Kenox U-CA 5 / Kenox U-CA 50 >\n\nconst AncientSamsungModel = /<\\s*(\\S[^,/]+)[,/]/\n\nexport function model(\n  cleanMake?: string,\n  rawModel?: string\n): string | undefined {\n  if (isExifUnset(cleanMake) || isExifUnset(rawModel)) {\n    return\n  }\n  // Some Canon will put quotes around the make and model (!!)\n  let m = stripQuotes(rawModel)\n\n  if (cleanMake === \"Samsung\") {\n    const match = AncientSamsungModel.exec(m)\n    if (match != null) {\n      m = match[1].trim()\n    }\n  }\n\n  const commonName = map(\n    i().CommonNamesByMake[cleanMake],\n    (arr: NamedPattern[]) => arr.find(([re]) => m!.match(re) != null)\n  )\n\n  if (commonName != null) {\n    return commonName[1].trim()\n  }\n\n  // If the make prefixes the model, remove that:\n  m = m.replace(new RegExp(`^${escapeRegExp(cleanMake)}\\\\s+`, \"i\"), \"\")\n\n  if (cleanMake === \"Sony\") {\n    m = m.replace(/^(?:DSLR-A|SLT-A|ILCA-|ILCE-)/, \"α\").replace(/7CL?/i, \"7c\") // ILCE-7CL is the α7c\n\n    const match = /M(\\d+)$/.exec(m)\n    if (match != null) {\n      m = m.slice(0, match.index) + \" \" + intToRoman(match[1])\n    }\n  }\n\n  if (cleanMake === \"Kodak\") {\n    m = m\n      .replace(/Kodak|digital|science|zoom|camera/gi, \"\")\n      .replace(/\\s+/g, \" \")\n  }\n\n  if (cleanMake === \"Olympus\" || cleanMake === \"OM System\") {\n    // Handle \"E-M5MarkIII\"\n    m = mapOr(\n      /^(.+?\\d)mark(i.+)$/i.exec(m),\n      match => `${match[1]} Mark ${match[2]}`,\n      () => m\n    )\n  }\n\n  if (cleanMake === \"Panasonic\") {\n    // Only remove \"DC-\" prefix if it leaves 2+ characters:\n    m = m.replace(/^(?:DC|DMC)-(.{2,})$/i, \"$1\")\n  }\n\n  if (cleanMake === \"Motorola\") {\n    // Handle \"DROID2\"\n    m = m.replace(/DROID/i, \"Droid \")\n  }\n\n  if (cleanMake === \"Canon\") {\n    // Handle \"EOS DIGITAL REBEL\"\n    m = m\n      .replace(/\\bDIGITAL\\b/i, \"\")\n      .trim()\n      .replace(/EOS\\s+REBEL/i, \"EOS Rebel\") // as per Canon's website\n\n    const match = m.match(/^EOS R(\\d+)\\s*m(\\d+)$/i)\n    if (match != null) {\n      m = `EOS R${match[1]} Mark ${intToRoman(match[2])}`\n    }\n    // Render \"EOS R6m2\" as \"EOS R6 Mark II\"\n  }\n\n  for (const re of i().IgnorableModelPatterns) {\n    m = replaceAll(m!, re).trim()\n  }\n\n  // Even if it's \"HP\":\n  if (\n    cleanMake!.match(/^HP|Hewlett.Packard$/i) != null &&\n    m.match(/^hp\\b/i) != null\n  ) {\n    // Remove \"HP\" prefix:\n    m = m.slice(2).trim()\n  }\n  return m\n}\n","import { ExifDateTime, ResourceEvent } from \"exiftool-vendored\"\nimport { lazy } from \"../../core/Lazy\"\nimport { pushUniq, remove } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank, mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isNumber } from \"../../fe/Number\"\nimport { isEmptyObj, pick } from \"../../fe/Object\"\nimport { parseJSON } from \"../../fe/ParseMaybe\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { AppName, AppNameVersion } from \"../AppName\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { stringifySorted } from \"../StringifySorted\"\nimport { IAssetFile } from \"../asset-file/IAssetFile\"\nimport { datedToMillis } from \"../date/DatedToMillis\"\nimport { parseDated } from \"../date/FuzzyDateParser\"\nimport { ExifTags } from \"./ExifTags\"\n\nconst logger = lazy(() => mkLogger(\"tags.MergedTags\"))\n\nexport type RevisionValue = number | string | string[]\n\nexport interface BaseRevision {\n  createdAt: number\n  field: string\n}\n\nexport interface PrimitiveRevision extends BaseRevision {\n  priorValue?: Maybe<RevisionValue>\n  newValue: Maybe<RevisionValue>\n}\n\n/**\n * Handles revisions to `Set` fields, like `Keywords`\n */\nexport interface SetAddRevision extends BaseRevision {\n  op: \"add\"\n  newValue: RevisionValue\n}\n\nexport interface SetDeleteRevision extends BaseRevision {\n  op: \"delete\"\n  priorValue: RevisionValue\n}\n\nexport function isBaseRevision(o: any): o is BaseRevision {\n  return isNumber(o?.createdAt) && notBlank(o?.field)\n}\n\nexport function isPrimitiveRevision(o: any): o is PrimitiveRevision {\n  return o?.op == null && isBaseRevision(o)\n}\n\nexport function isSetRevision(o: any): o is SetAddRevision | SetDeleteRevision {\n  return [\"add\", \"delete\"].includes(o?.op) && isBaseRevision(o)\n}\n\nexport type Revision = PrimitiveRevision | SetAddRevision | SetDeleteRevision\n\nexport function resourceEventToRevision(\n  re: Maybe<ResourceEvent>\n): Maybe<Revision> {\n  if (re == null || !toS(re.SoftwareAgent).startsWith(AppName())) {\n    return logger().tap({\n      msg: \"resourceEventToRevision() invalid\",\n      result: undefined,\n      meta: { resourceEvent: re }\n    })\n  }\n  const field = re.Changed\n\n  if (blank(field)) {\n    return logger().tap({\n      msg: \"resourceEventToRevision() missing Changed field name\",\n      result: undefined,\n      meta: { resourceEvent: re }\n    })\n  }\n\n  const fields = pick(\n    mapNotBlank(re.Parameters, parseJSON) ?? ({} as any),\n    \"newValue\",\n    \"priorValue\"\n  )\n\n  if (isEmptyObj(fields)) {\n    return logger().tap({\n      msg: \"resourceEventToRevision() missing Parameter fields\",\n      result: undefined,\n      meta: { resourceEvent: re }\n    })\n  }\n\n  const createdAtTs = datedToMillis(parseDated({ input: re.When }))\n\n  if (createdAtTs == null) {\n    return logger().tap({\n      msg: \"resourceEventToRevision() missing createdAt (When)\",\n      result: undefined,\n      meta: { resourceEvent: re }\n    })\n  }\n\n  if (blank(re.Action)) {\n    return logger().tap({\n      msg: \"resourceEventToRevision() missing op (Action)\",\n      result: undefined,\n      meta: { resourceEvent: re }\n    })\n  }\n\n  // TODO: Do we need to verify newValue and priorValue are set properly for\n  // add, delete, and assign?\n\n  return logger().tap({\n    msg: \"resourceEventToRevision()\",\n    result: {\n      createdAt: createdAtTs,\n      field,\n      op: re.Action === \"assign\" ? undefined : re.Action,\n      ...fields\n    },\n    meta: { resourceEvent: re }\n  })\n}\n\nexport function revisionToResourceEvent(revision: Revision): ResourceEvent {\n  return {\n    Action: (revision as any).op ?? \"assign\",\n    Changed: revision.field,\n    InstanceID: map((revision as any).id, toS),\n    Parameters: stringifySorted(\n      pick(revision as any, \"newValue\", \"priorValue\")\n    ),\n    SoftwareAgent: AppNameVersion(),\n    When: ExifDateTime.fromMillis(revision.createdAt ?? Date.now())\n  }\n}\n\nexport interface ExifTagsWithSource extends Partial<ExifTags> {\n  sourceModifiedTime: number\n  sourceIsPrimary: boolean // is this tag from the \"primary\" asset file variation?\n  SourceFile: string\n}\n\nfunction isPrimary(ea: ExifTagsWithSource | IAssetFile): boolean {\n  return (ea as any)?.sourceIsPrimary ?? (ea as any)?.shown ?? false\n}\n\nfunction mtime(ea: ExifTagsWithSource | IAssetFile): number {\n  return (ea as any)?.sourceModifiedTime ?? (ea as any)?.mtime ?? 0\n}\n\nfunction sourceFile(ea: Maybe<ExifTagsWithSource | IAssetFile>): Maybe<string> {\n  return (ea as any)?.SourceFile ?? (ea as any)?.uri\n}\n\nexport class MergedTags {\n  private readonly logger: Logger\n  constructor(readonly name: string) {\n    this.logger = mkLogger(`MergedTags(${name})`)\n  }\n  private readonly revisions: Revision[] = []\n  private readonly tags: (ExifTagsWithSource | IAssetFile)[] = []\n\n  addRevision(...r: Revision[]) {\n    this.revisions.push(...r)\n  }\n\n  addTag(...t: (ExifTagsWithSource | IAssetFile)[]) {\n    this.tags.push(...t)\n    // sort so first one found wins (so first look at all \"primary\" sources, and then look at the newest sources first)\n    sortBy(this.tags, ea => [!isPrimary(ea), -mtime(ea)])\n  }\n\n  get(field: string): Maybe<{ value: any; source: string[] }> {\n    // only look at relevant Revisions:\n    const revs = sortBy(\n      this.revisions.filter(ea => ea.field === field),\n      ea => ea.createdAt\n    )\n    const t = this.tags.find(ea => (ea as any)[field] != null)\n    let value = (t as any)?.[field] // SITS TSC\n    const source: string[] = []\n    if (value != null) mapNotBlank(sourceFile(t), ea => source.push(ea))\n\n    // Are we an array?\n    const isPrimitive =\n      revs.every(isPrimitiveRevision) &&\n      this.tags.every(ea => !Array.isArray((ea as any)[field]))\n\n    if (isPrimitive) {\n      for (const revision of revs as PrimitiveRevision[]) {\n        if (\n          value != null &&\n          value !== revision.priorValue &&\n          value !== revision.newValue\n        ) {\n          this.logger.info(\n            \"get(\" +\n              field +\n              \"): skipping revision because expected prior or new value didn't match current value\",\n            { revision }\n          )\n        } else {\n          value = revision.newValue as any\n          source.push(`Revision@${revision.createdAt}`)\n        }\n      }\n      return value == null ? undefined : { value, source }\n    } else {\n      // This is an array field\n      // Start with the newest value from tags:\n      const arr: (number | string | boolean)[] = toA(value as any)\n\n      // Ensure all revisions are applied:\n      for (const revision of revs as (SetAddRevision | SetDeleteRevision)[]) {\n        if (revision.op === \"add\" && revision.newValue != null) {\n          source.push(`Revision@${revision.createdAt}`)\n          pushUniq(arr, ...toA(revision.newValue as any))\n        } else if (revision.op === \"delete\" && revision.priorValue != null) {\n          source.push(`Revision@${revision.createdAt}`)\n          for (const val of toA(revision.priorValue as any)) {\n            remove(arr, val)\n          }\n        }\n      }\n\n      return {\n        value: arr as any, // SITS TSC\n        source\n      }\n    }\n  }\n}\n","import { blank, notBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { isChrome, isFirefox } from \"../../fe/UserAgents\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { isHeifSupported } from \"../img/Heif\"\nimport { isHeifMimeType } from \"../img/HeifFilter\"\nimport { isVideoSupported } from \"../img/Video\"\nimport {\n  AssetFiletypes,\n  CurrentBrowserMimetypes,\n  OldBrowserMimetypes,\n  RawImageFiletypes,\n  SharpImageFiletypes\n} from \"./FileTypes\"\nimport { readMimeType } from \"./ReadMimeType\"\n\nconst MimetypeAliases = {\n  // ExifTool renders m2ts, but it's supposed to be mp2t: https://www.iana.org/assignments/media-types/video/MP2T\n  \"video/m2ts\": \"video/mp2t\"\n} as const\n\nexport function isMimeTypeSupportedByBrowser(\n  mt: Maybe<string>,\n  userAgent: Maybe<string> = \"\" // < default to old browsers\n) {\n  return (\n    isChrome(userAgent) || isFirefox(userAgent)\n      ? CurrentBrowserMimetypes\n      : OldBrowserMimetypes\n  ).includes(toS(mt) as any)\n}\n\nexport function isImageMimeType(mimetype: Maybe<string>) {\n  return toS(mimetype).startsWith(\"image/\")\n}\n\nexport function isVideoMimeType(mimetype: Maybe<string>): boolean {\n  return (\n    notBlank(mimetype) &&\n    (mimetype.startsWith(\"video/\") ||\n      mimetype === \"application/mp4\" ||\n      mimetype === \"application/ogg\")\n  )\n}\n\nexport function normalizeMimetype(mimetype: string): string {\n  const s = toS(mimetype).toLowerCase()\n  return (MimetypeAliases as any)[s] ?? s\n}\n\nexport function isSharpMimeType(mimetype: Maybe<string>): boolean {\n  return !blank(mimetype) && normalizeMimetype(mimetype) in SharpImageFiletypes\n}\n\nexport function isLibrawMimeType(mimetype: Maybe<string>): boolean {\n  return !blank(mimetype) && normalizeMimetype(mimetype) in RawImageFiletypes\n}\n\nexport async function isFileMimeTypeIncluded(\n  f: SimpleFile | string,\n  patterns: string[]\n) {\n  return isMimeTypeIncluded(await readMimeType(f), patterns)\n}\n\nexport async function isAssetFileMimeType(f: SimpleFile | string) {\n  const mt = await readMimeType(f)\n  return blank(mt)\n    ? false\n    : isVideoMimeType(mt)\n    ? await isVideoSupported()\n    : isHeifMimeType(mt)\n    ? await isHeifSupported()\n    : mt in AssetFiletypes\n}\n\n/**\n * Supports \"image/*\"-style glob-matches\n */\nexport function isMimeTypeIncluded(mt: Maybe<string>, patterns: string[]) {\n  if (mt == null) return false\n  for (const ea of patterns) {\n    if (ea.includes(\"*\")) {\n      const re = new RegExp(\"^\" + ea.replace(/\\*/g, \".*\") + \"$\", \"i\")\n      if (re.exec(mt) != null) return true\n    } else {\n      if (ea.toLowerCase() === mt) return true\n    }\n  }\n  return false\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const NameTagFormats = strEnum(\n  \"as-is\",\n  \"family/given\",\n  \"family/fullname\"\n)\nexport type NameTagFormat = StrEnumKeys<typeof NameTagFormats>\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const NameTagOrders = strEnum(\"western\", \"eastern\")\nexport type NameTagOrder = StrEnumKeys<typeof NameTagOrders>\n","import { lazy } from \"../../core/Lazy\"\nimport { compactBlanks, mapNotEmpty, notEmptyOr, uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank } from \"../../fe/Blank\"\nimport { Defined, map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { TagPath, TagRoots } from \"../../fe/api/Tag\"\nimport { toA } from \"../../fe/toA\"\nimport { mkLogger } from \"../Logger\"\nimport { escapeRegExp, matchQuotes } from \"../RegExp\"\nimport { spliceCapture } from \"../String\"\nimport { min } from \"../math/Vector\"\nimport { Settings } from \"../settings/Settings\"\n\nconst logger = lazy(() => mkLogger(\"tags.Names\"))\n\n// const cleanupRE = /^,?\\s*(\\S.+?)\\s*,?$/\n\n// function cleanup(s: string) {\n//   return spliceCapture(s.trim(), cleanupRE)?.captured\n// }\n\n// function cleanupName(given: string, family: string) {\n//   return {\n//     given: cleanup(given),\n//     family: cleanup(family)\n//   }\n// }\n\nfunction escRE(s: string) {\n  return matchQuotes(escapeRegExp(s))\n}\n\nfunction familyNameREs() {\n  return Settings.tagNamesSurnames.values.map(\n    ea => new RegExp(\"\\\\b(\" + escRE(ea) + \")\\\\b\", \"i\")\n  )\n}\n\nfunction givenNameREs() {\n  return Settings.tagNamesGiven.values.map(\n    ea => new RegExp(\"\\\\b(\" + escRE(ea) + \")\\\\b\", \"i\")\n  )\n}\n\nfunction familyNamePrefixeREs() {\n  return mapNotEmpty(\n    compactBlanks(Settings.tagNamesSurnamePrefixes.values),\n    arr =>\n      sortBy(arr, ea => -ea.length).map(\n        ea => new RegExp(`\\\\b(${escRE(ea)}\\\\s+\\\\S+)`, \"i\")\n      )\n  )\n}\n\nfunction givenNameSurroundREs() {\n  const arr = compactBlanks(Settings.tagNamesGivenSurrounds.values)\n  for (const ea of arr) {\n    if (ea.length !== 2) {\n      logger().warn(\n        \"Settings.tagNamesFamilySurrounds has an invalid value:\",\n        ea\n      )\n    }\n  }\n  return arr.map(\n    ea =>\n      new RegExp(\n        `(${escapeRegExp(ea.charAt(0))}\\\\s*[^${escapeRegExp(\n          ea.charAt(0)\n        )}]+\\\\s*${escapeRegExp(ea.charAt(1))})`,\n        \"i\"\n      )\n  )\n}\n\nfunction familyNameSurroundREs() {\n  const arr = compactBlanks(Settings.tagNamesFamilySurrounds.values)\n  for (const ea of arr) {\n    if (ea.length !== 2) {\n      logger().warn(\n        \"Settings.tagNamesFamilySurrounds has an invalid value:\",\n        ea\n      )\n    }\n  }\n  return arr.map(\n    ea =>\n      new RegExp(\n        `${escapeRegExp(ea.charAt(0))}\\\\s*([^${escapeRegExp(\n          ea.charAt(0)\n        )}]*)\\\\s*${escapeRegExp(ea.charAt(1))}`,\n        \"i\"\n      )\n  )\n}\n\nconst lifespanRE = /(\\(\\s*\\d+\\s*-\\s*[\\d?]{0,4}\\s*\\)?)/\n\nconst modifierRE = /([,\\s]+(?:jr\\.?|junior|sr\\.?|senior|[iv]+\\.?))$/i\n\nconst uppercaseWordsRE = /\\b([A-Z‘’']+[-A-Z‘’']{2})\\b/\n\nconst ignorableNameRE = /^[()[\\]/.\\-_]+$/\n\n/**\n * Parse the given name into familyNames, givenNames, an optional modifier and\n * optional lifespan.\n */\nexport function parseName(compoundName: string): Maybe<{\n  givenNames: string[]\n  modifier: Maybe<string>\n  lifespan: Maybe<string>\n  familyNames: string[]\n}> {\n  if (blank(compoundName)) return\n\n  // normalize spaces so \"First  ( Maiden ) Last \" becomes \"First (Maiden) Last\"\n  let s = compoundName\n    .replace(/\\s+/g, \" \")\n    .replace(/\\(\\s+/g, \"(\")\n    .replace(/\\s+\\)/g, \")\")\n    .trim()\n\n  const lifespan = map(spliceCapture(s, lifespanRE), r => {\n    s = r.unmatched.trim()\n    // normalize whitespace:\n    return r.captured.replace(/\\s+/g, \"\")\n  })\n\n  // Strip off Bob Smith, jr.\n  const modifier = map(spliceCapture(s, modifierRE), r => {\n    s = r.unmatched.trim()\n    return r.captured.trim()\n  })\n\n  const givenNames: string[] = []\n  const givenNameEnds: string[] = []\n  const familyNames: string[] = []\n\n  for (const re of givenNameREs()) {\n    const r = spliceCapture(s, re)\n    if (r != null) {\n      givenNames.push(r.captured)\n      s = r.unmatched.trim()\n    }\n  }\n\n  for (const re of givenNameSurroundREs()) {\n    let r\n    do {\n      r = spliceCapture(s, re)\n      if (r != null) {\n        givenNameEnds.push(r.captured)\n        s = r.unmatched.trim()\n      }\n    } while (r != null)\n  }\n\n  let minFamilyNameIndex: Maybe<number>\n\n  function onCapture(r: Defined<ReturnType<typeof spliceCapture>>) {\n    if (minFamilyNameIndex == null || minFamilyNameIndex > r.matchedIndex) {\n      minFamilyNameIndex = min([minFamilyNameIndex, r.matchedIndex])\n    }\n  }\n\n  if (Settings.tagNamesCapitalizedAsFamily.valueOrDefault) {\n    let r\n    do {\n      r = spliceCapture(s, uppercaseWordsRE)\n      if (r != null) {\n        onCapture(r)\n        familyNames.push(r.captured)\n        s = r.unmatched.trim()\n      }\n    } while (r != null)\n  }\n\n  for (const re of familyNameSurroundREs()) {\n    let r\n    do {\n      r = spliceCapture(s, re)\n      if (r != null) {\n        onCapture(r)\n        familyNames.push(r.captured)\n        s = r.unmatched.trim()\n      }\n    } while (r != null)\n  }\n\n  // if (Settings.tagNamesParentheticalSurnames.valueOrDefault) {\n  //   let r\n  //   do {\n  //     r = spliceCapture(s, parenNameRE)\n  //     if (r != null) {\n  //       onCapture(r)\n  //       familyNames.push(r.captured)\n  //       s = r.remnants.trim()\n  //     }\n  //   } while (r != null)\n  // }\n\n  if (Settings.tagNamesLexical.valueOrDefault) {\n    const commaIndex = s.indexOf(\",\")\n    if (commaIndex >= 0) {\n      minFamilyNameIndex = undefined\n      familyNames.push(s.substring(0, commaIndex).trim())\n      givenNames.push(s.substring(commaIndex + 1).trim())\n      s = \"\"\n    }\n  }\n\n  for (const re of familyNameREs()) {\n    const r = spliceCapture(s, re)\n    if (r != null) {\n      onCapture(r)\n      familyNames.push(r.captured)\n      s = r.unmatched.trim()\n    }\n  }\n\n  for (const re of toA(familyNamePrefixeREs())) {\n    const r = spliceCapture(s, re)\n    if (r != null) {\n      onCapture(r)\n      familyNames.push(r.captured)\n      s = r.unmatched.trim()\n    }\n  }\n\n  if (minFamilyNameIndex != null && s.length > minFamilyNameIndex) {\n    // Everything to the right is a family name.\n    mapNotEmpty(\n      compactBlanks(s.slice(minFamilyNameIndex).split(/\\s+/)),\n      arr => {\n        familyNames.push(...arr)\n        s = s.slice(0, minFamilyNameIndex)\n      }\n    )\n  }\n\n  // OK, by this time we're either looking at an empty string, or [first]\n  // [middle] [last] (we may have pulled off either family names or given names,\n  // so everything is optional)\n\n  const names = compactBlanks(s.split(/\\s+/))\n\n  // cleanupGivenNames(givenNames)\n  const givenNameCount = givenNames.length\n\n  // cleanupFamilyNames(familyNames)\n  const familyNameCount = familyNames.length\n\n  if (names.length > 0) {\n    // So, we've got leftovers. Where should they go?\n    // If we don't have a family name, and we don't have a given name:\n    if (givenNameCount === 0 && familyNameCount > 0) {\n      // We have a family name. Assume the remainder are given names?\n      givenNames.push(...names)\n    } else if (\n      familyNameCount === 0 &&\n      givenNameCount > 0 &&\n      names.length === 1\n    ) {\n      familyNames.push(...names)\n    } else {\n      if (names.length === 1) {\n        // Assume one name is a given name\n        givenNames.push(...names)\n      } else {\n        // names.length > 1. Last or first name is family name, the remainder is given names.\n        const western = Settings.tagNamesOrder.valueOrDefault === \"western\"\n\n        familyNames.push(western ? names.pop()! : names.shift()!)\n        givenNames.push(...names)\n      }\n    }\n  }\n\n  // cleanupFamilyNames(familyNames)\n\n  return {\n    givenNames: cleanupNames([...givenNames, ...givenNameEnds]),\n    modifier,\n    lifespan,\n    familyNames: cleanupNames(familyNames),\n    minFamilyNameIndex\n  } as any\n}\n\nfunction cleanupNames(arr: Maybe<string>[]): string[] {\n  return uniq(compactBlanks(arr).filter(ea => ignorableNameRE.exec(ea) == null))\n}\n\n// export function cleanupGivenNames(givenNames: string[]) {\n//   filterInPlace(\n//     givenNames,\n//     ea =>\n//       notBlank(ea) &&\n//       !includesIgnoreCase(Settings.tagNamesGivenIgnored.values, ea)\n//   )\n// }\n\n// export function cleanupFamilyNames(familyNames: string[]) {\n//   for (const prefix of Settings.tagNamesFamilyIgnoredPrefixes.values) {\n//     for (let i = 0; i < familyNames.length; i++) {\n//       familyNames[i] = stripPrefixIgnoreCase(familyNames[i], prefix).trim()\n//     }\n//   }\n//   filterInPlace(familyNames, notBlank)\n// }\n\nfunction join(arr: Maybe<string>[]) {\n  let result = \"\"\n  for (const ea of compactBlanks(arr)) {\n    // we don't want to add a space after the modifier if it starts with a comma\n    result += ea.startsWith(\",\") ? ea : \" \" + ea\n  }\n  return result.trim()\n}\n\nexport function renderNameTag(name: string): TagPath[] {\n  if (blank(name)) return []\n\n  const fmt = Settings.tagNamesFormatter.valueOrDefault\n  const fam_full = fmt === \"family/fullname\"\n  const fam_given = fmt === \"family/given\"\n  if (fam_full || fam_given) {\n    const r = parseName(name)\n    if (r == null) {\n      return []\n    } else {\n      const suff = join([r.modifier, r.lifespan])\n      const given = join(r.givenNames)\n      const familyNames = compactBlanks(\n        notEmptyOr(r.familyNames, [\n          Settings.tagNamesDefaultFamily.valueOrDefault\n        ])\n      )\n      return familyNames.map(fam => [\n        TagRoots.Who,\n        fam,\n        fam_given ? join([given, suff]) : renderName(fam, given, suff)\n      ])\n    }\n  } else {\n    return [[TagRoots.Who, name.trim()]]\n  }\n}\n\nfunction renderName(family: string, given: string, suffix: string): string {\n  return join(\n    Settings.tagNamesOrder.valueOrDefault === \"western\"\n      ? [given, family, suffix]\n      : [family, given, suffix]\n  )\n}\n","import { Tags } from \"exiftool-vendored\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { normalizeRotation } from \"../../fe/Rotation\"\nimport { toS } from \"../../fe/toS\"\nimport { isVideoMimeType } from \"./MimeTypes\"\n\n// const ExifOrientations = new Map([\n//   [\"Horizontal (normal)\", 1],\n//   [\"Mirror horizontal\", 2],\n//   [\"Rotate 180\", 3],\n//   [\"Mirror vertical\", 4],\n//   [\"Mirror horizontal and rotate 270 CW\", 5],\n//   [\"Rotate 90 CW\", 6],\n//   [\"Mirror horizontal and rotate 90 CW\", 7],\n//   [\"Rotate 270 CW\", 8]\n// ])\n\n// TODO: support https://github.com/recurser/exif-orientation-examples\n\n// See: https://www.daveperrett.com/articles/2012/07/28/exif-orientation-handling-is-a-ghetto/\n\nexport function extractRotation(tags: Maybe<Tags>): Maybe<number> {\n  return tags == null\n    ? undefined\n    : orientationToRotation(tags.Orientation) ??\n        orientationToRotation(tags.CameraOrientation) ??\n        normalizeRotation(tags.Rotation) // < used by videos\n}\n\nconst ExifOrientationToRotation = new Map<string | number, number>([\n  [\"Horizontal (normal)\", 0],\n  [\"Rotate 90 CW\", 90],\n  [\"Rotate 180\", 180],\n  [\"Rotate 270 CW\", 270],\n  [1, 0],\n  [6, 90],\n  [3, 180],\n  [8, 270]\n  // TODO: FIXME: Mirror orientations are not currently mirrored properly.\n  // [\"Mirror horizontal\", 0], // 2\n  // [\"Mirror vertical\", 180], // 4\n  // [\"Mirror horizontal and rotate 270 CW\", 270], // 5\n  // [\"Mirror horizontal and rotate 90 CW\", 90], // 7\n  // [2, 0],\n  // [4, 180],\n  // [5, 270],\n  // [7, 90]\n])\n\nexport function orientationRequiresMirroring(\n  orientation: Maybe<string> | number\n) {\n  return (\n    [2, 4, 5, 7].includes(orientation as any) ||\n    toS(orientation).startsWith(\"Mirror\")\n  )\n}\n\n/**\n * @return clockwise rotation, or undefined if mirroring is involved or the\n * orientation string is undefined or unknown\n */\nexport function orientationToRotation(\n  orientation: Maybe<string | number>\n): Maybe<number> {\n  return map(orientation, ea => ExifOrientationToRotation.get(ea))\n}\n\nconst Rotation2ExifOrientation = new Map<number, number>([\n  [0, 1],\n  [90, 6],\n  [180, 3],\n  [270, 8]\n  // [0, 2],\n  // [180, 4],\n  // [270, 5],\n  // [90, 7]\n])\n\n/**\n * @param rotation clockwise rotation (0, 90, 180, 270)\n * @return if rotated is defined and a known value, return the ExifTool\n * Orientation string\n */\nexport function rotationToExifOrientation(\n  rotation: Maybe<number>\n): Maybe<number> {\n  return Rotation2ExifOrientation.get(normalizeRotation(rotation) as any)\n}\n\nexport type ImageDimensions = Required<Pick<Tags, \"ImageHeight\" | \"ImageWidth\">>\n\nexport function rotationToWriteTag(rotation: number, mimetype: string) {\n  return map(normalizeRotation(rotation), nr =>\n    isVideoMimeType(mimetype)\n      ? { Rotation: nr as any }\n      : map(rotationToExifOrientation(nr), ea => ({\n          \"Orientation#\": ea\n        }))\n  )\n}\n","import { Tags } from \"exiftool-vendored\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, mapNumeric, toInt } from \"../../fe/Number\"\nimport { Settings } from \"../settings/Settings\"\nimport { JsonSidecarTags } from \"./JsonSidecar\"\n\nexport function clampRating(rating: any): Maybe<number> {\n  const r = toInt(rating)\n  return r == null ? undefined : clamp(-1, 5, r)\n}\n\nexport function extractRating(\n  tags: Maybe<Tags & Pick<JsonSidecarTags, \"favorited\">>\n): Maybe<number> {\n  return (\n    clampRating(tags?.Rating) ??\n    mapNumeric(toInt(tags?.RatingPercent), pct => Math.ceil((pct * 5) / 100)) ??\n    // Only assert a rating if the JSON sidecar is favorited:\n    map(tags?.favorited, ea =>\n      ea === true ? Settings.likeRating.valueOrDefault : undefined\n    )\n  )\n}\n\nexport function extractLiked(tags: Maybe<Tags>): Maybe<boolean> {\n  const r = extractRating(tags)\n  return r == null ? undefined : r >= Settings.likeRating.valueOrDefault\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { FileCache } from \"../fs/FileCache\"\nimport { readFileType_ } from \"../fs/FileType\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFileOrString } from \"../fs/SimpleFile\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { cachedTags, rawTagsCache } from \"./ExifTool\"\nimport { normalizeMimetype } from \"./MimeTypes\"\n\nexport const mimetypeCache = lazy(\n  () =>\n    new FileCache<Maybe<string>>({\n      name: \"tags.mimetype\",\n      maxSize: 2048,\n      timeoutMs: commandTimeoutMs()\n    })\n)\n\nexport async function readMimeType(\n  pathOrFile: SimpleFileOrString\n): PromiseMaybe<string> {\n  if (blank(pathOrFile)) return\n  const f = PosixFile.for(pathOrFile)\n  return mimetypeCache().getOrSetAsync(f.nativePath, async () => {\n    return map(\n      rawTagsCache().get(f.nativePath)?.MIMEType ??\n        (await cachedTags(f))?.MIMEType ??\n        (await readFileType_(f.nativePath).catch(() => undefined))?.mime,\n      normalizeMimetype\n    )\n  })\n}\n","import { uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport {\n  commonPrefixIgnoreCase,\n  ensurePrefix,\n  equalsIgnoreCase\n} from \"../String\"\nimport { sortByAsync } from \"../async/Promise\"\nimport { inHiddenPhotoStructureDir } from \"../dir/InHiddenPhotoStructureDir\"\nimport { BaseFile } from \"../fs/BaseFile\"\nimport {\n  extAliases,\n  isExt,\n  isSidecarExt,\n  mkExtsRegExp,\n  normalizeExt\n} from \"../fs/FileExt\"\nimport { stripCopySuffixFromName } from \"../fs/FuzzyNames\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { Settings } from \"../settings/Settings\"\nimport { stripExt } from \"./FileTypes\"\n\nfunction strEql(a: string, b: string, { ignoreCase }: { ignoreCase: boolean }) {\n  return ignoreCase\n    ? equalsIgnoreCase(a, b, { normalize: true /* we did it already */ })\n    : a === b\n}\n\nexport function isSidecarOf(src: SimpleFile, sidecar: SimpleFile) {\n  // Must have a sidecar extension and not be hidden:\n  if (!isSidecarExt(sidecar.ext) || sidecar.base.startsWith(\".\")) {\n    return false\n  }\n  const isJson = isExt(sidecar.ext, \"json\")\n  const ignoreCase =\n    isJson || Settings.matchSidecarsCaseInsensitively.valueOrDefault\n\n  let srcName = src.base\n  let sidecarName = sidecar.name\n\n  if (strEql(srcName, sidecarName, { ignoreCase })) {\n    // Simplest case: \"image.jpg.xmp\" is a sidecar of \"image.jpg\"\n    return true\n  }\n\n  // OK, so, maybe the sidecar doesn't have the extension?\n  if (strEql(src.name, sidecarName, { ignoreCase })) {\n    // \"image.xmp\" is a sidecar of \"image.jpg\":\n    return true\n  }\n\n  // match image.JPG with image.jpeg.xmp (different spelling of the same file extension type)\n  const aliases = map(normalizeExt(src.ext), ea => extAliases().get(ea))\n  // we really _should_ be able to find an extension here:\n  if (aliases != null) {\n    const re = mkExtsRegExp(aliases)\n    srcName = srcName.replace(re, \"\")\n    sidecarName = sidecarName.replace(re, \"\")\n\n    if (strEql(srcName, sidecarName, { ignoreCase })) {\n      return true\n    }\n  }\n\n  const fuzzy = isJson || Settings.matchSidecarsFuzzily.valueOrDefault\n\n  if (fuzzy) {\n    for (const srcEa of uniq([\n      srcName,\n      src.name,\n      stripExt(srcName),\n      stripExt(src.name)\n    ])) {\n      for (const sidecarEa of uniq([\n        sidecarName,\n        sidecar.name,\n        stripExt(sidecarName),\n        stripExt(sidecar.name)\n      ])) {\n        if (\n          strEql(\n            stripCopySuffixFromName(srcEa),\n            stripCopySuffixFromName(sidecarEa),\n            { ignoreCase: fuzzy }\n          )\n        )\n          return true\n      }\n    }\n  }\n\n  return isJson && isJsonFuzzyMatch(srcName, sidecarName)\n}\n\nexport const AllowedUncommonSuffixRe =\n  /^((-edit(ed)?)|(-?\\w{1,2})|(-?\\(\\d{1,2}\\)))$/i\n\nfunction isJsonFuzzyMatch(srcName: string, sidecarName: string): boolean {\n  // guh, we have to do some b&115h!t for Google.\n  // https://forum.photostructure.com/t/creation-time-formatted-time-total-confusion-or-google-takeout-sidecar-files-are-misnamed/574/16?u=mrm\n  // https://forum.photostructure.com/t/incorrect-tags-assigned/842\n\n  const commonIdx = commonPrefixIgnoreCase(srcName, sidecarName)\n  if (commonIdx.length < 8) return false\n  function suffixOK(suffix: string) {\n    return blank(suffix) || suffix.match(AllowedUncommonSuffixRe) != null\n  }\n  const aSuffix = srcName.slice(commonIdx.length)\n  const aSuffixOK = suffixOK(aSuffix)\n\n  const bSuffix = sidecarName.slice(commonIdx.length)\n  const bSuffixOK = suffixOK(bSuffix)\n\n  return aSuffixOK && bSuffixOK\n}\n\nfunction cannotHaveSidecars(f: BaseFile) {\n  return (\n    // sidecars don't have sidecars:\n    isSidecarExt(f.ext) || inHiddenPhotoStructureDir(f)\n  )\n}\n\n/**\n *  @return oldest sidecars first (so newest sidecar metadata wins, as they are\n * layered on top of eachother)\n */\nexport async function existingSidecars<T extends BaseFile>(\n  src: T\n): Promise<T[]> {\n  if (cannotHaveSidecars(src)) return []\n  return sortByAsync({\n    name: \"_existingSidecars\",\n    arr: src.siblings(ea => isSidecarOf(src, ea)),\n    f: ea => ea.mtimeMs() // older first, see jsdoc ^^\n  })\n}\n\nexport function defaultSidecarExt() {\n  return ensurePrefix(Settings.defaultSidecarType.valueOrDefault, \".\")\n}\n","import { Tags } from \"exiftool-vendored\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { Dimensions, isDimensions, maybeDimSwap } from \"../../fe/Dimensions\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { first } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { FileCache } from \"../fs/FileCache\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFileOrString } from \"../fs/SimpleFile\"\nimport { aspectRatio } from \"../img/Dimensions\"\nimport { RawInfo, rawInfo } from \"../img/RawInfo\"\nimport { extractVideoFrame_ } from \"../img/Video\"\nimport { readRawTags } from \"./ExifTool\"\nimport { isLibrawMimeType, isVideoMimeType } from \"./MimeTypes\"\nimport { ImageDimensions, extractRotation } from \"./Orientation\"\n\nconst logger = lazy(() => mkLogger(\"tags.SizeInfo\"))\n\nexport interface SizeInfo extends ImageDimensions {\n  /**\n   * Dimensions after EXIF orientation has been applied\n   */\n  dimensions: Dimensions\n\n  /**\n   * Aspect ratio (width/height) after EXIF orientation has been applied\n   */\n  aspectRatio: number\n\n  /**\n   * These dimensions do not take EXIF orientation into account\n   */\n  fileDimensions: Dimensions\n\n  /**\n   * Degrees clockwise that the image should be rotated. `undefined` if the\n   * tag is missing. 0 if the image is already in correct orientation.\n   * Undefined if `Orientation` involves mirroring (which should be extremely\n   * rare)\n   */\n  rotation: Maybe<number>\n\n  /**\n   * EXIF Orientation\n   */\n  orientation?: number\n}\n\nconst sizeInfoCache = lazy(\n  () =>\n    new FileCache<Maybe<SizeInfo>>({\n      name: \"tags.sizeInfo\",\n      maxSize: 256,\n      timeoutMs: minuteMs\n    })\n)\n\n/**\n * Handles extracting dimensions from both image and video files\n */\nexport async function extractSizeInfoFromFile(\n  pathOrFile: Maybe<SimpleFileOrString>,\n  defaultTags?: Tags\n): PromiseMaybe<SizeInfo> {\n  if (pathOrFile == null) return\n  const f = PosixFile.for(pathOrFile)\n  return sizeInfoCache().getOrSetAsync(f.nativePath, () =>\n    _extractSizeInfoFromFile(f, defaultTags)\n  )\n}\n\nasync function _extractSizeInfoFromFile(\n  f: Maybe<PosixFile>,\n  defaultTags?: Tags\n): PromiseMaybe<SizeInfo> {\n  if (f == null) return\n  // defaultTags is set by tests and by videos after we extract a frame:\n  const t =\n    defaultTags == null || blank(defaultTags.ImageHeight)\n      ? await readRawTags(f)\n      : defaultTags\n  if (t == null) return\n\n  // If the video has a rotation value (or a sidecar with a rotation value), use\n  // that:\n  const rot = extractRotation(defaultTags) ?? extractRotation(t)\n\n  if (isLibrawMimeType(t.MIMEType)) {\n    return extractSizeInfoFromTags(t, rot, await rawInfo(f))\n  }\n\n  const si = extractSizeInfoFromTags(t, rot)\n  if (si != null) return si\n\n  if (isVideoMimeType(t.MIMEType)) {\n    return _extractSizeInfoFromFile(await extractVideoFrame_(f), t)\n  } else {\n    return\n  }\n}\n\n/**\n * Attempts to extract ImageHeight and ImageWidth from the given tags.\n *\n * You probably want the higher-level method, extractSizeInfoFromFile_().\n *\n * This is only exposed for use by __extractVideoFrame_\n */\nexport function extractSizeInfoFromTags(\n  tags: Maybe<\n    Partial<\n      ImageDimensions &\n        Pick<Tags, \"MIMEType\" | \"ImageSize\" | \"FileName\" | \"Orientation\">\n    >\n  >,\n  rotation?: Maybe<number>,\n  _rawInfo?: Maybe<Partial<RawInfo>>\n): Maybe<SizeInfo> {\n  rotation ??= extractRotation(tags)\n  const fileDimensions = first(\n    [\n      _rawInfo?.ImageSize,\n      // DON'T pull in ExifImageWidth/ExifImageHeight or\n      // SourceImageWidth/SourceImageHeight: those tags don't necessarily\n      // represent the actual image size.\n      { width: tags?.ImageWidth, height: tags?.ImageHeight }\n    ],\n    d => (isDimensions(d) ? d : undefined)\n  )\n\n  // Sometimes this is \"11mm\" (for .svg)\n  if (fileDimensions == null) {\n    return logger().tap({\n      msg: \"extractSizeInfo(\" + tags?.FileName + \") (undefined fileDimensions)\",\n      result: undefined,\n      meta: {\n        mimetype: tags?.MIMEType,\n        rawInfo,\n        fileDimensions\n      }\n    })\n  }\n\n  const dimensions = maybeDimSwap(fileDimensions, rotation)\n  return logger().tap({\n    msg: \"extractSizeInfo(\" + tags?.FileName + \")\",\n    result: {\n      ImageHeight: dimensions.height,\n      ImageWidth: dimensions.width,\n      aspectRatio: aspectRatio(dimensions)!,\n      dimensions,\n      rotation,\n      fileDimensions,\n      orientation: tags?.Orientation\n    },\n    meta: {\n      mimetype: tags?.MIMEType,\n      rawInfo\n    }\n  })\n}\n","import { defaultVideosToUTC } from \"exiftool-vendored\"\nimport { DateTime } from \"luxon\"\nimport { lazy } from \"../../core/Lazy\"\nimport { compact, isNotEmpty, uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { dayMs } from \"../../fe/Date\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { toA } from \"../../fe/toA\"\nimport { flatZip } from \"../Array\"\nimport { definedAndNotEql } from \"../Eql\"\nimport { mkLogger } from \"../Logger\"\nimport { diceCoeff } from \"../StringSimilarity\"\nimport { thenMap } from \"../async/Promise\"\nimport { time } from \"../async/PromiseTimer\"\nimport { DateInterval } from \"../date/DateInterval\"\nimport { Dated, datedOverlap } from \"../date/Dated\"\nimport { closeTo, toExifDateTime } from \"../date/FuzzyDate\"\nimport { extractDateFromPath, parseDated } from \"../date/FuzzyDateParser\"\nimport { getZoneName } from \"../date/getZoneName\"\nimport { inHiddenPhotoStructureDir } from \"../dir/InHiddenPhotoStructureDir\"\nimport { extFilter } from \"../fs/BaseFilePredicates\"\nimport { FileCache } from \"../fs/FileCache\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { isCachedDir, isSlowDir } from \"../fs/Readdir\"\nimport { SimpleFile, findFileIndex } from \"../fs/SimpleFile\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { SyncPredicate } from \"../predicates/SyncPredicates\"\nimport { Settings } from \"../settings/Settings\"\nimport { TagInferenceSettingValues } from \"../settings/TagInferenceSettingValues\"\nimport { bname } from \"./Bname\"\nimport { capturedAtFromTags } from \"./CapturedAt\"\nimport { RareTags } from \"./ExifTags\"\nimport { readRawTags } from \"./ExifTool\"\nimport { ExtTypes } from \"./ExtType\"\nimport { extractMakeAndModel } from \"./MakeModel\"\nimport { isAssetFileMimeType } from \"./MimeTypes\"\n\nconst logger = lazy(() => mkLogger(\"tags.TagInference\"))\n\nconst MaxSiblingsChecked = 7\n\nexport async function canInferForDir(d: PosixFile) {\n  if (\n    Settings.siblingInference.valueOrDefault === TagInferenceSettingValues.never\n  ) {\n    logger().debug(\n      \"canInferForDir(\" +\n        d +\n        \"): disabled: \" +\n        Settings.siblingInference.toEnvLine()\n    )\n    return false\n  }\n\n  if (true === inHiddenPhotoStructureDir(d)) {\n    logger().debug(\n      \"canInferForDir(\" + d + \"): disabled (PhotoStructure directory)\"\n    )\n    return false\n  }\n\n  if (\n    Settings.siblingInference.valueOrDefault ===\n      TagInferenceSettingValues.auto &&\n    (await isSlowDir(d.nativePath)) &&\n    !(await isCachedDir(d.nativePath))\n  ) {\n    logger().debug(\n      \"canInferForDir(\" + d + \"): disabled (slow uncached directory)\"\n    )\n    return false\n  }\n\n  return true\n}\n\n/**\n * HEY GUESS WHAT HERE ARE SOME HEURISTICS OO BOY OO BOY WHAT COULD\n * POSSIBLY GO WRONG, AMIRITE?\n *\n * Unfortunately, many smartphones don't encode the make and model into their\n * video headers (like the Google Pixel!). They are stinky, stinky poopy\n * pants, but we can try to clean up their mess. With a different stinky poopy\n * mess.\n *\n * Also unfortunately, `jpegtrans` from days of yore (2000s) didn't copy\n * tags to rotated images--so the image rotation was lossless, but the\n * resulting file lost its tags (like Make, Model, and capture time).\n *\n * If there are other files in the directory, and they have a consistent make\n * and model, assume the video shares the same make and model.\n */\nexport async function inferMakeAndModel(\n  f: PosixFile,\n  tags: Maybe<RareTags>\n): Promise<{\n  Make?: string\n  Model?: string\n}> {\n  const mm = extractMakeAndModel(tags)\n\n  if (mm.Make != null && mm.Model != null) {\n    return mm\n  }\n\n  if (!(await canInferForDir(f.parent()))) {\n    logger().debug(\n      \"inferMakeAndModel(\" + f + \"): cannot infer for this directory\",\n      f.parent()\n    )\n    return mm\n  }\n\n  // If a nearby file in the current directory have the same make and\n  // model, or a filename has the same prefix as our file, use that.\n  const nearestN = zipSibling(await nearestSiblings(f)).slice(0, 10)\n\n  logger().debug(\n    \"inferMakeAndModel(\" + f + \"): looking at nearby siblings\",\n    nearestN.map(ea => ea.base)\n  )\n\n  for (const sibling of nearestN) {\n    // DON'T readTags HERE! We'll go into inference infinite loopage!\n    const fromSibling = extractMakeAndModel(await readRawTags(sibling))\n    // If we have a Make or a Model, don't infer a different one from the sibling:\n    if (definedAndNotEql(fromSibling.Make, mm.Make)) {\n      logger().debug(\n        \"inferMakeAndModel(\" + f + \"): skipping sibling (mismatching Make)\",\n        { mm, fromSibling }\n      )\n      continue\n    }\n    // this shouldn't ever happen:\n    if (definedAndNotEql(fromSibling.Model, mm.Model)) {\n      logger().debug(\n        \"inferMakeAndModel(\" + f + \"): skipping sibling (mismatching Model)\",\n        { mm, fromSibling }\n      )\n      continue\n    }\n    if (fromSibling.Make != null && fromSibling.Model != null) {\n      return logger().tap({\n        msg: \"inferMakeAndModel(\" + f + \")\",\n        level: LogLevels.info,\n        result: fromSibling,\n        meta: { sibling: sibling.base }\n      })\n    }\n  }\n  return mm\n}\n\nexport async function inferCapturedAtFromSiblings(\n  file: PosixFile\n): PromiseMaybe<{ date: Dated; src: string }> {\n  if (!(await canInferForDir(file.parent()))) {\n    return\n  }\n\n  return thenMap(\n    beforeAfterCapturedAt(file),\n    ({ before, after, index, slots }) => {\n      if (!closeTo(before.date, after.date, 2 * dayMs)) {\n        // This \"same day\" heuristic means we don't apply this general heuristic\n        // when the siblings are really different.\n        return\n      }\n      return map(\n        DateInterval.for(\n          toExifDateTime(before.date, getZoneName(before.date)),\n          toExifDateTime(after.date, getZoneName(after.date)),\n          index,\n          slots\n        ),\n        date => ({\n          date,\n          src: `before:${before.src},after:${after.src}`\n        })\n      )\n    }\n  )\n}\n\nasync function firstWithCapturedAt(\n  arr: Maybe<PosixFile[]>\n): PromiseMaybe<{ date: Dated; src: string; index: number }> {\n  arr = toA(arr)\n  for (\n    let index = 0;\n    index < Math.min(arr.length, MaxSiblingsChecked);\n    index++\n  ) {\n    const sib = arr[index]\n    const tags = await readRawTags(sib)\n    const ca = capturedAtFromTags(tags)\n    if (ca != null) return { ...ca, index }\n  }\n  return\n}\n\nasync function firstWithZoneName(\n  arr: PosixFile[]\n): PromiseMaybe<{ zoneName: string; path: string; base: string; src: string }> {\n  arr = toA(arr).slice(0, MaxSiblingsChecked)\n  for (const sib of arr) {\n    const t = await readRawTags(sib) // < NOT readTags--that would cause an infinite loop!\n    logger().debug(\"firstWithZoneName() readRawTags\", { sib, t })\n    if (t != null && notBlank(t.tz) && t.tzSource !== defaultVideosToUTC) {\n      return logger().tap({\n        msg: \"firstWithZoneName()\",\n        result: {\n          zoneName: t.tz,\n          path: sib.nativePath,\n          base: sib.base,\n          src: t.tzSource ?? \"tags.tz\"\n        },\n        meta: {\n          tzSource: t.tzSource\n        }\n      })\n    }\n  }\n  logger().debug(\"firstWithZoneName(): no zone name found\", { arr })\n  return\n}\n\nexport type BeforeAfterResult = PromiseMaybe<{\n  before: { date: Dated; src: string }\n  after: { date: Dated; src: string }\n  index: number\n  slots: number\n}>\n\nconst bacaCache = lazy(\n  () => new FileCache<BeforeAfterResult>({ name: \"tags.beforeAfterCapturedAt\" })\n)\n\nexport function beforeAfterCapturedAt(file: PosixFile): BeforeAfterResult {\n  return bacaCache().getOrSet(file.nativePath, async () => {\n    const sibs = await nearestSiblings(file)\n    const before = await firstWithCapturedAt(sibs?.younger)\n    const after = await firstWithCapturedAt(sibs?.older)\n    return before == null || after == null\n      ? undefined\n      : {\n          before,\n          after,\n          index: before.index,\n          slots: before.index + after.index + 1\n        }\n  })\n}\n\nconst isAssetFileExtension: SyncPredicate<SimpleFile> = extFilter(\n  ExtTypes.AssetFile\n)\n\ntype NearestSiblings = { younger: PosixFile[]; older: PosixFile[] }\n\nfunction zipSibling(s: Maybe<NearestSiblings>): PosixFile[] {\n  return s == null ? [] : compact(flatZip(toA(s.younger), toA(s.older)))\n}\n\n/**\n * Return `{younger: PosixFile[], older: PosixFile[]}`, ordered by basename\n * similarity to `f`.\n *\n * Both `younger` and `older` will be truncated after `maxLength` entries, to\n * prevent large directories from causing exiftool to visit every entry in large\n * directories.\n */\nexport async function nearestSiblings(\n  f: PosixFile,\n  maxLength = 7\n): PromiseMaybe<NearestSiblings> {\n  if (!(await canInferForDir(f.parent()))) return\n\n  const dirents = await time(\"tags.nearestSiblings\", async () => {\n    const parent = await f.parent().directoryEntry()\n    const arr = await parent?.childFiles()\n    return arr?.filter(\n      async ea =>\n        // no hidden files:\n        ea.isFile() &&\n        !ea.isNameHidden() &&\n        // any file with EXIF:\n        (isAssetFileExtension(ea) ?? (await isAssetFileMimeType(ea)))\n    )\n  })\n\n  if (dirents == null) {\n    logger().info(\"nearestSiblings(): can't readdir parent, \" + f.parent())\n    return\n  }\n  const sorted = sortBy(dirents, ea => bname(ea))\n  // WE WANT BASE, NOT NAME, because we want the entry for `f`:\n  const myIndex = findFileIndex(f, sorted)\n  if (myIndex < 0) {\n    logger().warn(\"nearestSiblings(): can't find self in siblings: \" + f)\n    return\n  }\n\n  const minMatch = clamp(\n    0,\n    1,\n    Settings.siblingInferenceBasenameCoeff.valueOrDefault\n  )\n\n  const [youngerDE, olderDE] = [\n    sorted.slice(myIndex - maxLength * 2, myIndex),\n    sorted.slice(myIndex + 1, myIndex + 1 + maxLength * 2)\n  ]\n\n  const younger: PosixFile[] = []\n  const older: PosixFile[] = []\n\n  while (isNotEmpty(youngerDE) && younger.length < maxLength) {\n    const ea = PosixFile.forDirectoryEntry(youngerDE.pop()!)\n    if (diceCoeff(f.name, ea.name) >= minMatch) {\n      younger.push(ea)\n    }\n  }\n\n  while (isNotEmpty(olderDE) && older.length < maxLength) {\n    const ea = PosixFile.forDirectoryEntry(olderDE.shift()!)\n    if (diceCoeff(f.name, ea.name) >= minMatch) {\n      older.push(ea)\n    }\n  }\n\n  return logger().tap({\n    msg: \"nearestSiblings()\",\n    result: {\n      younger,\n      older\n    },\n    meta: { f }\n  })\n}\n\nexport async function nearestSiblingTzOffset(\n  f: PosixFile\n): PromiseMaybe<{ zoneName: string; path: string; base: string; src: string }> {\n  if (!(await canInferForDir(f.parent()))) return\n\n  const sibs = zipSibling(await nearestSiblings(f))\n  const result = await firstWithZoneName(sibs)\n  return logger().tap({\n    msg: \"nearestSiblingTzOffset()\",\n    result,\n    meta: { f, sibs: sibs.map(ea => ea.base) }\n  })\n}\n\n/**\n * If the basename encodes a date and time, and it matches any file stat time,\n * use that.\n */\nexport async function extractStatBname(\n  f: PosixFile\n): PromiseMaybe<{ src: string; date: Dated }> {\n  const input = uniq([bname(f, true), bname(f, false)])\n  const fromName = parseDated({ input })\n\n  if (fromName == null) {\n    logger().debug(\"extractStatBname(): bname isn't dated\", {\n      base: f.base,\n      input\n    })\n    return\n  }\n\n  const stat = await f.stat()\n  if (stat == null) {\n    logger().debug(\"extractStatBname(): no stat\", {\n      path: f.nativePath\n    })\n    return\n  }\n\n  for (const src of [\"birthtime\", \"atime\", \"mtime\", \"ctime\"] as const) {\n    if (datedOverlap({ a: fromName, b: stat[src] }).aOverlapsB) {\n      return logger().tap({\n        msg: \"extractStatBname()\",\n        result: { src, date: fromName },\n        meta: { input, stat }\n      })\n    }\n  }\n  return logger().tap({\n    msg: \"extractStatBname(): no stat overlap with bname\",\n    result: undefined,\n    meta: { input, fromName, stat }\n  })\n}\n\n/**\n * If the basename encodes a date and time, and it matches any file stat time,\n * use that.\n */\nexport async function extractStatPathTime(\n  f: PosixFile\n): PromiseMaybe<{ src: string; date: Dated }> {\n  const dateFromPath = extractDateFromPath(f.pathsForDateParsing)\n  if (dateFromPath == null) return\n\n  // The date encoded in the path may be quite course. If the stat time\n  // matches path-encoded date, let's use the stat time as a refinement.\n\n  const stat = await f.stat()\n  if (stat == null) return\n\n  // I'll take _any_ stat time (other than access time) that overlaps.\n  for (const src of [\"birthtime\", \"mtime\", \"ctime\"] as const) {\n    const d = stat[src]\n    if (\n      d != null &&\n      datedOverlap({ a: dateFromPath, b: d })?.aContainsB === true\n    ) {\n      return logger().tap({\n        msg: \"extractStatPathTime()\",\n        result: { src: \"path+\" + src, date: DateTime.fromJSDate(d) },\n        meta: { dateFromPath, stat, src }\n      })\n    }\n  }\n  return logger().tap({\n    msg: \"extractStatPathTime(): no match\",\n    result: undefined,\n    meta: { dateFromPath, stat }\n  })\n}\n","import { PathTag } from \"../../fe/api/Asset\"\nimport { TagPath, TagRef } from \"../../fe/api/Tag\"\nimport { compact, isEmpty, isNotEmpty, last, uniqBy } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { mapOr } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isString, replaceAll } from \"../../fe/String\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { ancestry } from \"../Array\"\nimport { Settings } from \"../settings/Settings\"\nimport { equalsIgnoreCase, includesIgnoreCase } from \"../String\"\n\n/**\n * ASCII unit separator. We're using an ASCII-separated path, rather than a\n * JSON-encoded path, to make \"getDescendants\" by path easier.\n */\nexport const TagSep = String.fromCharCode(31)\n\nexport function tagRefToS(tagref: Maybe<string | TagRef>): string {\n  // normalize() is required to make macOS paths match other platforms:\n  return toS(isString(tagref) ? tagref : tagref?.name).normalize()\n}\n\n// export function tagPathToTagRef(ref: TagPath): TagRef[] {\n//   return ref.map(ea => (isTagRef(ea) ? ea : { name: toS(ea) }))\n// }\n\nexport function tagPathToPathTag(tp: TagPath): PathTag[] {\n  return ancestry(tagPathToStringArray(tp)).map((tagPath, i) => ({\n    tagPath,\n    displayName: (tagPath[i] as any)[\"displayName\"]\n  }))\n}\n\nexport function tagPathToStringArray(tagPath: TagPath): string[] {\n  return compact(tagPath.map(tagRefToS))\n}\n\nexport function joinTagPath(tagPath: TagPath, _sep = TagSep): string {\n  return (\n    tagPathToStringArray(tagPath)\n      .map(ea => replaceAll(ea, _sep, \"\"))\n      .join(_sep) + (_sep === TagSep ? _sep : \"\")\n  )\n}\n\nexport function joinedTagPathBasename(tagPath: string) {\n  return last(splitTagPath(tagPath))\n}\n\nexport function splitTagPath(tagPath: string, _sep = TagSep): string[] {\n  // filter(notBlank) removes the empty final path element due to suffixing with\n  // TagSep:\n  return toS(tagPath).split(_sep).filter(notBlank)\n}\n\nexport function normalizeTagPath(tagPath: string): string {\n  return joinTagPath(splitTagPath(tagPath))\n}\n\nexport function uniqTagPaths(arr: Maybe<Maybe<TagPath>[]>) {\n  return uniqBy(toA(arr), t => (isEmpty(t) ? undefined : joinTagPath(t)))\n}\n\nfunction tagPathToLowerStr(tagPath: TagPath): string {\n  return tagPathToStringArray(tagPath).join(TagSep).toLowerCase() // case insensitive\n}\n\nexport function tagPathEql(a: TagPath, b: TagPath): boolean {\n  return a != null && b != null && tagPathToLowerStr(a) === tagPathToLowerStr(b)\n}\n\n/**\n * @return elements in `a` that are not in `b`\n */\nexport function tagDiff(\n  a: Maybe<Maybe<TagPath>[]>,\n  b: Maybe<Maybe<TagPath>[]>\n): TagPath[] {\n  const bPaths = new Set(compact(b).map(tag => tagPathToLowerStr(tag)))\n  return compact(a).filter(tag => !bPaths.has(tagPathToLowerStr(tag)))\n}\n\nexport function tagPathsInclude(needle: TagPath, haystack: TagPath[]) {\n  const s = tagPathToLowerStr(needle)\n  return haystack.some(ea => s === tagPathToLowerStr(ea))\n}\n\nexport function tagPathLeaf(tagPath: Maybe<TagPath | string>): Maybe<string> {\n  return blank(tagPath)\n    ? undefined\n    : Array.isArray(tagPath)\n    ? tagRefToS(last(tagPath))\n    : last(splitTagPath(tagPath))\n}\n\nexport function leafIsExcluded(\n  tagPath: Maybe<TagPath | string>,\n  excluded: string[]\n): boolean {\n  return mapOr(\n    tagPathLeaf(tagPath),\n    leaf => includesIgnoreCase(excluded, leaf),\n    () => false\n  )\n}\n\n/**\n * @return true if ancestor is equivalent to or is an ancestor of `descendant`\n */\nexport function isTagPathDescendant(\n  ancestor: TagPath,\n  descendant: TagPath\n): boolean {\n  if (\n    isEmpty(ancestor) ||\n    isEmpty(descendant) ||\n    ancestor.length > descendant.length\n  ) {\n    return false\n  }\n  const des = tagPathToStringArray(descendant)\n  return tagPathToStringArray(ancestor).every((ea, i) =>\n    equalsIgnoreCase(ea, des[i])\n  )\n}\n\nexport function omitAncestorTags(tagPaths: TagPath[]): TagPath[] {\n  if (!Settings.omitAncestorTags.valueOrDefault) return tagPaths\n\n  // longest tags should \"win\". Omit all tags that are ancestors of winning tags.\n  const result: TagPath[] = []\n\n  for (const tagPath of sortBy(tagPaths.filter(isNotEmpty), ea => -ea.length)) {\n    if (!result.some(ea => isTagPathDescendant(tagPath, ea))) {\n      result.push(tagPath)\n    }\n  }\n  // restore the prior sort order:\n  return sortBy(result, ea => tagPaths.indexOf(ea))\n}\n","import { Tags } from \"exiftool-vendored\"\nimport { uniq } from \"../../fe/Array\"\nimport { mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { compactValues } from \"../../fe/Object\"\nimport { toS } from \"../../fe/toS\"\nimport { ExifTags } from \"./ExifTags\"\n\nexport function extractTitleDescription(t: ExifTags) {\n  // from https://exiftool.org/forum/index.php?topic=1464.msg6370#msg6370\n\n  // Olympus sometimes adds OLYMPUS DIGITAL CAMERA as the ImageDescription, but\n  // also includes that string as the \"CameraID\". In any event, if the title or\n  // description matches the camera id, or \"OLYMPUS DIGITAL CAMERA\", it's not\n  // valid, and we should look elsewhere for the title or description.\n\n  const not = uniq([\n    \"OLYMPUS DIGITAL CAMERA\",\n    t.original?.Make,\n    t.original?.Model,\n    t.Model,\n    t.Make,\n    t.CameraID\n  ]).map(ea => mapNotBlank(ea, s => s.trim().toLowerCase().normalize()))\n\n  const first = (...fieldNames: (keyof Tags)[]): Maybe<string> => {\n    for (const fieldName of fieldNames) {\n      const s = toS(t[fieldName]).trim()\n      if (notBlank(s) && !not.includes(s.toLowerCase().normalize())) {\n        return s\n      }\n    }\n    return\n  }\n\n  return compactValues({\n    title: first(\"XPTitle\", \"Title\", \"ObjectName\"),\n    description: first(\n      \"XPSubject\",\n      \"Description\",\n      \"ImageDescription\",\n      \"Caption-Abstract\"\n    )\n  })\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport {\n  PS_LIBRARY_SCHEME,\n  PS_LOCAL_FILE_SCHEME,\n  PS_NETWORK_FILESYSTEM_SCHEME\n} from \"../../fe/URI\"\nimport { toA } from \"../../fe/toA\"\nimport { mkLogger } from \"../Logger\"\nimport { thenCompact, thenMap } from \"../async/Promise\"\nimport { exists } from \"../fs/Stat\"\nimport { Volume } from \"../volumes/Volume\"\nimport { bestVolumeForPath } from \"../volumes/Volumes\"\nimport { URI } from \"./URI\"\nimport { uriEncodingVariants } from \"./UriNormalization\"\nimport { nativePath2psfile, psfile2nativePath } from \"./psfile\"\nimport { nativePath2pslib, pslib2nativePath } from \"./pslib\"\nimport { nativePath2psnet, psnet2nativePath } from \"./psnet\"\n\nconst logger = lazy(() => mkLogger(\"uri.FileURI\"))\n\nexport async function nativePath2uri(\n  nativePath: string,\n  volume?: Volume\n): Promise<URI> {\n  if (nativePath == null || blank(nativePath)) {\n    return logger().throw(\"empty nativePath passed to nativePath2uri()\", {\n      retriable: false\n    })\n  }\n\n  return (\n    nativePath2pslib(nativePath) ??\n    (await nativePath2psfile(nativePath, volume)) ??\n    (await nativePath2psnet(nativePath, volume)) ??\n    URI.file(nativePath)\n  )\n}\n\nexport async function nativePath2uris(nativePath: string): Promise<URI[]> {\n  const vol = await bestVolumeForPath(nativePath)\n  return thenCompact([\n    nativePath2pslib(nativePath),\n    nativePath2psfile(nativePath, vol),\n    nativePath2psnet(nativePath, vol),\n    URI.file(nativePath)\n  ])\n}\n\nexport async function nativePath2uriVariants(\n  nativePath: string\n): Promise<string[]> {\n  const arr = await nativePath2uris(nativePath)\n  return uniq(flatten(arr.map(uriEncodingVariants)))\n}\n\nexport async function uriVariants(\n  uri: string,\n  mountpoint?: string\n): Promise<string[]> {\n  const result = uriEncodingVariants(uri)\n  result.push(\n    ...toA(\n      await thenMap(uri2nativePath(uri, mountpoint), nativePath2uriVariants)\n    )\n  )\n  return uniq(result)\n}\n\nfunction toURI(uri: string | URI): Maybe<URI> {\n  try {\n    if (URI.isUri(uri)) return uri\n    return URI.parse(uri, true)\n  } catch (err) {\n    logger().warn(\"bad URI\", { uri, err })\n    return\n  }\n}\n\nexport async function uri2nativePath(\n  uri: string | URI,\n  mountpoint?: string\n): PromiseMaybe<string> {\n  if (blank(uri)) return\n  const u = toURI(uri)\n  if (u == null) return\n\n  switch (u.scheme) {\n    case \"file\":\n      return u.fsPath\n    case PS_LOCAL_FILE_SCHEME:\n      return psfile2nativePath(u, mountpoint)\n    case PS_NETWORK_FILESYSTEM_SCHEME:\n      return psnet2nativePath(u, mountpoint)\n    case PS_LIBRARY_SCHEME:\n      return pslib2nativePath(u)\n    default:\n      throw new Error(\"unsupported URI: \" + uri)\n  }\n}\n\nexport async function uriExists(uri: string | URI, mountpoint?: string) {\n  const np = await uri2nativePath(uri, mountpoint)\n  return np != null && (await exists(np))\n}\n","// see https://github.com/microsoft/vscode/blob/master/src/vs/base/common/uri.ts\nimport { posix, win32 } from \"path\"\nimport { toUnicode } from \"punycode\"\nimport { inspect } from \"util\"\nimport { mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { ensureSuffix, splitLast } from \"../../fe/String\"\nimport { URLSearchParamable, toURLSearchParams } from \"../../fe/URLSearchParams\"\nimport { toS } from \"../../fe/toS\"\nimport { findLast } from \"../Array\"\nimport { CharCode } from \"../CharCode\"\nimport { isWin, isWinPortable } from \"../platform/Platform\"\n\nconst _schemePattern = /^\\w[\\w+.-]*$/\nconst _singleSlashStart = /^\\//\nconst _doubleSlashStart = /^\\/\\//\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n  // scheme, must be set\n  if (!ret.scheme && _strict === true) {\n    throw new Error(\n      `[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`\n    )\n  }\n\n  // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n  // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n  if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n    throw new Error(\"[UriError]: Scheme contains illegal characters.\")\n  }\n\n  // path, http://tools.ietf.org/html/rfc3986#section-3.3\n  // If a URI contains an authority component, then the path component\n  // must either be empty or begin with a slash (\"/\") character.  If a URI\n  // does not contain an authority component, then the path cannot begin\n  // with two slash characters (\"//\").\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character'\n        )\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")'\n        )\n      }\n    }\n  }\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n  if (!scheme && !_strict) {\n    return \"file\"\n  }\n  return scheme\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n  // the slash-character is our 'default base' as we don't\n  // support constructing URIs relative to other URIs. This\n  // also means that we alter and potentially break paths.\n  // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n  switch (scheme) {\n    case \"https\":\n    case \"http\":\n    case \"file\":\n      if (!path) {\n        path = _slash\n      } else if (path[0] !== _slash) {\n        path = _slash + path\n      }\n      break\n  }\n  return path\n}\n\nconst _empty = \"\"\nconst _slash = \"/\"\n// eslint-disable-next-line regexp/no-unused-capturing-group\nconst _regexp = /^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n  static isUri(thing: any): thing is URI {\n    if (thing instanceof URI) {\n      return true\n    }\n    if (thing == null) {\n      return false\n    }\n    return (\n      typeof (<URI>thing).authority === \"string\" &&\n      typeof (<URI>thing).fragment === \"string\" &&\n      typeof (<URI>thing).path === \"string\" &&\n      typeof (<URI>thing).query === \"string\" &&\n      typeof (<URI>thing).scheme === \"string\" &&\n      typeof (<URI>thing).fsPath === \"function\" &&\n      typeof (<URI>thing).with === \"function\" &&\n      typeof (<URI>thing).toString === \"function\"\n    )\n  }\n\n  /**\n   * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part before the first colon.\n   */\n  readonly scheme: string\n\n  /**\n   * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part between the first double slashes and the next slash.\n   */\n  readonly authority: string\n\n  /**\n   * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly path: string\n\n  /**\n   * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly query: URLSearchParams\n\n  /**\n   * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly fragment: string\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    scheme: string,\n    authority?: string,\n    path?: string,\n    query?: URLSearchParamable,\n    fragment?: string,\n    _strict?: boolean\n  )\n\n  /**\n   * @internal\n   */\n  protected constructor(components: UriComponents)\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    schemeOrData: string | UriComponents,\n    authority?: string,\n    path?: string,\n    query?: string | URLSearchParams,\n    fragment?: string,\n    _strict: boolean = false\n  ) {\n    if (typeof schemeOrData === \"object\") {\n      this.scheme = schemeOrData.scheme || _empty\n      this.authority = schemeOrData.authority || _empty\n      this.path = schemeOrData.path || _empty\n      this.query = toURLSearchParams(schemeOrData.query ?? \"\")!\n      this.fragment = schemeOrData.fragment || _empty\n      // no validation because it's this URI\n      // that creates uri components.\n      // _validateUri(this);\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict)\n      this.authority = orElse(authority, _empty)\n      this.path = _referenceResolution(this.scheme, orElse(path, _empty))\n      this.query = toURLSearchParams(query ?? \"\")!\n      this.fragment = orElse(fragment, _empty)\n\n      _validateUri(this, _strict)\n    }\n  }\n\n  // ---- filesystem path -----------------------\n\n  /**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n  get fsPath(): string {\n    // if (this.scheme !== 'file') {\n    // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n    // }\n    return uriToFsPath(this, false)\n  }\n\n  // ---- modify to new -------------------------\n\n  with(change: {\n    scheme?: string\n    authority?: string | null\n    path?: string | null\n    query?: URLSearchParamable | null\n    fragment?: string | null\n  }): URI {\n    if (change == null) {\n      return this\n    }\n\n    let { scheme, authority, path, query, fragment } = change\n    if (scheme === undefined) {\n      scheme = this.scheme\n    } else if (scheme === null) {\n      scheme = _empty\n    }\n    if (authority === undefined) {\n      authority = this.authority\n    } else if (authority === null) {\n      authority = _empty\n    }\n    if (path === undefined) {\n      path = this.path\n    } else if (path === null) {\n      path = _empty\n    }\n    if (query === undefined) {\n      query = this.query\n    } else if (query === null) {\n      query = _empty\n    }\n    if (fragment === undefined) {\n      fragment = this.fragment\n    } else if (fragment === null) {\n      fragment = _empty\n    }\n\n    if (\n      scheme === this.scheme &&\n      authority === this.authority &&\n      path === this.path &&\n      query === this.query &&\n      fragment === this.fragment\n    ) {\n      return this\n    }\n\n    return new Uri(scheme, authority, path, query, fragment)\n  }\n\n  // ---- parse & validate ------------------------\n\n  /**\n   * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n   * `file:///usr/home`, or `scheme:with/path`.\n   *\n   * @param value A string which represents an URI (see `URI#toString`).\n   */\n  static parse(value: string, _strict: boolean = false): URI {\n    const match = _regexp.exec(value)\n    if (!match) {\n      return new Uri(_empty, _empty, _empty, _empty, _empty)\n    }\n    const scheme = match[2] || _empty\n    const authority = percentDecode(match[4] || _empty)\n    const path = (match[5] || _empty).split(\"/\").map(percentDecode).join(\"/\")\n    const fixedPath =\n      scheme === \"psfile\" && path.startsWith(\"//\") ? path.slice(1) : path // TODO SITS\n    const query = toURLSearchParams(match[7])\n    const fragment = percentDecode(match[9] || _empty)\n    return new Uri(scheme, authority, fixedPath, query, fragment, _strict)\n  }\n\n  /**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n  static file(path: string): URI {\n    let authority = _empty\n\n    // normalize to fwd-slashes on windows,\n    // on other systems bwd-slashes are valid\n    // filename character, eg /f\\oo/ba\\r.txt\n    if (isWin) {\n      path = path.replace(/\\\\/g, _slash)\n    }\n\n    // check for authority as used in UNC shares\n    // or use the path as given\n    if (path[0] === _slash && path[1] === _slash) {\n      const idx = path.indexOf(_slash, 2)\n      if (idx === -1) {\n        authority = path.substring(2)\n        path = _slash\n      } else {\n        authority = path.substring(2, idx)\n        path = path.substring(idx) || _slash\n      }\n    }\n\n    return new Uri(\"file\", authority, path, _empty, _empty)\n  }\n\n  static from(components: {\n    scheme: string\n    authority?: string\n    path?: string\n    query?: string | URLSearchParams\n    fragment?: string\n  }): URI {\n    return new Uri(\n      components.scheme,\n      components.authority,\n      components.path,\n      components.query,\n      components.fragment\n    )\n  }\n\n  /**\n   * Join a URI path with path fragments and normalizes the resulting path.\n   *\n   * @param uri The input URI.\n   * @param pathFragment The path fragment to add to the URI path.\n   * @returns The resulting URI.\n   */\n  static joinPath(uri: URI, ...pathFragment: string[]): URI {\n    if (!uri.path) {\n      throw new Error(`[UriError]: cannot call joinPaths on URI without path`)\n    }\n    let newPath: string\n    if (isWin && uri.scheme === \"file\") {\n      newPath = URI.file(\n        win32.join(uriToFsPath(uri, true), ...pathFragment)\n      ).path\n    } else {\n      newPath = posix.join(uri.path, ...pathFragment)\n    }\n    return uri.with({ path: newPath })\n  }\n\n  isRootPath(): boolean {\n    return this.path == null || this.path === _slash\n  }\n\n  get pathBase(): Maybe<string> {\n    return this.isRootPath()\n      ? \"\"\n      : map(this.path, path => findLast(path.split(_slash), notBlank))\n  }\n\n  parent(): URI {\n    if (this.isRootPath()) return this\n    return this.with({\n      path: this.path.slice(0, this.path.lastIndexOf(_slash))\n    })\n  }\n\n  join(...path: string[]): URI {\n    return this.with({\n      path: ensureSuffix(this.path, _slash) + path.join(_slash)\n    })\n  }\n\n  // ---- printing/externalize ---------------------------\n\n  /**\n   * Creates a string representation for this URI. It's guaranteed that calling\n   * `URI.parse` with the result of this function creates an URI which is equal\n   * to this URI.\n   *\n   * * The result shall *not* be used for display purposes but for externalization or transport.\n   * * The result will be encoded using the percentage encoding and encoding happens mostly\n   * ignore the scheme-specific encoding rules.\n   *\n   * @param skipEncoding Do not encode the result, default is `false`\n   */\n  toString(skipEncoding: boolean = false): string {\n    return _asFormatted(this, skipEncoding)\n  }\n\n  toJSON(): UriComponents {\n    return this\n  }\n\n  [inspect.custom]() {\n    return this.toString()\n  }\n}\n\nexport interface UriComponents {\n  scheme: string\n  authority: string\n  path: string\n  query?: URLSearchParams | string\n  fragment: string\n}\n\ninterface UriState extends UriComponents {\n  $mid: number\n  external: string\n  fsPath: string\n  _sep: 1 | undefined\n}\n\nconst _pathSepMarker = isWinPortable ? 1 : undefined\n\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n  _formatted: string | null = null\n  _fsPath: string | null = null\n\n  get fsPath(): string {\n    if (this._fsPath == null) {\n      this._fsPath = uriToFsPath(this, false)\n    }\n    return this._fsPath\n  }\n\n  toString(skipEncoding: boolean = false): string {\n    if (!skipEncoding) {\n      if (this._formatted == null) {\n        this._formatted = _asFormatted(this, false)\n      }\n      return this._formatted\n    } else {\n      // we don't cache that\n      return _asFormatted(this, true)\n    }\n  }\n\n  toJSON(): UriComponents {\n    const res = <UriState>{\n      $mid: 1\n    }\n    // cached state\n    if (this._fsPath != null) {\n      res.fsPath = this._fsPath\n      res._sep = _pathSepMarker\n    }\n    if (this._formatted != null) {\n      res.external = this._formatted\n    }\n    // uri components\n    if (this.path) {\n      res.path = this.path\n    }\n    if (this.scheme) {\n      res.scheme = this.scheme\n    }\n    if (this.authority) {\n      res.authority = this.authority\n    }\n    mapNotBlank(this.query, ea => (res.query = ea))\n    if (this.fragment) {\n      res.fragment = this.fragment\n    }\n    return res\n  }\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n  [CharCode.Colon]: \"%3A\", // gen-delims\n  [CharCode.Slash]: \"%2F\",\n  [CharCode.QuestionMark]: \"%3F\",\n  [CharCode.Hash]: \"%23\",\n  [CharCode.OpenSquareBracket]: \"%5B\",\n  [CharCode.CloseSquareBracket]: \"%5D\",\n  [CharCode.AtSign]: \"%40\",\n\n  [CharCode.ExclamationMark]: \"%21\", // sub-delims\n  [CharCode.DollarSign]: \"%24\",\n  [CharCode.Ampersand]: \"%26\",\n  [CharCode.SingleQuote]: \"%27\",\n  [CharCode.OpenParen]: \"%28\",\n  [CharCode.CloseParen]: \"%29\",\n  [CharCode.Asterisk]: \"%2A\",\n  [CharCode.Plus]: \"%2B\",\n  [CharCode.Comma]: \"%2C\",\n  [CharCode.Semicolon]: \"%3B\",\n  [CharCode.Equals]: \"%3D\",\n\n  [CharCode.Space]: \"%20\"\n}\n\nexport function encodeURIComponentFast(\n  uriComponent: string,\n  allowSlash: boolean\n): string {\n  let res: string | undefined\n  let nativeEncodePos = -1\n\n  for (let pos = 0; pos < uriComponent.length; pos++) {\n    const code = uriComponent.charCodeAt(pos)\n\n    // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n    if (\n      (code >= CharCode.a && code <= CharCode.z) ||\n      (code >= CharCode.A && code <= CharCode.Z) ||\n      (code >= CharCode.Digit0 && code <= CharCode.Digit9) ||\n      code === CharCode.Dash ||\n      code === CharCode.Period ||\n      code === CharCode.Underline ||\n      code === CharCode.Tilde ||\n      (allowSlash && code === CharCode.Slash)\n    ) {\n      // check if we are delaying native encode\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos))\n        nativeEncodePos = -1\n      }\n      // check if we write into a new string (by default we try to return the param)\n      if (res !== undefined) {\n        res += uriComponent.charAt(pos)\n      }\n    } else {\n      // encoding needed, we need to allocate a new string\n      if (res === undefined) {\n        res = uriComponent.substr(0, pos)\n      }\n\n      // check with default table first\n      const escaped = encodeTable[code]\n      if (escaped !== undefined) {\n        // check if we are delaying native encode\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(\n            uriComponent.substring(nativeEncodePos, pos)\n          )\n          nativeEncodePos = -1\n        }\n\n        // append escaped variant to result\n        res += escaped\n      } else if (nativeEncodePos === -1) {\n        // use native encode only when needed\n        nativeEncodePos = pos\n      }\n    }\n  }\n\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos))\n  }\n\n  return res !== undefined ? res : uriComponent\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n  let res: string | undefined\n  for (let pos = 0; pos < path.length; pos++) {\n    const code = path.charCodeAt(pos)\n    if (code === CharCode.Hash || code === CharCode.QuestionMark) {\n      if (res === undefined) {\n        res = path.substr(0, pos)\n      }\n      res += encodeTable[code]\n    } else {\n      if (res !== undefined) {\n        res += path[pos]\n      }\n    }\n  }\n  return res !== undefined ? res : path\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n  let value: string\n  if (uri.authority && uri.path.length > 1 && uri.scheme === \"file\") {\n    // unc path: file://shares/c$/far/boo\n    value = `//${uri.authority}${uri.path}`\n  } else if (\n    uri.path.charCodeAt(0) === CharCode.Slash &&\n    ((uri.path.charCodeAt(1) >= CharCode.A &&\n      uri.path.charCodeAt(1) <= CharCode.Z) ||\n      (uri.path.charCodeAt(1) >= CharCode.a &&\n        uri.path.charCodeAt(1) <= CharCode.z)) &&\n    uri.path.charCodeAt(2) === CharCode.Colon\n  ) {\n    if (!keepDriveLetterCasing) {\n      // windows drive letter: file:///c:/far/boo\n      value = uri.path[1].toLowerCase() + uri.path.substr(2)\n    } else {\n      value = uri.path.substr(1)\n    }\n  } else {\n    // other path\n    value = uri.path\n  }\n  if (isWin) {\n    value = value.replace(/\\//g, \"\\\\\")\n  }\n  return value\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n  const encoder = !skipEncoding\n    ? encodeURIComponentFast\n    : encodeURIComponentMinimal\n\n  let res = \"\"\n  const { scheme, query, fragment } = uri\n  let { authority, path } = uri\n  if (scheme) {\n    res += scheme\n    res += \":\"\n  }\n  if (authority || scheme === \"file\") {\n    res += _slash\n    res += _slash\n  }\n  if (authority) {\n    let idx = authority.indexOf(\"@\")\n    if (idx !== -1) {\n      // <user>@<auth>\n      const userinfo = authority.substr(0, idx)\n      authority = authority.substr(idx + 1)\n      idx = userinfo.indexOf(\":\")\n      if (idx === -1) {\n        res += encoder(userinfo, false)\n      } else {\n        // <user>:<pass>@<auth>\n        res += encoder(userinfo.substr(0, idx), false)\n        res += \":\"\n        res += encoder(userinfo.substr(idx + 1), false)\n      }\n      res += \"@\"\n    }\n    // MRM 20200815: DON'T DOWNCASE:\n    // authority = authority.toLowerCase()\n    idx = authority.indexOf(\":\")\n    if (idx === -1) {\n      res += encoder(authority, false)\n    } else {\n      // <auth>:<port>\n      res += encoder(authority.substr(0, idx), false)\n      res += authority.substr(idx)\n    }\n  }\n  if (path) {\n    // lower-case windows drive letters in /C:/fff or C:/fff\n    if (\n      path.length >= 3 &&\n      path.charCodeAt(0) === CharCode.Slash &&\n      path.charCodeAt(2) === CharCode.Colon\n    ) {\n      const code = path.charCodeAt(1)\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}` // \"/c:\".length === 3\n      }\n    } else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n      const code = path.charCodeAt(0)\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}` // \"/c:\".length === 3\n      }\n    }\n    // encode the rest of the path\n    res += encoder(path, true)\n  }\n\n  mapNotBlank(query, q => (res += \"?\" + q))\n\n  if (fragment) {\n    res += \"#\"\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment\n  }\n  return res\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n  try {\n    return decodeURIComponent(str)\n  } catch {\n    if (str.length > 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3))\n    } else {\n      return str\n    }\n  }\n}\n\nconst _rEncodedAsHex = /(?:%[\\dA-Z][\\dA-Z])+/gi\n\nexport function percentDecode(str: string): string {\n  if (str.startsWith(\"xn--\")) return toUnicode(str)\n  if (!str.match(_rEncodedAsHex)) {\n    return str\n  }\n  return str.replace(_rEncodedAsHex, match => decodeURIComponentGraceful(match))\n}\n\nexport function toURI(u: string | URI): URI {\n  return URI.isUri(u) ? u : URI.parse(u)\n}\n\nexport function uriToBasename(u: string | URI): Maybe<string> {\n  return splitLast(toS(u), \"/\")\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { uniq } from \"../../fe/Array\"\nimport { eql } from \"../../fe/Eql\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport {\n  PS_LOCAL_FILE_SCHEME,\n  PS_NETWORK_FILESYSTEM_SCHEME\n} from \"../../fe/URI\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { uri2nativePath } from \"./FileURI\"\nimport { URI, toURI } from \"./URI\"\n\nconst uriPrefixes = [\n  \"http:\",\n  \"https:\",\n  \"file:\",\n  PS_LOCAL_FILE_SCHEME,\n  PS_NETWORK_FILESYSTEM_SCHEME\n].map(ea => ea + \"//\")\n\nexport function isUri(s: string): boolean {\n  const l = toS(s).toLowerCase()\n  return uriPrefixes.some(ea => l.startsWith(ea))\n}\n\nconst logger = lazy(() => mkLogger(\"uri.UriNormalization\"))\n\nexport function normalizeURI(uri: string): string {\n  try {\n    return URI.parse(uri).toString()\n  } catch (err) {\n    logger().warn(\"Failed to normalize invalid URI\", { uri, err })\n    return uri\n  }\n}\n\n/**\n * NOT FOR GENERAL USE (I don't think?)\n * @return true iff a and b are defined and are either equal or have the same\n * normalized content\n */\nfunction strEql(a: Maybe<string>, b: Maybe<string>) {\n  return a == null || b == null\n    ? false\n    : // normalize() is expensive, so we only do it if the paths are different\n      a === b || a.normalize() === b.normalize()\n}\n\n//\n// URI UNICODE NORMALIZATION\n//\n\n// We don't store normalized unicode URIs, as this allows us to store the actual\n// filename characters.\n\n// We *do* compare URIs by normalizing them, so macOS (using NFD) and other\n// filesystems (using NFC) can be considered equivalent.\n\nexport function uriEqlSync(a: Maybe<string | URI>, b: Maybe<string | URI>) {\n  try {\n    if (a == null || b == null) return false\n    const au = toURI(a)\n    const bu = toURI(b)\n    return (\n      au.scheme === bu.scheme &&\n      au.authority === bu.authority &&\n      strEql(au.path, bu.path)\n    )\n  } catch {\n    return false\n  }\n}\n\nexport async function uriIsEquivalent(\n  a: Maybe<string | URI>,\n  b: Maybe<string | URI>\n): Promise<boolean> {\n  try {\n    if (a == null || b == null) return false\n    return (\n      eql(a, b) ||\n      uriEqlSync(a, b) ||\n      strEql(await uri2nativePath(a), await uri2nativePath(b))\n    )\n  } catch {\n    return false\n  }\n}\n\nexport function uriEncodingVariants(uri: string | URI): string[] {\n  const u = toURI(uri)\n  return uniq([\n    u.toString(),\n    u.with({ path: u.path.normalize(\"NFC\") }).toString(),\n    u.with({ path: u.path.normalize(\"NFD\") }).toString()\n  ])\n}\n","import { join, posix, win32 } from \"path\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { ensurePrefix } from \"../../fe/String\"\nimport { PS_LOCAL_FILE_SCHEME } from \"../../fe/URI\"\nimport { containedByNativePath } from \"../fs/Path\"\nimport { native2posix } from \"../fs/PosixNative\"\nimport { isPosix } from \"../platform/Platform\"\nimport { Volume } from \"../volumes/Volume\"\nimport { bestVolumeForPath, bestVolumeForVolsha } from \"../volumes/Volumes\"\nimport { URI } from \"./URI\"\nimport { volsha } from \"./volsha\"\n\nexport async function nativePath2psfile(\n  nativePath: string,\n  vol?: Maybe<Volume>\n) {\n  if (blank(nativePath)) return\n  vol =\n    vol != null &&\n    containedByNativePath({\n      ancestor: vol.mountpoint,\n      descendant: nativePath,\n      acceptSelf: true // we shouldn't normally need to accept self--the volume mountpoint shouldn't be an asset native path!\n    })\n      ? vol\n      : await bestVolumeForPath(nativePath)\n  if (vol == null || blank(vol.uuid)) return\n\n  const fullPath = native2posix(nativePath)\n  const volPath = native2posix(vol.mountpoint)\n  if (!fullPath.normalize().startsWith(volPath.normalize())) return\n  const path = ensurePrefix(fullPath.slice(volPath.length), \"/\")\n\n  return URI.from({\n    scheme: PS_LOCAL_FILE_SCHEME,\n    authority: volsha(vol.uuid),\n    path\n  })\n}\n\nexport function joinMountpoint(mountpoint: string, posixPath: string) {\n  return join(mountpoint, ...posixPath.split(\"/\").slice(1))\n}\n\nexport async function psfile2nativePath(\n  uri: URI,\n  mountpoint?: string\n): PromiseMaybe<string> {\n  if (uri.scheme !== PS_LOCAL_FILE_SCHEME) {\n    throw new Error(\"invalid URI: \" + uri + \" (bad scheme)\")\n  }\n  if (blank(uri.authority)) {\n    throw new Error(\"invalid URI: \" + uri + \" (missing authority)\")\n  }\n\n  // Best-case, the volsha matches the mountpoint:\n\n  // Don't look at the mountpoint if it includes a separator character for the\n  // \"other\" platform (windows vs posix):\n\n  const notMySep = isPosix ? win32.sep : posix.sep\n\n  const mountpointMatchesPlatform =\n    notBlank(mountpoint) && !mountpoint.includes(notMySep)\n\n  if (mountpointMatchesPlatform && !blank(mountpoint)) {\n    const vol = await bestVolumeForPath(mountpoint)\n    if (vol?.uuid != null) {\n      const authority = volsha(vol.uuid)\n      if (authority === uri.authority) {\n        // Best case: everything still matches!\n        // We trust the volume mountpoint more that the given one, though:\n        return joinMountpoint(vol.mountpoint!, uri.path)\n      }\n    }\n  }\n\n  // Dang, the mountpoint's volsha doesn't match.\n\n  // See if we can resolve the volsha from current volumes:\n\n  const volshaVolume = await bestVolumeForVolsha(uri.authority)\n\n  if (volshaVolume != null) {\n    return joinMountpoint(volshaVolume.mountpoint, uri.path)\n  }\n\n  // last-ditch hope that the mountpoint actually works:\n\n  if (mountpointMatchesPlatform && notBlank(mountpoint)) {\n    return joinMountpoint(mountpoint, uri.path)\n  }\n\n  return undefined\n}\n","import { uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { ensurePrefix, stripPrefix } from \"../../fe/String\"\nimport { PS_LIBRARY_SCHEME } from \"../../fe/URI\"\nimport { libraryOriginalsDirPosixFile } from \"../dir/LibraryDirs\"\nimport { containedByNativePath, posixPathFrom } from \"../fs/Path\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { Settings } from \"../settings/Settings\"\nimport { URI } from \"./URI\"\n\nexport const PSLIB_ROOT_URI = URI.from({\n  scheme: PS_LIBRARY_SCHEME,\n  path: \"\"\n})\n\nexport function nativePath2pslib(nativePath: string) {\n  if (blank(nativePath)) return\n\n  const libDir = Settings.libraryDir.valueOrDefault // < valueOrDefault for Docker\n  if (blank(libDir)) return\n\n  const parent = uniq([libDir, libraryOriginalsDirPosixFile()]).find(dir =>\n    containedByNativePath({\n      ancestor: dir,\n      descendant: nativePath,\n      acceptSelf: true\n    })\n  )\n\n  if (parent == null) return\n\n  // We can't just `\"/\" + ` because that breaks for the root library dir :(\n\n  const path = ensurePrefix(posixPathFrom(parent, nativePath), \"/\")\n\n  return URI.from({\n    scheme: PS_LIBRARY_SCHEME,\n    path\n  })\n}\n\nexport function pslib2nativePath(uri: URI): Maybe<string> {\n  if (uri.scheme !== PS_LIBRARY_SCHEME) {\n    throw new Error(\"invalid URI: \" + uri + \" (bad scheme)\")\n  }\n  const origDir = libraryOriginalsDirPosixFile()\n  if (origDir == null) {\n    throw new Error(\"invalid URI: \" + uri + \" (no library set)\")\n  }\n  // strip initial \"/\" because we want a relative path\n  const relativePath = stripPrefix(uri.path, \"/\")\n  const orig = origDir.join(relativePath)\n\n  // there may be two directories to look in: $PS_LIBRARY and $PS_ORIGINALS.\n  // Return the originals dir if it exists, else the library dir if it exists,\n  // else the originals dir path.\n\n  if (orig.isFileSync()) return orig.nativePath\n\n  if (!origDir.eql(Settings.libraryDir.valueOrDefault)) {\n    const lib = PosixFile.for(Settings.libraryDir.valueOrDefault!).join(\n      relativePath\n    )\n    if (lib.isFileSync()) return lib.nativePath\n  }\n\n  // give up\n  return orig.nativePath\n}\n","import * as _path from \"path\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { PS_NETWORK_FILESYSTEM_SCHEME } from \"../../fe/URI\"\nimport { toA } from \"../../fe/toA\"\nimport { equalsIgnoreCase, stripPrefix } from \"../String\"\nimport { native2posix } from \"../fs/PosixNative\"\nimport { isReadableDirectory } from \"../fs/Stat\"\nimport { isEquivalentHost } from \"../net/nslookup\"\nimport { isWin } from \"../platform/Platform\"\nimport { Volume } from \"../volumes/Volume\"\nimport { bestVolumeForPath, volumes } from \"../volumes/Volumes\"\nimport { URI } from \"./URI\"\n\nexport async function nativePath2psnet(\n  nativePath: string,\n  vol?: Maybe<Volume>\n): PromiseMaybe<URI> {\n  if (blank(nativePath)) return\n\n  vol ??= await bestVolumeForPath(nativePath)\n\n  // Prefer the volume, if available:\n  if (\n    vol != null &&\n    vol.remote === true &&\n    notBlank(vol.remoteHost) &&\n    notBlank(vol.remoteShare)\n  ) {\n    return URI.from({\n      scheme: PS_NETWORK_FILESYSTEM_SCHEME,\n      authority: vol.remoteHost,\n      path: _path.posix.join(\n        \"/\" + vol.remoteShare,\n        stripPrefix(native2posix(nativePath), native2posix(vol.mountpoint))\n      )\n    })\n  }\n\n  // If it's a UNC path, URI knows how to handle it:\n  if (nativePath.startsWith(\"\\\\\\\\\")) {\n    return URI.file(nativePath).with({ scheme: PS_NETWORK_FILESYSTEM_SCHEME })\n  }\n\n  // Give up:\n  return\n}\n\nexport async function psnet2nativePath(\n  uri: URI,\n  mountpoint?: string\n): PromiseMaybe<string> {\n  if (uri.scheme !== PS_NETWORK_FILESYSTEM_SCHEME) {\n    throw new Error(\"invalid URI: \" + uri + \" (bad scheme)\")\n  }\n\n  if (blank(uri.authority)) {\n    throw new Error(\"invalid URI: \" + uri + \" (missing authority)\")\n  }\n\n  const arr = uri.path.split(\"/\").slice(1) // < slice(1) to skip over the '' due to the absolute path\n  const share = arr[0]\n\n  if (blank(share)) {\n    throw new Error(\"invalid URI: \" + uri + \" (missing share)\")\n  }\n\n  if (isWin) {\n    return `\\\\\\\\${uri.authority}\\\\${arr.join(_path.sep)}`\n  }\n\n  const path = arr.slice(1)\n\n  // If there's a mounted drive with this share, use that:\n  const vols = await volumes()\n\n  for (const vol of toA(vols)) {\n    if (vol.remote !== true) continue\n    if (\n      equalsIgnoreCase(vol.remoteShare, share) &&\n      (await isEquivalentHost(uri.authority, vol.remoteHost))\n    ) {\n      return _path.join(vol.mountpoint, ...path)\n    }\n  }\n\n  if (await isReadableDirectory(mountpoint)) {\n    return _path.join(mountpoint!, ...path)\n  }\n\n  return\n}\n","import { mapNotBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { memoize } from \"../MemoizedFunc\"\nimport { shortStringSha } from \"../StringHash\"\n\nexport const volsha = memoize(\n  (uuid: Maybe<string>) => mapNotBlank(uuid, shortStringSha),\n  { maxSize: 128, ttlMs: minuteMs }\n)\n","import { configDir } from \"../dir/ConfigDir\"\nimport { PosixFile } from \"../fs/PosixFile\"\n\nexport function channelVersionsCache() {\n  return PosixFile.forMaybe(configDir())?.join(\"channel-versions.json\")\n}\n","import { version, versionMajor, versionMinor, versionPatch } from \"../Version\"\nimport { extractUpdateChannel } from \"./UpdateChannels\"\n\nexport function channel() {\n  return extractUpdateChannel(version)\n}\n\n/**\n * @return \"1.2.3\", even if `version` is \"1.2.3-alpha.0\" or \"1.2.3-beta.32\"\n */\nexport const baseVersion = () =>\n  [versionMajor, versionMinor, versionPatch].join(\".\")\n\n/**\n * Used for version documentation at https://photostructure.com/v${versionMajorMinor}/\n */\nexport const versionMajorMinor = versionMajor + \".\" + versionMinor\n","import { Range, SemVer, parse, satisfies } from \"semver\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { Comparable } from \"../../fe/Primitive\"\nimport { toS } from \"../../fe/toS\"\nimport { greatestBy } from \"../Array\"\nimport { UpdateChannels, extractUpdateChannel } from \"./UpdateChannels\"\n\n// Typical debian package versions don't comply with semver:\n// 0.11.2-6\n// 2:4.15.13+dfsg-0ubuntu1.4\n// 4.8.0-2ubuntu1\n\nconst DebianVersionRE =\n  /^(?:\\d+:)?(?<major>\\d+)(?<minor>\\.\\d+)?(?<patch>\\.\\d+)?/\n\nexport function debianVersionToSemver(\n  version: Maybe<string | SemVer>\n): Maybe<string> {\n  if (version instanceof SemVer) return version.version\n  const ver = DebianVersionRE.exec(version ?? \"\")?.groups\n  return ver == null\n    ? undefined\n    : ver.major + (ver.minor ?? \".0\") + (ver.patch ?? \".0\")\n}\n\nexport function semverSatisfies(\n  version: string | SemVer,\n  range: string | Range\n): boolean {\n  if (blank(version)) return false\n  const optionsOrLoose = { loose: true, includePrerelease: true }\n  if (satisfies(version, range, optionsOrLoose)) return true\n  const v = debianVersionToSemver(version)\n  return v == null ? false : satisfies(v, range, optionsOrLoose)\n}\n\nexport function semverGte(v1: string | SemVer, v2: string | SemVer): boolean {\n  return semverLatest(v1, v2) === v1\n}\n\nexport function toSemver(v: string | SemVer): Maybe<SemVer> {\n  try {\n    return v instanceof SemVer ? v : parse(v, { loose: true }) ?? undefined\n  } catch {\n    return\n  }\n}\n\nfunction semverSortBy(v: string | SemVer): Maybe<Comparable[]> {\n  const s = toSemver(v)\n  const ord = UpdateChannels.ordinal(extractUpdateChannel(toS(v)))\n  return s == null\n    ? undefined\n    : [s.major, s.minor, s.patch, ord, ...s.prerelease.slice(1)]\n}\n\nexport function semverLatest<T extends string | SemVer>(...arr: T[]): Maybe<T> {\n  return greatestBy(arr, semverSortBy)\n}\n","import { isObject } from \"../../fe/Object\"\nimport { isString } from \"../../fe/String\"\nimport { UpdateChannel, UpdateChannels } from \"./UpdateChannels\"\n\nexport interface UpdateChannelVersion {\n  channel: UpdateChannel\n  version: string\n}\n\nexport function isUpdateChannelVersion(x: unknown): x is UpdateChannelVersion {\n  return (\n    isObject(x) &&\n    UpdateChannels.has((x as UpdateChannelVersion).channel) &&\n    isString((x as UpdateChannelVersion).version)\n  )\n}\n","import { StrEnumKeys, strEnum } from \"../../fe/StrEnum\"\n\n// these must be in order from least-to-most stable:\nexport const UpdateChannels = strEnum(\"prealpha\", \"alpha\", \"beta\", \"stable\")\nexport type UpdateChannel = StrEnumKeys<typeof UpdateChannels>\n\nexport function extractUpdateChannel(version: string): UpdateChannel {\n  for (const c of UpdateChannels.values) {\n    // the minus sign lets \"alpha\" not spuriously match against \"prealpha\":\n    if (version.includes(\"-\" + c)) return c\n  }\n  return UpdateChannels.stable\n}\n\n/**\n * What channels are equivalent or better than `channel`?\n */\nexport function eligibleForChannel(channel: UpdateChannel): UpdateChannel[] {\n  return UpdateChannels.values.slice(UpdateChannels.ordinal(channel))\n}\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\n\n/**\n * Consistent version formatting.\n *\n * @returns \"(missing version)\" if the input is blank.\n */\nexport function ver(s: Maybe<string>) {\n  return blank(s)\n    ? \"(missing version)\"\n    : s.replace(/^(?:v|ver|version)?\\s*/, \"version \")\n}\n","import { compact } from \"../../fe/Array\"\nimport { tt } from \"../../fe/BabyMarkdown\"\nimport { dayMs, minuteMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { fmtDuration } from \"../../fe/FmtDuration\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { SimpleAppName } from \"../AppName\"\nimport { EditionName, EditionType } from \"../EditionName\"\nimport { mkLogger } from \"../Logger\"\nimport { osFullName } from \"../OperatingSystem\"\nimport { version } from \"../Version\"\nimport { MemoizedDeferred, lazyAsync } from \"../async/LazyAsync\"\nimport { configDir } from \"../dir/ConfigDir\"\nimport { isDirectory } from \"../fs/Stat\"\nimport { HealthCheckTest } from \"../health/HealthCheck\"\nimport { t } from \"../licensing/Licensing\"\nimport { Settings } from \"../settings/Settings\"\nimport { commandTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { httpGetJson_ } from \"../web/HttpGet\"\nimport { channelVersionsCache } from \"./ChannelVersionsCache\"\nimport { channel } from \"./PhotoStructureVersion\"\nimport { semverGte, semverLatest } from \"./SemVer\"\nimport {\n  UpdateChannelVersion,\n  isUpdateChannelVersion\n} from \"./UpdateChannelVersion\"\nimport {\n  UpdateChannel,\n  UpdateChannels,\n  eligibleForChannel,\n  extractUpdateChannel\n} from \"./UpdateChannels\"\nimport { ver } from \"./Ver\"\n\nconst logger = defer(() => mkLogger(\"VersionCheck\"))\n\nexport function currentChannel() {\n  const least = [Settings.updateChannel.valueOrDefault, channel()]\n    .map(ea => UpdateChannels.ordinal(ea))\n    .sort()[0]\n  // we want the least-stable value:\n  return UpdateChannels.values[least] ?? Settings.updateChannel.valueOrDefault\n}\n\nexport type CheckVersionResult = HealthCheckTest & {\n  latestVersion?: string\n  latestChannel?: UpdateChannel\n}\n\nexport async function checkVersion_(args?: {\n  installedVersion: string\n  latestVersion: string\n}): Promise<CheckVersionResult> {\n  if (true !== Settings.autoUpdateCheck.value) {\n    const msg = [\"PhotoStructure version checking is disabled\"]\n    if (Settings.optOut.valueOrDefault === true) {\n      msg.push(\"Set \" + tt(Settings.optOut.toEnvLine(false)) + \" to enable.\")\n    } else if (Settings.autoUpdateCheck.value === false) {\n      msg.push(\n        \"Set \" + tt(Settings.autoUpdateCheck.toEnvLine(true)) + \" to enable.\"\n      )\n    } else {\n      msg.push(\n        \"Finish setup, or set \" +\n          tt(Settings.autoUpdateCheck.toEnvLine(true)) +\n          \" to enable.\"\n      )\n    }\n    return { level: \"disabled\", msg }\n  }\n\n  const dir = configDir()\n  if (dir == null || !(await isDirectory(dir))) {\n    return {\n      level: \"warn\",\n      msg: [\n        \"PhotoStructure version checking is disabled\",\n        \"No suitable configuration directory exists.\"\n      ]\n    }\n  }\n\n  const channelVersions: Maybe<ChannelVersionJson> = await getChannelVersions_()\n  if (channelVersions == null) {\n    return {\n      level: \"warn\",\n      msg: [\"Failed to fetch PhotoStructure version information\"]\n    }\n  }\n  const installedVersion = args?.installedVersion ?? version\n  const myChannel = extractUpdateChannel(installedVersion)\n\n  // This shouldn't be necessary--we should be copying versions to less-stable channels\n  const channelCandidates = eligibleForChannel(myChannel)\n  const versionCandidates = channelVersions.versions\n    .filter(ea => channelCandidates.includes(ea.channel))\n    .map(ea => ea.version)\n\n  const latestVersion =\n    args?.latestVersion ?? semverLatest(...versionCandidates)\n\n  if (latestVersion == null) {\n    return {\n      level: \"warn\",\n      msg: [\n        \"PhotoStructure version checking failed\",\n        \"No suitable version was found for \" +\n          Settings.updateChannel.toEnvLine()\n      ]\n    }\n  }\n\n  const latestChannel = extractUpdateChannel(latestVersion)\n\n  const currentVerMsg =\n    \"You are running \" + EditionName() + \" \" + ver(installedVersion)\n\n  const latestVerMsg =\n    \"The latest published \" +\n    tt(latestChannel) +\n    \" build is \" +\n    ver(latestVersion)\n\n  const advice =\n    latestChannel === myChannel\n      ? undefined\n      : \"You should consider switching to the \" +\n        tt(latestChannel) +\n        \" channel.\"\n\n  const agoMs = Date.now() - channelVersions.updatedAt\n  const lastCheckedMsg =\n    \"Last checked \" +\n    (agoMs < minuteMs ? \"just now\" : fmtDuration(agoMs, 1) + \" ago\") +\n    \" (\" +\n    new Date(channelVersions.updatedAt).toISOString() +\n    \")\"\n\n  const msgs = compact([currentVerMsg, latestVerMsg, advice, lastCheckedMsg])\n\n  // During a release, it's plausible that users will be running a version\n  // that is newer than what is in the channel-versions.json if they update\n  // manually because I announced it on discord.\n\n  // **Don't freak out**\n  if (semverGte(installedVersion, latestVersion)) {\n    return {\n      level: \"ok\",\n      msg: [\"PhotoStructure is up to date\", ...msgs],\n      latestVersion,\n      latestChannel\n    }\n  } else {\n    return {\n      level: \"warn\",\n      msg: [\"PhotoStructure is out of date\", ...msgs],\n      latestVersion,\n      latestChannel\n    }\n  }\n}\n\nexport async function userAgent() {\n  return Settings.allowUserAgent.valueOrDefault\n    ? systemUserAgent()\n    : SimpleAppName\n}\n\nexport async function systemUserAgent() {\n  return (\n    SimpleAppName +\n    \"/\" +\n    version +\n    \" (\" +\n    osFullName() +\n    \") \" +\n    EditionType().toLowerCase() +\n    \"/\" +\n    (await t())\n  )\n}\n\ninterface ChannelVersionJson {\n  versions: UpdateChannelVersion[]\n  updatedAt: number\n  updatedByVersion: string\n}\n\nconst ChannelVersionsUrl = \"https://photostructure.com/channel-versions.json\"\n\n// lazy for tests (and timeout)\nexport const getChannelVersions_: MemoizedDeferred<Maybe<ChannelVersionJson>> =\n  lazyAsync({\n    timeoutMs: commandTimeoutMs(),\n    ttlMs: minuteMs,\n    later: async () => {\n      const cache = channelVersionsCache()!\n      const response = await httpGetJson_({\n        url: ChannelVersionsUrl,\n        config: {\n          headers: {\n            \"User-Agent\": await userAgent()\n          }\n        },\n        cache,\n        ttlMs: dayMs,\n        preCacheTransform: versions => ({\n          versions,\n          updatedAt: Date.now(),\n          updatedByVersion: version\n        })\n      })\n\n      const result = response.data as any as ChannelVersionJson\n\n      // Is the response valid?\n      if (\n        result == null ||\n        !Array.isArray(result.versions) ||\n        result.versions.length === 0 ||\n        result.versions.some(ea => !isUpdateChannelVersion(ea)) ||\n        result.updatedByVersion !== version\n      ) {\n        if (response.fromCache) {\n          logger().info(\n            \"getChannelVersions_(): Invalid or stale cached response. Retrying after wiping cache\",\n            {\n              result,\n              cache\n            }\n          )\n          await cache.unlink_()\n          return getChannelVersions_.refresh()\n        }\n        logger().throw(\"getChannelVersions_(): Invalid response\", { result })\n      }\n\n      return logger().tap({\n        msg: \"getChannelVersions_()\",\n        result\n      })\n    }\n  })\n","import { compactBlanks } from \"../../fe/Array\"\nimport { libraryOriginalsDirPosixFile } from \"../dir/LibraryDirs\"\nimport { containedByNativePath, pathIsRoot } from \"../fs/Path\"\nimport { isPosix } from \"../platform/Platform\"\nimport { Settings } from \"../settings/Settings\"\n\nexport function mightBeAssetMountpoint(nativePath: string) {\n  for (const dir of compactBlanks([\n    Settings.libraryDir.valueOrDefault,\n    libraryOriginalsDirPosixFile(),\n    ...Settings.scanPaths.values\n  ])) {\n    // Don't let a \"/\" in scanPaths make everything not ignorable\n    if (isPosix && pathIsRoot(dir)) continue\n    if (\n      containedByNativePath({\n        ancestor: dir,\n        descendant: nativePath,\n        acceptSelf: true\n      })\n    )\n      return true\n  }\n  return false\n}\n","import { nativePath2uri } from \"../uri/FileURI\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\nimport { volumes } from \"./Volumes\"\n\nexport const currentVolumeRoots = lazyFsAsync(\n  \"currentVolumeRoots\",\n  _currentVolumeRoots\n)\n\nasync function _currentVolumeRoots(): Promise<{\n  uris: string[]\n  mountpoints: string[]\n}> {\n  const uris: string[] = []\n  const mountpoints: string[] = []\n  for (const vol of await volumes()) {\n    mountpoints.push(vol.mountpoint)\n    const uri = (await nativePath2uri(vol.mountpoint, vol))?.toString()\n    if (uri != null) uris.push(uri)\n  }\n  return { uris, mountpoints }\n}\n","import { isDocker } from \"../platform/isDocker\"\n\nexport const DefaultExcludedLinuxRoots = [\n  \"boot\",\n  \"efi\",\n  \"etc\",\n  \"lib\", // don't exclude /net, that's used for nfs mounts!\n  \"proc\",\n  \"snap\",\n  \"sys\",\n  \"tmp\"\n]\n\nexport const DefaultExcludedLinuxMountpointPaths = [\n  ...(isDocker() ? [\"/\"] : []), // < don't scan or examine the root volume\n  \"/dev/shm\",\n  \"/run\",\n  \"/run/lock\",\n  \"/run/qemu\",\n  \"/run/snapd/ns\",\n  \"/tmp\",\n  \"/var/tmp\"\n]\n\nexport const DefaultExcludedLinuxMountpointNames = [\"#snapshot\"]\n","export const DefaultExcludedFilesystemTypes = [\n  \"cgmfs\",\n  \"cgroup\",\n  \"debugfs\",\n  \"devfs\",\n  \"devtmpfs\",\n  \"sunrpc\",\n  \"sysfs\",\n  \"tracefs\",\n  \"udev\"\n]\n","import { lazy } from \"../../core/Lazy\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toA } from \"../../fe/toA\"\nimport { mkLogger } from \"../Logger\"\nimport { assignMissingPrimitives } from \"../Object\"\nimport { isReadableDirectorySync } from \"../fs/StatSync\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { Settings } from \"../settings/Settings\"\nimport { mightBeAssetMountpoint } from \"./AssetMountpoint\"\nimport { dfPosixRaw } from \"./DfPosixRaw\"\nimport { gioVolumes, isGioSupported } from \"./Gio\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\nimport { mountpoints } from \"./Mountpoints\"\nimport { isExcludedFilesystem, isExcludedMountpoint } from \"./PosixVolumes\"\nimport { DfVolume } from \"./Volume\"\n\nconst logger = lazy(() => mkLogger(\"volumes.DfPosix\"))\n\nconst localMountpoints = lazyFsAsync(\n  \"localMountpoints\",\n  // We'll assume gio mountpoints are always remote, so we can ignore gio stuff\n  // here:\n  async () =>\n    (await dfPosixRaw({ localsOnly: true, paths: await mountpoints() }))?.map(\n      vol => vol.mountpoint\n    )\n)\n\nfunction isRemoteFilesystem(fs: Maybe<string>) {\n  return notBlank(fs) && Settings.remoteFilesystemTypes.values.includes(fs)\n}\n\nexport function acceptPosixVolume(vol: DfVolume): boolean {\n  const notAssetMountpoint = !mightBeAssetMountpoint(vol.mountpoint)\n  const excludedFS =\n    vol.filesystem == null ? false : isExcludedFilesystem(vol.filesystem)\n  const excludedMP = isExcludedMountpoint(vol.mountpoint)\n  const excludedDir = Settings.validateMountpoints.valueOrDefault\n    ? !isReadableDirectorySync(vol.mountpoint)\n    : false\n\n  const excluded =\n    notAssetMountpoint && (excludedFS || excludedMP || excludedDir)\n\n  return logger().tap({\n    msg: \"acceptPosixVolume()\",\n    result: !excluded,\n    meta: {\n      volume: vol,\n      notAssetMountpoint,\n      excludedFS,\n      excludedMP,\n      excludedDir\n    }\n  })\n}\n\n// This doesn't need to be cached: it's cached already by _volumesImpl\nexport async function dfPosix() {\n  // df on docker doesn't return all mountpoints (!!) unless we tell `df` which paths we want:\n  const paths = isDocker() ? await mountpoints() : undefined\n  const vols = await dfPosixRaw({ paths })\n\n  if (vols == null) return\n  const locals = toA(await localMountpoints())\n  vols.forEach(vol => {\n    vol.remote =\n      !locals.includes(vol.mountpoint) || isRemoteFilesystem(vol.filesystem)\n  })\n  if (await isGioSupported()) {\n    for (const vol of toA(await gioVolumes())) {\n      // only push unique mountpoints\n      const prior = vols.find(ea => ea.mountpoint === vol.mountpoint)\n      if (prior == null) {\n        vols.push(vol)\n      } else {\n        logger().info(\"Merging GIO and df volume\", {\n          dfVol: prior,\n          gioVol: vol\n        })\n        // We don't trust gio as much as we trust df, so only assign missing fields (like remote host):\n        assignMissingPrimitives(prior, vol)\n      }\n    }\n  }\n  return vols.filter(acceptPosixVolume)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { compact, compactBlanks } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toInt } from \"../../fe/Number\"\nimport { KiB } from \"../../fe/Units\"\nimport { parseFixed } from \"../Fixed\"\nimport { mkLogger } from \"../Logger\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { isMac } from \"../platform/Platform\"\nimport { DfVolume } from \"./Volume\"\nimport { commandTimeoutMs } from \"./VolumeTtls\"\n\nconst logger = lazy(() => mkLogger(\"volumes.DfPosixRaw\"))\n\n// KiB: https://en.wikipedia.org/wiki/Byte#Units_based_on_powers_of_2\nfunction kibToBytes(s: string): number {\n  return toInt(s, { defaultValue: 0 })! * KiB\n}\n\nexport async function dfPosixRawLocal_() {\n  return stdout_(\"df\", [\"-l\", \"-k\", \"-P\"], {\n    timeoutMs: commandTimeoutMs(),\n    ignoreStderr: false,\n    ignoreExitCode: false\n  })\n}\n\nexport async function dfPosixRaw({\n  localsOnly,\n  paths,\n  output\n}: {\n  localsOnly?: boolean\n  paths?: string[]\n  output?: string\n} = {}): Promise<DfVolume[]> {\n  // HEY FUTURE ME: Make sure you run `coreutils` version of `df` on Alpine!\n  const args = [\"-k\", \"-P\"]\n  if (localsOnly === true) args.push(\"-l\")\n  args.push(...compactBlanks(paths))\n  output ??= await stdout_(\"df\", args, {\n    timeoutMs: commandTimeoutMs(),\n    // https://askubuntu.com/questions/1227667/df-command-throws-error-on-run-user-1000-doc-folder\n    ignoreStderr: true,\n    ignoreExitCode: true\n  })\n  if (blank(output)) {\n    logger().warn(\"empty output\", { localsOnly, paths })\n    return []\n  }\n\n  logger().debug(\"output\", { localsOnly, paths, output })\n\n  const arr = parseDfVolumes(output)\n  if (localsOnly === true) {\n    arr.forEach(ea => (ea.remote = false))\n  }\n  return arr\n}\n\ninterface ParsedVolume {\n  Filesystem: string\n  \"1024-blocks\": string\n  Used: string\n  Available: string\n  \"Mounted on\": string\n}\n\nexport function parseDfVolumes(output: string) {\n  const parsed = parseFixed(\n    [\n      \"Filesystem\",\n      \"1024-blocks\",\n      \"Used\",\n      \"Available\",\n      \"Capacity\",\n      \"Mounted on\"\n    ],\n    output\n  )\n  return compact(parsed.map(ea => parseDfVolume(ea as any)))\n}\n\nexport function parseDfVolume(vol: ParsedVolume): Maybe<DfVolume> {\n  // HEY FUTURE ME: Don't filter \"ignorable\" volumes here. `mountpoints()` and\n  // `volumes()` does that for us.\n\n  const filesystem = vol[\"Filesystem\"]\n  const mountpoint = vol[\"Mounted on\"]\n  const size = kibToBytes(vol[\"1024-blocks\"]) ?? 0\n  if (size === 0) {\n    logger().info(\"parseDfVolume(): skipping (size is 0)\", { vol })\n    return\n  }\n\n  const used = kibToBytes(vol[\"Used\"]) ?? 0\n  const available = kibToBytes(vol[\"Available\"]) ?? 0\n\n  if (used === 0 && available === 0) {\n    logger().info(\"parseDfVolume(): skipping (used and available is 0)\", {\n      vol,\n      size,\n      used,\n      available\n    })\n    return\n  }\n\n  return {\n    filesystem,\n    mountpoint,\n    // 20220530: macOS MIS-REPORTS VOLUME SIZES, YAY\n    size: isMac ? used + available : size,\n    used,\n    available\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { compact, uniq } from \"../../fe/Array\"\nimport { sort } from \"../../fe/ArraySort\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, gte0 } from \"../../fe/Number\"\nimport { Obj, compactBlankValues } from \"../../fe/Object\"\nimport { ensureSuffix } from \"../../fe/String\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { equalsIgnoreCase } from \"../String\"\nimport { mapAsync } from \"../async/Promise\"\nimport { onError } from \"../error/OnError\"\nimport { PowerShell } from \"../pwsh/PowerShell\"\nimport { Settings } from \"../settings/Settings\"\nimport { mountpointsWin } from \"./MountpointsWin\"\nimport { parseRemoteName } from \"./RemoteVolumesWin\"\nimport { Volume } from \"./Volume\"\nimport { commandTimeoutMs } from \"./VolumeTtls\"\n\nconst logger = lazy(() => mkLogger(\"volumes.DfWin\"))\n\n// This is already cached by _volumesImpl()\nexport async function dfWin() {\n  const disks = await volumeInfoWin()\n  return disks.filter(d => d.ok !== false && gt0(d.size))\n}\n\nconst DriveLetterRE = /([a-z]+)(?::\\\\)?/i\n\nfunction cleanDriveLetter(driveLetter?: Maybe<string>) {\n  return driveLetter?.match(DriveLetterRE)?.[1]?.toUpperCase()\n}\n\nexport function normalizeDriveLetter(driveLetter: Maybe<string>) {\n  return map(cleanDriveLetter(driveLetter), ea => ea + \":\\\\\")\n}\n\n// Returns network-mapped drives, but doesn't get operational status or UUIDs:\nexport function getPsDriveCommand(driveLetter?: Maybe<string>) {\n  return `Get-PSDrive -PSProvider FileSystem ${toS(\n    cleanDriveLetter(driveLetter)\n  )} | Select-Object -Property Root,DisplayRoot,Description,Used,Free`\n}\n\nfunction parseGetPsDriveRow(ea: Obj): Maybe<Volume> {\n  return ea == null || blank(ea.Root) || !gte0(ea.Free) || !gte0(ea.Used)\n    ? undefined\n    : (compactBlankValues({\n        mountpoint: ensureSuffix(ea.Root, \":\\\\\").toUpperCase(),\n        label: ea.Description,\n        size: ea.Used + ea.Free,\n        used: ea.Used,\n        available: ea.Free,\n        remote: notBlank(ea.DisplayRoot),\n        ...map(parseRemoteName(ea.DisplayRoot), remote => ({\n          remoteHost: remote.host,\n          remoteShare: remote.share\n        }))\n      }) as Volume)\n}\n\n// Note: Get-Disk and Get-Partition return physical (not logical) disk info.\n\n// No remote drives, but we get UUIDs:\nexport function getVolumeCommand(driveLetter?: Maybe<string>) {\n  return `Get-Volume ${toS(\n    cleanDriveLetter(driveLetter)\n  )} | Select-Object -Property DriveLetter,FileSystem,FileSystemLabel,Size,SizeRemaining,HealthStatus,OperationalStatus,UniqueId`\n}\n\nexport function getLocalVolumesWin_() {\n  return PowerShell.instance().executeJsonToA(getVolumeCommand())\n}\n\nconst uuidRE = /\\{([-a-z\\d]{7,})\\}/i\n\n/**\n * @param s \"\\\\?\\Volume{717926df-0000-0000-0000-50e01f000000}\\\"\n */\nfunction uniqueId2uuid(s: Maybe<string>) {\n  return logger().tap({\n    msg: \"uniqueId2uuid\",\n    result: map(uuidRE.exec(toS(s)), m => m[1]),\n    meta: { s }\n  })\n}\n\nfunction toDefinedAndNotEql(s: Maybe<string>, v: string) {\n  s = s?.trim()\n  return !blank(s) && !equalsIgnoreCase(s, v) ? s : undefined\n}\n\nexport function parseGetVolumeRow(o: Obj): Maybe<Volume> {\n  // We don't care about system recovery volumes:\n  if (\n    o.DriveLetter == null ||\n    o.DriveLetter === \"null\" ||\n    o.FileSystemLabel === \"System Reserved\"\n  ) {\n    logger().debug(\"parseGetVolumeRow(): skipping system recovery volume\", {\n      o\n    })\n    return\n  }\n  const mountpoint = normalizeDriveLetter(o.DriveLetter)\n  if (mountpoint == null) {\n    logger().debug(\n      \"parseGetVolumeRow(): skipping volume: invalid DriveLetter\",\n      { o }\n    )\n    return\n  }\n  const notOkStatus = compact([\n    toDefinedAndNotEql(o.HealthStatus, \"healthy\"),\n    toDefinedAndNotEql(o.OperationalStatus, \"OK\")\n  ]).join(\"; \")\n  const ok =\n    o.Size != null &&\n    o.SizeRemaining != null &&\n    notBlank(o.DriveLetter) &&\n    blank(notOkStatus)\n  return logger().tap({\n    msg: \"parseGetVolumeRow()\",\n    result: {\n      mountpoint,\n      filesystem: o.FileSystem,\n      label: o.FileSystemLabel,\n      uuid: uniqueId2uuid(o.UniqueId),\n      size: o.Size,\n      used: o.Size - o.SizeRemaining,\n      available: o.SizeRemaining,\n      remote: false, // Get-Volume only returns local drives.\n      ok,\n      status: notOkStatus\n    },\n    meta: { input: o }\n  })\n}\n\nexport async function volumeInfoWin(): Promise<Volume[]> {\n  // Windows can sometimes get confused and map the same network drive to both\n  // f:\\ and F:\\\n  const driveLetters = uniq(\n    toA(await mountpointsWin()).map(normalizeDriveLetter)\n  )\n\n  // We ask for each drive letter separately to parallelize the requests.\n  const psDrivesJson = await mapAsync({\n    name: \"volumeInfoWin.psDrivesJson\",\n    arr: driveLetters,\n    f: drive =>\n      PowerShell.instance()\n        .executeJsonToA(getPsDriveCommand(drive))\n        .catch(error => {\n          onError(\"volumeInfoWin(): Get-PSDrive failed for drive \" + drive, {\n            error\n          })\n          return []\n        }),\n    maxConcurrent: Settings.powerShellProcs.valueOrDefault,\n    timeoutMs: commandTimeoutMs()\n  })\n\n  const psDriveVols = compact(flatten(psDrivesJson).map(parseGetPsDriveRow))\n\n  // NOTE: Get-Volume doesn't return network drives or virtual drives\n\n  const getVolumesJson = await mapAsync({\n    name: \"volumeInfoWin.volumesJson\",\n    arr: driveLetters,\n    f: drive =>\n      PowerShell.instance()\n        .executeJsonToA(getVolumeCommand(drive))\n        .catch(err => {\n          logger().debug(\n            \"volumeInfoWin(): Get-Volume failed for drive \" + drive,\n            err\n          )\n          return []\n        }),\n    maxConcurrent: Settings.powerShellProcs.valueOrDefault,\n    timeoutMs: commandTimeoutMs()\n  })\n\n  const getVolumesVols = compact(flatten(getVolumesJson).map(parseGetVolumeRow))\n\n  // Don't include any mountpoints that are unhealthy:\n  const unhealthy = uniq(\n    [...psDriveVols, ...getVolumesVols]\n      .filter(ea => ea.ok === false)\n      .map(ea => ea.mountpoint)\n  )\n\n  const healthyMountpoints = sort(\n    uniq([...psDriveVols, ...getVolumesVols].map(ea => ea.mountpoint)).filter(\n      ea => !unhealthy.includes(ea)\n    )\n  )\n\n  logger().info(\"volumeInfoWin()\", {\n    psDriveVols,\n    getVolumesVols,\n    healthyMountpoints,\n    unhealthy\n  })\n\n  const vols = healthyMountpoints.map(mountpoint => ({\n    ...psDriveVols.find(ea => mountpoint === ea.mountpoint)!,\n    ...getVolumesVols.find(ea => mountpoint === ea.mountpoint)!\n  })) as Volume[]\n\n  vols.forEach(vol => {\n    const sad = unhealthy.includes(vol.mountpoint)\n    if (sad) vol.ok = false\n    vol.ignorable = vol.ignorable === true || vol.ok === false\n  })\n\n  return vols\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { map } from \"../../fe/Maybe\"\nimport { opt } from \"../../fe/Opt\"\nimport { mkLogger } from \"../Logger\"\nimport { isBillingService } from \"../ServiceNames\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { stripPrefix, stripSuffix } from \"../String\"\nimport { memoizeAsync } from \"../async/MemoizedAsyncFunc\"\nimport { mapAsyncSerial, thenFlatten, thenMap } from \"../async/Promise\"\nimport { thenOrTimeout } from \"../async/ThenOrTimeout\"\nimport { stdoutResult_, stdout_ } from \"../child/ChildProcess\"\nimport { BaseFile } from \"../fs/BaseFile\"\nimport { pathTo } from \"../fs/PathTo\"\nimport { isReadableDirectory } from \"../fs/Stat\"\nimport { isLinux } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { dfPosixRaw } from \"./DfPosixRaw\"\nimport { setupVolumeTTL } from \"./LazyFsAsync\"\nimport { readProcMounts } from \"./MountpointsPosix\"\nimport { commandTimeoutMs, mountpointsTtlMs } from \"./VolumeTtls\"\n\nexport const isGioSupported = lazy(async () => {\n  if (\n    !isLinux ||\n    isDocker() ||\n    isBillingService() ||\n    null == (await pathTo({ tool: GioCommand }))\n  ) {\n    return false\n  }\n\n  try {\n    const result = await stdoutResult_(GioCommand, [\"version\"], {\n      timeoutMs: commandTimeoutMs(),\n      ignoreStderr: true\n    })\n    return result.code === 0\n  } catch (err) {\n    return false\n  }\n})\n\nexport const GioCommand = \"gio\"\nexport const GioMountMonitorArgs = [\"mount\", \"--monitor\", \"--anonymous\"]\n\nconst logger = lazy(() => mkLogger(\"volumes.Gio\"))\n\n/**\n * The `gio` subsystem may not be installed, in which case, we have to poll\n * the results of `df`.\n *\n * These volumes won't be in a `df` list.\n */\n// DO NOT USE lazyFsAsync here, as mountpoints() uses this function!\nexport const gioVolumes = lazy(async () =>\n  thenOrTimeout(\n    async () => {\n      if (!(await isGioSupported())) return\n      // We need to find the FUSE mountpoints that gvfs is using:\n      const fuseDirs = await gvfsFuseDirectories()\n      if (isEmpty(fuseDirs)) return []\n      logger().info(\"gioVolumes()\", { fuseDirs })\n      return mapAsyncSerial({\n        arr: fuseDirs,\n        name: \"gioVolumes\",\n        timeoutMs: mountpointsTtlMs(),\n        f: async dir => {\n          // df doesn't return the correct mountpoint, at least on Ubuntu:\n\n          // $ df -kP '/run/user/1000/gvfs/smb-share:server=mini.local,share=shared%20folder'\n          // Filesystem     1024-blocks     Used Available Capacity Mounted on\n          // gvfsd-fuse       195296444 67824088 127472356      35% /run/user/1000/gvfs\n\n          const vols = await dfPosixRaw({\n            paths: [dir.nativePath]\n          })\n\n          const vol = vols?.[0]\n\n          if (vol == null || !dir.nativePath.startsWith(vol.mountpoint)) {\n            logger().warn(\"df failed to find \" + dir, { vols })\n            return\n          }\n          // fix the mountpoint to be the correct full path:\n          vol.mountpoint = dir.nativePath\n          const remoteInfo = await getRemoteInfo(vol.mountpoint)\n          return remoteInfo == null\n            ? vol\n            : { remote: true, ...vol, ...remoteInfo }\n        }\n      })\n    },\n    mountpointsTtlMs(),\n    () =>\n      logger().warn(\"gioVolumes(): timed out after \" + mountpointsTtlMs + \"ms\"),\n    result =>\n      logger().log(isEmpty(result) ? \"debug\" : \"info\", \"gioVolumes()\", {\n        result\n      })\n  )\n)\n\nlater(() => setupVolumeTTL(gioVolumes))\n\nconst getRemoteInfo = memoizeAsync(\n  async (mountpoint: string) => {\n    try {\n      const lines = (\n        await stdout_(GioCommand, [\"info\", mountpoint], {\n          timeoutMs: commandTimeoutMs()\n        })\n      ).split(/[\\r\\n]+/)\n      const uri = mapNotBlank(\n        lines.find(ea => ea.startsWith(\"uri: \")),\n        ea => new URL(stripPrefix(ea, \"uri: \"))\n      )\n      return {\n        displayName: map(\n          lines.find(ea => ea.startsWith(\"display name: \")),\n          ea => stripPrefix(ea, \"display name: \")\n        ),\n        remoteHost: map(uri, ea => ea.hostname),\n        remoteShare: opt(uri)\n          .flatMap(ea => ea.pathname)\n          .flatMap(ea => stripPrefix(ea, \"/\"))\n          .flatMap(ea => stripSuffix(ea, \"/\"))\n          .flatMap(decodeURIComponent)\n          .filter(notBlank)\n          .get()\n      }\n    } catch (err) {\n      logger().warn(\"getRemoteInfo(): info failed\", { mountpoint, err })\n      return\n    }\n  },\n  {\n    name: \"gio.getRemoteInfo\",\n    maxSize: 255,\n    timeoutMs: ShortCommandTimeoutMs,\n    clearEveryMs: 10 * minuteMs\n  }\n)\n\n// $ grep gvfs /etc/mtab\n// gvfsd-fuse /run/user/1000/gvfs fuse.gvfsd-fuse rw,nosuid,nodev,relatime,user_id=1000,group_id=1000 0 0\n\nasync function gvfsFuseDirectories(): Promise<BaseFile[]> {\n  if (!(await isGioSupported())) {\n    return logger().tap({\n      msg: \"gvfsFuseDirectories(): gio is not supported\",\n      result: []\n    })\n  }\n\n  return logger().tap({\n    msg: \"gvfsFuseDirectories()\",\n    result: await thenFlatten(\n      await thenMap(\n        readProcMounts(\n          undefined,\n          fs => fs === \"gvfsd-fuse\",\n          isReadableDirectory // we want all readable gvfsd-fuse mountpoints\n        ),\n        arr => arr.map(ea => BaseFile.for(ea).clear().childDirectories())\n      )\n    )\n  })\n}\n","import { lazy, MemoizedThunk } from \"../../core/Lazy\"\nimport { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { later } from \"../../fe/Delay\"\nimport { Later } from \"../../fe/Later\"\nimport { time } from \"../async/PromiseTimer\"\nimport { isIgnorableError, isRetriableError } from \"../error/ErrorTypes\"\nimport { ee } from \"../event/EventEmitter\"\nimport { Settings } from \"../settings/Settings\"\nimport { mountpoints } from \"./Mountpoints\"\nimport { commandTimeoutMs } from \"./VolumeTtls\"\n\n/**\n * lazy-ify `l` with retries\n */\nexport function lazyFsAsync<T>(\n  name: string,\n  l: Later<T>,\n  ttlMs?: number\n): MemoizedThunk<Promise<T>> {\n  const result = lazy(\n    () =>\n      time(\"volumes.\" + name, () =>\n        retryOnReject(l, {\n          maxRetries: 2,\n          timeoutMs: commandTimeoutMs(),\n          errorIsRetriable: err =>\n            isRetriableError(err) !== false && isIgnorableError(err) !== false\n        })\n      ),\n    ttlMs\n  )\n  later(() => {\n    mountpoints.watchLater(() => result.unset())\n    ee().on(\"clearCache\", () => result.unset())\n    if (ttlMs == null) setupVolumeTTL(result)\n  })\n  return result\n}\n\nexport function setupVolumeTTL<T>(l: MemoizedThunk<T>) {\n  l.setTTL(Settings.volumeMetadataTtlMs.valueOrDefault)\n  Settings.volumeMetadataTtlMs.watchLater(ea => l.setTTL(ea))\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { uniq } from \"../../fe/Array\"\nimport { blank, toNotBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gte, toInt } from \"../../fe/Number\"\nimport { mkLogger } from \"../Logger\"\nimport { assignMissingPrimitives } from \"../Object\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { sortIgnoreCase } from \"../String\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { parseEnvTokens } from \"../env/EnvTokens\"\nimport { splitLines } from \"../fs/CRLF\"\nimport { isDirectorySync } from \"../fs/StatSync\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { dfPosixRaw } from \"./DfPosixRaw\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\nimport { DfVolume, Volume } from \"./Volume\"\nimport { commandTimeoutMs } from \"./VolumeTtls\"\n\n// this is LocalVolumes**Linux** because lsblk and blkid are both from the\n// util-linux package.\n\n/*\n * lsblk --json! I LOVE YOU but I can't have you\n$ lsblk --json --output mountpoint,uuid\n{\n   \"blockdevices\": [\n      {\"mountpoint\": \"/snap/vlc/190\", \"uuid\": null},\n      {\"mountpoint\": null, \"uuid\": null},\n      {\"mountpoint\": \"/home/archive\", \"uuid\": \"5bcd3874-036b-4c80-ad00-258d34f5a097\"},\n      {\"mountpoint\": null, \"uuid\": null},\n      {\"mountpoint\": \"/boot/efi\", \"uuid\": \"32BA-03AC\"},\n      {\"mountpoint\": \"/\", \"uuid\": \"45e94248-490a-4224-b067-3ea48bb062e5\"},\n      {\"mountpoint\": \"[SWAP]\", \"uuid\": \"f8fbf87c-3ba3-4618-b733-74dab6f67cf2\"},\n      {\"mountpoint\": \"/home\", \"uuid\": \"bf676327-0a04-42ff-8088-313fad5082f7\"}\n   ]\n}\n\nbecause --json is fairly new (requires 2.27+). SO SAD.\n\nThis works with debian jessie:\n\n$ lsblk -P --output mountpoint,uuid\nMOUNTPOINT=\"/snap/kde-frameworks-5/26\" UUID=\"\"\nMOUNTPOINT=\"/snap/spotify/16\" UUID=\"\"\nMOUNTPOINT=\"/snap/core/4650\" UUID=\"\"\nMOUNTPOINT=\"/snap/inkscape/4019\" UUID=\"\"\nMOUNTPOINT=\"/snap/spotify/13\" UUID=\"\"\nMOUNTPOINT=\"/snap/vlc/365\" UUID=\"\"\nMOUNTPOINT=\"/snap/core/4917\" UUID=\"\"\nMOUNTPOINT=\"/snap/ffmpeg/13\" UUID=\"\"\nMOUNTPOINT=\"/snap/core/4830\" UUID=\"\"\nMOUNTPOINT=\"/snap/vlc/190\" UUID=\"\"\nMOUNTPOINT=\"/snap/docker/179\" UUID=\"\"\nMOUNTPOINT=\"\" UUID=\"\"\nMOUNTPOINT=\"\" UUID=\"fRFzBv-zld2-4ZJR-zbYw-C3sX-K9pI-KjnP1v\"\nMOUNTPOINT=\"/\" LABEL=\"root\" UUID=\"a7713a75-f1d9-4aba-8cdf-028a9339faee\"\n\n */\n\nconst logger = lazy(() => mkLogger(\"volumes.LocalVolumesLinux\"))\n\nexport async function addLocalVolumeInfoLinux(vols: DfVolume[]) {\n  // this doesn't work on docker (UUID is always blank!)\n  if (isDocker()) return\n  const lsblk = await localVolumes_lsblk_().catch(error =>\n    logger().warn(\"lsblk failed\", { error })\n  )\n  const blkid = await localVolumes_blkid_().catch(error =>\n    logger().warn(\"blkid failed\", { error })\n  )\n  if (lsblk == null && blkid == null) return\n  const mountpoints = sortIgnoreCase(\n    uniq([\n      ...(lsblk ?? []).filter(ea => !ea.ignorable).map(ea => ea.mountpoint),\n      ...vols.map(ea => ea.mountpoint)\n    ])\n  )\n  const result: Volume[] = []\n  for (const mountpoint of mountpoints) {\n    const vol = vols.find(ea => ea.mountpoint === mountpoint)\n    const info = lsblk?.find(ea => ea.mountpoint === mountpoint)\n    const merged = { ...vol, ...info } as Volume\n    const uuid = blkid?.find(ea => ea.filesystem === merged.filesystem)\n    if (uuid != null) assignMissingPrimitives(merged, uuid)\n    if (merged.size == null || merged.available == null) {\n      // this may only be needed within Docker...\n      const df = (\n        await dfPosixRaw({ localsOnly: false, paths: [mountpoint] })\n      )?.[0]\n      logger().info(\"backfilling mountpoint\", { info, vol, df })\n      if (df != null) assignMissingPrimitives(merged, df)\n    }\n    result.push(merged)\n  }\n  return result\n}\n\nconst VersionRe = /lsblk from util-linux ([\\d.]+)$/i\n\nconst lsblkVersion = lazy(async () => {\n  const s = await stdout_(\"lsblk\", [\"--version\"], {\n    timeoutMs: ShortCommandTimeoutMs\n  })\n  return VersionRe.exec(s)?.[1]\n    ?.split(\".\")\n    .map(ea => toInt(ea))\n})\n\n// lsblk from ubuntu 18 (bionic), 2.31, doesn't know about fsused and fsavail.\nconst lsblkOutput = lazy(async () => {\n  const cols = [\"mountpoint\", \"label\", \"uuid\"]\n  const v = await lsblkVersion()\n  if (v != null && gte(v[0], 2) && gte(v[1], 34)) {\n    cols.push(\"fsused\", \"fsavail\")\n  }\n  return cols.join(\",\")\n})\n\nexport const localVolumes_lsblk_ = lazyFsAsync(\n  \"localVolumes_lsblk\",\n  async () => {\n    const sout = await stdout_(\n      \"lsblk\",\n      [\"-P\", \"-b\", \"--output\", await lsblkOutput()],\n      {\n        timeoutMs: commandTimeoutMs() // we may need to wait for spinning rust to spin up.\n      }\n    )\n    const result = splitLines(sout)\n      .map(input => parseEnvTokens({ input, lowerCaseKeys: true }))\n      .filter(ea => ea != null)\n      .map(ea => {\n        const ignorable =\n          blank(ea.mountpoint) ||\n          ea.mountpoint.startsWith(\"/snap/\") ||\n          ea.mountpoint === \"/boot\" ||\n          ea.mountpoint.startsWith(\"/boot/\") ||\n          !isDirectorySync(ea.mountpoint) // < docker can bind-mount files. Ignore those.\n\n        const used = toInt(ea.fsused)\n        const available = toInt(ea.fsavail)\n        return {\n          mountpoint: ea.mountpoint,\n          label: ea.label as Maybe<string>,\n          uuid: ea.uuid,\n          ignorable,\n          ...(used != null && available != null\n            ? { used, available, size: used + available }\n            : undefined),\n          // if we're docker, we don't know:\n          ...(!isDocker() ? { remote: false } : undefined)\n        }\n      })\n\n    return logger().tap({\n      msg: \"localVolumes_lsblk\",\n      level: LogLevels.trace,\n      result\n    })\n  },\n  0\n)\n\n/*\n\nfedora HAS TO BE DIFFERENT\n\n$ blkid -o export\n\nDEVNAME=/dev/nvme0n1p5\nUUID=97becbab-9977-45f2-9d8a-8176fda49860\nBLOCK_SIZE=4096\nTYPE=ext4\nPARTUUID=4ed70ef1-bfe5-4049-bec9-e0a73dc764d0\n\nDEVNAME=/dev/nvme0n1p3\nLABEL=Acer\nBLOCK_SIZE=512\nUUID=CC70EE7F70EE6F9E\nTYPE=ntfs\nPARTLABEL=Basic\\ data\\ partition\nPARTUUID=e6666cf5-03dc-440b-b6a0-acc3c909bb93\n\n*/\n\nexport const localVolumes_blkid_ = lazyFsAsync(\n  \"localVolumes_blkid\",\n  async () => {\n    const sout = await stdout_(\"blkid\", [\"-o\", \"export\"], {\n      timeoutMs: commandTimeoutMs() // we may need to wait for spinning rust to spin up.\n    })\n    // these are separated by multiple blank lines:\n    return (\n      sout\n        .split(/\\n{2,}/)\n        .map(input => parseEnvTokens({ input, lowerCaseKeys: false }))\n        // we're going to join on device-name AKA filesystem, so that needs to be a path:\n        .filter(ea => true === ea?.DEVNAME?.includes(\"/\"))\n        .map(ea => ({\n          filesystem: ea.DEVNAME,\n          label: toNotBlank(ea.PARTLABEL) ?? toNotBlank(ea.LABEL),\n          uuid: toNotBlank(ea.PARTUUID) ?? toNotBlank(ea.UUID)\n        }))\n    )\n  },\n  0\n)\n","import { parse } from \"plist\"\nimport { lazy } from \"../../core/Lazy\"\nimport { uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { mapOr } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { thenMap } from \"../../fe/Promise\"\nimport { toA } from \"../../fe/toA\"\nimport { mkLogger } from \"../Logger\"\nimport { mapAsyncSerial } from \"../async/Promise\"\nimport { thenOrTimeout } from \"../async/ThenOrTimeout\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { dfPosixRaw } from \"./DfPosixRaw\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\nimport { DfVolume, Volume } from \"./Volume\"\nimport { commandTimeoutMs } from \"./VolumeTtls\"\n\nconst logger = lazy(() => mkLogger(\"volumes.LocalVolumesMac\"))\n\nexport async function addLocalVolumeInfoMac(\n  vols: DfVolume[]\n): PromiseMaybe<Volume[]> {\n  return thenMap(mnt2uuidMac(), uuids =>\n    vols.map(vol =>\n      mapOr(\n        uuids.get(vol.mountpoint),\n        info => ({ ...vol, ...info }),\n        () => vol\n      )\n    )\n  )\n}\n\nexport const mnt2uuidMac = lazyFsAsync(\"mnt2uuidMac\", _mnt2uuidMac, 0)\n\nconst diskRE = /^(\\/dev\\/disk\\d+)/\n\nasync function _mnt2uuidMac() {\n  const l = await dfPosixRaw({ localsOnly: true })\n  const diskDevices = uniq(l.map(ea => ea.filesystem?.match(diskRE)?.[1]))\n  const timeoutMs = Math.round(commandTimeoutMs() / 3)\n\n  const stdouts = await mapAsyncSerial({\n    name: \"_mnt2uuidMac()\",\n    arr: diskDevices,\n    f: async dev =>\n      thenOrTimeout(\n        stdout_(\"diskutil\", [\"list\", \"-plist\", dev], {\n          timeoutMs\n        }),\n        timeoutMs,\n        () => logger().warn(\"Timeout: failed to get disk metadata for \" + dev)\n      )\n  })\n\n  const result = new Map<string, Partial<Volume>>()\n\n  for (const out of stdouts) {\n    try {\n      const p = parse(out) as any\n      for (const vols of toA(p.AllDisksAndPartitions)) {\n        for (const vol of toA(vols.APFSVolumes)) {\n          if (!blank(vol.MountPoint) && !isTrue(vol.OSInternal)) {\n            result.set(vol.MountPoint, {\n              filesystem: \"/dev/\" + vol.DeviceIdentifier,\n              label: vol.VolumeName,\n              size: vol.Size,\n              uuid: vol.VolumeUUID\n            })\n          } else {\n            logger().debug(\"skipping\", vol)\n          }\n        }\n      }\n    } catch (err) {\n      logger().warn(\"Failed to parse diskutil output\", { err, out })\n    }\n  }\n  return result\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { isEmpty, isNotEmpty } from \"../../fe/Array\"\nimport { sort } from \"../../fe/ArraySort\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { rateLimited } from \"../RateLimited\"\nimport { isSyncService } from \"../ServiceNames\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { includesIgnoreCase } from \"../String\"\nimport { end } from \"../async/Endable\"\nimport { awaitAll, filterAsync } from \"../async/Promise\"\nimport { time } from \"../async/PromiseTimer\"\nimport { stdoutResult_ } from \"../child/ChildProcess\"\nimport { mkBasicWatchedChild } from \"../child/WatchedChild\"\nimport { onError } from \"../error/OnError\"\nimport { broadcastEvent_ } from \"../event/BroadcastEvent\"\nimport { ee } from \"../event/EventEmitter\"\nimport { SimpleFileOrString, toNativePath_ } from \"../fs/SimpleFile\"\nimport { isReadableDirectory } from \"../fs/Stat\"\nimport { isLinux, isMac, isWin } from \"../platform/Platform\"\nimport { Settings } from \"../settings/Settings\"\nimport { mightBeAssetMountpoint } from \"./AssetMountpoint\"\nimport {\n  GioCommand,\n  GioMountMonitorArgs,\n  gioVolumes,\n  isGioSupported\n} from \"./Gio\"\nimport { maybeWatchProcMounts, mountpointsPosix } from \"./MountpointsPosix\"\nimport { mountpointsWin } from \"./MountpointsWin\"\nimport { isExcludedMountpoint } from \"./PosixVolumes\"\nimport {\n  commandTimeoutMs,\n  mountpointsTtlMs,\n  volumeMetadataTtlMs\n} from \"./VolumeTtls\"\n\nconst logger = lazy(() => mkLogger(\"volumes.Mountpoints\"))\n\nfunction unsetMountpoints() {\n  mountpoints.unset()\n  mountpoints_.unset()\n}\n\nfunction setMountpointsTTL(ttl: number = mountpointsTtlMs()) {\n  mountpoints.setTTL(ttl)\n  mountpoints_.setTTL(ttl)\n}\n\nexport const localMountpointSetup = lazy(async () => {\n  // These may be excluded paths:\n  Settings.libraryDir.watchLater(unsetMountpoints)\n  Settings.scanPaths.watchLater(unsetMountpoints)\n\n  // Only do mountpoint monitoring by sync (which cares)\n  if (isSyncService()) {\n    later(async () => {\n      const log = mkLogger(\"Mountpoints.localMountpointSetup()\")\n      if (isMac) {\n        log.info(\"Setting up Mac diskutil activity watcher\")\n        setMountpointsTTL(volumeMetadataTtlMs())\n        diskUtilActivity()\n      }\n      if (isLinux) {\n        await maybeWatchProcMounts()\n        if (await isGioSupported()) {\n          log.info(\"Setting up Linux gio mount monitor\")\n          setMountpointsTTL(volumeMetadataTtlMs())\n          gioMountMonitor()\n        }\n        if (await isFindmntSupported()) {\n          log.info(\"Setting up Linux findmnt mount monitor\")\n          setMountpointsTTL(volumeMetadataTtlMs())\n          findmntPoll()\n        }\n      }\n    }, 30 * secondMs) // let startup go faster. Mountpoint monitoring can wait.\n  } else {\n    await awaitAll([\n      end(diskUtilActivity.clear()),\n      end(gioMountMonitor.clear()),\n      end(findmntPoll.clear())\n    ])\n  }\n})\n\nasync function onMountpointsChanged() {\n  unsetMountpoints()\n  if (isSyncService()) {\n    await broadcastEvent_(\"mountpointsChanged\")\n  }\n}\n\n// Stores the last successful mountpoints() call. No TTL needed.\nconst priorMountpoints = lazy<Maybe<string[]>>(() => undefined)\n\nfunction mountpointsImpl() {\n  return time(\"volumes.Mountpoints\", isWin ? mountpointsWin : mountpointsPosix)\n}\n\nexport const mountpoints_ = lazy(async () => {\n  {\n    const arr = Settings.mountpoints.values\n    if (isNotEmpty(arr)) {\n      return arr\n    }\n  }\n  const arr = await thenOrTimeoutError(mountpointsImpl(), ShortCommandTimeoutMs)\n  if (isEmpty(arr)) {\n    return logger().throw(\"mountpointsImpl() returned empty.\", { fatal: false })\n  } else {\n    const result = sort(\n      await filterAsync({\n        arr,\n        name: \"mountpointFilter\",\n        timeoutMs: commandTimeoutMs(),\n        f: async ea => {\n          if (!mightBeAssetMountpoint(ea) && isExcludedMountpoint(ea))\n            return false\n          if (Settings.validateMountpoints.valueOrDefault) {\n            if (!(await isReadableDirectory(ea))) {\n              logger().warn(`mountpoint ${ea} is not readable`)\n              return false\n            }\n          }\n          return true\n        }\n      })\n    )\n    priorMountpoints.set(result)\n    return result\n  }\n})\n\nexport const mountpoints = lazy(async () => {\n  try {\n    return await mountpoints_()\n  } catch (cause) {\n    onError(\"mountpoints() failed\", { cause })\n    return priorMountpoints()\n  }\n})\n\nexport async function isPosixMountpoint(\n  d: SimpleFileOrString\n): Promise<boolean> {\n  if (isWin) return false\n  const arr = (await mountpoints()) ?? []\n  const np = toNativePath_(d)\n  return isMac // case insensitive, YAY\n    ? includesIgnoreCase(arr, np)\n    : arr.includes(np)\n}\n\n// we don't delete the priorMountpoints because that's a safety backstop\nlater(\n  () => {\n    ee().on(\"clearCache\", () => {\n      gioVolumes.unset()\n      unsetMountpoints()\n    })\n    Settings.mountpointsTtlMs.watch(setMountpointsTTL)\n  },\n  isTest ? 1 : minuteMs // < wait until settings have been read\n)\n\n/**\n * Provides near-real-time updates when volumes change on macs:\n */\nexport const diskUtilActivity = lazy(() =>\n  mkBasicWatchedChild({\n    cmd: \"diskutil\",\n    args: [\"activity\"],\n    onStdout: rateLimited({\n      name: \"diskUtilActivity\",\n      f: () => onMountpointsChanged(),\n      minCallDelayMs: 1.5 * secondMs\n    })\n  })\n)\n\nexport const gioMountMonitor = lazy(() =>\n  mkBasicWatchedChild({\n    cmd: GioCommand,\n    args: GioMountMonitorArgs,\n    onStdout: rateLimited({\n      name: \"gioMountMonitor\",\n      f: () => {\n        gioVolumes.unset()\n        return onMountpointsChanged()\n      },\n      minCallDelayMs: ShortCommandTimeoutMs\n    })\n  })\n)\n\nconst isFindmntSupported = lazy(async () => {\n  if (!isLinux) return false\n  try {\n    const result = await stdoutResult_(\"findmnt\", [\"--version\"], {\n      timeoutMs: commandTimeoutMs(),\n      ignoreStderr: true\n    })\n    return result.code === 0\n  } catch (err) {\n    return false\n  }\n})\n\nexport const findmntPoll = lazy(() =>\n  mkBasicWatchedChild({\n    cmd: \"findmnt\",\n    args: [\"--poll\"],\n    onStdout: rateLimited({\n      name: \"findmntPoll\",\n      f: () => onMountpointsChanged(),\n      minCallDelayMs: ShortCommandTimeoutMs\n    })\n  })\n)\n","import { lazy } from \"../../core/Lazy\"\nimport { compact } from \"../../fe/Array\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { allNotBlank } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { isSyncService } from \"../ServiceNames\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { unoctal } from \"../String\"\nimport { filterAsync, thenMap } from \"../async/Promise\"\nimport { FsWatcher } from \"../fs/FsWatcher\"\nimport { readLines_ } from \"../fs/ReadLines\"\nimport { isEmptyFile, isReadableDirectory } from \"../fs/Stat\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { isLinux } from \"../platform/Platform\"\nimport { Settings } from \"../settings/Settings\"\nimport { dfPosixRaw } from \"./DfPosixRaw\"\nimport { gioVolumes, isGioSupported } from \"./Gio\"\nimport { mountpoints } from \"./Mountpoints\"\nimport { isExcludedMountpoint } from \"./PosixVolumes\"\n\nconst logger = lazy(() => mkLogger(\"volumes.MountpointsPosix\"))\n\nexport async function mountpointsPosix() {\n  const result =\n    (await readProcMounts()) ??\n    (await thenMap(dfPosixRaw({ localsOnly: false }), vols =>\n      vols.map(vol => vol.mountpoint)\n    ))\n  if (result != null && (await isGioSupported())) {\n    try {\n      await thenMap(gioVolumes(), gioVols =>\n        result.push(...gioVols.map(ea => ea.mountpoint))\n      )\n    } catch (err) {\n      // may fail due to timeouts. It's better to have *some* volumes than crash:\n      logger().warn(\"Failed to fetch gio volumes\", err)\n    }\n  }\n  // HEY FUTURE ME: mountpoints() does filtering for us.\n  return result\n}\n\nconst ProcMounts = \"/proc/mounts\"\n\nexport function defaultFilesystemTypePredicate(fsType: string) {\n  return !Settings.excludedFilesystemTypes.has(fsType)\n}\n\nfunction defaultMountpointPredicate(mountpoint: string): SyncOrAsync<boolean> {\n  return (\n    !isExcludedMountpoint(mountpoint) &&\n    (Settings.validateMountpoints.valueOrDefault\n      ? isReadableDirectory(mountpoint)\n      : true)\n  )\n}\n\nexport async function readProcMounts(\n  procMounts = ProcMounts,\n  filesystemTypePredicate = defaultFilesystemTypePredicate,\n  mountpointPredicate = defaultMountpointPredicate\n): PromiseMaybe<string[]> {\n  if (!isLinux) return\n  try {\n    const lines = await readLines_(procMounts)\n    const tokens = compact(\n      lines.map(line => {\n        // this whitespace split is safe because linux will escape whitespace with octals:\n        const [fs, mp] = line.split(/\\s+/)\n        return allNotBlank(fs, mp)\n          ? ([fs, unoctal(mp)] as [string, string])\n          : undefined\n      })\n    )\n    const result = await filterAsync({\n      name: \"mountpoints filter\",\n      arr: tokens,\n      f: async ([fs, mp]) => {\n        const fsOK = filesystemTypePredicate(fs)\n        const mpOK = await mountpointPredicate(mp)\n        return logger().tap({\n          level: LogLevels.trace,\n          msg: \"readProcMounts().predicate filters\",\n          result: fsOK && mpOK,\n          meta: { fs, mp, fsOK, mpOK }\n        })\n      }\n    })\n\n    return logger().tap({\n      msg: \"readProcMounts()\",\n      result: result.map(([, ea]) => ea),\n      meta: {\n        procMounts\n      }\n    })\n  } catch (error) {\n    logger().info(\"Failed to read /proc/mount\", error)\n    return\n  }\n}\n\nexport const maybeWatchProcMounts = lazy(async () =>\n  !isLinux || !isSyncService() || (await isEmptyFile(ProcMounts))\n    ? undefined\n    : new FsWatcher({\n        target: ProcMounts,\n        maxPollIntervalMs: minuteMs,\n        onChange: () => {\n          logger().info(\"detected change in \" + ProcMounts)\n          mountpoints.unset()\n        },\n        initialDelayMs: ShortCommandTimeoutMs,\n        sha: true\n      })\n)\n","import { lazy } from \"../../core/Lazy\"\nimport { secondMs } from \"../../fe/Date\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { mkLogger } from \"../Logger\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { sortIgnoreCase } from \"../String\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { fsutil } from \"../fs/PathTo\"\nimport { PowerShell } from \"../pwsh/PowerShell\"\n\nconst logger = lazy(() => mkLogger(\"volumes.MountpointsWin\"))\n\n// we really do want to lazy() this: it's used both by mountpoints() and dfWin()\nexport const mountpointsWin = lazy(async () => {\n  try {\n    // powershell should be easier on the system, as it doesn't involve a fork\n    return await thenOrTimeoutError(mountpointsWinPwsh(), ShortCommandTimeoutMs)\n  } catch (error) {\n    logger().warn(\"mountpointsWinPwsh()\", { error })\n    return mountpointsWinFsutil()\n  }\n})\n\nexport async function mountpointsWinPwsh() {\n  // Note that Get-PSDrive can be quite slow if you don't specificy just the\n  // Root -Property, but seems to be quick (~10ms) when asking just for Root.\n  const arr = await PowerShell.instance().executeJsonToA(\n    \"Get-PSDrive -PSProvider FileSystem | Select-Object -Property Root\"\n  )\n  // [{\"Root\":\"C:\\\\\"},{\"Root\":\"D:\\\\\"},{\"Root\":\"Q:\\\\\"},{\"Root\":\"R:\\\\\"}]\n  return arr == null\n    ? undefined\n    : sortIgnoreCase(arr.map(ea => ea.Root as string))\n}\n\nconst driveletterRe = /\\s([A-Z]:\\\\)/g\n\n/**\n * fsutil-based list of all currently active drive letters\n *\n * @return [\"C:\\\", \"D:\\\", ...]\n */\nexport async function mountpointsWinFsutil() {\n  // Note that `fsutil fsinfo drives` seems to be about an order of magnitude\n  // faster than ` wmic logicaldisk get caption`.\n\n  // Example output: Drives: C:\\ H:\\ I:\\\"\"\n  const sout = await stdout_(fsutil(), [\"fsinfo\", \"drives\"], {\n    timeoutMs: 10 * secondMs\n  })\n  const result: string[] = []\n  let match: RegExpExecArray | null\n  while ((match = driveletterRe.exec(sout)) !== null) {\n    result.push(match[1])\n  }\n  return sortIgnoreCase(result)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { mkLogger } from \"../Logger\"\nimport { memoize } from \"../MemoizedFunc\"\nimport { isTest } from \"../NodeEnv\"\nimport { toPathnames } from \"../fs/Path\"\nimport { isLinux, isPosix, isWin } from \"../platform/Platform\"\nimport { Settings } from \"../settings/Settings\"\n\nconst logger = lazy(() => mkLogger(\"volumes.PosixVolumes\"))\n\n// https://www.pathname.com/fhs/pub/fhs-2.3.html\n\n// NOTE: DO NOT EXCLUDE \"/dev/mapper/ubuntu--vg-root\", that may be the root (and\n// only!) filesystem\n\n// rootfs             8064632   738996    7325636      10% /\n// devtmpfs           8064644        0    8064644       0% /dev\n// tmpfs              8139340        0    8139340       0% /dev/shm\n// cgroup_root           8192        0       8192       0% /sys/fs/cgroup\n// tmpfs               131072      236     130836       1% /var/log\n// /dev/sda1         15000224   257824   14742400       2% /boot\n// overlay            8064632   738996    7325636      10% /lib/modules\n// overlay            8064632   738996    7325636      10% /lib/firmware\n// tmpfs                 1024        0       1024       0% /mnt/disks\n// tmpfs                 1024        0       1024       0% /mnt/remotes\n// /dev/md1        9764349900 68111704 9696238196       1% /mnt/disk1\n// /dev/sdc1        244197560 22023600  222164096      10% /mnt/cache\n// shfs            9764349900 68111704 9696238196       1% /mnt/user0\n// shfs            9764349900 68111704 9696238196       1% /mnt/user\n// /dev/loop2        20971520     3960   20429576       1% /var/lib/docker\n// /dev/loop3         1048576     3852     926164       1% /etc/libvirt\n\n// Filesystem              1024-blocks       Used  Available Capacity Mounted on\n// udev                       32857360          0   32857360       0% /dev\n// tmpfs                       6584180       4908    6579272       1% /run\n// /dev/nvme0n1p2            479152840  321307948  133435500      71% /\n// tmpfs                      32920884     212868   32708016       1% /dev/shm\n// tmpfs                          5120          4       5116       1% /run/lock\n// tmpfs                      32920884          0   32920884       0% /sys/fs/cgroup\n// /dev/loop1                    56832      56832          0     100% /snap/core18/2066\n// /dev/loop2                    56832      56832          0     100% /snap/core18/2074\n// /dev/loop3                   101760     101760          0     100% /snap/core/11316\n// /dev/loop4                    66688      66688          0     100% /snap/gtk-common-themes/1515\n// /dev/nvme1n1              960381672  786958628  124568532      87% /mnt/c24fdf53-fc92-43ae-a1a5-9342d067b4a5\n// /dev/loop5                    52352      52352          0     100% /snap/snap-store/518\n// /dev/loop0                   101760     101760          0     100% /snap/core/11187\n// /dev/loop6                    66432      66432          0     100% /snap/gtk-common-themes/1514\n// /dev/loop8                   166784     166784          0     100% /snap/gnome-3-28-1804/145\n// /dev/loop9                   183936     183936          0     100% /snap/spotify/46\n// /dev/loop10                  259200     259200          0     100% /snap/dbeaver-ce/136\n// /dev/loop11                  224256     224256          0     100% /snap/gnome-3-34-1804/72\n// /dev/loop12                   89344      89344          0     100% /snap/sqlitebrowser/3233\n// /dev/loop13                   33152      33152          0     100% /snap/snapd/12159\n// /dev/loop14                   52224      52224          0     100% /snap/snap-store/547\n// /dev/loop15                  224256     224256          0     100% /snap/gnome-3-34-1804/66\n// /dev/loop16                  183808     183808          0     100% /snap/spotify/45\n// /dev/loop17                   33152      33152          0     100% /snap/snapd/12398\n// /dev/nvme0n1p1               523248       8036     515212       2% /boot/efi\n// 10.1.1.9:/volume1/homes  7496824320 4121892736 3374931584      55% /rusty2-homes-nfs\n// //10.1.1.9/homes         7496824260 4121892788 3374931472      55% /media/mrm/rusty2-home\n// //10.1.1.7/homes         5809423160 4979412148  830011012      86% /media/mrm/rusty-home\n// tmpfs                       6584176          8    6584168       1% /run/user/1002\n// tmpfs                       6584176         20    6584156       1% /run/user/125\n// tmpfs                       6584176       1528    6582648       1% /run/user/1000\n// /dev/loop18                  168832     168832          0     100% /snap/gnome-3-28-1804/161\n// /dev/loop19                  259200     259200          0     100% /snap/dbeaver-ce/137\n\nexport function isExcludedFilesystem(filesystem: string) {\n  if (blank(filesystem)) return false\n  return isPosix && Settings.excludedFilesystemTypes.values.includes(filesystem)\n}\n\nconst LinuxDevMapperRE =\n  isLinux || isTest ? /^\\/dev(?!\\/mapper)(?:\\/|\\/?$)/i : undefined\n\nconst LinuxVarSnapRE = isLinux || isTest ? /^\\/var\\/snap(?:$|\\/)/ : undefined\n\nconst LinuxRunUserGVFSRE =\n  isLinux || isTest ? /^\\/run\\/user\\/\\d+\\/gvfs\\/.+$/i : undefined\n\nconst LinuxDockerRE = isLinux || isTest ? /^\\/var\\/lib\\// : undefined\n\n// Avoid stuff like\n\n// mrm@m1 % mount | grep /System\n// /dev/disk3s6 on /System/Volumes/VM (apfs, local, noexec, journaled, noatime, nobrowse)\n// /dev/disk3s2 on /System/Volumes/Preboot (apfs, local, journaled, nobrowse)\n// /dev/disk3s4 on /System/Volumes/Update (apfs, local, journaled, nobrowse)\n// /dev/disk1s2 on /System/Volumes/xarts (apfs, local, noexec, journaled, noatime, nobrowse)\n// /dev/disk1s1 on /System/Volumes/iSCPreboot (apfs, local, journaled, nobrowse)\n// /dev/disk1s3 on /System/Volumes/Hardware (apfs, local, journaled, nobrowse)\n// /dev/disk3s1 on /System/Volumes/Data (apfs, local, journaled, nobrowse, protect)\n// map auto_home on /System/Volumes/Data/home (autofs, automounted, nobrowse)\n\n// mrm@mini ~ % mount | grep System\n// /dev/disk6s4 on /System/Volumes/VM (apfs, local, noexec, journaled, noatime, nobrowse)\n// /dev/disk6s2 on /System/Volumes/Preboot (apfs, local, journaled, nobrowse)\n// /dev/disk6s6 on /System/Volumes/Update (apfs, local, journaled, nobrowse)\n// /dev/disk6s1 on /System/Volumes/Data (apfs, local, journaled, nobrowse)\n// map auto_home on /System/Volumes/Data/home (autofs, automounted, nobrowse)\n\n// DO NOT AVOID \"/System/Volumes/Data\": that's where people's home dir is!\n\n// (memoized mostly to avoid all the duplicate log messages)\nexport const isExcludedMountpoint = memoize(\n  (mountpoint: Maybe<string>) => {\n    if (isWin) return false // no excluded drive letters\n    const why = whyExcludedMountpoint(mountpoint)\n    return logger().tap({\n      msg: \"isExcludedMountpoint\",\n      result: why != null,\n      meta: { mountpoint, why }\n    })\n  },\n  { maxSize: 512 }\n)\n\nexport function whyExcludedMountpoint(\n  mountpoint: Maybe<string>\n): Maybe<string> {\n  if (blank(mountpoint)) {\n    return \"blank\"\n  }\n  const arr = toPathnames(mountpoint)\n  const root = arr[0]\n  const basename = arr[arr.length - 1]\n  if (Settings.excludedRootDirectories.has(root)) {\n    return \"ExcludedRootDirectory\"\n  }\n  if (Settings.excludedMountpointPaths.has(mountpoint)) {\n    return \"excludedMountpointPaths\"\n  }\n  if (Settings.excludedMountpointBasenames.has(basename)) {\n    return \"excludedMountpointBasenames\"\n  }\n  if (LinuxDevMapperRE?.test(mountpoint) === true) {\n    return \"LinuxDevMapperRE\"\n  }\n  if (LinuxVarSnapRE?.test(mountpoint) === true) {\n    return \"LinuxVarSnapRE\"\n  }\n  if (root === \"run\" && LinuxRunUserGVFSRE?.test(mountpoint) === false) {\n    return \"LinuxRunRE\"\n  }\n  if (LinuxDockerRE?.test(mountpoint) === true) {\n    return \"LinuxDockerRE\"\n  }\n  return\n}\n","import { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { RemoteVolume, Volume } from \"./Volume\"\n\n/* \n\non mac el capitan for SMB/CIFS:\n\n//mrm@rusty2._afpovertcp._tcp.local/home  7496824260 4120551220 3376273040    55%    /Volumes/home\n//GUEST:@unraid._smb._tcp.local/system    9764349900   68111664 9696238236     1%    /Volumes/system\n\n//mrm@rusty._smb._tcp.local/homes ...\n//mrm@rusty.local/photos ...\n//mrm@rusty/web ...\n\non ubuntu 18:\n\n//10.1.1.7/homes ...\n\nWith NFS:\n\n10.1.1.9:/volume1/homes\n\n192.168.1.10:/opt/Media ...\n\n*/\n\nconst smbRe = /\\/\\/(?<user>.+@)?(?<remoteHost>[^/@]+)\\/(?<remoteShare>.+)/\n\nconst smbHostnameTrimmerRe = /(?:\\._(?:smb|afs|nfs|tcp|afpovertcp))+/i\n\n// should also handle sshfs:\nexport const nfsRe = /^([^:\\s]+):(\\/.*)$/\n\nexport function addRemoteVolumeInfoPosix(volumes: Volume[]): Volume[] {\n  for (const vol of volumes) {\n    if (vol.remote === true) {\n      const result = parseRemote(vol.filesystem)\n      if (result != null) {\n        vol.remoteHost = result.remoteHost\n        vol.remoteShare = result.remoteShare\n      }\n    }\n  }\n  return volumes\n}\n\nexport function parseRemote(filesystem: Maybe<string>): Maybe<RemoteVolume> {\n  if (blank(filesystem)) return\n  const smb = smbRe.exec(filesystem)?.groups\n  if (smb != null && !blank(smb.remoteHost) && !blank(smb.remoteShare)) {\n    return {\n      remoteHost: smb.remoteHost.replace(smbHostnameTrimmerRe, \"\"),\n      remoteShare: smb.remoteShare\n    }\n  }\n  const nfs = nfsRe.exec(filesystem)\n  if (nfs != null) {\n    const remoteHost = nfs[1]\n    const remoteShare = nfs[2]\n    if (!blank(remoteHost) && !blank(remoteShare)) {\n      return {\n        remoteHost,\n        remoteShare\n      }\n    }\n  }\n  return\n}\n","import { compact } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { opt } from \"../../fe/Opt\"\nimport { toS } from \"../../fe/toS\"\nimport { thenMap } from \"../async/Promise\"\nimport { stdout_ } from \"../child/ChildProcess\"\nimport { parseFixed } from \"../Fixed\"\nimport { wmic } from \"../fs/PathTo\"\nimport { toMap } from \"../Map\"\nimport { Try } from \"../Object\"\nimport { isWin } from \"../platform/Platform\"\nimport { PowerShell } from \"../pwsh/PowerShell\"\nimport { ensureSuffix } from \"../String\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\nimport { Volume } from \"./Volume\"\n\n/*\n$ wmic netuse get LocalName, RemoteName, COnnectionState, Status\nConnectionState  LocalName  RemoteName        Status\nConnected        H:         \\\\10.1.1.7\\homes  OK\nDisconnected     I:         \\\\10.1.1.3\\mrm    Unavailable\n*/\n\nexport async function addRemoteVolumeInfoWin(\n  volumes: Volume[],\n  netInfos?: NetInfo[]\n): Promise<Volume[]> {\n  if (!isWin) throw new Error(\"wtf\")\n  await thenMap(\n    orElse<NetInfo[] | PromiseMaybe<NetInfo[]>>(netInfos, () => netInfoWin()),\n    arr => {\n      const m = toMap(arr, ea => [ea.mountpoint, ea])\n      volumes.forEach(vol => {\n        map(m.get(vol.mountpoint), netInfo => {\n          vol.remote = true\n          vol.remoteHost = netInfo.host\n          vol.remoteShare = netInfo.share\n          vol.ok = netInfo.ok\n        })\n      })\n    }\n  )\n  return volumes\n}\n\nconst columns = [\"LocalName\", \"RemoteName\", \"Status\"]\nconst netuseCmd = [\"NETUSE\", \"get\", columns.join(\",\")]\n\nexport interface NetInfo {\n  /** \"H:\\\" */\n  mountpoint: string\n  /** probably the IP address of the remote share */\n  host: string\n  /** the name of the share */\n  share: string\n  /** true if the Status of the share is \"OK\" */\n  ok: boolean\n}\n\nconst UNC_RE = /^\\\\\\\\([^\\\\]+)\\\\(.+)$/\nconst driveLetterRE = /^[a-z]:\\\\?$/i\n\nexport const NetInfoCmd = `Get-WmiObject Win32_NetworkConnection | Select-Object -Property LocalName,RemoteName,ConnectionState,Status`\n\nasync function _netInfoWin(): Promise<NetInfo[]> {\n  const result = await PowerShell.instance().executeJsonToA(NetInfoCmd)\n  return result == null\n    ? _netInfoWinWmic()\n    : compact(\n        result\n          .filter((ea: any) => notBlank(ea.LocalName)) // can't do anything if we don't have a localname.\n          .map((ea: any) =>\n            map(parseRemoteName(ea.RemoteName), ({ host, share }) =>\n              map(driveLetterRE.exec(toS(ea.LocalName)), driveLetter => ({\n                mountpoint: ensureSuffix(driveLetter[0], \"\\\\\"),\n                host,\n                share,\n                ok: ea.Status === \"OK\" && ea.ConnectionState === \"Connected\"\n              }))\n            )\n          )\n      )\n}\n\nexport function parseRemoteName(\n  remoteName: string\n): Maybe<{ host: string; share: string }> {\n  if (blank(remoteName)) return\n\n  return opt(remoteName)\n    .flatMap(ea => UNC_RE.exec(ea))\n    .map(ea => ({\n      host: ea[1],\n      share: ea[2]\n    }))\n    .orElse(() =>\n      opt(remoteName)\n        .flatMap(url => Try(() => new URL(url)))\n        .filter(url => notBlank(url.hostname))\n        .map(url => ({\n          host: url.hostname,\n          share: opt(url.pathname)\n            .filter(notBlank)\n            .getOrElse(() => \"/\")\n        }))\n    )\n    .get()\n}\n\nexport async function _netInfoWinWmic(): Promise<NetInfo[]> {\n  const cmd = wmic()\n  const sout = await stdout_(cmd, netuseCmd, { timeoutMs: 15 * secondMs })\n  const parsed = parseFixed(columns, sout)\n  return compact(\n    parsed.map((ea: any) =>\n      map(UNC_RE.exec(toS(ea.RemoteName)), remoteName =>\n        map(driveLetterRE.exec(toS(ea.LocalName)), driveLetter => ({\n          mountpoint: ensureSuffix(driveLetter[0], \"\\\\\"),\n          host: remoteName[1],\n          share: remoteName[2],\n          ok: ea.Status === \"OK\"\n        }))\n      )\n    )\n  )\n}\n\nconst cacheForever = 0\nconst netInfoWin = lazyFsAsync(\"netInfoWin\", _netInfoWin, cacheForever)\n","import { secondMs } from \"../../fe/Date\"\nimport { MiB } from \"../../fe/Units\"\nimport { Settings } from \"../settings/Settings\"\n\n/**\n * This needs to be short enough to pick up when drives are inserted or\n * ejected in reasonable-ish time, but not so often it breaks the OS\n */\nexport function mountpointsTtlMs() {\n  return Settings.mountpointsTtlMs.valueOrDefault\n}\n\n/**\n * Update frequently enough to detect substantive changes in available bytes\n */\nexport function volumeMetadataTtlMs() {\n  return Settings.volumeMetadataTtlMs.valueOrDefault\n}\n\n// TODO: MOVE to .. (this isn't a volume-specific thing!)\n/**\n * How long the `df` or `wmic` should be allowed to run before timing out.\n * Note that external hard drives can take longer than 10 seconds to spin\n * up...\n */\nexport function commandTimeoutMs() {\n  return Settings.commandTimeoutMs.valueOrDefault\n}\n\n/**\n * The worst-expected transfer rate for file I/O:\n */\nexport const MinIoRate = MiB / secondMs\n","import { basename } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { isFalse, isTrue } from \"../../fe/Boolean\"\nimport { later } from \"../../fe/Delay\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { thenOrOnTimeout, thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { FifoCacheAsync } from \"../FifoCacheAsync\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { stripComments } from \"../String\"\nimport { withBoundedConcurrency } from \"../async/Promises\"\nimport { ee } from \"../event/EventEmitter\"\nimport { splitLines } from \"../fs/CRLF\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { Settings } from \"../settings/Settings\"\nimport { mountpoints } from \"./Mountpoints\"\nimport { Volume } from \"./Volume\"\nimport { commandTimeoutMs } from \"./VolumeTtls\"\nimport { writeVolumeUuid } from \"./WriteVolumeUuid\"\n\nconst logger = lazy(() => mkLogger(\"volumes.VolumeUUID\"))\n\n// This isn't a TTLMap because we don't expect to have bajillions of\n// mountpoints, they don't expire, and we force-clear it whenever mountpoints\n// change.\nconst cache = lazy(\n  () =>\n    new FifoCacheAsync<Maybe<string>>({\n      name: \"volumes.VolumeUUID\",\n      maxSize: 500,\n      timeoutMs: commandTimeoutMs()\n    })\n)\n\nlater(() => {\n  ee().on(\"clearCache\", () => cache.clear())\n  mountpoints.watchLater(() => cache.clear())\n})\n\nexport async function addVolumeUUIDs(vols: Volume[]): Promise<void> {\n  await withBoundedConcurrency({\n    name: \"addVolumeUUIDs\",\n    laters: vols.map(\n      ea => () =>\n        thenOrOnTimeout(addVolumeUUID(ea), commandTimeoutMs(), () =>\n          logger().warn(\"addVolumeUUIDs(\" + ea.mountpoint + \") timed out\", {\n            timeoutMs: commandTimeoutMs()\n          })\n        )\n    )\n  })\n}\n\nexport function volumeUuidNotExpected(v: Volume) {\n  return (\n    isTrue(v.ignorable) ||\n    (isDocker() && v.mountpoint === \"/\") ||\n    (isTest && basename(v.mountpoint) === \"node_modules\")\n  )\n}\n\n/**\n * Prefer the UUID stored on the mountpoint/.uuid.\n *\n * If that cannot be read, use the UUID already on the volume.\n *\n * If that is missing/timesout, use the last-set UUID for that volume, stored in\n * APP_DATA/mountpoint-uuids.json\n */\nasync function addVolumeUUID(v: Volume): Promise<void> {\n  if (volumeUuidNotExpected(v)) {\n    // Don't bother reading the .uuid.\n    return\n  }\n\n  if (isFalse(v.ok)) {\n    // We don't want to touch this filesystem, it may hang!\n    return\n  }\n\n  const uuid = await cache().getOrSetAsync(v.mountpoint, async () =>\n    readVolumeUUID(v)\n  )\n  if (uuid != null) v.uuid = uuid\n}\n\nexport function toVolumeUUID(s: Maybe<string>): Maybe<string> {\n  if (blank(s)) return\n  const clean = stripComments(s)\n    .replace(/[^\\da-z-]+/gi, \"\")\n    .trim()\n    .replace(/^-|-$/g, \"\")\n  // reject 000-00000-00000\n  return clean.length <= 8 || /^[0-]*$/.test(clean) || /^[F-]*$/i.test(clean)\n    ? undefined\n    : clean\n}\n\nexport async function readUuidFile_(file: PosixFile) {\n  const buf = await thenOrTimeoutError(file.readTextFile_(), commandTimeoutMs())\n  // return the first line, stripped of comments, that contains something uuid-esque:\n  for (const line of splitLines(buf)) {\n    const result = toVolumeUUID(line)\n    if (result != null) return result\n  }\n  throw new Error(\"No UUID found in \" + file)\n}\n\n/**\n * If the vol UUID file exists, use that instead of the device UUID.\n */\nexport async function readVolumeUUID(v: Volume): PromiseMaybe<string> {\n  // TODO: if we can't find a .uuid in the mountpoint, should we look at a, then\n  // b, then c for a .uuid for `mountpoint/a/b/c/file.jpg`?\n\n  if (Settings.readVolumeUuidFiles.valueOrDefault) {\n    for (const subpath of Settings.volumeUuidFilePaths.values) {\n      const volUuidFile = PosixFile.for(v.mountpoint).join(subpath)\n\n      const savedUUID = await readUuidFile_(volUuidFile).catch(error =>\n        logger().info(\"Failed to read \" + volUuidFile, { error })\n      )\n      if (savedUUID != null) {\n        return logger().tap({\n          msg: \"Serving UUID from \" + subpath,\n          result: savedUUID,\n          meta: {\n            mountpoint: v.mountpoint\n          }\n        })\n      }\n    }\n  }\n\n  // Don't try to write to the root directory:\n  if (v.mountpoint === \"/\") return v.uuid\n\n  if (Settings.writeVolumeUuidFiles.valueOrDefault) {\n    const uuid = await writeVolumeUuid(v)\n    if (uuid != null) return uuid\n  }\n\n  // Only return the hardware uuid if we couldn't persist the safeUUID for later\n  return v.uuid\n}\n","import _os from \"os\"\nimport _path from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport {\n  commonPrefixLength,\n  compact,\n  compactBlanks,\n  eqlPrimitiveUnordered,\n  isEmpty,\n  isNotEmpty,\n  uniqBy\n} from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank, mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { dayMs, minuteMs, secondMs } from \"../../fe/Date\"\nimport { delay, later } from \"../../fe/Delay\"\nimport { eql } from \"../../fe/Eql\"\nimport { Latch } from \"../../fe/Latch\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { clamp, gt, gt0, toInt } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { tol } from \"../../fe/Thunk\"\nimport { toA } from \"../../fe/toA\"\nimport { greatestBy } from \"../Array\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { isSyncService, isWorkerService } from \"../ServiceNames\"\nimport { shim0 } from \"../Shim0\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport {\n  ensureSuffix,\n  equalsIgnoreCase,\n  sortByCaseInsensitive\n} from \"../String\"\nimport { asyncFind, mapAsync, thenFlatten, thenMap } from \"../async/Promise\"\nimport { thenOrTimeout } from \"../async/ThenOrTimeout\"\nimport { cacheDir } from \"../dir/CacheDir\"\nimport { libraryDataDir } from \"../dir/LibraryDir\"\nimport { getDevEnvFlag } from \"../env/DevEnvFlags\"\nimport { env } from \"../env/Env\"\nimport { getEnv } from \"../env/GetEnv\"\nimport { onError } from \"../error/OnError\"\nimport { toWrappedError } from \"../error/WrappedError\"\nimport { ee } from \"../event/EventEmitter\"\nimport { actualPath } from \"../fs/ActualPath\"\nimport { withLock_ } from \"../fs/FsLock\"\nimport { bestMountpointForDir, containedByNativePath } from \"../fs/Path\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { SimpleFile, toNativePath_ } from \"../fs/SimpleFile\"\nimport { isReadableDirectory } from \"../fs/Stat\"\nimport { cleanHostname } from \"../net/Hostname\"\nimport { friendlyname } from \"../net/nslookup\"\nimport { isMac, isWin } from \"../platform/Platform\"\nimport { isDocker } from \"../platform/isDocker\"\nimport { Settings } from \"../settings/Settings\"\nimport { volsha } from \"../uri/volsha\"\nimport { dfPosix } from \"./DfPosix\"\nimport { dfWin } from \"./DfWin\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\nimport { addLocalVolumeInfoLinux } from \"./LocalVolumesLinux\"\nimport { addLocalVolumeInfoMac } from \"./LocalVolumesMac\"\nimport { mountpoints } from \"./Mountpoints\"\nimport { addRemoteVolumeInfoPosix } from \"./RemoteVolumesPosix\"\nimport { addRemoteVolumeInfoWin } from \"./RemoteVolumesWin\"\nimport { Volume } from \"./Volume\"\nimport { commandTimeoutMs, mountpointsTtlMs } from \"./VolumeTtls\"\nimport { addVolumeUUIDs } from \"./VolumeUUID\"\n\nconst logger = lazy(() => mkLogger(\"volumes.Volumes\"))\n\n// volumes() is the public method, which does caching and timeouts via lazyFsAsync\n\n// volumesImpl is the BiImpl which may delegate to _volumesImpl or an RPC call.\n\nconst os: string = _os.platform()\n\nexport interface CachedVolume extends Volume {\n  os: string\n  /**\n   * If cached, what hostname extracted this volume?\n   */\n  fromHost?: string\n}\n\nconst mount2vol = new Map<string, Volume>()\nconst mount2volsha = new Map<string, string>()\nconst volsha2vol = new Map<string, Volume>()\n\nexport const mountpointToVolsha = lazyFsAsync(\n  \"mountpointToVolsha\",\n  async () => {\n    await loadCachedVolumes()\n    return mount2volsha\n  }\n)\n\nfunction replaceIfNewer(\n  key: Maybe<string>,\n  vol: Volume,\n  cache: Map<string, Volume>\n) {\n  if (blank(key)) return\n  const prior = cache.get(key)\n  if (prior == null || !gt(prior.updatedAt, vol.updatedAt)) {\n    cache.set(key, vol)\n    map(volsha(vol.uuid), ea => mount2volsha.set(vol.mountpoint, ea))\n  }\n}\n\nfunction cacheVolume<T extends Volume>(vol: Maybe<T>) {\n  if (vol == null) return\n  replaceIfNewer(vol.mountpoint, vol, mount2vol)\n  replaceIfNewer(volsha(vol.uuid), vol, volsha2vol)\n  return vol\n}\n\nfunction systemVolumeCacheDir() {\n  return PosixFile.forMaybe(cacheDir())?.join(\"volumes\")\n}\n\nfunction libraryVolumeCacheDir() {\n  return PosixFile.forMaybe(libraryDataDir())?.join(\"volumes\")\n}\n\nfunction volumeCacheDirs() {\n  return compact([systemVolumeCacheDir(), libraryVolumeCacheDir()])\n}\n\nasync function readCachedVolumes() {\n  const arr = await mapAsync({\n    name: \"readCachedVolumes\",\n    arr: thenFlatten(\n      volumeCacheDirs().map(dir =>\n        dir.childFiles(ea => ea.ext === \".json\" && !ea.base.startsWith(\".\"))\n      )\n    ),\n    f: file => file.readJson<CachedVolume>()\n  })\n  const sorted = sortBy(arr, ea => [ea.mountpoint, -ea.updatedAt!])\n  ;[...sorted.reverse()].forEach(cacheVolume)\n\n  const uniq = uniqBy(sorted, ea => ea.mountpoint).map(ea => ({\n    ...ea,\n    fromCache: true\n  }))\n\n  return sortByCaseInsensitive(uniq, ea => ea.mountpoint)\n}\n\nexport async function clearVolumesCache({\n  deleteFileCache = false\n}: { deleteFileCache?: boolean } = {}) {\n  logger().warn(\"clearVolumesCache()\", { deleteFileCache })\n  volumes.unset()\n  mount2vol.clear()\n  volsha2vol.clear()\n  loadCachedVolumes.unset()\n  cachedVolumes.unset()\n  if (deleteFileCache) {\n    await Promise.all(volumeCacheDirs().map(ea => ea.rmrf()))\n  }\n}\n\nconst loadCachedVolumes = lazyFsAsync(\"loadCachedVolumes\", async () => {\n  const vols = await readCachedVolumes()\n  vols?.forEach(cacheVolume)\n  return vols\n})\n\nexport const canWriteVolumesToCache = lazy(() => isSyncService() || isTest)\n\n// only exposed for tests:\nexport const priorWriteVolumesToCacheLatch = lazy<Maybe<Latch>>(() => undefined)\n\nexport async function writeVolumesToCache(arr: Maybe<Volume[]>) {\n  if (arr == null) return\n  const l = new Latch()\n  void priorWriteVolumesToCacheLatch.set(l)\n  const updatedAt = Date.now()\n  const vols: CachedVolume[] = arr\n    .filter(ea => !isTrue(ea.fromCache))\n    .map(ea => ({\n      ...ea,\n      ...(isDocker() ? {} : { fromHost: cleanHostname() }),\n      updatedAt,\n      os\n    }))\n\n  // Figure out what to write once, then write the volumes into both dirs:\n\n  const name2vol = new Map<string, CachedVolume>()\n  for (const vol of vols) {\n    // we need to include both the mountpoint and the volsha: some volumes\n    // won't have UUIDs.\n    for (const key of compactBlanks([\n      volsha(vol.uuid),\n      volsha(vol.mountpoint)\n    ])) {\n      name2vol.set(key, vol)\n    }\n  }\n  const dirs = volumeCacheDirs() // may be empty!\n  for (const dir of dirs) {\n    await withLock_(\n      {\n        file: dir,\n        timeoutMs: ShortCommandTimeoutMs\n      },\n      async () => {\n        for (const [name, vol] of name2vol.entries()) {\n          const f = dir.join(name + \".json\")\n          try {\n            await f.writeJson_(vol)\n          } catch (error) {\n            logger().warn(\n              \"writeVolumesToCache(): failed to write volumes cache\",\n              {\n                error,\n                output: f.nativePath,\n                vol\n              }\n            )\n            await f.unlink()\n          }\n        }\n      }\n    )\n  }\n  logger().debug(\"writeVolumesToCache(): complete.\", {\n    dirs,\n    vol_mountpoints: vols.map(ea => ea.mountpoint)\n  })\n\n  void l.resolve()\n}\n\nexport const cachedVolumes = lazy<Promise<CachedVolume[]>>(async () => {\n  const arr = compact(await loadCachedVolumes())\n  const m = toA(await mountpoints())\n  const withCurrentMountpoints = arr.filter(ea => m.includes(ea.mountpoint))\n  const result = isNotEmpty(withCurrentMountpoints)\n    ? withCurrentMountpoints\n    : arr.filter(ea => os === ea?.os) // Ideally we're only include from current host\n  return logger().tap({\n    msg: \"cachedVolumes()\",\n    level: \"trace\",\n    result: result.filter(ea => !isTrue(ea.ignorable)),\n    meta: {\n      currentMountpoints: m,\n      withCurrentMountpoints: withCurrentMountpoints.map(ea => ea.mountpoint)\n    }\n  })\n}, minuteMs)\n\n// NOT CACHED\nexport async function priorVolumesIfMountpointsMatch() {\n  const prior = await cachedVolumes()\n  // workers should just use priorVolumes():\n  if (isWorkerService() && isNotEmpty(prior)) return prior\n  const m = toA(await mountpoints())\n  const staleAt =\n    Date.now() -\n    clamp(minuteMs, dayMs, Settings.volumeMetadataTtlMs.valueOrDefault)\n  const priorIsStale =\n    Settings.volumeMetadataTtlMs.valueOrDefault === 0\n      ? false\n      : prior.some(ea => !gt(ea.updatedAt, staleAt))\n  const priorIsMissingMountpoints = !eqlPrimitiveUnordered(\n    m,\n    prior.map(ea => ea.mountpoint)\n  )\n  logger().debug(\"priorVolumesIfMountpointsMatch()\", {\n    priorIsStale,\n    priorIsMissingMountpoints\n  })\n  return !priorIsStale && !priorIsMissingMountpoints ? prior : undefined\n}\n\nexport const volumes = lazyFsAsync(\"volumes\", _volumes)\n\nasync function _volumes() {\n  try {\n    const prior = await thenOrTimeout(\n      priorVolumesIfMountpointsMatch(),\n      commandTimeoutMs()\n    )\n    if (prior != null) {\n      logger().debug(\"volumes(): returning prior-cached volumes\")\n      return prior\n    }\n\n    const result = await thenOrTimeoutError(volumesImpl(), commandTimeoutMs())\n    if (isNotEmpty(result)) {\n      return result\n    }\n  } catch (cause) {\n    onError(toWrappedError(\"volumes() failed\", { cause }))\n  }\n  logger().debug(\"fallback: returning priorVolumes()\")\n  return cachedVolumes()\n}\n\n// only exposed so the shim can be set:\nexport const volumesImpl = shim0({ name: \"fs.volumes\", impl: _volumesImpl })\n\n// for emitVolumesChanged():\nlet priorMountpoints: string[]\n\nasync function _volumesImpl(): PromiseMaybe<Volume[]> {\n  // FOR TESTING:\n  if (isTest) {\n    const hangMs = toInt(env().PS_VOLUMES_HANG_MS)\n    if (gt0(hangMs)) {\n      logger().warn(\"PS_VOLUMES_HANG_MS: delay for \" + hangMs)\n      await delay(hangMs, false)\n    }\n\n    const fail = getDevEnvFlag(\"PS_FAIL_VOLUMES\")\n    if (fail) {\n      logger().throw(\"PS_FAIL_VOLUMES\")\n      return\n    }\n  }\n\n  const rawDfVols = await thenOrTimeout(\n    isWin ? dfWin() : dfPosix(),\n    mountpointsTtlMs(),\n    () => onError(\"Timed out getting local volume metadata\")\n  )\n  if (rawDfVols == null) {\n    logger().warn(\"df failed\")\n    return\n  }\n\n  const dfVols = Settings.validateMountpoints.valueOrDefault\n    ? compact(\n        await mapAsync({\n          name: \"nonRpcVolumes: filter unhealthy volumes\",\n          arr: rawDfVols,\n          timeoutMs: commandTimeoutMs(),\n          f: async vol => {\n            try {\n              // Exclude volumes whose mountpoint doesn't exist (like unhealthy gio\n              // mountpoints):\n              const isDir = await isReadableDirectory(vol.mountpoint)\n              if (isDir) {\n                return vol\n              } else {\n                logger().info(\n                  \"validateMountpoints(): \" +\n                    vol.mountpoint +\n                    \" is not a directory\"\n                )\n              }\n            } catch (err) {\n              logger().info(\n                \"validateMountpoints(): failed to stat \" + vol.mountpoint,\n                err\n              )\n            }\n            return\n          }\n        })\n      )\n    : rawDfVols\n\n  // We only need to fetch remote volume information if there are remote volumes\n  // that are missing remoteHost:\n  if (dfVols.some(ea => ea.remote === true && blank((ea as any)?.remoteHost))) {\n    await thenOrTimeout(\n      isWin ? addRemoteVolumeInfoWin(dfVols) : addRemoteVolumeInfoPosix(dfVols),\n      10 * secondMs // < windows NET USE is flaky\n    ).catch(error => {\n      onError(\"Failed to get remote volume info\", { error })\n    })\n  }\n  const vols: Volume[] =\n    (isWin\n      ? dfVols\n      : isMac\n      ? await addLocalVolumeInfoMac(dfVols)\n      : await addLocalVolumeInfoLinux(dfVols)) ?? dfVols\n\n  for (const vol of vols) {\n    vol.updatedAt ??= Date.now()\n    // force boolean:\n    vol.remote = isTrue(vol.remote)\n    // undefine any blank labels:\n    if (blank(vol.label)) delete vol.label\n    // Fix hostnames:\n    mapNotBlank(\n      vol.remoteHost,\n      // remote DNS hosts cannot be case sensitive\n      ea => (vol.remoteHost = ea.toLowerCase().normalize().trim())\n    )\n  }\n\n  await addVolumeUUIDs(vols)\n\n  const sorted = sortBy(vols, ea => ea.mountpoint)\n\n  logger().debug(\"_volumes(): final result\", { sorted })\n\n  if (priorMountpoints != null && !eql(priorMountpoints, sorted)) {\n    later(() => ee().emit(\"volumesChanged\"))\n  }\n\n  sorted.forEach(cacheVolume)\n\n  await writeVolumesToCache(sorted)\n\n  return Object.freeze(sorted) as Volume[]\n}\n\nexport const rootPath = lazy(() =>\n  isWin\n    ? opt(getEnv(\"SystemDrive\")) // < looks like \"C:\", not \"C:\\\"\n        .filter(notBlank)\n        .orElse(() => \"C:\")\n        .map(ea => ensureSuffix(ea, \"\\\\\"))\n        .get()!\n    : \"/\"\n)\n\nexport function rootVolume(): PromiseMaybe<Volume> {\n  return bestVolumeForPath(rootPath())\n}\n\nexport function bestMountpoint(\n  nativePath: Maybe<string>,\n  mounts: Maybe<string[]>\n): Maybe<string> {\n  return blank(nativePath) || isEmpty(mounts)\n    ? undefined\n    : greatestBy(\n        mounts.filter(mount =>\n          containedByNativePath({\n            ancestor: mount,\n            descendant: nativePath,\n            acceptSelf: true\n          })\n        ),\n        mount =>\n          commonPrefixLength(\n            nativePath.split(_path.sep),\n            mount.split(_path.sep)\n          )\n      )\n}\n\nexport async function bestVolumeForPath(\n  file: Maybe<string | SimpleFile>,\n  vols?: Maybe<Volume[]>\n): PromiseMaybe<Volume> {\n  const np = map(file, toNativePath_)\n  if (blank(np)) return\n  const nativePath = await actualPath(np)\n\n  for (const vp of [\n    { name: \"args\", vols },\n    { name: \"cachedVolumes()\", vols: cachedVolumes },\n    { name: \"volumes()\", vols: volumes },\n    { name: \"allPriorVolumes()\", vols: loadCachedVolumes }\n  ]) {\n    const arr = await tol(vp.vols)\n    if (isEmpty(arr)) continue\n    const mp = bestMountpointForDir(\n      nativePath,\n      arr.map(ea => ea.mountpoint)\n    )\n    if (mp == null) continue\n    const result = arr.find(ea => ea.mountpoint === mp)\n    if (result != null) {\n      logger().debug(\"bestVolumeForPath()\", {\n        nativePath,\n        result: result.mountpoint,\n        src: vp.name\n      })\n      return result\n    }\n  }\n  return logger().tap({\n    msg: \"bestVolume(): no volumes were applicable(!!)\",\n    result: undefined,\n    meta: {\n      nativePath\n    }\n  })\n}\n\nexport async function bestVolumeForVolsha(volumeSha: string) {\n  for (const vp of [\n    { name: \"allPriorVolumes()\", vols: loadCachedVolumes },\n    { name: \"volumes()\", vols: volumes }\n  ]) {\n    const match = toA(await vp.vols()).find(ea => volsha(ea.uuid) === volumeSha)\n    logger().debug(\"bestVolumeForVolsha(): \" + vp.name, { match })\n    if (match != null) return match\n  }\n  return\n}\n\nexport async function remoteVolumeFor(\n  remoteHost: string,\n  remoteShare: string\n): PromiseMaybe<Volume> {\n  return thenMap(volumes(), vols =>\n    bestRemoteVolume(remoteHost, remoteShare, vols)\n  )\n}\n\n/**\n * Find the first volume in `vols` that matches (case-insensitively) the given\n * `remoteHost` and `remoteShare`.\n */\nexport async function bestRemoteVolume(\n  remoteHost: string,\n  remoteShare: string,\n  vols: Volume[]\n): PromiseMaybe<Volume> {\n  // Share names may be mostly unique, and they aren't messed with, so filter by that first:\n  const withCorrectShare = vols.filter(vol =>\n    equalsIgnoreCase(remoteShare, vol.remoteShare)\n  )\n  if (isEmpty(withCorrectShare)) return\n\n  const withExactHostname = withCorrectShare.find(\n    vol =>\n      isTrue(vol.remote) &&\n      notBlank(vol.remoteHost) &&\n      equalsIgnoreCase(remoteHost, vol.remoteHost)\n  )\n  if (withExactHostname != null) return withExactHostname\n\n  const friendlyRemoteHost = await friendlyname(remoteHost)\n  return asyncFind(withCorrectShare, async vol =>\n    equalsIgnoreCase(friendlyRemoteHost, await friendlyname(vol.remoteHost!))\n  )\n}\n\nexport async function findVolumeForVolsha(\n  volumeSha: string\n): PromiseMaybe<Volume> {\n  if (blank(volumeSha)) {\n    return undefined\n  }\n  return (\n    volsha2vol.get(volumeSha) ??\n    (await loadCachedVolumes())?.find(ea => volsha(ea.uuid) === volumeSha) ??\n    (await volumes())?.find(ea => volsha(ea.uuid) === volumeSha)\n  )\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { notBlankOr, toNotBlank } from \"../../fe/Blank\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { mkLogger } from \"../Logger\"\nimport { version } from \"../Version\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { safeUUID } from \"../math/UUID\"\nimport { Settings } from \"../settings/Settings\"\n\nconst logger = lazy(() => mkLogger(\"volumes.WriteVolumeUUID\"))\n\nexport function volumeUuidSubpath() {\n  return toNotBlank(Settings.volumeUuidFilePaths.values[0]) ?? \".uuid\"\n}\n\nexport async function writeVolumeUuid({\n  mountpoint,\n  uuid\n}: {\n  mountpoint: string\n  uuid?: Maybe<string>\n}): PromiseMaybe<string> {\n  const f = PosixFile.for(mountpoint).join(volumeUuidSubpath())\n  uuid = notBlankOr(uuid, safeUUID)\n  if (await f.parent().isReadWritable()) {\n    try {\n      // Try to persist the UUID for later (or if the volume is remotely mounted)\n      await f.writeText_(\n        uuid,\n        \"\",\n        \"# This volume UUID was written by PhotoStructure v\" + version,\n        \"# See https://photostructure.com/faq/what-is-a-volume/ for details.\"\n      )\n      logger().info(\"writeVolumeUuid(): Saved new UUID for \" + mountpoint, {\n        uuid\n      })\n      return uuid\n    } catch (error) {\n      // Only return the UUID if we can persist it successfully.\n      logger().warn(\n        \"writeVolumeUuid(): Failed to save new UUID for \" + mountpoint,\n        { error }\n      )\n    }\n  } else {\n    logger().warn(\n      `writeVolumeUuid(): cannot write to ${f}, directory is not read/write`\n    )\n  }\n  return\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\nexport const HelmetPlugins = strEnum(\n  \"all\",\n  \"contentSecurityPolicy\",\n  \"crossOriginEmbedderPolicy\",\n  \"crossOriginOpenerPolicy\",\n  \"crossOriginResourcePolicy\",\n  \"dnsPrefetchControl\",\n  \"expectCt\",\n  \"frameguard\",\n  \"hidePoweredBy\",\n  \"hsts\",\n  \"ieNoOpen\",\n  \"noSniff\",\n  \"originAgentCluster\",\n  \"permittedCrossDomainPolicies\",\n  \"referrerPolicy\",\n  \"xssFilter\"\n)\n\nexport type HelmetPlugin = StrEnumKeys<typeof HelmetPlugins>\n","import axios, { AxiosRequestConfig } from \"axios\"\nimport { defer } from \"../../fe/Defer\"\nimport { Json } from \"../../fe/JSON\"\nimport { gt0, gte } from \"../../fe/Number\"\nimport { mkLogger } from \"../Logger\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { HttpStatusIs } from \"./HttpStatus\"\n\nconst logger = defer(() => mkLogger(\"web.HttpGet\"))\n\nexport type HttpGetJsonResult = {\n  data: Json\n  updatedAt: number\n  fromCache: boolean\n}\n\nexport async function httpGetJson_(args: {\n  url: string\n  config?: AxiosRequestConfig\n  cache: PosixFile\n  ttlMs: number\n  preCacheTransform?: (data: Json) => Json\n}): Promise<HttpGetJsonResult> {\n  const f = args.cache\n  const updatedAt = await f.mtimeMs()\n\n  if (\n    updatedAt != null &&\n    gt0(await f.size()) &&\n    gte(updatedAt, Date.now() - args.ttlMs)\n  ) {\n    return {\n      data: await f.readJson_(),\n      updatedAt,\n      fromCache: true\n    }\n  }\n\n  const response = await axios.get(args.url, args.config)\n  const data = response.data\n  if (!HttpStatusIs.success(response.status)) {\n    logger().throw(\"Failed\", { url: args.url, response })\n  }\n\n  const json = args.preCacheTransform?.(data) ?? data\n  logger().info(\"Fetch success. Caching\", {\n    args,\n    json,\n    cache: f\n  })\n  await f.writeJson_(json)\n\n  return {\n    data: json,\n    updatedAt: Date.now(),\n    fromCache: false\n  }\n}\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { within } from \"../../fe/Number\"\n\nexport const HttpStatus = Object.freeze({\n  /**\n   * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-200-ok\n   */\n  OK: 200,\n\n  /**\n   * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-202-accepted\n   */\n  Accepted: 202,\n\n  /**\n   * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-301-moved-permanently\n   */\n  MovedPermanently: 301,\n\n  /**\n   * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-302-found\n   */\n  Found: 302,\n\n  /**\n   * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-303-see-other\n   */\n  SeeOther: 303,\n\n  /**\n   * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-400-bad-request\n   */\n  BadRequest: 400,\n\n  /**\n   * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-401-unauthorized\n   */\n  Unauthorized: 401,\n\n  /**\n   * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-403-forbidden\n   */\n  Forbidden: 403,\n\n  /**\n   * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-404-not-found\n   */\n  NotFound: 404,\n\n  /**\n   * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-500-internal-server-error\n   */\n  InternalServerError: 500,\n\n  /**\n   * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-501-not-implemented\n   */\n  NotImplemented: 501,\n\n  /**\n   * The 503 (Service Unavailable) status code indicates that the server is\n   * currently unable to handle the request due to a temporary overload or\n   * scheduled maintenance, which will likely be alleviated after some delay.\n   *\n   * @see\n   * https://www.rfc-editor.org/rfc/rfc9110.html#name-503-service-unavailable\n   */\n  ServiceUnavailable: 503\n})\n\nexport const HttpStatusIs = Object.freeze({\n  success(code: Maybe<number>) {\n    return within(200, 299, code)\n  },\n  redirect(code: Maybe<number>) {\n    return within(300, 399, code)\n  },\n  clientError(code: Maybe<number>) {\n    return within(400, 499, code)\n  },\n  serverError(code: Maybe<number>) {\n    return within(500, 599, code)\n  },\n  error(code: Maybe<number>) {\n    return within(400, 599, code)\n  }\n})\n","import { LibraryTagName, TagPath, TagRoots } from \"../../fe/api/Tag\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { PS_LIBRARY_SCHEME, PS_LOCAL_FILE_SCHEME } from \"../../fe/URI\"\nimport { toURI, URI } from \"../uri/URI\"\n\n/**\n * @param isFile if true, don't include the last path element in `uri` (as\n * it's the filename, and that's not a tag)\n */\nexport function uriToTagPath({\n  uri,\n  isFile\n}: {\n  uri: Maybe<URI | string>\n  isFile: boolean\n}): Maybe<TagPath> {\n  if (uri == null) return\n  const u = toURI(uri)\n  const authority =\n    u.scheme === PS_LIBRARY_SCHEME\n      ? LibraryTagName\n      : u.scheme === PS_LOCAL_FILE_SCHEME\n      ? u.authority\n      : undefined\n\n  if (blank(authority)) return\n\n  // simple file URIs won't have a valid authority.\n  // slice off the filename:\n  const arr = u.path.split(\"/\")\n\n  return compactBlanks([\n    TagRoots.fs,\n    authority,\n    ...(isFile ? arr.slice(0, -1) : arr)\n  ])\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { compactBlanks, isEmpty } from \"../../fe/Array\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { mkTagUri } from \"../../fe/app/FullPaths\"\nimport { hostname } from \"../net/Hostname\"\nimport { myExternalIp4Addresses } from \"../net/ip\"\nimport { Settings } from \"../settings/Settings\"\nimport { tagPathToStringArray } from \"../tags/TagPaths\"\nimport { nativePath2uri } from \"../uri/FileURI\"\nimport { URI, toURI } from \"../uri/URI\"\nimport { uriToTagPath } from \"./UriToTagPath\"\n\nexport default function myWebUrls(\n  port = Settings.httpPort.valueOrDefault\n): URI[] {\n  const hostnames = [Settings.localhost.valueOrDefault]\n  if (Settings.exposeNetworkWithoutAuth.valueOrDefault) {\n    hostnames.push(...compactBlanks([myExternalIp4Addresses()[0], hostname()]))\n  }\n  const base = toURI(\"http://a\")\n\n  return hostnames.map(ea => base.with({ authority: ea + \":\" + port }))\n}\n\nexport const myWebUrl = lazy(() => myWebUrls()[0])\n\nexport async function mkFolderUrl(nativePath: string) {\n  const uri = await nativePath2uri(nativePath)\n  const tagPath = uriToTagPath({ uri, isFile: false })\n  if (isEmpty(tagPath)) return\n  const change = mkTagUri(tagPathToStringArray(tagPath))\n  return myWebUrl()?.with(change)\n}\n\nexport function mkAssetUrl(assetId: Maybe<number>): Maybe<URI> {\n  return gt0(assetId)\n    ? myWebUrl()?.with({ path: \"/asset/\" + assetId })\n    : undefined\n}\n","import { join } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { MultiMap } from \"../../fe/MultiMap\"\nimport { stripDiacritics, stripEmoji } from \"../String\"\nimport { splitCompactLines } from \"../fs/CRLF\"\nimport { ProjectPath } from \"../fs/ProjectPath\"\nimport { zcat } from \"../fs/zcat\"\nimport { unl33t } from \"./Leet\"\n\nexport const CussNativePath = lazy(() =>\n  join(ProjectPath.Data(), \"cuss.txt.br\")\n)\n\nexport const loadCuss = lazy(async () => {\n  const words = splitCompactLines(await zcat(CussNativePath()))\n  cussTrie.set(asTrie(words))\n})\n\nconst cussTrie = lazy<ReturnType<typeof asTrie>>(() => ({\n  trie: new MultiMap<string, string>(),\n  small: []\n}))\n\n// uuid spec passes fastest with 3:\nconst TriePrefixLength = 3\n\nfunction asTrie(words: string[]): {\n  trie: MultiMap<string, string>\n  small: string[]\n} {\n  const trie = new MultiMap<string, string>()\n  const small: string[] = []\n  for (const ea of words) {\n    if (ea.length < TriePrefixLength) {\n      small.push(ea)\n    } else {\n      trie.add(ea.slice(0, TriePrefixLength), ea)\n    }\n  }\n  // console.log(\n  //   \"asTrie(): \" +\n  //     words.length +\n  //     \" words, \" +\n  //     trie.store.size +\n  //     \" prefixes, \" +\n  //     small.length +\n  //     \" too small\"\n  // )\n  return { trie, small }\n}\n\nexport function getCuss(s: string, naughtyWords?: string[]): Maybe<string> {\n  const lc = stripEmoji(stripDiacritics(s.toLowerCase().normalize()))\n  const { small, trie } =\n    naughtyWords == null ? cussTrie() : asTrie(naughtyWords)\n  for (const w of [lc.replace(/[^a-z]/gi, \"\"), ...unl33t(lc)]) {\n    const smol = small.find(ea => w.includes(ea))\n    if (smol != null) return smol\n    for (let i = 0; i < w.length - (TriePrefixLength - 1); i++) {\n      const arr = trie.get(w.slice(i, TriePrefixLength))\n      if (arr != null) {\n        const sub = w.slice(i)\n        const bad = arr.find(ea => sub.startsWith(ea))\n        if (bad != null) {\n          return bad\n        }\n      }\n    }\n  }\n  return\n}\n\nexport function isCussy(s: string) {\n  return getCuss(s) != null\n}\n\nexport function decuss(f: () => string): string {\n  let retries = 10\n  let s = \"\"\n  do {\n    s = f()\n  } while (retries-- > 0 && isCussy(s.replace(/[^a-z]/gi, \"\")))\n\n  return s\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { MultiMap } from \"../../fe/MultiMap\"\nimport { toA } from \"../../fe/toA\"\n\nexport function l33t(s: string): string {\n  let result = \"\"\n  const m = a2l()\n  for (const ea of s) {\n    result += m.get(ea)?.[0] ?? ea\n  }\n  return result\n}\n\nconst l2a = lazy(() => {\n  const m = new MultiMap<string, string>()\n  for (const { l, a } of [\n    // { l: \"!\", a: [\"i\"] },\n    // { l: \"(\", a: [\"c\"] },\n    // { l: \"@\", a: [\"a\"] },\n    // { l: \"&\", a: [\"g\"] },\n    // { l: \"+\", a: [\"t\"] },\n    // { l: \"|\", a: [\"i\", \"l\"] },\n    // { l: \"$\", a: [\"s\"] },\n    { l: \"0\", a: [\"o\"] },\n    { l: \"1\", a: [\"i\", \"l\"] },\n    { l: \"2\", a: [\"z\"] },\n    { l: \"3\", a: [\"e\"] },\n    { l: \"4\", a: [\"a\"] },\n    { l: \"5\", a: [\"s\"] },\n    { l: \"6\", a: [\"b\"] },\n    { l: \"7\", a: [\"t\"] },\n    { l: \"8\", a: [\"b\"] },\n    { l: \"9\", a: [\"g\", \"q\"] }\n  ]) {\n    m.add(l, ...a)\n  }\n  return m\n})\n\nconst a2l = lazy(() => {\n  const m = l2a().inverse()\n  for (const ea of m.values()) {\n    ea.sort()\n  }\n  return m\n})\n\nexport function unl33t(s: string): string[] {\n  if (blank(s)) return [\"\"]\n  const origPrefix = s.substring(0, 1)\n  const prefixes = [origPrefix, ...toA(l2a().get(origPrefix))]\n  const suffixes = unl33t(s.substring(1))\n  return flatten(suffixes.map(suff => prefixes.map(pref => pref + suff)))\n}\n","import os from \"os\"\nimport { lazy } from \"../../core/Lazy\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { clamp } from \"../../fe/Number\"\nimport { mkLogger } from \"../Logger\"\n\nconst logger = lazy(() => mkLogger(\"work.CpuInfo\"))\n\n// cpus() can take 500ms!\nexport const cpuInfo = lazy(() => os.cpus(), 5 * minuteMs)\n\nexport const cpuCount = lazy(() => {\n  try {\n    const availableParallelism = os.availableParallelism?.()\n    const cpuInfoLength = cpuInfo().length\n    return logger().tap({\n      msg: \"cpuCount()\",\n      result: clamp(1, 128, Math.ceil(availableParallelism ?? cpuInfoLength)),\n      meta: {\n        availableParallelism,\n        cpuInfoLength\n      }\n    })\n  } catch (error) {\n    logger().warn(\"availableParallelism()/cpuCount() failed\", { error })\n    return 1\n  }\n})\n\n// Don't look at cgroup info--the algorithm for determining what \"1024\" means\n// in cpu.shares relies on a sum of all cgroup cpu.shares values, and we don't\n// have access to that within docker. See\n// https://bugs.openjdk.org/browse/JDK-8281181\n","import os from \"os\"\nimport { secondMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, gt0, gte, gte0, mapFinite } from \"../../fe/Number\"\nimport { lazy } from \"../Lazy\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { EndableRanks } from \"../async/Endable\"\nimport { EndableInterval } from \"../async/EndableInterval\"\nimport { InternalErrorFlag } from \"../error/ErrorFlags\"\nimport { Average } from \"../math/Average\"\nimport { isWin } from \"../platform/Platform\"\nimport { Settings } from \"../settings/Settings\"\nimport { cpuInfo } from \"./CpuInfo\"\nimport { singleThreadMode } from \"./MaxCpus\"\n\nconst logger = lazy(() => mkLogger(\"work.CpuUsage\"))\n\nconst logTooBusy = lazy(\n  () => {\n    logger().warn(\"Current system load is too high to schedule more work\", {\n      currentBusyPct: CpuUsage.instance().busyPct(),\n      max: Settings.cpuBusyPercent.valueOrDefault\n    })\n  },\n  (isTest ? 15 : 60) * secondMs\n)\n\nexport function isTooBusy(): boolean {\n  const busyPct = CpuUsage.instance().busyPct()\n  // If people set cpuLoadPercent too low, this results in PhotoStructure\n  // never running. Only set this if the setting is reasonable.\n\n  const reasonableMaxCpuPct = clamp(\n    1,\n    125, // allow for overscheduling: **they asked for it!**\n    Math.round(Settings.cpuBusyPercent.valueOrDefault)\n  )\n  if (gte(busyPct, reasonableMaxCpuPct)) {\n    logTooBusy()\n    return true\n  } else {\n    logTooBusy.unset() // < log the next time we're too high\n    return false\n  }\n}\n\n/**\n * Watches and reports system cpu utilization (as opposed to process.cpuUsage,\n * which returns this process' utilization)\n */\nexport class CpuUsage extends EndableInterval {\n  readonly #busyPctAvg = new Average(5)\n  #prior = new CpuTimes()\n\n  static instance = defer(() => new CpuUsage())\n\n  /**\n   * @param intervalMs most OSes don't seem to update _os.CpuInfo more than\n   * twice a second, so 500ms is a reasonable default\n   * @param sampleCount larger numbers give more smoothing. 1.5 seconds of\n   * smoothing should be fine. 1 disables smoothing.\n   */\n  constructor() {\n    super({\n      name: \"CpuUsage()\",\n      callback: () => this.#sample(),\n      // sampling is expensive--it can take 500ms on slow windows boxen!\n      intervalMs: (singleThreadMode() ? 60 : isWin ? 20 : 10) * secondMs,\n      rank: EndableRanks.first\n    })\n    mapFinite(busyPctFromLoad(), ea => this.#busyPctAvg.push(ea))\n\n    // set .last:\n    this.#sample()\n  }\n\n  get cpuCount() {\n    return this.#prior.cpuCount\n  }\n\n  /**\n   * weighted average percent of the time CPUs are idle\n   */\n  idlePct(): Maybe<number> {\n    return map(this.busyPct(), ea => 100 - ea)\n  }\n\n  busyPct(): Maybe<number> {\n    return this.#busyPctAvg.sampleAvg ?? busyPctFromLoad()\n  }\n\n  #pushBusyPct(ea: Maybe<number>) {\n    if (gte0(ea)) this.#busyPctAvg.push(ea)\n  }\n\n  #sample(): void {\n    this.#pushBusyPct(busyPctFromLoad())\n    const now = new CpuTimes()\n    this.#pushBusyPct(now.busyPct(this.#prior))\n    this.#prior = now\n  }\n}\n\nclass CpuTimes {\n  readonly cpuCount: number\n  readonly busyMs: number\n  readonly idleMs: number\n\n  constructor(cpus: os.CpuInfo[] = os.cpus()) {\n    let busyMs = 0\n    let idleMs = 0\n    for (const ea of cpus) {\n      busyMs += ea.times.user + ea.times.nice + ea.times.sys + ea.times.irq\n      idleMs += ea.times.idle\n    }\n    this.busyMs = busyMs\n    this.idleMs = idleMs\n    this.cpuCount = cpus.length\n  }\n\n  busyPct(prior: CpuTimes): Maybe<number> {\n    const busyMs = this.busyMs - prior?.busyMs\n    const idleMs = this.idleMs - prior?.idleMs\n    const totalMs = busyMs + idleMs\n    if (\n      prior?.cpuCount === this.cpuCount &&\n      gte0(busyMs) &&\n      gte0(idleMs) &&\n      gt0(totalMs)\n    ) {\n      return Math.round(100.0 * (busyMs / totalMs))\n    } else {\n      logger().warn(\n        \"busyPct(): Unexpected CpuTimes. If this continues, busyPct() will be incorrect.\" +\n          InternalErrorFlag,\n        {\n          self: this,\n          prior,\n          busyMs,\n          idleMs,\n          totalMs\n        }\n      )\n      return\n    }\n  }\n}\n\n/**\n * @return undefined on Windows, or [0, 100+] percent of time CPUs are busy.\n * If we're overscheduled, this will be > 100%.\n */\nfunction busyPctFromLoad() {\n  return isWin\n    ? undefined\n    : Math.ceil(100 * (os.loadavg()[0] / cpuInfo().length))\n}\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { Endable, ending } from \"../async/Endable\"\nimport { HealthCheck } from \"../health/HealthCheck\"\nimport { isTooBusy } from \"./CpuUsage\"\n\nexport type DoNotRunEndable = Pick<Endable, \"ended\">\n\nexport function doNotRun(endable?: DoNotRunEndable): boolean {\n  return whyDoNotRun(endable) != null\n}\n\nexport function whyDoNotRun(endable?: DoNotRunEndable): Maybe<string> {\n  if (true === endable?.ended) return \"endable ended\"\n  if (ending()) return \"service is ending\"\n  if (isTooBusy()) return \"system is too busy\"\n  const s = HealthCheck.summary()\n  return [\"ok\", \"warn\"].includes(s.level)\n    ? undefined\n    : s.level + \": \" + s.msg.join(\"\\n\")\n}\n","import os from \"os\"\nimport { lazy } from \"../../core/Lazy\"\nimport { gt0 } from \"../../fe/Number\"\nimport { fmtBytes } from \"../../fe/Units\"\nimport { mkLogger } from \"../Logger\"\nimport { intFromFileSync } from \"../fs/ReadFile\"\nimport { avg } from \"../math/Vector\"\nimport { isDocker } from \"../platform/isDocker\"\n\nconst logger = lazy(() => mkLogger(\"work.FreeMem\"))\n\n// lazy for tests:\n\nexport const estimatedFreeMem = lazy<number>(() => {\n  const freemem = os.freemem()\n  const totalmem = os.totalmem()\n  // By using both free and total memory, we don't ignore current system load,\n  // but aren't borked if all memory is used currently (by filesystem cache,\n  // presumably)\n  const result = (freemem * 2 + totalmem) / 3\n  if (isDocker()) {\n    // See\n    // https://www.reddit.com/r/PhotoStructure/comments/sn68f9/initial_scan_not_adding_everything/hw4bqmj/\n\n    const mem = intFromFileSync(\"/sys/fs/cgroup/memory/memory.limit_in_bytes\")\n    // k8s may return 9223372036854771712 if memory isn't limited (which means use the system memory...)\n    if (gt0(mem))\n      return logger().tap({\n        msg: \"estimatedFreeMem() (docker mode)\",\n        result: avg([mem, result])!, // < don't keel over if the cgroup memory limit is tiny\n        meta: { freemem, totalmem, cgroupMem: mem }\n      })\n  }\n  return logger().tap({\n    msg: \"estimatedFreeMem() \",\n    result,\n    meta: {\n      result: fmtBytes(result),\n      freemem: fmtBytes(freemem),\n      totalmem: fmtBytes(totalmem)\n    }\n  })\n})\n","import { ee } from \"../event/EventEmitter\"\n\nlet paused = false\n\nexport function isPaused(): boolean {\n  return paused\n}\n\nexport function pause(newPausedValue = true): void {\n  if (newPausedValue === false) {\n    resume()\n  } else {\n    // no infinite loops\n    if (!paused) {\n      paused = true\n      ee().emit(\"pause\")\n    }\n  }\n}\n\nexport function resume(): void {\n  // no infinite loops\n  if (paused) {\n    paused = false\n    ee().emit(\"clearCache\")\n    ee().emit(\"resume\")\n  }\n}\n\n// See Service.setupEventHandlers!\n","import { lazy } from \"../../core/Lazy\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { clamp, gt0, sigFigs, toGt0 } from \"../../fe/Number\"\nimport { MB } from \"../../fe/Units\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { ee } from \"../event/EventEmitter\"\nimport { LogLevels } from \"../log/LogLevel\"\nimport { lerp2d } from \"../math/Lerp\"\nimport { Settings } from \"../settings/Settings\"\nimport { cpuCount } from \"./CpuInfo\"\nimport { estimatedFreeMem } from \"./FreeMem\"\nimport { timeoutRate } from \"./WorkTimeout\"\n\nconst logger = lazy(() => mkLogger(\"work.MaxCpus\"))\n\nlater(() => {\n  if (isTest) {\n    ee().on(\"clearCache\", () =>\n      // we actually set() some of these in some specs:\n      clearMaxWorkCaches()\n    )\n  }\n  ee().on(\"settingsChanged\", clearMaxWorkCaches)\n  Settings.cpuBusyPercent.watchLater(clearMaxWorkCaches)\n  Settings.maxConcurrentImports.watchLater(clearMaxWorkCaches)\n})\n\nexport function clearMaxWorkCaches() {\n  estimatedFreeMem.unset()\n  maxCpus.unset()\n  maxConcurrentImports.unset()\n  timeoutRate.prior()?.clear()\n  sharpThreadsPerProcess.unset()\n  cpuCount.unset()\n}\n\nconst maxProcsForMem = lazy(() => {\n  // Clamp maxMemoryMb to (128Mb, 1Gb) so if someone sets it to, say, 8gb, we\n  // don't get the side-effect of running an artificially small number of\n  // workers.\n  const worstCaseMemPerProc =\n    clamp(128, 1024, Settings.maxMemoryMb.valueOrDefault) * MB\n  // We don't want to over-subscribe system memory, but we need to run at\n  // least one:\n  return logger().tap({\n    msg: \"maxProcsForMem\",\n    result: Math.max(1, Math.floor(estimatedFreeMem() / worstCaseMemPerProc)),\n    meta: {\n      estFreeMemMb: Math.round(estimatedFreeMem() / MB),\n      worstCaseMemPerProcMb: Math.round(worstCaseMemPerProc / MB)\n    }\n  })\n}, minuteMs)\n\nexport function timeoutPenalization() {\n  const timeoutsPerMinute = Math.round(\n    timeoutRate.prior()?.eventsPerMinute ?? 0\n  )\n  const timeoutThrottleCoeff = Settings.timeoutThrottleCoeff.valueOrDefault\n\n  const result =\n    timeoutsPerMinute === 0 || timeoutThrottleCoeff === 0\n      ? 1 // < timeouts are disabled\n      : sigFigs(timeoutThrottleCoeff / timeoutsPerMinute, 2)\n\n  return logger().tap({\n    msg: \"timeoutPenalization()\",\n    level: result > 1 ? LogLevels.warn : LogLevels.debug,\n    result,\n    meta: {\n      timeoutsPerMinute,\n      timeoutThrottleCoeff\n    }\n  })\n}\n\nexport function targetCpuLoadPct() {\n  return (toGt0(Settings.cpuBusyPercent.valueOrDefault) ?? 1) / 100\n}\n\nexport function singleThreadMode() {\n  return (\n    Math.round(targetCpuLoadPct() * cpuCount()) <= 1 ||\n    Settings.cpuBusyPercent.valueOrDefault <= 1 ||\n    maxCpus() === 1\n  )\n}\n\n// We don't need a timeout TTL here: if we get a timeout, that will get set. See\n// WorkTimeout.ts\nexport const maxCpus = lazy(_maxCpus)\n\nfunction _maxCpus() {\n  // HEY WHAT'S THIS MINUS ONE? It's to leave a CPU for sync!\n  const cpuPortion = Math.max(\n    1,\n    Math.floor(targetCpuLoadPct() * cpuCount()) - 1\n  )\n\n  // maxCpus must be at least 1, and not more than min(cpuPortion, maxProcsForMem)\n  let result = cpuPortion\n\n  const timeoutsPerSecond = timeoutRate.prior()?.eventsPerMinute ?? 0\n\n  // Make the lazy estimation that most work takes about a second:\n  const penalization = timeoutPenalization()\n\n  if (penalization !== 1) {\n    // we don't need to go below this setting\n    const resultBeforePenalization = result\n    result = result * penalization\n    logger().warn(\"Recent timeouts! Throttling down.\", {\n      penalization,\n      resultBeforePenalization,\n      resultAfterPenalization: result\n    })\n  }\n\n  // We don't want to over-subscribe system memory\n  const upperBound = Math.min(cpuPortion, maxProcsForMem())\n\n  // but we need to run at least one CPU:\n  result = clamp(1, upperBound, Math.ceil(result))\n\n  return logger().tap({\n    msg: \"maxCpus()\",\n    level: LogLevels.info,\n    result,\n    meta: {\n      cpuLoadPct: targetCpuLoadPct(),\n      cpuCount: cpuCount(),\n      cpuPortion,\n      penalization,\n      timeoutsPerSecond,\n      maxProcsForMem: maxProcsForMem()\n    }\n  })\n}\n\nexport const maxConcurrentImports = lazy(_maxConcurrentImports)\n\nfunction _maxConcurrentImports() {\n  if (gt0(Settings.maxConcurrentImports.valueOrDefault)) {\n    return clamp(1, maxCpus(), Settings.maxConcurrentImports.valueOrDefault)\n  }\n  return maxCpus()\n}\n\nexport const sharpThreadsPerProcess = lazy(() => {\n  const i = Settings.sharpThreadsPerProcess.valueOrDefault\n  return i > 0\n    ? i\n    : clamp(\n        1,\n        Math.min(maxCpus(), Settings.sharpThreadsPerProcess.max),\n        // bigger second x scales down sharp threads\n        Math.floor(lerp2d(maxCpus(), { x: 1, y: 1 }, { x: 6, y: 2 }))\n      )\n})\n","import { Rate } from \"batch-cluster\"\nimport { setInterval } from \"timers\"\nimport { lazy } from \"../../core/Lazy\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { ShortCommandTimeoutMs } from \"../ShortCommandTimeoutMs\"\nimport { ee } from \"../event/EventEmitter\"\nimport { rateStats } from \"../math/Rate\"\nimport { maxConcurrentImports, maxCpus } from \"./MaxCpus\"\n\nconst logger = lazy(() => mkLogger(\"work.WorkTimeout\"))\n\nexport const timeoutRate = lazy(\n  () => new Rate(5 * minuteMs, isTest ? 100 : ShortCommandTimeoutMs)\n)\n\nconst refreshEveryMinute = lazy(() =>\n  // Make sure if we recover, we throttle back up:\n  // (this was an EndableInterval, but that caused a deploop (!?))\n  setInterval(refresh, minuteMs).unref()\n)\n\nfunction refresh() {\n  // we need to update these every minute if we've had any (soft or hard)\n  // timeouts.\n\n  // We want .refresh(), not just .unset(), so .watchLater() listeners gets\n  // invoked:\n  maxCpus.refresh()\n  maxConcurrentImports.refresh()\n  refreshEveryMinute()\n}\n\nexport function onTimeout() {\n  const r = timeoutRate()\n  r.onEvent()\n  logger().warn(\"onTimeout()\", rateStats(r))\n  refresh()\n}\n\nlater(() => {\n  ee().on(\"clearCache\", () => {\n    maxCpus.unset()\n    maxConcurrentImports.unset()\n    timeoutRate.unset()\n  })\n})\n","import { Task } from \"batch-cluster\"\nimport { parseJSON } from \"../../core/JSON\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { ee } from \"../../core/event/EventEmitter\"\nimport { splitLines } from \"../../core/fs/CRLF\"\nimport { isProgressEvt } from \"../../core/progress/ProgressEvt\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { errorFromJson } from \"../../fe/Error\"\nimport { stringify } from \"../../fe/JSON\"\nimport { isNumber } from \"../../fe/Number\"\nimport { WorkRequest, WorkRequestMethod } from \"./WorkRequests\"\n\nconst logger = lazy(() => mkLogger(\"worker.RequestTask\"))\n\nexport class RequestTask<N extends WorkRequestMethod> extends Task<any> {\n  constructor(readonly request: WorkRequest<N>) {\n    super(stringify(request), input => this.#parse(input))\n  }\n\n  // MUST BE KEPT IN SYNC WITH ./Worker.onStdinData!\n\n  #parse(buff: string) {\n    // logger().debug(\"Got data from worker\", { request: this.request })\n    for (const line of compactBlanks(splitLines(buff))) {\n      const response = parseJSON(line)\n      if (response == null) {\n        logger().warn(\"ignoring non-json line from worker\", { line })\n      } else if (response.error != null) {\n        logger().warn(\"worker threw error\", { response })\n        throw errorFromJson(response.error)\n      } else if (isNumber(response.id)) {\n        if (response.id !== this.request.id) {\n          return logger().throw(\n            `bad request: #parse given mismatching requests (${response.id} != ${this.request.id})`,\n            {\n              response,\n              request: this.request\n            }\n          )\n        } else {\n          return response.response\n        }\n      } else if (isProgressEvt(response)) {\n        ee().emit(\"progress\", response)\n      } else {\n        logger().warn(\"ignoring json line from worker\", { response })\n      }\n    }\n\n    return logger().throw(\"bad request: #parse missing valid response\")\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { entries, values } from \"../../fe/Object\"\nimport { thenOrOnTimeout, thenOrTimeoutError } from \"../../fe/ThenOrTimeout\"\nimport { Args } from \"../Args\"\nimport { addDefaultJsonRevivers } from \"../JsonSetup\"\nimport { mkLogger } from \"../Logger\"\nimport { isWorkerService } from \"../ServiceNames\"\nimport { ending } from \"../async/Endable\"\nimport { isRetriableError } from \"../error/ErrorTypes\"\nimport { statTimeoutMs } from \"../fs/StatTimeout\"\nimport { Settings } from \"../settings/Settings\"\nimport { singleThreadMode } from \"../work/MaxCpus\"\nimport { onTimeout } from \"../work/WorkTimeout\"\nimport { RequestTask } from \"../worker/RequestTask\"\nimport { WorkerCluster } from \"../worker/WorkerCluster\"\nimport {\n  WorkRequestMethod,\n  WorkRequestMethods,\n  WorkRequests,\n  WorkerFunctions\n} from \"./WorkRequests\"\n\nconst logger = lazy(() => mkLogger(\"worker.ShimDelegation\"))\n\nlet id = 0\n\nconst defaultTimeouts = [\n  [\n    WorkRequestMethods.buildAssetPreviews_,\n    Settings.taskTimeoutMs.valueOrDefault\n  ]\n] as const\n\n// only exported for tests\nexport const workerMethodTimeouts = lazy(\n  () => new Map<WorkRequestMethod, number>(defaultTimeouts)\n)\n\nasync function onChild<M extends WorkRequestMethod>(\n  method: M,\n  ...args: Args<WorkRequests[M]>\n) {\n  let bc = (await WorkerCluster()).t\n  if (bc.ended) {\n    if (ending()) {\n      logger().warn(\"onChild(): cluster is ended, running task myself\", {\n        method,\n        args\n      })\n      return (WorkerFunctions[method] as any)(...(args as any))\n    } else {\n      logger().warn(\"onChild(): cluster ended unexpectedly. Restarting.\", {\n        method,\n        args\n      })\n      bc = (await WorkerCluster.refresh()).t\n    }\n  }\n  const timeoutMs = workerMethodTimeouts().get(method) ?? statTimeoutMs()\n  const request = { id: id++, method, args }\n  return retryOnReject(\n    async () => {\n      const t = new RequestTask(request)\n      const p = bc.enqueueTask(t)\n      void thenOrOnTimeout(p, timeoutMs / 3, () => {\n        logger().warn(\"soft timeout servicing work request\", {\n          request,\n          timeoutMs\n        })\n        onTimeout()\n      })\n      return thenOrTimeoutError(p, timeoutMs)\n    },\n    {\n      maxRetries: Settings.maxRetries.valueOrDefault,\n      timeoutMs,\n      retryDelay: Settings.minDelayBetweenRetriesMs.valueOrDefault,\n      errorIsRetriable: err => isRetriableError(err) !== false\n    }\n  )\n}\n\nexport async function setupShimDelegates() {\n  addDefaultJsonRevivers()\n  // The worker service shouldn't be calling this method, but in case it does:\n  if (singleThreadMode() || isWorkerService()) {\n    logger().warn(\"in single-threaded mode\")\n    clearShims()\n    await (await WorkerCluster.prior())?.end()\n  } else {\n    for (const [meth, func] of entries(WorkerFunctions)) {\n      ;(func as any).setShim((args: any) => onChild(meth, args))\n    }\n  }\n}\n\nexport function clearShims() {\n  for (const func of values(WorkerFunctions)) {\n    func.setShim(undefined)\n  }\n}\n","import { isNumber } from \"../../fe/Number\"\nimport { keys } from \"../../fe/Object\"\nimport { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\nimport { Args } from \"../Args\"\nimport { assetFileMetadata_ } from \"../asset-file/AssetFileFactory\"\nimport { shimmedFileSha_ } from \"../fs/Hash\"\nimport { imageHash_ } from \"../img/ImageHash\"\nimport { prepFileForBrowser } from \"../img/PrepFileForBrowser\"\nimport { buildAssetPreviews_ } from \"../img/Previews\"\nimport { _extractVideoFrame_ } from \"../img/Video\"\nimport { Shim1 } from \"../Shim1\"\nimport { _readRawTags, _readTags } from \"../tags/ExifTool\"\nimport { ping } from \"./ping\"\n\n/**\n * These are all of the `shim`-ed functions.\n *\n * Note that they all may not be configured to run remotely--see\n * `WorkerFunctions` below.\n */\nexport const _AllWorkerFunctions = {\n  _extractVideoFrame_,\n  _readRawTags,\n  _readTags,\n  assetFileMetadata_,\n  buildAssetPreviews_,\n  imageHash_,\n  ping,\n  prepFileForBrowser,\n  shimmedFileSha_\n} satisfies Record<string, Shim1<any, any>>\n\n/**\n * List of `shim`-ed functions that are\n */\nexport const WorkerFunctions = {\n  _extractVideoFrame_, // TODO: is this really expensive?\n  _readRawTags, // comment out so exiftool can just run from sync\n  _readTags, // comment out so exiftool can just run from sync\n  assetFileMetadata_,\n  buildAssetPreviews_,\n  imageHash_,\n  ping,\n  prepFileForBrowser,\n  shimmedFileSha_ // < takes time to compute and slows down the main thread\n} satisfies Record<string, Shim1<any, any>>\n\nexport type WorkRequests = typeof WorkerFunctions\n\nexport const WorkRequestMethods = strEnum(...keys(WorkerFunctions))\nexport type WorkRequestMethod = StrEnumKeys<typeof WorkRequestMethods>\n\n// See event/SharedState\nexport interface WorkRequest<N extends WorkRequestMethod> {\n  // simple number, because workers aren't shared across processes\n  id: number\n  method: N\n  args: Args<WorkRequests[N]>\n}\n\nexport function isWorkRequest(obj: any): obj is WorkRequest<any> {\n  return (\n    typeof obj === \"object\" &&\n    WorkRequestMethods.has(obj?.method) &&\n    isNumber(obj.id)\n  )\n}\n","import { BatchCluster } from \"batch-cluster\"\nimport {\n  BatchClusterObserver,\n  batchClusterOptions\n} from \"../../core/BatchClusterObserver\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { ReadyStr } from \"../../core/StdoutWrite\"\nimport { EndableRanks } from \"../../core/async/Endable\"\nimport { spawn } from \"../../core/child/ChildProcess\"\nimport { pathToService } from \"../../core/child/ChildService\"\nimport { FatalErrorRe } from \"../../core/error/ErrorFlags\"\nimport { splitLines } from \"../../core/fs/CRLF\"\nimport { isProgressEvt } from \"../../core/progress/ProgressEvt\"\nimport { emitProgressEvt } from \"../../core/progress/ProgressObserver\"\nimport { maxCpus } from \"../../core/work/MaxCpus\"\nimport { secondMs } from \"../../fe/Date\"\nimport { stringify } from \"../../fe/JSON\"\nimport { clamp } from \"../../fe/Number\"\nimport { parseJSON } from \"../../fe/ParseMaybe\"\nimport { toS } from \"../../fe/toS\"\nimport { ChildServiceExitCommand } from \"../child/ChildServiceExitCommand\"\nimport { isPacked } from \"../platform/IsPacked\"\nimport { Settings } from \"../settings/Settings\"\nimport { cpuCount } from \"../work/CpuInfo\"\nimport { WorkRequest } from \"./WorkRequests\"\nimport { workerEnv } from \"./WorkerEnv\"\n\nconst logger = lazy(() => mkLogger(\"worker.cluster\"))\n\nexport async function workerClusterPriorEnd() {\n  return (await WorkerCluster.prior())?.t.closeChildProcesses()\n}\n\nexport const WorkerCluster = lazy(async () => {\n  const worker = await pathToService(\"worker\")\n  if (worker == null) {\n    return logger().throw(\"Could not find worker.js\")\n  }\n  logger().info(\"worker.js found at \" + worker)\n\n  const pingReq: WorkRequest<\"ping\"> = {\n    id: -1,\n    method: \"ping\",\n    args: [{}]\n  }\n\n  const bc = new BatchCluster({\n    processFactory: async () => {\n      logger().info(\"Spawning new worker\", {\n        execPath: process.execPath,\n        worker: worker.nativePath,\n        // Why not maxConcurrentImports(), you ask? Because each import may do\n        // several things in parallel, and we want enough child workers to\n        // handle that effectively and not result in spurious timeouts due to\n        // starvation on the worker queue.\n        maxProcs: maxCpus()\n      })\n      return spawn(process.execPath, [worker.nativePath], 0, {\n        env: await workerEnv()\n      })\n    },\n\n    ...batchClusterOptions(maxCpus(), \"worker.BatchCluster\"),\n    // worker doesn't emit to stderr!\n    streamFlushMillis: 0,\n    versionCommand: stringify(pingReq),\n    healthCheckCommand: stringify(pingReq),\n    taskTimeoutMillis: Settings.taskTimeoutMs.valueOrDefault,\n    maxProcAgeMillis: Settings.taskTimeoutMs.valueOrDefault * 4,\n    minDelayBetweenSpawnMillis: isPacked() ? secondMs : 1,\n    pass: ReadyStr,\n    fail: FatalErrorRe,\n    exitCommand: ChildServiceExitCommand\n  })\n  bc.on(\"taskData\", buf => {\n    // this may have progress events. Publish those.\n    for (const line of splitLines(toS(buf))) {\n      const ea = parseJSON(line)\n      if (isProgressEvt(ea)) emitProgressEvt(ea)\n    }\n  })\n\n  // if we get soft timeouts, that may cause concurrency to be throttled:\n  maxCpus.watchLater(newValue => {\n    const maxProcs = clamp(1, cpuCount(), newValue ?? maxCpus())\n    logger().warn(\"maxConcurrentImports changed\", { maxProcs, newValue })\n    return bc.setMaxProcs(maxProcs)\n  })\n\n  return new BatchClusterObserver(\"worker\", bc, EndableRanks.first)\n})\n","import { childEnv } from \"../../core/child/ChildEnv\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { mountpoints } from \"../../core/volumes/Mountpoints\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { values } from \"../../fe/Object\"\n\nexport async function workerEnv() {\n  const overrides = {}\n  for (const s of values(Settings)) {\n    if (s.hasValue() && !isTrue(s.opts.transient)) {\n      s.addToEnvMaybe(overrides)\n    }\n  }\n  Settings.libraryDir.addToEnv(overrides)\n  Settings.mountpoints.addToEnv(overrides, await mountpoints())\n  return childEnv({ overrides, forWorker: true })\n}\n","import process from \"process\"\nimport { delay } from \"../../fe/Delay\"\nimport { gt0 } from \"../../fe/Number\"\nimport { isTest } from \"../NodeEnv\"\nimport { shim1 } from \"../Shim1\"\nimport { exit } from \"../async/Exit\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { memoryUsageIsHigh } from \"../health/MemoryHealthCheck\"\n\nexport const ping = shim1({\n  name: \"worker.ping\",\n  async impl(args: {\n    input?: string\n    delay?: number\n    throw?: {\n      message: string\n      errno?: number\n      ignorable?: boolean\n    }\n    pretendMemUsageIsHigh?: boolean\n  }): Promise<{ input: string; pid: number }> {\n    if (gt0(args?.delay)) {\n      await delay(args.delay)\n    }\n\n    if (isTest && true === args?.pretendMemUsageIsHigh) {\n      memoryUsageIsHigh.set(true)\n    }\n\n    if (args?.throw != null) {\n      throw new WrappedError(args.throw.message, args.throw)\n    }\n\n    if (memoryUsageIsHigh()) {\n      void exit({ reason: \"memory usage is high\", status: 1 })\n      throw new WrappedError(\"Memory usage is high\", { fatal: true })\n    }\n\n    return {\n      pid: process.pid,\n      input: args?.input ?? \"(no input)\"\n    }\n  }\n})\n","import { sortBy } from \"./ArraySort\"\nimport { notBlankish } from \"./Blank\"\nimport { eql } from \"./Eql\"\nimport { stringify } from \"./JSON\"\nimport { List } from \"./List\"\nimport { getOrSet } from \"./Map\"\nimport { Defined } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport {\n  Comparable,\n  Primitivable,\n  Primitivables,\n  Primitive,\n  isPrimitive,\n  isPrimitiveArray,\n  lt\n} from \"./Primitive\"\nimport { randomInt } from \"./Random\"\nimport { MaybeReadonlyArray } from \"./Readonly\"\nimport { MaybeNullSyncOrAsync } from \"./SyncOrAsync\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { isFunction } from \"./isFunction\"\nimport { toA } from \"./toA\"\nimport { toS } from \"./toS\"\n\n// Added isNotEmpty so I can make the arr is not null assertion:\nexport function isNotEmpty<L extends List<any>>(arr: MaybeNull<L>): arr is L {\n  return arr != null && toA(arr).length > 0\n}\n\nexport function toNotEmpty<L extends List<any>>(arr: MaybeNull<L>): Maybe<L> {\n  return isNotEmpty(arr) ? arr : undefined\n}\n\nexport function notEmptyOr<L extends List<any>>(\n  arr: Maybe<L>,\n  defaultValue: ThunkOrT<L>\n): L {\n  return isNotEmpty(arr) ? arr : tot(defaultValue)\n}\n\nexport function isEmpty(\n  arr: MaybeNull<List<any>> | MaybeReadonlyArray<any>\n): arr is undefined {\n  return arr == null || toA(arr).length === 0\n}\n\nexport function mapArray<T, U>(\n  arr: MaybeNull<T[]>,\n  f: (t: T[]) => U\n): Maybe<U> {\n  return Array.isArray(arr) ? f(arr) : undefined\n}\n\nexport function mapNotEmpty<L extends List<any>, R>(\n  arr: Maybe<L>,\n  f: (ea: L) => R\n): Maybe<R> {\n  return isNotEmpty(arr) ? f(arr) : undefined\n}\n\nexport function mapNotEmptyOr<L extends List<any>, R>(\n  arr: Maybe<L>,\n  f: (ea: L) => R,\n  defaultValue: ThunkOrT<R>\n): R {\n  return isNotEmpty(arr) ? f(arr) : tot(defaultValue)\n}\n\nexport function toPrimitive(\n  a: Primitive | Primitive[] | Primitivable | Primitivables\n): Primitive | Primitive[] {\n  return isPrimitive(a) || isPrimitiveArray(a) ? a : a.valueOf()\n}\n\n// only deals with primitive arrays. use isEqlArray() instead.\nfunction eqlArray<T extends Primitive>(a: T[], b: T[]): boolean {\n  return (\n    a != null &&\n    b != null &&\n    a.length === b.length &&\n    a.every((ea, idx) => ea === b[idx])\n  )\n}\n\n/**\n * @return true if `prefix` == `haystack.slice(0, prefix.length)`.\n */\nexport function startsWith<T extends Primitive>(\n  haystack: T[],\n  prefix: T[]\n): boolean {\n  return eqlArray(haystack.slice(0, prefix.length), prefix)\n}\n\n/**\n * Retain all items from `arr` where the `keepIfTrue` returns `true`.\n * @return true if `arr` was changed.\n */\nexport function filterInPlace<T>(\n  arr: T[],\n  keepIfTrue: (item: T, index: number, ea: T[]) => boolean\n): T[] {\n  for (let i = 0; i < arr.length; ) {\n    if (keepIfTrue(arr[i], i, arr)) {\n      i++\n    } else {\n      arr.splice(i, 1)\n    }\n  }\n  return arr\n}\n\n/**\n * Retain all items from `arr` where the `keepIfTrue` returns `true`.\n * @return true if `arr` was changed.\n */\nexport async function filterInPlaceAsync<T>(\n  arr: T[],\n  keepIfTrue: (item: T, index: number, ea: T[]) => MaybeNullSyncOrAsync<boolean>\n): Promise<T[]> {\n  for (let i = 0; i < arr.length; ) {\n    if (true === (await keepIfTrue(arr[i], i, arr))) {\n      i++\n    } else {\n      arr.splice(i, 1)\n    }\n  }\n  return arr\n}\n\nexport function move<T>(arr: T[], fromIndex: number, toIndex: number): T[] {\n  if (\n    fromIndex === toIndex ||\n    fromIndex < 0 ||\n    toIndex < 0 ||\n    fromIndex >= arr.length ||\n    toIndex >= arr.length\n  ) {\n    return arr\n  }\n  const ea = arr[fromIndex]\n  arr.splice(fromIndex, 1)\n  arr.splice(toIndex, 0, ea)\n  return arr\n}\n\n// ES2016 polyfill that also supports Iterable\nexport function includes(\n  haystack: MaybeNull<any[] | Iterable<any>>,\n  needle: any\n): boolean {\n  if (haystack == null) return false\n  for (const ea of haystack) {\n    if (needle.valueOf() === ea.valueOf()) return true\n  }\n  return false\n}\n\nexport function indexOf<T>(\n  iter: Maybe<Iterable<T>>,\n  f: (t: T, index: number) => boolean\n): Maybe<number> {\n  if (iter == null) return\n  let index = 0\n  for (const ea of iter) {\n    if (f(ea, index)) return index\n    index++\n  }\n  return\n}\n\nexport function indexOfPrimitive<T>(\n  iter: Maybe<Iterable<T>>,\n  t: T\n): Maybe<number> {\n  if (iter == null) return\n  let index = 0\n  for (const ea of iter) {\n    if (ea === t) return index\n    index++\n  }\n  return\n}\n\nexport function includesAny(\n  haystack?: Primitive[],\n  needles?: Primitive[]\n): boolean {\n  return (\n    isNotEmpty(haystack) &&\n    isNotEmpty(needles) &&\n    haystack.some(ea => needles.includes(ea))\n  )\n}\n\n/**\n * @returns true iff all `needles` are found in `haystack`\n */\nexport function includesAll(\n  haystack?: Primitive[],\n  needles?: Primitive[]\n): boolean {\n  if (isEmpty(haystack) || isEmpty(needles)) return false\n  for (const needle of needles) {\n    if (!haystack.includes(needle)) return false\n  }\n  return true\n}\n\nexport function eqlPrimitiveUnordered(a: Primitive[], b: Primitive[]): boolean {\n  if (a == null || b == null || a.length !== b.length) return false\n  const a1 = sortBy(a, toPrimitive)\n  const b1 = sortBy(b, toPrimitive)\n  return a1.every((ea, idx) => ea === b1[idx])\n}\n\nexport function pushUniq<T>(arr: T[], ...items: T[]): T[] {\n  for (const item of items) {\n    if (item != null && !arr.some(ea => eql(ea, item))) {\n      arr.push(item)\n    }\n  }\n  return arr\n}\n\nexport function pushUniqBy<T>(\n  arr: T[],\n  items: T[],\n  valueOf: (t: T) => Comparable\n): T[] {\n  const vArr = arr.map(valueOf)\n  for (const item of items) {\n    const v = valueOf(item)\n    if (!vArr.includes(v)) {\n      arr.push(item)\n      vArr.push(v)\n    }\n  }\n  return arr\n}\n\nexport function insertAt<T>(arr: T[], index: number, ...items: T[]): T[] {\n  arr.splice(index, 0, ...items)\n  return arr\n}\n\n/**\n * Insert `item` into `arr` only if `item` is not in `arr` (according to `cmp`).\n *\n * Assumes `arr` is ascending-sorted.\n */\nexport function insertUniq<T>(\n  arr: T[],\n  item: T,\n  cmp_: (a: T, b: T) => number\n): T[] {\n  // verify the array is already in proper sort-order\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (cmp_(arr[i], arr[i + 1]) > 0) {\n      throw new Error(\"badly sorted array: \" + arr)\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    const ea = arr[i]\n    const c = cmp_(ea, item)\n    if (c === 0) return arr\n    // if item is greater than ea, insert right before ea\n    if (c > 0) {\n      arr.splice(i, 0, item)\n      return arr\n    }\n  }\n  arr.push(item)\n  return arr\n}\n\n// Can't call this delete, as that's a javascript keyword\nexport function remove<T>(arr: T[], ...element: T[]): boolean {\n  const before = arr.length\n  filterInPlace(arr, ea => element.every(ea2 => !eql(ea, ea2)))\n  return before !== arr.length\n}\n\nexport function removeSame<T>(arr: T[], ...element: T[]): boolean {\n  const before = arr.length\n  filterInPlace(arr, ea => element.every(ea2 => ea !== ea2))\n  return before !== arr.length\n}\n\n/**\n * Compact _the passed-in array_\n */\nexport function compact<T>(iter: MaybeNull<Iterable<T>>): Defined<T>[] {\n  // SITS: don't remove the toA: some callers may not give a proper iterable!\n  return iter == null ? [] : (filterInPlace(toA(iter), ea => ea != null) as any)\n}\n\nexport function compactBlanks<T>(iter: MaybeNull<Iterable<T>>): string[] {\n  // trim() to fix https://gitlab.com/mceachen/photostructure/issues/58\n  return iter == null\n    ? []\n    : toA(iter)\n        .map(ea => toS(ea).trim())\n        .filter(ea => ea.length > 0)\n}\n\nexport function compactBlankish<T>(iter: MaybeNull<Iterable<T>>): Defined<T>[] {\n  return iter == null ? [] : [...iter].filter(notBlankish)\n}\n\nexport function uniq<T>(arr: Maybe<Iterable<Maybe<T>>>): Defined<T>[] {\n  // PERF: if `arr` is empty or only 1 or 2 elements, maybe we don't have to\n  // call uniqBy:\n  if (arr == null) return []\n  const c = compact(arr)\n  if (c.length <= 1) return c\n  if (c.length < 10) {\n    const f = c[0]\n    if (c.every(ea => ea === f)) {\n      return [f]\n    }\n  }\n  return uniqBy(c, ea => (isPrimitive(ea) ? ea : stringify(ea)))\n}\n\nexport function uniqFirst<T>(arr: Maybe<Iterable<Maybe<T>>>): NonNullable<T>[] {\n  if (arr == null) return []\n  const result: NonNullable<T>[] = []\n  for (const ea of arr) {\n    if (ea != null && !eql(result[result.length - 1], ea)) {\n      result.push(ea as any)\n    }\n  }\n  return result\n}\n\nexport function uniqSubstrings(arr: Maybe<string>[]): string[] {\n  if (arr == null) return []\n  const strings = compact(arr)\n  if (arr.length === 0) return []\n  const result: string[] = []\n  for (const str of sortBy(strings, ea => [-ea.length, ea.toLowerCase()])) {\n    if (!result.some(ea => ea.includes(str))) {\n      result.push(str)\n    }\n  }\n  return sortBy(result, ea => strings.indexOf(ea))\n}\n\n/**\n * First-one-in-wins\n */\nexport function uniqBy<T, V extends Primitive>(\n  arr: Iterable<Maybe<T>>,\n  f: (t: T) => Maybe<V> = ea => stringify(ea) as V\n): T[] {\n  const m = new Map<V, T>()\n  for (const ea of arr) {\n    if (ea != null) {\n      const v = f(ea)\n      if (v != null) {\n        getOrSet(m, v, () => ea)\n      }\n    }\n  }\n  return [...m.values()]\n}\n\n/**\n * Last-one-in-wins\n */\nexport function uniqByLast<T, V extends Primitive>(\n  arr: Iterable<Maybe<T>>,\n  f: (t: T) => Maybe<V> = ea => stringify(ea) as V\n): T[] {\n  const m = new Map<V, T>()\n  for (const ea of arr) {\n    if (ea != null) {\n      const key = f(ea)\n      if (key != null) {\n        m.set(key, ea)\n      }\n    }\n  }\n  return [...m.values()]\n}\n\n/**\n * First-one-in-wins\n */\nexport function uniqBy2<T>(\n  arr: Maybe<T>[],\n  equals: (a: T, b: T) => boolean\n): T[] {\n  const result: T[] = []\n  for (const a of arr) {\n    if (a != null && result.every(b => !equals(a, b))) {\n      result.push(a)\n    }\n  }\n  return result\n}\n\nexport function clear<T>(arr: T[]): T[] {\n  arr.length = 0\n  return arr\n}\n\n/**\n * Equivalent to filtering all items in an array to a new array and calling\n * length. This method avoids creating the intermediate array.\n *\n * @return the number of elements in `arr` that `predicate` returns `true`.\n */\nexport function count<T>(\n  arr: T[],\n  predicate: (t: T, idx: number) => boolean\n): number {\n  return arr.reduce((acc, ea, idx) => acc + (predicate(ea, idx) ? 1 : 0), 0)\n}\n\n/**\n * Equivalent to mapping all items in an array to a new number array and calling\n * Vector.sum(). This method avoids creating the intermediate array.\n *\n * @return the sum of elements of `f`-transmuted numbers from `arr`.\n */\nexport function sum<T>(\n  arr: T[],\n  f: (t: T, currentIndex: number) => number\n): number {\n  return arr.reduce((acc, ea, idx) => acc + f(ea, idx), 0)\n}\n\nexport function firstMatch(\n  re: RegExp,\n  arr: Maybe<string>[]\n): Maybe<RegExpExecArray> {\n  for (const s of compact(arr)) {\n    const m = re.exec(s)\n    if (m != null) return m\n  }\n  return\n}\n\nexport function commonPrefixLength<T extends Primitive>(\n  a: Maybe<T[] | string>,\n  b: Maybe<T[] | string>\n): number {\n  if (a == null || b == null) return 0\n  if (a === b) return a.length\n  if (typeof a === \"string\") a = [...a] as T[]\n  if (typeof b === \"string\") b = [...b] as T[]\n  if (eqlArray(a, b)) return a.length\n  let result = 0\n  while (a[result] === b[result]) result++\n  return result\n}\n\n/**\n * Make random perturbations to `array` to minimize the given expense function\n */\nexport function anneal<T>({\n  array,\n  expense,\n  allowedDelta\n}: {\n  array: T[]\n  expense: (arr: T[], fromIndex: number, toIndex: number) => Comparable\n  allowedDelta: number\n}): T[] {\n  const delta = Math.round(allowedDelta)\n  if (delta < 2) return array\n  for (let mid = 0; mid < array.length - 1; mid++) {\n    const newPos = randomInt(\n      Math.max(0, mid - delta),\n      Math.min(array.length, mid + delta),\n      [mid]\n    )\n    if (newPos == null) continue\n    // the range is either [mid - 1, newPos + 1] or [newPos - 1, mid + 1]\n    const i = Math.max(0, Math.min(newPos, mid) - 1)\n    const j = Math.min(array.length, Math.max(newPos, mid) + 1)\n    const currentExpense = expense(array, i, j)\n    move(array, mid, newPos)\n    const newExpense = expense(array, i, j)\n    // undo the move if newExpense isn't better:\n    if (lt(currentExpense, newExpense)) {\n      move(array, newPos, mid)\n    }\n  }\n  return array\n}\n\n/**\n * @param from inclusive\n * @param to exclusive\n * @param f\n */\nexport function range<T = number>(\n  from: number,\n  to: number,\n  f: (i: number) => T = ea => ea as any\n): T[] {\n  return stepRange(from, to, 1, f)\n}\n\n/**\n * @param to return an array up to but not including `to`\n * @see https://docs.python.org/2/library/functions.html#range\n */\nexport function stepRange<T = number>(\n  from: number,\n  to: number,\n  step: number = 1,\n  f: (i: number) => T = ea => ea as any\n): T[] {\n  const r: T[] = []\n  if (from < to) {\n    for (let i = from; i < to; i += step) {\n      r.push(f(i))\n    }\n  } else {\n    for (let i = from; i > to; i -= step) {\n      r.push(f(i))\n    }\n  }\n  return r\n}\n\nexport const primitiveValueOfOrElse = (a: any) => {\n  if (isPrimitive(a)) {\n    return a\n  }\n  // [].valueOf() is worthless, so use json\n  if (Array.isArray(a)) {\n    return stringify(a)\n  }\n  if (isFunction(a.valueOf)) {\n    return a.valueOf()\n  } else {\n    throw new Error(\"Cannot get primitive value for \" + JSON.stringify(a))\n  }\n}\n\n/**\n * `minuend - subtrahend`.\n *\n * @template T must have a .valueOf() implementation\n * @param {T[]} minuend (haystack)\n * @param {T[]} subtrahend (needles)\n * @returns {T[]} values in `minuend` that, according to `.valueOf()`, are\n * not in `subtrahend`. Neither arg is mutated.\n */\nexport function diff<T>(\n  minuend: MaybeReadonlyArray<T>,\n  subtrahend: T[],\n  valueOf: (t: T) => Primitive = primitiveValueOfOrElse\n): T[] {\n  const s = new Set(subtrahend.map(valueOf))\n  return minuend.filter(ea => !s.has(valueOf(ea)))\n}\n\nexport function last<T>(arr: Maybe<T[]>): Maybe<T> {\n  return arr != null ? arr[arr.length - 1] : undefined\n}\n\nexport function commaList(arr: string[], finalJoin = \"or\"): string {\n  if (arr.length <= 1) return arr.join(\"\")\n  if (arr.length === 2) return arr.join(\" \" + finalJoin + \" \")\n  return (\n    arr.slice(0, -1).join(\", \") + \", \" + finalJoin + \" \" + arr[arr.length - 1]\n  )\n}\n\nexport function arrToIterator<T>(arr: T[]): IterableIterator<T> {\n  return arr[Symbol.iterator]()\n}\n\nexport function arrayEndsWith<T extends Comparable>(\n  arr: T[],\n  suffix: T[]\n): boolean {\n  if (arr.length < suffix.length) return false\n  for (let i = 0; i < suffix.length; i++) {\n    // PERF: avoids the slice (and subsequent GC)\n    if (arr[arr.length - suffix.length + i] !== suffix[i]) return false\n  }\n  return true\n}\n","export function copyArrayTo<T>(source: T[], destination: T[]): T[] {\n  for (let i = 0; i < source.length; i++) {\n    destination[i] = source[i]\n  }\n  destination.length = source.length\n  return destination\n}\n","import { compact, toPrimitive } from \"./Array\"\nimport { copyArrayTo } from \"./ArrayCopy\"\nimport { isIterable } from \"./Iterable\"\nimport { stringify } from \"./JSON\"\nimport { getOrSet } from \"./Map\"\nimport { Defined, map } from \"./Maybe\"\nimport { Maybe } from \"./MaybeTypes\"\nimport {\n  Comparable,\n  Primitivable,\n  Primitivables,\n  Primitive,\n  cmp\n} from \"./Primitive\"\nimport { toA } from \"./toA\"\n\nexport function sort<\n  T extends Primitive | Primitive[] | Primitivable | Primitivables\n>(arr: Maybe<T>[] | ReadonlyArray<Maybe<T>>): Defined<T>[] {\n  return sortByInPlace(compact(arr), toPrimitive)\n}\n\nexport function sortByInPlace<T>(arr: T[], f: (t: T) => Comparable): T[] {\n  return copyArrayTo(sortBy(arr, f), arr)\n}\n\nexport function sortUniqBy<T>(arr: T[], f: (t: T) => Comparable): T[] {\n  const m = new Map<string, T>()\n  for (const ea of arr) {\n    getOrSet(m, stringify(f(ea)), () => ea)\n  }\n  return sortBy(m.values(), f)\n}\n\nexport function sortUniq<T extends Comparable>(arr: T[]): T[] {\n  return sortUniqBy(arr, ea => ea)\n}\n\nexport function sortUniqByInPlace<T>(arr: T[], f: (t: T) => Comparable): T[] {\n  return copyArrayTo(sortUniqBy(arr, f), arr)\n}\n\nexport function isSorted(arr: Primitivable[]): boolean {\n  return arr.every((ea, idx) => idx === 0 || ea > arr[idx - 1])\n}\n\nexport function sortedBy<T>(arr: T[], f: (t: T) => Primitive): boolean {\n  return arr.every((ea, idx) => idx === 0 || f(ea) > f(arr[idx - 1]))\n}\n/**\n * Returns a copy of arr, stable sorted by the given constraint. Note that false\n * < true, and that `f` may return an array for sort priorities, or undefined if\n * the item should be skipped from the returned result.\n *\n * Note: localeSort() thinks lower case should come before upper case (!!)\n */\n\nexport function sortBy<T>(\n  arr: Iterable<Maybe<T>> | Maybe<T>[],\n  f: (t: T, index: number) => Maybe<Comparable | Comparable[]>\n): T[] {\n  return (toA(arr).filter(ea => ea != null) as T[])\n    .map((item, idx) => ({\n      item,\n      cmp: map(f(item, idx), ea => [ea, idx])\n    }))\n    .filter(ea => ea.cmp != null)\n    .sort((a, b) => cmp(a.cmp!, b.cmp!))\n    .map(ea => ea.item)\n}\n\nexport function deepSortBy<T, V extends Primitive | Primitive[]>(\n  arr: Iterable<T> | T[],\n  f: (t: T) => Maybe<V>\n): T[] {\n  return sortBy(arr, f).map(ea =>\n    isIterable(ea) ? deepSortBy(ea, f) : ea\n  ) as any // SITS typing\n}\n\nexport function pushSorted<T>(\n  arr: T[],\n  item: T,\n  f: (t: T) => Comparable | Comparable[]\n): T[] {\n  const idx = arr.findIndex(ea => f(item) < f(ea))\n  if (idx === -1) {\n    arr.push(item)\n  } else {\n    arr.splice(idx, 0, item)\n  }\n  return arr\n}\n","import { isFunction } from \"./isFunction\"\n\nexport type AsPromiseable<T> =\n  | T\n  | Promise<T>\n  | (() => T | Promise<T>)\n  | Promise<() => T | Promise<T>>\n\nexport async function asPromise<T>(o: AsPromiseable<T>): Promise<T> {\n  const a = await o\n  return isFunction(a) ? a() : a\n}\n","import { id2id, IDish } from \"./api/ID\"\nimport { compact } from \"./Array\"\nimport { blank } from \"./Blank\"\nimport { fmtLocalToShort } from \"./Date\"\nimport { ReducerName, ReducerNames } from \"./ImageReducers\"\nimport { SqWidths } from \"./ImageSizes\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { gt0, numericOr, toGt0 } from \"./Number\"\nimport { StringValued } from \"./Object\"\nimport { ThumbSize } from \"./ThumbSizes\"\nimport { toS } from \"./toS\"\nimport {\n  assembleFullPath,\n  mergeURLSearchParams,\n  URLSearchParamable\n} from \"./URLSearchParams\"\nimport { ua } from \"./UserAgent\"\nimport { isSafari } from \"./UserAgents\"\n\nfunction mkSrcSet(url: string, width: number) {\n  return url + \" \" + width + \"w\"\n}\n\nfunction toQuery(assetId: IDish, params?: Maybe<URLSearchParamable>[]) {\n  let result = params == null ? undefined : mergeURLSearchParams(...params)\n  const v = toS((assetId as any)[\"v\"])\n  if (!blank(v) && v !== \"1\") {\n    ;(result ??= new URLSearchParams()).append(\"v\", v)\n  }\n  return result\n}\n\nexport function assetUrl({\n  assetId,\n  params\n}: {\n  assetId: IDish\n  params?: Maybe<URLSearchParamable>[]\n}) {\n  return assetId == null\n    ? \"\"\n    : assembleFullPath(\"/asset/\" + id2id(assetId), toQuery(assetId, params))\n}\n\nexport function assetLinkAttrs({\n  assetId,\n  params\n}: {\n  assetId: IDish\n  params?: Maybe<URLSearchParamable>[]\n}) {\n  const href = assetUrl({ assetId, params })\n  return blank(href) ? {} : { href }\n}\n\n/**\n * resized preview image\n */\nexport function assetImgLink({\n  assetId,\n  reducer,\n  width,\n  params\n}: {\n  assetId: IDish\n  reducer: ReducerName\n  width?: number\n  params?: Maybe<URLSearchParamable>[]\n}) {\n  // Must match ImgRouter:\n  return assembleFullPath(\n    `/img/${id2id(assetId)}/${reducer}/${toGt0(width) ?? 320}`,\n    toQuery(assetId, params)\n  )\n}\n\n/**\n * Sends the full \"shown\" asset\n */\nexport function assetImgActualLink({\n  assetId,\n  assetFileId,\n  params\n}: {\n  assetId: IDish\n  assetFileId?: number\n  params?: Maybe<URLSearchParamable>[]\n}) {\n  // Must match ImgActualRouter:\n  return assembleFullPath(\n    `/img/${compact([id2id(assetId), assetFileId]).join(\"/\")}/actual`,\n    toQuery(assetId, params)\n  )\n}\n\nexport function assetVideoLink({\n  assetId,\n  assetFileId,\n  params\n}: {\n  assetId: IDish\n  assetFileId: number\n  params?: Maybe<URLSearchParamable>[]\n}): string {\n  return assembleFullPath(\n    `/video/${id2id(assetId)}-${assetFileId}`,\n    toQuery(assetId, params)\n  )\n}\n\nexport function assetSqImgAttrs({\n  assetId,\n  params,\n  lazyLoad,\n  size = \"m\"\n}: {\n  assetId: IDish\n  params?: Maybe<URLSearchParamable>[]\n  lazyLoad?: boolean\n  size?: ThumbSize\n}) {\n  return {\n    ...assetImgAttrs({\n      assetId,\n      params,\n      reducer: \"sq\",\n      widths: SqWidths,\n      lazyLoad\n    }),\n    // This is only directionally accurate. It's the max size expected for the\n    // given thumb size.\n    sizes:\n      (size === \"s\" ? 80 : size === \"m\" ? 160 : 320) *\n        numericOr((globalThis as any)?.window?.devicePixelRatio, 1) +\n      \"px\"\n  }\n}\n\nexport function assetImgAttrs({\n  assetId,\n  params,\n  reducer,\n  widths,\n  lazyLoad,\n  af\n}: {\n  assetId: IDish\n  params?: Maybe<URLSearchParamable>[]\n  reducer: ReducerName\n  widths?: number[]\n  lazyLoad?: boolean\n  af?: { assetFileId: number; width: number }\n}) {\n  const id = id2id(assetId)\n  if (id == null) {\n    return { src: \"/images/clear-64.png\" }\n  }\n  widths = (widths ?? []).filter(gt0)\n  if (widths.length === 0) widths.push(320) // backstop\n  const width = Math.min(...widths)\n  const attrs: StringValued = { width: toS(width) }\n  const title = fmtLocalToShort((assetId as any)[\"capturedAtLocal\"])\n  if (title != null) {\n    attrs.title = title\n  }\n  const src = assetImgLink({ assetId, params, reducer, width })\n  // TODO: safari and safari mobile doesn't support lazy loading.\n  lazyLoad ??= true\n  const laterLoad = lazyLoad && isSafari(ua())\n\n  if (laterLoad) {\n    attrs.src = \"/images/clear-64.png\"\n    attrs[\"data-src\"] = src\n  } else {\n    attrs.src = src\n  }\n\n  if (!isSafari(ua())) {\n    // safari doesn't support loading yet.\n    attrs.loading = lazyLoad ? \"lazy\" : \"eager\"\n  }\n\n  if (reducer === ReducerNames.sq) {\n    // attrs.sizes is set in the frontend based on the current thumbnail size.\n    attrs.height = toS(width)\n  }\n  const srcSetArr = widths.map(w =>\n    mkSrcSet(assetImgLink({ assetId, params, reducer, width: w }), w)\n  )\n  if (af != null) {\n    srcSetArr.push(\n      mkSrcSet(\n        assetImgActualLink({ assetId, params, assetFileId: af.assetFileId }),\n        af.width\n      )\n    )\n  }\n  attrs[(laterLoad ? \"data-\" : \"\") + \"srcSet\"] = srcSetArr.join(\",\")\n  return attrs\n}\n","import { delay } from \"./Delay\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { gt0 } from \"./Number\"\nimport { SyncOrAsync } from \"./SyncOrAsync\"\nimport { thenOrTimeoutError } from \"./ThenOrTimeout\"\nimport { toErr } from \"./toErr\"\n\nexport async function retryOnReject<T>(\n  f: () => SyncOrAsync<T>,\n  opts: {\n    maxRetries: number\n    timeoutMs?: number\n    retryDelay?: number\n    onRetryWaitUntil?: (retryCount: number) => any\n    errorIsRetriable?: (error: Error) => Maybe<boolean>\n  }\n): Promise<T> {\n  const g = gt0(opts.timeoutMs)\n    ? () => thenOrTimeoutError(f(), opts.timeoutMs!)\n    : f\n\n  if (opts.maxRetries <= 0) {\n    return g()\n  }\n  const onRetryWaitUntil =\n    opts.onRetryWaitUntil ??\n    ((retry: number) =>\n      delay(Math.max(250, (opts.retryDelay ?? 250) * (retry ?? 1))))\n\n  let retryCount = 0\n  const h: () => Promise<T> = async () => {\n    try {\n      return await g()\n    } catch (err) {\n      const error = toErr(err)!\n      if (\n        false === opts.errorIsRetriable?.(error) ||\n        retryCount > opts.maxRetries\n      ) {\n        throw error\n      } else {\n        retryCount++\n        await onRetryWaitUntil(retryCount)\n        return h()\n      }\n    }\n  }\n  return h()\n}\n","import { Maybe } from \"./MaybeTypes\"\n\n/**\n * @see https://github.com/tc39/proposal-relative-indexing-method#polyfill\n */\nexport function at<T>(arr: Maybe<T[]>, i: number) {\n  if (arr == null) return\n  // ToInteger() abstract op\n  i = Math.trunc(i) || 0\n  // Allow negative indexing from the end\n  if (i < 0) i += arr.length\n  // OOB access is guaranteed to return undefined\n  if (i < 0 || i >= arr.length) return undefined\n  // Otherwise, this is just normal property access\n  return arr[i]\n}\n","import { compactBlankish } from \"./Array\"\nimport { blank } from \"./Blank\"\nimport { flatten } from \"./Flatten\"\nimport { replaceAllMatches } from \"./RegExp\"\nimport { toS } from \"./toS\"\n\nexport function md2html(markdown: string) {\n  let result = markdown\n    // escape html, then add code blocks, bold, and list items\n    .replace(/</g, \"&lt;\")\n    // horizontal rule:\n    .replace(/^---$/gm, \"<hr/>\")\n    // Handle lists:\n    .replace(/^ *- (.*)$/gm, (_, s) => \"<li>\" + s.trim() + \"</li>\")\n\n  result = replaceAllMatches(\n    result,\n    /```([^`]+)```/g,\n    m => `<code>${m[1]}</code>`\n  )\n  result = replaceAllMatches(result, /\\*\\*([^*]+)\\*\\*/, m => `<b>${m[1]}</b>`)\n\n  return result\n}\n\nexport function tt(str: any) {\n  return blank(str) ? \"\" : \"```\" + toS(str) + \"```\"\n}\n\nexport function b(str: any) {\n  return \"**\" + toS(str) + \"**\"\n}\n\nexport function li(...arr: any[]) {\n  return compactBlankish(flatten(arr))\n    .map((s: any) => \"- \" + toS(s))\n    .join(\"\\n\")\n}\n","import { Defined, orElse } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toS } from \"./toS\"\n\n/**\n * @return true if o is nullish, an empty string, or only whitespace.\n */\nexport function blank(o: any): o is undefined {\n  // PERF: unrolled from Opt\n  return o == null || o === \"\"\n    ? true\n    : typeof o === \"string\"\n    ? o.trim() === \"\"\n    : false\n}\n\nexport function notBlank<T>(s: T): s is Defined<T> {\n  return !blank(s)\n}\n\nexport function notBlankToS(s: Maybe<any>) {\n  return notBlank(s) && s !== \"undefined\" ? toS(s).trim() : undefined\n}\n\n/** aka \"trimToUndefined\" */\nexport function toNotBlank(o: any): Maybe<string> {\n  if (o == null) return\n  const s = toS(o)\n  return s.length === 0 || s.trim().length === 0 ? undefined : s\n}\n\n/**\n * Equivalent to `Opt(s).flatMap(toS).filter(notBlank).getOrElse(() => orElse)`\n */\nexport function notBlankOr(s: any, ifBlank: ThunkOrT<string>): string {\n  if (s == null) return tot(ifBlank)\n  const str = toS(s).trim()\n  return str.length > 0 ? str : tot(ifBlank)\n}\n\nexport function notBlankAnd(s: any, f: (ea: string) => boolean): boolean {\n  return !blank(s) ? f(s) : false\n}\n\nexport function mapNotBlank<T>(arg: any, f: (s: string) => T): Maybe<T> {\n  if (arg === false || arg == null || arg === \"\") {\n    return undefined\n  }\n  const s = toS(arg)\n  return notBlank(s) ? f(s!) : undefined\n}\n\nexport function mapNotBlankOr<T>(\n  arg: any,\n  f: (s: string) => T,\n  defaultValue: T | (() => T)\n): T {\n  return orElse(mapNotBlank(arg, f), defaultValue)\n}\n\nexport function firstNotBlank(...arr: MaybeNull<string>[]): Maybe<string> {\n  // PERF: unrolled\n  for (const ea of arr) {\n    if (typeof ea === \"string\" && ea.trim().length > 0) return ea\n  }\n  return\n}\n\nconst BlankishRE = /^\\s*(?:(?:null|undefined)\\s*)?$/i\n\nexport function blankish(s: any): s is undefined {\n  return s == null || BlankishRE.test(toS(s))\n}\n\nexport function notBlankish<T>(s: T): s is Defined<T> {\n  return !blankish(s)\n}\n","import { Maybe } from \"../fe/MaybeTypes\"\n\nexport function isBoolean(object: any): object is boolean {\n  return typeof object === \"boolean\"\n}\n\n/**\n * (Fairly) strict coercion to true.\n *\n * @return false unless `o` is `true` or `1` (or stringifies to \"true\" or \"1\")\n */\nexport function isTrue(o: any): boolean {\n  if (typeof o === \"boolean\") {\n    return o\n  } else if (o == null) {\n    return false\n  } else if (o === 1) {\n    return true\n  } else {\n    const s = String(o).toLowerCase().trim()\n    return [\"true\", \"1\"].includes(s)\n  }\n}\n\n/**\n * (Fairly) strict coercion to boolean. If parsing fails, returns undefined.\n */\nexport function toBoolean(o: any): Maybe<boolean> {\n  return isTrue(o) ? true : isFalse(o) ? false : undefined\n}\n\nexport function boolToInt(o: any) {\n  return isTrue(o) ? 1 : 0\n}\n\n/**\n * (Fairly) strict coercion to false.\n *\n * @return false unless `o` is `false` or `0` (or stringifies to \"false\" or\n * \"0\")\n */\nexport function isFalse(o: any, ...synonyms: string[]): boolean {\n  if (typeof o === \"boolean\") return !o\n  if (o == null) return false\n  if (o === 0) return true\n  const s = String(o).toLowerCase()\n  return [\"false\", \"0\", ...synonyms].map(ea => ea.toLowerCase()).includes(s)\n}\n\nexport function isDisabled(o: any): boolean {\n  return isFalse(o, \"no\", \"disable\", \"disabled\")\n}\n\nexport function or(arr: any[]): boolean {\n  return arr.some(ea => isTrue(ea))\n}\n\nexport function and(arr: any[]): boolean {\n  return arr.every(ea => isTrue(ea))\n}\n\n/**\n * @return true if `arr` has at least one `true` and no `false` entries\n */\nexport function maybeAnd(arr: Maybe<boolean>[]): Maybe<boolean> {\n  let result: Maybe<boolean>\n  for (const ea of arr) {\n    if (ea === false) return false\n    if (ea === true) result = true\n  }\n  return result\n}\n\nexport function mapBoolean<T>(obj: any, f: (b: boolean) => T): Maybe<T> {\n  return isTrue(obj) ? f(true) : isFalse(obj) ? f(false) : undefined\n}\n\nexport function mapTrue<T>(b: any, f: () => T): Maybe<T> {\n  return isTrue(b) ? f() : undefined\n}\n","import { stringify } from \"./JSON\"\n\nexport function clone<T>(obj: T): T {\n  return obj == null ? obj : JSON.parse(stringify(obj))\n}\n\nexport function shallowClone<T>(obj: T): T {\n  return Array.isArray(obj)\n    ? [...obj]\n    : typeof obj === \"object\"\n    ? { ...obj }\n    : (obj as any)\n}\n","import { isEmpty } from \"./Array\"\nimport { blank } from \"./Blank\"\nimport { lazy } from \"./Lazy\"\nimport { map, mapOr } from \"./Maybe\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { isNumber, toFixedStr } from \"./Number\"\nimport { pad2, pad3 } from \"./Pad\"\nimport { ensurePrefix } from \"./String\"\nimport { plur } from \"./Units\"\n\nexport const secondMs = 1000\nexport const minuteMs = 60 * secondMs\nexport const hourMs = 60 * minuteMs\nexport const dayMs = 24 * hourMs\nexport const weekMs = 7 * dayMs\n/** TRY TO AVOID USING THIS (it's 32 * dayMs) */\nexport const monthMs = 32 * dayMs\nexport const yearMs = 365.25 * dayMs\n\nconst shortDateTimeFormat = lazy(\n  () =>\n    new Intl.DateTimeFormat(undefined, {\n      // weekday: \"short\",\n      year: \"numeric\",\n      month: \"short\",\n      day: \"numeric\",\n      hour: \"numeric\",\n      minute: \"numeric\",\n      second: \"numeric\"\n    })\n)\nconst shortDateFormat = lazy(\n  () =>\n    new Intl.DateTimeFormat(undefined, {\n      day: \"numeric\",\n      year: \"numeric\",\n      month: \"short\"\n    })\n)\n\nexport function toDate(d: Date | number): Date {\n  return d instanceof Date ? d : new Date(d)\n}\n\nexport function fmtDateShort(d: Date | number) {\n  if (d == null) return\n  return d instanceof Date &&\n    d.getHours() === 0 &&\n    d.getMinutes() === 0 &&\n    d.getSeconds() === 0\n    ? shortDateFormat().format(d)\n    : shortDateTimeFormat().format(d)\n}\n\n/**\n * split an HMS string into a (possibly empty) prefix of zeroes and the remaining suffix.\n */\nexport function splitHMS(hms: string): string[] {\n  return mapOr(\n    /^[0:]{1,4}/.exec(hms),\n    m => [m[0], hms.slice(m[0].length)],\n    () => [\"\", hms]\n  )\n}\n\nexport function isDate(obj: any): obj is Date {\n  return obj instanceof Date\n}\n\nexport function thisYear() {\n  return new Date().getFullYear()\n}\n\n/**\n * @return Date `deltaMs` in the past\n */\nexport function ago(deltaMs: number, from?: Date): Date {\n  return new Date((from?.getTime() ?? Date.now()) - deltaMs)\n}\n\n/**\n * @return Date `deltaMs` in the future\n */\nexport function hence(deltaMs: number, from?: Date): Date {\n  return ago(-deltaMs, from)\n}\n\nexport function unixtime(d?: Date | number): number {\n  const ms = isDate(d) ? d.getTime() : isNumber(d) ? d : Date.now()\n  return Math.floor(ms / secondMs)\n}\n\n/**\n * Appropriate for filenames: yMMddHHmmss\n */\nexport function fmtYMDHMS(arg: Date | number): string {\n  const d = toDate(arg)\n  return (\n    d.getFullYear() +\n    pad2(d.getMonth() + 1) +\n    pad2(d.getDate()) +\n    pad2(d.getHours()) +\n    pad2(d.getMinutes()) +\n    pad2(d.getSeconds())\n  )\n}\n\n/**\n * Format millis duration in HH:MM:SS.sss\n */\nexport function fmtHMS(\n  ms: number,\n  opts: { includeMs: boolean } = { includeMs: true }\n): string {\n  const h = Math.floor(ms / hourMs)\n  ms -= h * hourMs\n  const m = Math.floor(ms / minuteMs)\n  ms -= m * minuteMs\n  const s = Math.floor(ms / secondMs)\n  const millis = Math.floor(ms - s * secondMs)\n  return (\n    pad2(h) +\n    \":\" +\n    pad2(m) +\n    \":\" +\n    pad2(s) +\n    (opts.includeMs ? \".\" + pad3(millis) : \"\")\n  )\n}\n\nconst Units = [\n  { ms: yearMs, s: \"Y\" },\n  { ms: weekMs, s: \"W\" },\n  { ms: dayMs, s: \"D\" },\n  { ms: hourMs, s: \"H\" },\n  { ms: minuteMs, s: \"M\" }\n]\n\nexport function fmtIsoDuration(ms: number): string {\n  if (ms === 0) return \"PT0S\"\n  const dateParts: string[] = []\n  const timeParts: string[] = []\n  for (const unit of Units.slice(Units.findIndex(ea => ea.ms <= ms!))) {\n    const i = Math.floor(ms / unit.ms)\n    ms -= i * unit.ms\n    if (i > 0) (unit.ms >= dayMs ? dateParts : timeParts).push(i + unit.s)\n  }\n  if (ms > 0) {\n    timeParts.push(toFixedStr(ms / secondMs, 3) + \"S\")\n  }\n  return (\n    \"P\" +\n    dateParts.join(\"\") +\n    (isEmpty(timeParts) ? \"\" : \"T\" + timeParts.join(\"\"))\n  )\n}\n\n/**\n * ISO-formatted datestamp: y-MM-dd\n */\nexport function fmtIsoDate(ts: Date | number): string {\n  const d = isDate(ts) ? ts : new Date(ts)\n  return (\n    d.getFullYear() + \"-\" + pad2(d.getMonth() + 1) + \"-\" + pad2(d.getDate())\n  )\n}\n\nexport function localToDate(local: Maybe<number>): Maybe<Date> {\n  if (local == null || local < 0) return\n  let i = local\n  const pop2 = () => {\n    const result = i % 100\n    i = Math.floor(i / 100)\n    return result\n  }\n  const millisecond = 10 * pop2()\n  const second = pop2()\n  const minute = pop2()\n  const hour = pop2()\n  const day = pop2()\n  const month = pop2()\n  const year = i\n  return new Date(year, month - 1, day, hour, minute, second, millisecond)\n}\n\nexport function fmtLocalToShort(cs: number): Maybe<string> {\n  return map(localToDate(cs), fmtDateShort)\n}\n\nexport function nextMidnightTs() {\n  return new Date().setHours(24, 0, 0, 0)\n}\n\nexport function msUntilMidnight() {\n  // .setHours() returns getTime() (!?!)\n  return nextMidnightTs() - Date.now()\n}\n\nexport function fmtAgo(ts: number, suffix = \"ago\"): string {\n  return fmtElapsedMs(Date.now() - ts, suffix)\n}\n\nexport function fmtElapsedMs(ms: number, suffix = \"ago\"): string {\n  if (ms < 1000) return \"just now\"\n  suffix = blank(suffix) ? \"\" : ensurePrefix(suffix, \" \")\n  if (ms < minuteMs) return plur(Math.floor(ms / secondMs), \"second\") + suffix\n  if (ms < hourMs) return plur(Math.floor(ms / minuteMs), \"minute\") + suffix\n  if (ms < dayMs) return plur(Math.floor(ms / hourMs), \"hour\") + suffix\n  if (ms < weekMs) return plur(Math.floor(ms / dayMs), \"day\") + suffix\n  if (ms < yearMs) return plur(Math.floor(ms / weekMs), \"week\") + suffix\n  return plur(Math.floor(ms / yearMs), \"year\") + suffix\n}\n","export function dateToJson(d: Date) {\n  return {\n    _ctor: Date.name,\n    iso: d.toISOString()\n  }\n}\n","/* globals Symbol: false, Uint8Array: false, WeakMap: false */\n/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nimport { isBoolean } from \"./Boolean\"\n\nconst type_detect = require(\"type-detect\")\n\nexport interface MemoizeMap extends WeakMap<object, WeakMap<object, boolean>> {}\n\nexport interface DeepEqlOptions<T1 = unknown, T2 = unknown> {\n  /**\n   * Override default algorithm, determining custom equality.\n   */\n  comparator?: (\n    leftHandOperand: T1,\n    rightHandOperand: T2,\n    keyname?: string | symbol\n  ) => boolean | null\n\n  /**\n   * Provide a custom memoization object which will cache the results of\n   * complex objects for a speed boost.\n   *\n   * By passing `false` you can disable memoization, but this will cause circular\n   * references to blow the stack.\n   */\n  memoize?: MemoizeMap | false\n}\n\n/*!\n * Check to see if the MemoizeMap has recorded a result of the two operands\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @returns {Boolean|null} result\n */\nfunction memoizeCompare(\n  leftHandOperand: any,\n  rightHandOperand: any,\n  memoizeMap?: MemoizeMap\n): boolean | null {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (\n    memoizeMap == null ||\n    isPrimitive(leftHandOperand) ||\n    isPrimitive(rightHandOperand)\n  ) {\n    return null\n  }\n  const result = memoizeMap.get(leftHandOperand)?.get(rightHandOperand)\n  if (typeof result === \"boolean\") {\n    return result\n  }\n  return null\n}\n\n/*!\n * Set the result of the equality into the MemoizeMap\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @param {Boolean} result\n */\nfunction memoizeSet(\n  leftHandOperand: any,\n  rightHandOperand: any,\n  memoizeMap: MemoizeMap | undefined,\n  result: boolean\n) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (\n    memoizeMap == null ||\n    isPrimitive(leftHandOperand) ||\n    isPrimitive(rightHandOperand)\n  ) {\n    return\n  }\n  let leftHandMap = memoizeMap.get(leftHandOperand)\n  if (leftHandMap != null) {\n    leftHandMap.set(rightHandOperand, result)\n  } else {\n    leftHandMap = new WeakMap()\n    leftHandMap.set(rightHandOperand, result)\n    memoizeMap.set(leftHandOperand, leftHandMap)\n  }\n}\n\n/**\n * Assert deeply nested sameValue equality between two objects of any type.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm,\n * determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization\n    object which will cache the results of complex objects for a speed boost.\n    By passing `false` you can disable memoization, but this will cause\n    circular references to blow the stack.\n * @return {Boolean} equal match\n */\nexport function deepEql<T1 = unknown, T2 = unknown>(\n  leftHandOperand: T1,\n  rightHandOperand: T2,\n  options?: DeepEqlOptions<T1, T2> | undefined\n): boolean {\n  options ??= {}\n  if (false !== options.memoize) {\n    options.memoize ??= new WeakMap()\n  }\n  return _deepEqual(leftHandOperand, rightHandOperand, options)\n}\n\nfunction _deepEqual<T1 = unknown, T2 = unknown>(\n  leftHandOperand: T1,\n  rightHandOperand: T2,\n  options?: DeepEqlOptions<T1, T2> | undefined,\n  key?: string | symbol\n): boolean {\n  // If we have a comparator, we can't assume anything; so bail to its check first.\n  if (options?.comparator != null) {\n    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options, key)\n  }\n\n  const simpleResult = simpleEqual(leftHandOperand, rightHandOperand)\n  if (simpleResult !== null) {\n    return simpleResult\n  }\n\n  // Deeper comparisons are pushed through to a larger function\n  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options)\n}\n\n/**\n * Many comparisons can be canceled out early via simple equality or primitive checks.\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @return {Boolean|null} equal match\n */\nfunction simpleEqual(leftHandOperand: any, rightHandOperand: any) {\n  // Equal references (except for Numbers) can be returned early\n  if (leftHandOperand === rightHandOperand) {\n    // Handle +-0 cases\n    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand\n  }\n\n  // handle NaN cases\n  if (\n    leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare\n    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare\n  ) {\n    return true\n  }\n\n  // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,\n  // strings, and undefined, can be compared by reference.\n  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    // Easy out b/c it would have passed the first equality check\n    return false\n  }\n  return null\n}\n\n/*!\n * The main logic of the `deepEqual` function.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n*/\nfunction extensiveDeepEqual<T1 = unknown, T2 = unknown>(\n  leftHandOperand: T1,\n  rightHandOperand: T2,\n  options: DeepEqlOptions<T1, T2> | undefined,\n  key?: string | symbol\n): boolean {\n  options ??= {}\n  const memoize: MemoizeMap | undefined =\n    options.memoize === false\n      ? undefined\n      : (options.memoize ??= new WeakMap() as any)\n  const comparator = options?.comparator\n\n  // Check if a memoized result exists.\n  const memoizeResultLeft = memoizeCompare(\n    leftHandOperand,\n    rightHandOperand,\n    memoize\n  )\n  if (memoizeResultLeft !== null) {\n    return memoizeResultLeft\n  }\n  const memoizeResultRight = memoizeCompare(\n    rightHandOperand,\n    leftHandOperand,\n    memoize\n  )\n  if (memoizeResultRight !== null) {\n    return memoizeResultRight\n  }\n\n  // If a comparator is present, use it.\n  if (comparator) {\n    const comparatorResult = comparator(leftHandOperand, rightHandOperand, key)\n    // Comparators may return null, in which case we want to go back to default behavior.\n    if (comparatorResult === false || comparatorResult === true) {\n      memoizeSet(leftHandOperand, rightHandOperand, memoize, comparatorResult)\n      return comparatorResult\n    }\n    // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide\n    // what to do, we need to make sure to return the basic tests first before we move on.\n    const simpleResult = simpleEqual(leftHandOperand, rightHandOperand)\n    if (simpleResult !== null) {\n      // Don't memoize this, it takes longer to set/retrieve than to just compare.\n      return simpleResult\n    }\n  }\n\n  const leftHandType = type_detect(leftHandOperand)\n  if (leftHandType !== type_detect(rightHandOperand)) {\n    memoizeSet(leftHandOperand, rightHandOperand, memoize, false)\n    return false\n  }\n\n  // Temporarily set the operands in the memoize object to prevent blowing the stack\n  memoizeSet(leftHandOperand, rightHandOperand, memoize, true)\n\n  const result = extensiveDeepEqualByType(\n    leftHandOperand,\n    rightHandOperand,\n    leftHandType,\n    options as any\n  )\n  memoizeSet(leftHandOperand, rightHandOperand, memoize, result)\n  return result\n}\n\nfunction extensiveDeepEqualByType(\n  leftHandOperand: any,\n  rightHandOperand: any,\n  leftHandType: string,\n  options?: DeepEqlOptions | undefined\n) {\n  switch (leftHandType) {\n    case \"String\":\n    case \"Number\":\n    case \"Boolean\":\n    case \"Date\":\n      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values\n      return _deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf())\n    case \"Promise\":\n    case \"Symbol\":\n    case \"function\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return leftHandOperand === rightHandOperand\n    case \"Error\":\n      return keysEqual(\n        leftHandOperand,\n        rightHandOperand,\n        [\"name\", \"message\", \"code\"],\n        options\n      )\n    case \"Arguments\":\n    case \"Int8Array\":\n    case \"Uint8Array\":\n    case \"Uint8ClampedArray\":\n    case \"Int16Array\":\n    case \"Uint16Array\":\n    case \"Int32Array\":\n    case \"Uint32Array\":\n    case \"Float32Array\":\n    case \"Float64Array\":\n    case \"Array\":\n      return iterableEqual(leftHandOperand, rightHandOperand, options)\n    case \"RegExp\":\n      return regexpEqual(leftHandOperand, rightHandOperand)\n    case \"Generator\":\n      return generatorEqual(leftHandOperand, rightHandOperand, options)\n    case \"DataView\":\n      return iterableEqual(\n        new Uint8Array(leftHandOperand.buffer),\n        new Uint8Array(rightHandOperand.buffer),\n        options\n      )\n    case \"ArrayBuffer\":\n      return iterableEqual(\n        new Uint8Array(leftHandOperand),\n        new Uint8Array(rightHandOperand),\n        options\n      )\n    case \"Set\":\n      return entriesEqual(leftHandOperand, rightHandOperand, options)\n    case \"Map\":\n      return entriesEqual(leftHandOperand, rightHandOperand, options)\n    case \"Temporal.PlainDate\":\n    case \"Temporal.PlainTime\":\n    case \"Temporal.PlainDateTime\":\n    case \"Temporal.Instant\":\n    case \"Temporal.ZonedDateTime\":\n    case \"Temporal.PlainYearMonth\":\n    case \"Temporal.PlainMonthDay\":\n      return leftHandOperand.equals(rightHandOperand)\n    case \"Temporal.Duration\":\n      return (\n        leftHandOperand.total(\"nanoseconds\") ===\n        rightHandOperand.total(\"nanoseconds\")\n      )\n    case \"Temporal.TimeZone\":\n    case \"Temporal.Calendar\":\n      return leftHandOperand.toString() === rightHandOperand.toString()\n    default:\n      return objectEqual(leftHandOperand, rightHandOperand, options)\n  }\n}\n\n/*!\n * Compare two Regular Expressions for equality.\n *\n * @param {RegExp} leftHandOperand\n * @param {RegExp} rightHandOperand\n * @return {Boolean} result\n */\n\nfunction regexpEqual(leftHandOperand: RegExp, rightHandOperand: RegExp) {\n  return leftHandOperand.toString() === rightHandOperand.toString()\n}\n\n/*!\n * Compare two Sets/Maps for equality. Faster than other equality functions.\n *\n * @param {Set} leftHandOperand\n * @param {Set} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction entriesEqual(\n  leftHandOperand: Set<any> | Map<any, any>,\n  rightHandOperand: Set<any> | Map<any, any>,\n  options?: DeepEqlOptions | undefined\n): boolean {\n  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach\n  if (leftHandOperand.size !== rightHandOperand.size) {\n    return false\n  }\n  if (leftHandOperand.size === 0) {\n    return true\n  }\n  const leftHandItems: any[] = []\n  const rightHandItems: any[] = []\n  leftHandOperand.forEach(function gatherEntries(key, value) {\n    leftHandItems.push([key, value])\n  })\n  rightHandOperand.forEach(function gatherEntries(key, value) {\n    rightHandItems.push([key, value])\n  })\n  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options)\n}\n\n/*!\n * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction iterableEqual(\n  leftHandOperand: ArrayLike<any>,\n  rightHandOperand: ArrayLike<any>,\n  options?: DeepEqlOptions | undefined\n): boolean {\n  const length = leftHandOperand.length\n  if (length !== rightHandOperand.length) {\n    return false\n  }\n  if (length === 0) {\n    return true\n  }\n  let index = -1\n  while (++index < length) {\n    if (\n      _deepEqual(leftHandOperand[index], rightHandOperand[index], options) ===\n      false\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/*!\n * Simple equality for generator objects such as those returned by generator functions.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction generatorEqual(\n  leftHandOperand: Iterator<any>,\n  rightHandOperand: Iterator<any>,\n  options?: DeepEqlOptions | undefined\n): boolean {\n  return iterableEqual(\n    getGeneratorEntries(leftHandOperand),\n    getGeneratorEntries(rightHandOperand),\n    options\n  )\n}\n\n/*!\n * Determine if the given object has an @@iterator function.\n *\n * @param {Object} target\n * @return {Boolean} `true` if the object has an @@iterator function.\n */\nfunction hasIteratorFunction(target: any): boolean {\n  return (\n    typeof Symbol !== \"undefined\" &&\n    typeof target === \"object\" &&\n    typeof Symbol.iterator !== \"undefined\" &&\n    typeof target[Symbol.iterator] === \"function\"\n  )\n}\n\n/*!\n * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.\n * This will consume the iterator - which could have side effects depending on the @@iterator implementation.\n *\n * @param {Object} target\n * @returns {Array} an array of entries from the @@iterator function\n */\nfunction getIteratorEntries(target: any): any[] {\n  if (hasIteratorFunction(target)) {\n    try {\n      return getGeneratorEntries(target[Symbol.iterator]())\n    } catch (iteratorError) {\n      return []\n    }\n  }\n  return []\n}\n\n/*!\n * Gets all entries from a Generator. This will consume the generator - which could have side effects.\n *\n * @param {Generator} target\n * @returns {Array} an array of entries from the Generator.\n */\nfunction getGeneratorEntries(generator: Iterator<any>): any[] {\n  let generatorResult = generator.next()\n  const accumulator = [generatorResult.value]\n  while (generatorResult.done === false) {\n    generatorResult = generator.next()\n    accumulator.push(generatorResult.value)\n  }\n  return accumulator\n}\n\n/*!\n * Gets all own and inherited enumerable keys from a target.\n *\n * @param {Object} target\n * @returns {Array} an array of own and inherited enumerable keys from the target.\n */\nfunction getEnumerableKeys(target: any): string[] {\n  const keys = []\n  for (const key in target) {\n    if (target[key] !== undefined) keys.push(key)\n  }\n  return keys\n}\n\nfunction getEnumerableSymbols(target: any): symbol[] {\n  const keys = []\n  const allKeys = Object.getOwnPropertySymbols(target)\n  for (let i = 0; i < allKeys.length; i += 1) {\n    const key = allKeys[i]\n    if (Object.getOwnPropertyDescriptor(target, key)?.enumerable === true) {\n      keys.push(key)\n    }\n  }\n  return keys\n}\n\n/*!\n * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of\n * each key. If any value of the given key is not equal, the function will return false (early).\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\nfunction keysEqual(\n  leftHandOperand: any,\n  rightHandOperand: any,\n  keys: (string | symbol)[],\n  options?: DeepEqlOptions | undefined\n): boolean {\n  const length = keys.length\n  if (length === 0) {\n    return true\n  }\n  for (let i = 0; i < length; i += 1) {\n    const key = keys[i]\n    const lhs = leftHandOperand[key]\n    const rhs = rightHandOperand[key]\n    if (typeof lhs === \"function\" && typeof rhs === \"function\") {\n      if (lhs.toString() !== rhs.toString()) {\n        return false\n      }\n    } else {\n      const eql = _deepEqual(lhs, rhs, options, key)\n      if (eql === false) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/*!\n * Recursively check the equality of two Objects. Once basic sameness has been\n * established it will defer to `deepEqual` for each enumerable key in the\n * object.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\nfunction objectEqual(\n  leftHandOperand: Record<string | symbol, any>,\n  rightHandOperand: Record<string | symbol, any>,\n  options?: DeepEqlOptions | undefined\n): boolean {\n  if (typeof leftHandOperand.eql === \"function\") {\n    const result = leftHandOperand.eql(rightHandOperand)\n    if (isBoolean(result)) return result\n  }\n\n  if (typeof rightHandOperand.eql === \"function\") {\n    const result = rightHandOperand.eql(leftHandOperand)\n    if (isBoolean(result)) return result\n  }\n\n  if (typeof leftHandOperand.toJSON === \"function\") {\n    return objectEqual(leftHandOperand.toJSON(), rightHandOperand, options)\n  }\n\n  if (typeof rightHandOperand.toJSON === \"function\") {\n    return objectEqual(leftHandOperand, rightHandOperand.toJSON(), options)\n  }\n\n  if (\n    typeof leftHandOperand === \"object\" &&\n    typeof rightHandOperand === \"object\" &&\n    typeof leftHandOperand.constructor === \"function\" &&\n    typeof rightHandOperand.constructor === \"function\"\n  ) {\n    if (\n      false ===\n      objectEqual(\n        leftHandOperand.constructor,\n        rightHandOperand.constructor,\n        options\n      )\n    ) {\n      return false\n    }\n  }\n\n  const leftHandKeys = [\n    ...getEnumerableKeys(leftHandOperand),\n    ...getEnumerableSymbols(leftHandOperand)\n  ]\n  const rightHandKeys = [\n    ...getEnumerableKeys(rightHandOperand),\n    ...getEnumerableSymbols(rightHandOperand)\n  ]\n\n  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {\n    if (\n      iterableEqual(\n        mapSymbols(leftHandKeys).sort(),\n        mapSymbols(rightHandKeys).sort()\n      ) === false\n    ) {\n      return false\n    }\n    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options)\n  }\n\n  const leftHandEntries = getIteratorEntries(leftHandOperand)\n  const rightHandEntries = getIteratorEntries(rightHandOperand)\n  if (\n    leftHandEntries.length &&\n    leftHandEntries.length === rightHandEntries.length\n  ) {\n    leftHandEntries.sort()\n    rightHandEntries.sort()\n    return iterableEqual(leftHandEntries, rightHandEntries, options)\n  }\n\n  if (\n    leftHandKeys.length === 0 &&\n    leftHandEntries.length === 0 &&\n    rightHandKeys.length === 0 &&\n    rightHandEntries.length === 0\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/*!\n * Returns true if the argument is a primitive.\n *\n * This intentionally returns true for all objects that can be compared by reference,\n * including functions and symbols.\n *\n * @param {Mixed} value\n * @return {Boolean} result\n */\nfunction isPrimitive(value: any) {\n  return value === null || typeof value !== \"object\"\n}\n\nfunction mapSymbols(arr: any) {\n  return arr.map(function mapSymbol(entry: any) {\n    if (typeof entry === \"symbol\") {\n      return entry.toString()\n    }\n\n    return entry\n  })\n}\n","interface Defer<T> {\n  (): T\n  prior(): T | undefined\n}\n\n/**\n * Just like {@link MemoizedThunk}, but evaluated only once.\n */\nexport function defer<T>(thunk: () => T): Defer<T> {\n  let prior: T\n  let caught: Error\n  let applied = false\n  const result = function DeferImpl() {\n    if (applied) {\n      if (caught != null) throw caught\n      return prior!\n    }\n    try {\n      applied = true\n      return (prior = thunk())\n    } catch (error: any) {\n      caught = error\n      throw error\n    }\n  }\n  result.prior = () => prior\n  return result\n}\n","import { secondMs } from \"./Date\"\nimport { isBrowser, isNode } from \"./NodeOrBrowser\"\nimport { gt0 } from \"./Number\"\nimport { maybeCall } from \"./Object\"\n\nexport function delayUntil(date: Date | number) {\n  const t = gt0(date) ? date : date.getTime()\n  const delayMs = t - Date.now()\n  if (delayMs < 0) {\n    if (delayMs > -500) {\n      // meh close enough\n      return\n    } else {\n      throw new Error(\n        \"Mr. Fusion not found, cannot time travel back \" + -delayMs + \"ms\"\n      )\n    }\n  }\n  return delay(delayMs).then(() => delayMs)\n}\n\nexport function delay(millis: number, unref: boolean = true) {\n  // On windows at least, setTimeout() only ensures N-1 millis have passed.\n  return new Promise<void>(resolve => {\n    if (millis <= 0) {\n      resolve()\n    } else {\n      // ceil(+0.5) to make sure we wait enough time:\n\n      // SITS: any casting shenanigans to make this work on the frontend and\n      // backend:\n      const t: any = setTimeout(() => resolve(), Math.ceil(millis + 0.5))\n      if (millis > secondMs && unref && isNode) {\n        // if the millis is trivial, don't bother to unref\n        t.unref() // < only node has unref!\n      }\n    }\n  })\n}\n\nexport function later(f: () => any, delayMs: number = 1) {\n  const ms = Math.max(1, Math.ceil(delayMs))\n  const t = isNode && ms <= 1 ? setImmediate(f) : setTimeout(f, ms)\n  return isBrowser || delayMs <= secondMs ? t : maybeCall(t, \"unref\") ?? t\n}\n","import { Maybe } from \"./MaybeTypes\"\nimport { gt0, toGt0 } from \"./Number\"\nimport { swappableRotation } from \"./Rotation\"\nimport { megapixels, pixels2size } from \"./Units\"\n\nexport interface Dimensions {\n  width: number\n  height: number\n}\n\nexport function isDimensions(a: any): a is Dimensions {\n  return a != null && gt0(a.width) && gt0(a.height)\n}\n\nexport function isCloseAspectRatio(\n  a: Maybe<number>,\n  b: Maybe<number>,\n  withinRatio = 0.05\n): boolean {\n  return (\n    gt0(a) &&\n    gt0(b) &&\n    a > 1 === b > 1 && // both are portrait or both are landscape\n    Math.abs(a - b) <= Math.max(a, b) * withinRatio\n  )\n}\n\nexport function dimGte(a: Dimensions, b: Dimensions): boolean {\n  return a.width >= b.width && a.height >= b.height\n}\n\nexport function fmtDim(d: Dimensions, space = \" \") {\n  return `${d.width}${space}×${space}${d.height}`\n}\n\nexport function dimToSize(d: Dimensions) {\n  return pixels2size(d.width * d.height)\n}\n\n/**\n * return `{ width: dim.height, height: dim.width }`\n */\nexport function dimSwap(dim: Dimensions): Dimensions {\n  return { width: dim.height, height: dim.width }\n}\n\nexport function maybeDimSwap(\n  dim: Dimensions,\n  rotation: Maybe<number>\n): Dimensions {\n  return swappableRotation(rotation) ? dimSwap(dim) : dim\n}\n\nexport function maybeFlipInPlace(dim: Dimensions, rotation: Maybe<number>) {\n  if (swappableRotation(rotation)) {\n    ;[dim.width, dim.height] = [dim.height, dim.width]\n  }\n}\n\nexport function isPortrait(dim: Dimensions): boolean {\n  return dim.width / dim.height < 1\n}\n\nexport function dmegapixels(dim: Dimensions) {\n  return megapixels(pixels(dim))\n}\n\n/**\n * @return 0 if dim is invalid\n */\nexport function pixels(dim: Maybe<Dimensions>) {\n  return (toGt0(dim?.width) ?? 0) * (toGt0(dim?.height) ?? 0)\n}\n","import { deepEql } from \"./DeepEql\"\nimport { isFunction } from \"./isFunction\"\n\nexport function eql(a: any, b: any): boolean {\n  return deepEql(a, b, { comparator })\n}\n\n// export function isEqlSimple(a: any, b: any): boolean | undefined {\n//   // same pointer or primitive value is eql\n//   if (a === b) return true\n\n//   // undefined != null\n//   if (a == null || b == null) return false\n\n//   // a and b must be the same type\n//   if (typeof a !== typeof b) return false\n\n//   // typeof's match, so if either is a string, both are\n//   if (isString(a)) {\n//     return eqlStrings(a, b)\n//   }\n\n//   if (isPrimitive(a)) {\n//     return a === b\n//   }\n\n//   return undefined\n// }\n\n// const DefaultMaxDepth = 10\n\n// export function eql2(a: any, b: any, maxDepth = DefaultMaxDepth): boolean {\n//   if (maxDepth < 0) return true\n\n//   const simpleEql = isEqlSimple(a, b)\n//   if (simpleEql != null) return simpleEql\n\n//   // typeof [] === 'object' (!!!!), so don't test for isObject before isArray!\n//   if (Array.isArray(a) || Array.isArray(b)) {\n//     return isEqlArray(a, b, maxDepth - 1) ?? false\n//   }\n\n//   if (isFunction(a) && isFunction(b)) {\n//     // toString() returns the function implementation\n//     return a.toString() === b.toString()\n//   }\n\n//   if (typeof a === \"object\" && typeof b === \"object\") {\n//     return isEqlObject(a, b, maxDepth - 1)\n//   }\n//   return false\n// // }\n\n// export function isEqlArray(\n//   a: any,\n//   b: any,\n//   maxDepth = DefaultMaxDepth\n// ): boolean | undefined {\n//   if (!Array.isArray(a) || !Array.isArray(b)) return undefined\n//   if (a.length !== b.length) return false\n//   for (let i = 0; i < a.length; i++) {\n//     if (!eql(a[i], b[i], maxDepth - 1)) return false\n//   }\n//   return true\n// }\n\nexport function dateComparator(a: any, b: any): undefined | boolean {\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime()\n  }\n  return undefined\n}\n\nexport function functionComparator(a: any, b: any): undefined | boolean {\n  return isFunction(a) && isFunction(b)\n    ? a.toString() === b.toString()\n    : undefined\n}\n\nexport type Comparator = (a: any, b: any) => undefined | boolean\n\nconst objComparators: Comparator[] = [dateComparator, functionComparator]\nconst fieldComparators = new Map<string | symbol, Comparator>()\n\nexport function pushObjComparator(c: Comparator) {\n  objComparators.push(c)\n}\n\nexport function unshiftObjComparator(c: Comparator) {\n  objComparators.unshift(c)\n}\n\nexport function setFieldComparator(fieldName: string | symbol, c: Comparator) {\n  fieldComparators.set(fieldName, c)\n}\n\nfunction comparator(a: any, b: any, key?: string | symbol): boolean | null {\n  if (a == null || b == null) return a === b // null should not eql undefined\n  if (key != null) {\n    const c = fieldComparators.get(key)\n    if (c != null) return c(a, b) ?? null\n  }\n  for (const ea of objComparators) {\n    const r = ea(a, b)\n    if (r != null) return r\n  }\n  return null\n}\n\n// export function fieldEql(\n//   fieldName: string,\n//   a: any,\n//   b: any,\n//   maxDepth = DefaultMaxDepth\n// ): boolean {\n//   return maxDepth < 0\n//     ? true\n//     : fieldComparators?.get(fieldName)?.(a, b) ?? eql(a, b, maxDepth - 1)\n// }\n\n// export function isEqlObject(\n//   a: Record<string, unknown>,\n//   b: Record<string, unknown>,\n//   maxDepth = DefaultMaxDepth\n// ): boolean {\n//   if (maxDepth < 0 || typeof a !== \"object\" || typeof b !== \"object\")\n//     return false\n//   if (a === b) return true\n\n//   for (const c of objComparators) {\n//     const result = c(a, b)\n//     if (result != null) return result\n//   }\n\n//   if (isFunction(a.eql)) {\n//     const r = a.eql(b)\n//     if (isBoolean(r)) return r\n//   }\n\n//   if (isFunction(b.eql)) {\n//     const r = b.eql(a)\n//     if (isBoolean(r)) return r\n//   }\n\n//   const aObj = isFunction(a.toJSON) ? a.toJSON() : a\n//   const bObj = isFunction(b.toJSON) ? b.toJSON() : b\n\n//   const e = isEqlSimple(aObj, bObj)\n//   if (e != null) return e\n\n//   // the order of keys\n//   const aKeys = sort(keysWithDefinedValues(aObj))\n//   const bKeys = sort(keysWithDefinedValues(bObj))\n\n//   if (true !== isEqlArray(aKeys, bKeys, maxDepth)) return false\n\n//   for (const key of aKeys) {\n//     if (fieldEql(key, aObj[key], bObj[key], maxDepth - 1) === false) {\n//       return false\n//     }\n//   }\n//   return true\n// }\n","import { compact, compactBlankish, isEmpty, uniq } from \"./Array\"\nimport { blank, notBlank, toNotBlank } from \"./Blank\"\nimport { flatten } from \"./Flatten\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { toInt } from \"./Number\"\nimport { assignFields, compactValues, omit } from \"./Object\"\nimport { toS } from \"./toS\"\n\n// the space after the colon prevents URLs from being split:\nexport const ErrorDelimiter = \": \"\n\nexport const IgnoredErrorNames = [\"Error\", \"String\", \"Object\", \"WrappedError\"]\n\n/**\n * @return the `.name` or class name of the Error, or undefined if not\n * informative (like \"Error\" or \"WrappedError\")\n */\nexport function errorName(\n  err: Maybe<Error | { name?: string }>\n): Maybe<string> {\n  return err == null\n    ? undefined\n    : [err?.name, err?.constructor?.name]\n        .find(ea => ea != null && !IgnoredErrorNames.includes(ea))\n        ?.toString()\n}\n\nexport function errorCode(err: any): Maybe<string> {\n  return err == null ? undefined : toNotBlank(err?.code) // like \"EBUSY\"\n}\n\nexport function errorErrno(err: any): Maybe<number> {\n  return err == null ? undefined : toInt(err?.errno)\n}\n\n// We should skip over the stack frames that are created from creating frames:\nconst FramesToIgnoreRE = /shortStack|errorToVerbose/\n\nexport function shortStack(stack?: string, maxLines = 9): string[] {\n  try {\n    if (blank(stack)) {\n      const err = new Error()\n      // captureStackTrace may not be a function on some browsers\n      Error.captureStackTrace?.(err)\n      stack = err.stack\n    }\n\n    const result = toS(stack)\n      .split(\"\\n\")\n      .filter(\n        ea =>\n          !blank(ea) &&\n          ea.trim().startsWith(\"at \") &&\n          FramesToIgnoreRE.exec(ea) == null\n      )\n      .slice(0, maxLines)\n      .map(ea => ea.replace(/^\\s*at /i, \"\"))\n\n    return isEmpty(result) ? [\"(missing stack)\"] : result\n  } catch (err) {\n    return [\"Failed to captured stacktrace: \" + err]\n  }\n}\n\nexport function asError(reason?: any): Error {\n  if (blank(reason)) {\n    throw new Error(\"undefined error\")\n  } else if (reason instanceof Error) {\n    return reason\n  } else if (Array.isArray(reason)) {\n    const first = reason[0]\n    if (first instanceof Error) {\n      if (reason.length > 1) {\n        ;(first as any).errors = reason.slice(1)\n      }\n      return first\n    } else {\n      return new Error(\n        reason\n          .map(ea => toS(ea))\n          .filter(notBlank)\n          .join(\", \")\n      )\n    }\n  } else {\n    // Errors render as \"Error: something bad happened\". If you create a new\n    // Error from that string, you'll get an Error that toString's to \"Error:\n    // Error: something bad happened\", so strip the name of the error and give\n    // it to the return value:\n    const s = errorToS(reason).replace(/^Error: /i, \"\")\n    return new Error(s)\n  }\n}\n\nexport function errorToJson(error: Error) {\n  return compactValues({\n    _ctor: Error.name,\n    message: error.message ?? String(error),\n    stack: error.stack,\n    name: errorName(error),\n    code: errorCode(error),\n    errno: errorErrno(error),\n    ...omit(error as any, \"name\", \"message\", \"code\", \"errno\")\n  })!\n}\n\nexport function errorFromJson(obj: any) {\n  return assignFields(new Error(), omit(obj, \"_ctor\"))\n}\n\n// core has a fancier version of this:\nexport function errorToArr(...errors: any[]): string[] {\n  const arr = []\n  for (const ea of errors) {\n    if (ea == null) continue\n    if (ea instanceof Error) {\n      arr.push(errorName(ea), errorCode(ea), ea?.message)\n    } else {\n      arr.push(toS(ea))\n    }\n  }\n  return uniq(\n    compactBlankish(flatten(compact(arr).map(ea => ea.split(ErrorDelimiter))))\n  )\n}\n\n// core has a fancier version of this:\nexport function errorToS(...errors: any[]): string {\n  return errorToArr(...errors).join(ErrorDelimiter)\n}\n","import { Dimensions } from \"./Dimensions\"\n\nexport function fitInside(input: Dimensions, max: Dimensions) {\n  const inputAspectRatio = input.width / input.height\n  const maxAspectRatio = max.width / max.height\n\n  if (inputAspectRatio >= maxAspectRatio) {\n    // too wide, height takes aspect ratio into account.\n    const width = max.width\n    return {\n      width,\n      height: Math.floor(width / inputAspectRatio)\n    }\n  } else {\n    // too tall, width takes aspect ratio into account.\n    const height = max.height\n    return {\n      width: Math.floor(height * inputAspectRatio),\n      height\n    }\n  }\n}\n","import { MaybeNull } from \"./MaybeTypes\"\nimport { MaybeReadonlyArray } from \"./Readonly\"\nimport { toA } from \"./toA\"\n\n/**\n * Compacts and flattens ONE LEVEL\n */\nexport function flatten<T>(\n  arr: MaybeReadonlyArray<MaybeNull<T> | MaybeNull<T>[]>,\n  result: T[] = []\n): T[] {\n  for (const ea1 of toA(arr)) {\n    if (ea1 != null) {\n      for (const ea2 of toA(ea1)) {\n        if (ea2 != null) result.push(ea2)\n      }\n    }\n  }\n  return result\n}\n","import { compact, isEmpty } from \"./Array\"\nimport { dayMs, hourMs, minuteMs, secondMs, weekMs, yearMs } from \"./Date\"\nimport { mapOr } from \"./Maybe\"\nimport { gte0, isNumber } from \"./Number\"\nimport { plur } from \"./Units\"\n\nconst Units = [\n  { ms: yearMs, s: \"year\", p: \"years\" },\n  { ms: yearMs / 12, s: \"month\", p: \"months\" }, // oof, but this is fuzzy\n  { ms: weekMs, s: \"week\", p: \"weeks\" },\n  { ms: dayMs, s: \"day\", p: \"days\" },\n  { ms: hourMs, s: \"hour\", p: \"hours\" },\n  { ms: minuteMs, s: \"minute\", p: \"minutes\" },\n  { ms: secondMs, s: \"second\", p: \"seconds\" }\n]\n\n/**\n * CAUTION: this is for human consumption, not robots: we render rough\n * \"months\"!\n */\nexport function fmtDuration(\n  ms: number,\n  units: number = 2,\n  suffix?: { singular: string; plural: string }\n): string {\n  if (!gte0(ms)) {\n    return !isNumber(ms) ? \"\" : \"-\" + fmtDuration(Math.abs(ms), units)\n  }\n  const largestUnitIndex = Units.findIndex(ea => ea.ms <= ms)\n  if (largestUnitIndex === -1) return \"\"\n  let remaining =\n    ms +\n    // hack for rounding:\n    mapOr(\n      Units[largestUnitIndex + Math.max(2, units) - 1],\n      ea => Math.round(ea.ms * 0.4),\n      0\n    )\n  const result = compact(\n    Units.slice(largestUnitIndex, largestUnitIndex + units).map(unit => {\n      if (unit.ms > remaining) {\n        return\n      } else {\n        const i = Math.floor(remaining / unit.ms)\n        remaining -= i * unit.ms\n        return { i, s: plur(i, unit.s, unit.p) }\n      }\n    })\n  )\n  if (isEmpty(result)) return \"\"\n  return (\n    result.map(ea => ea.s).join(\", \") +\n    mapOr(\n      suffix,\n      ea => \" \" + (result[result.length - 1].i !== 1 ? ea.singular : ea.plural),\n      \"\"\n    )\n  )\n}\n","import { compactBlanks, uniq } from \"./Array\"\n\nexport function fmtList(arr: string[], joinWord: string): string {\n  arr = uniq(compactBlanks(arr))\n  return arr == null || arr.length === 0\n    ? \"\"\n    : arr.length === 1\n    ? arr.join(\"\")\n    : arr.slice(0, -1).join(\", \") +\n      \" \" +\n      joinWord.trim() +\n      \" \" +\n      arr[arr.length - 1]\n}\n\nexport function orList(arr: string[]): string {\n  return fmtList(arr, \"or\")\n}\n\nexport function andList(arr: string[]): string {\n  return fmtList(arr, \"and\")\n}\n","import { Emoji } from \"./Emoji\"\nimport { IconName } from \"./IconName\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { PrimitiveValued } from \"./Primitive\"\nimport { RunStateEnum } from \"./RunStateEnum\"\nimport { ServiceName, ServiceNames } from \"./ServiceNames\"\nimport { StrEnumKeys, strEnum } from \"./StrEnum\"\n\nexport const HealthCheckSections = strEnum(\n  \"Summary\",\n  \"Library\",\n  // \"Storage\",\n  \"System\",\n  \"Tools\"\n)\nexport type HealthCheckSection = StrEnumKeys<typeof HealthCheckSections>\n\nconst HealthCheckEmoji: Record<HealthCheckSection, Emoji> = {\n  Summary: \"bookmark-tabs\",\n  Library: \"library\",\n  // Storage: \"dvd\",\n  System: \"computer\",\n  Tools: \"wrench\"\n} as const\n\nexport const HealthCheckLevels = strEnum(\n  \"error\",\n  \"no-library\",\n  \"pending\",\n  \"stop-sync\",\n  \"warn\",\n  \"ok\",\n  \"disabled\"\n)\nexport type HealthCheckLevel = StrEnumKeys<typeof HealthCheckLevels>\n\nconst OkLevels = [\n  HealthCheckLevels.ok,\n  HealthCheckLevels.disabled,\n  HealthCheckLevels.pending\n] as HealthCheckLevel[]\n\nexport function levelIsNotOK(level: HealthCheckLevel) {\n  return !OkLevels.includes(level)\n}\n\nexport function isHealthCheckLevelFatal(\n  level: HealthCheckLevel,\n  serviceName: ServiceName\n) {\n  if (\n    ([ServiceNames.web, ServiceNames.main] as ServiceName[]).includes(\n      serviceName\n    )\n  ) {\n    // main and web should never be in a fatal state:\n    return false\n  }\n  // Only keep main and web running if HealthChecks are in error state:\n  if (level === HealthCheckLevels.error) return true\n  if (\n    serviceName === ServiceNames.sync &&\n    level === HealthCheckLevels[\"no-library\"]\n  ) {\n    // sync requires a library to do work:\n    return true\n  }\n  return false\n}\n\nexport const HealthCheckLevelToEmoji: Record<HealthCheckLevel, Emoji> = {\n  pending: \"busy-dots\",\n  \"no-library\": \"new-yellow\",\n  ok: \"green-check\",\n  warn: \"warning\",\n  \"stop-sync\": \"pause\",\n  error: \"error\",\n  disabled: \"sleeping-face-desat\"\n} as const\n\nexport function healthCheckLevelToEmoji(level: HealthCheckLevel): Emoji {\n  return HealthCheckLevelToEmoji[level]\n}\n\nexport const HealthCheckLevelDescription = {\n  pending: \"Health checks are running...\",\n  \"no-library\": \"No library is open\",\n  ok: \"OK\",\n  warn: \"Warning\",\n  \"stop-sync\": \"Some health checks are preventing sync from running\",\n  error: \"Some health checks failed: sync will not run\",\n  disabled: \"Some health checks are disabled\" // < shouldn't ever show\n} as const\n\nexport interface Link {\n  text: string\n  method?: \"POST\" | \"GET\"\n  type?: \"button\" | \"link\"\n  title?: string\n  url: string\n  icon?: IconName\n}\n\nexport interface HealthCheckResult {\n  section: HealthCheckSection\n  id: string\n  level: HealthCheckLevel\n  msg: string[]\n  /**\n   * When this result was completed\n   */\n  ts: number\n  /**\n   * How long it took to complete this result\n   */\n  elapsedMs?: number\n  meta?: PrimitiveValued\n  links?: Maybe<Link[]>\n  buttons?: Maybe<Link[]>\n}\n\nexport interface HealthChecksForSection {\n  section: HealthCheckSection\n  emoji: string\n  results: HealthCheckResult[]\n}\n\nexport interface HealthCheckSummary extends HealthCheckResult {\n  settled: boolean\n  settledCount: number\n  pendingCount: number\n  pendingIds: string[]\n  state: RunStateEnum\n  /**\n   * If we're not OK, what's the first HealthCheck.id that caused this level?\n   */\n  linkIds?: string[]\n}\n\nexport const BaseHealthCheckSummary = {\n  id: \"summary\",\n  section: HealthCheckSections.Summary\n} as const\n\nexport function newHealthCheckSections(): HealthChecksForSection[] {\n  return HealthCheckSections.values.map(section => ({\n    section,\n    emoji: HealthCheckEmoji[section],\n    results:\n      section === \"Summary\"\n        ? [\n            {\n              ...BaseHealthCheckSummary,\n              level: \"pending\",\n              settled: false,\n              ts: Date.now(),\n              msg: [\"⌚ Requesting health check results...\"]\n            }\n          ]\n        : []\n  }))\n}\n","import { strEnum, StrEnumKeys } from \"./StrEnum\"\n\n// export const ReducerNames = strEnum(\"fit\", \"fill\", \"sq\")\nexport const ReducerNames = strEnum(\"fit\", \"sq\")\nexport type ReducerName = StrEnumKeys<typeof ReducerNames>\n","import { strEnum, StrEnumKeys } from \"./StrEnum\"\n\n/**\n * @see https://en.wikipedia.org/wiki/Graphics_display_resolution\n */\nexport const FitSizes = strEnum(\n  \"uhd8k\",\n  \"uhd5k\",\n  \"uhd4k\",\n  \"qhd\",\n  \"fhd\",\n  \"hd\",\n  \"wvga\",\n  \"qvga\",\n  \"qqvga\"\n)\nexport type FitSize = StrEnumKeys<typeof FitSizes>\nexport const FitSizeValues = FitSizes.values\n\nexport const SqSizes = strEnum(\"s480\", \"s240\", \"s120\", \"s60\")\nexport type SqSize = StrEnumKeys<typeof SqSizes>\n\nexport const SqWidths = [60, 120, 240, 480]\n\nexport type ImageSizeName = FitSize | SqSize\n","import { gt0, gte0, lt0 } from \"./Number\"\n\n/**\n * @return true if obj is both Iterable *and not a string* (because srsly wth)\n */\nexport function isIterable(obj: any): obj is Iterable<any> {\n  return (\n    obj != null &&\n    typeof obj !== \"string\" &&\n    typeof obj[Symbol.iterator] === \"function\"\n  )\n}\n\n// export function max<T>(i: Iterable<T>, f: (t: T) => Comparable): Maybe<T> {\n//   let result = undefined\n//   let m = undefined\n//   for (const ea of i) {\n//     const r = f(ea)\n//     if (m == null || m < r) {\n//       m = r\n//       result = ea\n//     }\n//   }\n//   return result\n// }\n\nexport function sliceIterable<T>(\n  iterable: Iterable<T>,\n  start: number,\n  end?: number\n): T[] {\n  // If start is negative, we have to iterate the whole thing anyway, so\n  // delegate to Array.slice():\n  if (lt0(start)) {\n    return [...iterable].slice(start, end)\n  }\n\n  const iter = iterable[Symbol.iterator]()\n  if (gt0(start)) {\n    for (let i = 0; i < start; i++) {\n      iter.next()\n    }\n  }\n  const result: T[] = []\n\n  // if end is null, run until .done:\n  for (let i = start; gte0(end) ? i < end : true; i++) {\n    const next = iter.next()\n    // This is pretty lame of the iterator interface, IMHO. Don't return an\n    // object with a value if it doesn't have a value!\n    if (next.value != null || next.done !== true) {\n      result.push(next.value)\n    }\n    if (next.done === true) {\n      break\n    }\n  }\n  // don't splice! This may change the underlying iterable!\n  if (lt0(end)) {\n    return result.slice(0, end)\n  }\n  return result\n}\n\nexport function countIterable(i: Iterable<any>): number {\n  // Avoids GC from creating an array\n  let c = 0\n  const iter = i[Symbol.iterator]()\n  while (true !== iter.next().done) c++\n  return c\n}\n","import { dateToJson } from \"./DateToJson\"\nimport { errorFromJson, errorToJson } from \"./Error\"\nimport { denull } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { isFunction } from \"./isFunction\"\n\nexport type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | { [property: string]: Json }\n  | Json[]\n\nexport type DatedJson =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | Date\n  | { [property: string]: DatedJson }\n  | DatedJson[]\n\n/**\n * Work-alike to JSON.stringify, except that circular dependencies are replaced\n * with a string reference.\n */\nexport function stringify(\n  ea: any,\n  replacer?: (this: any, key: string, value: any) => any,\n  space?: string | number\n): string {\n  return JSON.stringify(decycle(ea), replacer, denull(space))\n}\n\nexport function stringifyPretty(ea: any, indent = 2) {\n  return stringify(ea, undefined, indent)\n}\n\nexport interface JsonReviver {\n  name: string\n  fromJSON(ea: any): any\n}\n\nconst Revivers = new Map<string, JsonReviver>()\n\nexport function addJsonRevivers(...arr: JsonReviver[]) {\n  for (const ea of arr) {\n    Revivers.set(ea.name, ea)\n  }\n}\n\naddJsonRevivers(\n  {\n    name: Error.name,\n    fromJSON: errorFromJson\n  },\n  {\n    name: Date.name,\n    fromJSON: ea => new Date(ea.iso)\n  }\n)\n\nexport function parseJSON_<T>(s: string): T {\n  return retrocycle(JSON.parse(s, reviver)) as any\n}\n\nexport function parseJSON<T = any>(s: MaybeNull<string | Buffer>): Maybe<T> {\n  try {\n    const s2 = s?.toString().trim()\n    if (s2 != null && s2.length > 0) {\n      return parseJSON_(s2)\n    }\n  } catch {\n    //\n  }\n  return\n}\n\nfunction reviver(_key: string, value: any) {\n  // PERF: map inlined\n  const r = Revivers.get(value?._ctor)\n  return r == null ? value : r.fromJSON(value)\n}\n\nfunction toJSON(obj: any) {\n  return (\n    // We have to avoid Date.toJSON(): it just returns a string\n    (obj instanceof Date ? dateToJson(obj) : undefined) ??\n    obj?.toJSON?.() ??\n    (obj instanceof Error ? errorToJson(obj) : obj)\n  )\n}\n\n// https://github.com/douglascrockford/JSON-js/blob/master/cycle.js\n\n/**\n * Make a deep copy of an object or array, assuring that there is at most\n * one instance of each object or array in the resulting structure. The\n * duplicate references (which might be forming cycles) are replaced with\n * an object of the form\n *      {\"$ref\": PATH}\n * where the PATH is a JSONPath string that locates the first occurrence.\n * So,\n *      var a = [];\n *      a[0] = a;\n *      return JSON.stringify(JSON.decycle(a));\n * produces the string '[{\"$ref\":\"$\"}]'.\n * If a replacer function is provided, then it will be called for each value.\n * A replacer function receives a value and returns a replacement value.\n * JSONPath is used to locate the unique object. $ indicates the top level of\n * the object or array. [NUMBER] or [STRING] indicates a child element or\n * property.\n */\nfunction decycle(object: any) {\n  const objects: any[] = [] // Keep a reference to each unique object or array\n  const paths: string[] = [] // Keep the path to each unique object or array\n\n  return (function derez(value, path): any {\n    // The derez recurses through the object, producing the deep copy.\n\n    if (isFunction(value)) return undefined\n\n    let i: number // The loop counter\n    let name: string // Property name\n    let nu: any // The new object or array\n\n    let _value = toJSON(value)\n\n    // typeof null === 'object', so go on if this value is really an object but not\n    // one of the weird builtin objects.\n\n    if (typeof _value === \"object\" && _value != null) {\n      // Remove all fields that shouldn't be serialized:\n      for (const k in _value) {\n        if (k.startsWith(\"__\")) {\n          if (value === _value) {\n            _value = { ..._value }\n          }\n          delete _value[k]\n        }\n      }\n\n      // If the value is an object or array, look to see if we have already\n      // encountered it. If so, return a $ref/path object. This is a hard way,\n      // linear search that will get slower as the number of unique objects grows.\n\n      for (i = 0; i < objects.length; i += 1) {\n        if (objects[i] === _value) {\n          return { $ref: paths[i] }\n        }\n      }\n\n      // Otherwise, accumulate the unique value and its path.\n\n      objects.push(_value)\n      paths.push(path)\n\n      // If it is an array, replicate the array.\n\n      if (Array.isArray(_value)) {\n        nu = []\n\n        for (i = 0; i < _value.length; i += 1) {\n          nu[i] = derez(_value[i], path + \"[\" + i + \"]\")\n        }\n      } else {\n        // If it is an object, replicate the object.\n\n        nu = {}\n\n        for (name in _value) {\n          if (Object.prototype.hasOwnProperty.call(_value, name)) {\n            nu[name] = derez(\n              _value[name],\n              path + \"[\" + JSON.stringify(name) + \"]\"\n            )\n          }\n        }\n      }\n\n      return nu\n    }\n\n    return _value\n  })(object, \"$\")\n}\n\n/**\n  * Restore an object that was reduced by decycle. Members whose values are\n  * objects of the form\n  *      {$ref: PATH}\n  * are replaced with references to the value found by the PATH. This will\n  * restore cycles. `value` will be mutated.\n\n  * The eval function is used to locate the values described by a PATH. The\n  * root object is kept in a $ variable. A regular expression is used to\n  * assure that the PATH is extremely well formed. The regexp contains nested\n  * * quantifiers. That has been known to have extremely bad performance\n  * problems on some browsers for very long strings. A PATH is expected to be\n  * reasonably short. A PATH is allowed to belong to a very restricted subset of\n  * Goessner's JSONPath.\n\n  * So,\n  *      const s = '[{\"$ref\":\"$\"}]';\n  *      return JSON.retrocycle(JSON.parse(s));\n  * produces an array containing a single element which is the array itself.\n*/\nfunction retrocycle($: any) {\n  const px =\n    // eslint-disable-next-line no-control-regex\n    /^\\$(?:\\[(?:\\d+|\"(?:[^\\\\\"\\u0000-\\u001f]|\\\\(?:[\\\\\"/bfnrt]|u[\\da-zA-Z]{4}))*\")\\])*$/\n\n  ;(function rez(value) {\n    // The rez function walks recursively through the object looking for $ref\n    // properties. When it finds one that has a value that is a path, then it\n    // replaces the $ref object with a reference to the value that is found by\n    // the path.\n\n    let i, item, name, path\n\n    if (value != null && typeof value === \"object\") {\n      if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n        for (i = 0; i < value.length; i += 1) {\n          item = value[i]\n\n          if (item != null && typeof item === \"object\") {\n            path = item.$ref\n\n            if (typeof path === \"string\" && px.test(path)) {\n              value[i] = eval(path)\n            } else {\n              rez(item)\n            }\n          }\n        }\n      } else {\n        for (name in value) {\n          if (typeof value[name] === \"object\") {\n            item = value[name]\n\n            if (item != null) {\n              path = item.$ref\n\n              if (typeof path === \"string\" && px.test(path)) {\n                value[name] = eval(path)\n              } else {\n                rez(item)\n              }\n            }\n          }\n        }\n      }\n    }\n  })($)\n\n  return $\n}\n","import { PromiseState } from \"./PromiseState\"\n\n// This is used by logging, so it can't have any dependencies.\n\n/**\n * Simple one-count concurrent barrier\n */\nexport class Latch implements Promise<void> {\n  // required by lib.es2015:\n  readonly [Symbol.toStringTag] = \"Latch\"\n  // Expose `promise` so we can have a honest-to-goodness Promise\n  readonly promise: Promise<void>\n  private _state: PromiseState = \"pending\"\n  error?: Error\n  private _resolve!: () => void\n  private _reject!: (err?: Error) => void\n\n  constructor(readonly id?: any) {\n    this.promise = new Promise<void>((resolve, reject) => {\n      this._resolve = resolve\n      this._reject = reject\n    })\n  }\n\n  // This is used by LogMeta for logging:\n  toLogJSON() {\n    return {\n      _ctor: \"Latch\",\n      id: this.id,\n      state: this.state()\n    }\n  }\n\n  resolve(): Latch {\n    if (this.isPending()) {\n      this._resolve()\n      this._state = \"resolved\"\n    }\n    return this\n  }\n\n  reject(error?: Error): Latch {\n    if (this.isPending()) {\n      this._reject(error)\n      this._state = \"rejected\"\n      this.error = error\n    }\n    return this\n  }\n\n  observe(p: Promise<any>): this {\n    p.then(\n      () => this.resolve(),\n      err => this.reject(err)\n    )\n    return this\n  }\n\n  observeQuietly(p: Promise<any>): this {\n    p.then(\n      () => this.resolve(),\n      () => this.resolve()\n    )\n    return this\n  }\n\n  isPending(): boolean {\n    return this._state === \"pending\"\n  }\n\n  isSettled() {\n    return !this.isPending()\n  }\n\n  isResolved() {\n    return this._state === \"resolved\"\n  }\n\n  isRejected() {\n    return this._state === \"rejected\"\n  }\n\n  state(): PromiseState {\n    return this._state\n  }\n\n  then<T1, T2>(\n    onfulfilled?: ((v: void) => T1 | PromiseLike<T1>) | undefined | null,\n    onrejected?: ((reason: any) => T2 | PromiseLike<T2>) | undefined | null\n  ): Promise<T1 | T2> {\n    return this.promise.then(onfulfilled, onrejected)\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: any) => TResult | PromiseLike<TResult>)\n      | undefined\n      | null\n  ): Promise<void | TResult> {\n    return this.promise.catch(onrejected)\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<void> & this {\n    void this.promise.finally(onfinally)\n    return this\n  }\n}\n","import { isEmpty } from \"./Array\"\nimport { ChangeListener } from \"./ChangeListener\"\nimport { eql } from \"./Eql\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { gt0 } from \"./Number\"\nimport { setUnrefTimeout } from \"./UnrefTimeout\"\nimport { UnwrapPromiseLike } from \"./UnwrapPromiseLike\"\n\n// USED BY LOG: DON'T DEPEND ON ANYTHING (much)\n\nexport interface MemoizedLazy<T> {\n  /**\n   * Force the prior value to be `t`\n   */\n  set(t: T): void\n  /**\n   * clears the prior value\n   * @return the prior value\n   */\n  clear(): Maybe<T>\n  /**\n   * Clears the prior value but doesn't return it (so we don't have to\n   * explicitly ignore unawaited promises)\n   */\n  unset(): void\n  /**\n   * Forces the underlying thunk or later to be applied\n   */\n  refresh(): T\n  /**\n   * @return the milliseconds a prior result may be returned by `apply`, or\n   * undefined if no TTL is set\n   */\n  ttl(): Maybe<number>\n  /**\n   * @param ttl undefined to remove TTL expirations\n   */\n  setTTL(ttl: number | undefined): void\n  /**\n   * Immediately calls the listener with current value, and calls the listener\n   * if the result changes.\n   */\n  watch(watcher: ChangeListener<T>): void\n  /**\n   * Calls the listener if the result changes later. The underlying thunk is\n   * not applied now (like with {@link MemoizedThunk.watch}).\n   */\n  watchLater(watcher: ChangeListener<T>): void\n  lastSetAgoMs(): Maybe<number>\n  /**\n   * Was this applied and not cleared or unset?\n   */\n  hasPrior(): boolean\n  /**\n   * @return the previously-memoized value, if it isn't stale (according to\n   * `ttl()`)\n   */\n  prior(): Maybe<T>\n\n  /**\n   * Has a result not been calculated, or was calculated more than `ttl()` ms\n   * ago?\n   */\n  isStale(): boolean\n\n  toString(): string\n}\n\nexport interface MemoizedThunk<T> extends MemoizedLazy<T> {\n  (): T\n}\n\nexport type UnwrapLazy<T> = T extends MemoizedThunk<infer U> ? U : T\nexport type UnwrapLazyAsync<T> = T extends MemoizedThunk<infer U>\n  ? UnwrapPromiseLike<U>\n  : T\n\n// HEY, FUTURE ME: yeah, I know you think something here should call\n// ee().on(\"clearCache\",), but DON'T DO IT, MAN. lazy is used by lots of\n// instances that we want to be garbage collected, and that would create a huge\n// memory leak.\n\n/**\n * @param ttlMs if 0 or null, the result of `thunk` will be cached forever.\n */\nexport function lazy<T>(thunk: () => T, ttlMs?: number): MemoizedThunk<T> {\n  let lastSetTs: number | undefined\n  let result: T | undefined\n  const watchers: ChangeListener<T>[] = []\n\n  // HEY FUTURE ME: We're using named functions here, instead of fat arrows,\n  // so they show up properly in stacktraces.\n\n  function Lazy() {\n    if (Lazy.isStale()) {\n      // NO PROMISE AWAITING HERE. Otherwise N calls would go through while we\n      // wait for the promise to resolve.\n      Lazy.setResult(thunk())\n    }\n    return result!\n  }\n  // REMEMBER: function `.name` is not allowed to be overridden!\n\n  async function onSetResult(priorP: Maybe<T>, currentP: T) {\n    if (isEmpty(watchers)) return\n    // prior and current could be a promise!\n\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const _prior = await priorP\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const current = await currentP\n    if (!eql(_prior, current)) {\n      for (const ea of watchers) ea(current)\n    }\n    // We're interpreting undefined as unset, and `null` as a valid set value.\n    if (ttlMs != null && ttlMs > 0 && current !== undefined) {\n      // help the garbage collector:\n      setUnrefTimeout(() => Lazy.vacuum(), ttlMs)\n    }\n  }\n\n  Lazy.vacuum = function vacuum() {\n    if (Lazy.isStale()) Lazy.unset()\n  }\n\n  Lazy.setResult = function setResult(t: T) {\n    lastSetTs = Date.now()\n    void onSetResult(result, t)\n    return (result = t)\n  }\n\n  Lazy.isStale = function isStale() {\n    return lastSetTs == null || (gt0(ttlMs) && lastSetTs + ttlMs < Date.now())\n  }\n\n  Lazy.set = function set(t: T) {\n    Lazy.setResult(t)\n  }\n\n  Lazy.unset = function unset() {\n    Lazy.setResult(undefined as any)\n    lastSetTs = undefined\n  }\n\n  Lazy.clear = function clear() {\n    const _prior = result\n    Lazy.unset()\n    return _prior\n  }\n\n  Lazy.prior = function prior() {\n    Lazy.vacuum()\n    return result\n  }\n\n  Lazy.refresh = function refresh() {\n    return Lazy.setResult(thunk())\n  }\n\n  Lazy.ttl = function ttl() {\n    return ttlMs\n  }\n\n  Lazy.setTTL = function setTTL(ttl: number | undefined) {\n    ttlMs = gt0(ttl) ? ttl : undefined\n  }\n\n  Lazy.watchLater = function watchLater(watcher: ChangeListener<T>) {\n    watchers.push(watcher)\n  }\n\n  Lazy.watch = function watch(watcher: ChangeListener<T>) {\n    watcher(Lazy())\n    Lazy.watchLater(watcher)\n  }\n\n  Lazy.toString = function toString() {\n    return \"[Lazy]\"\n  }\n\n  Lazy.toJSON = function toJSON() {\n    // We don't support JSON encode/decode:\n    return undefined\n  }\n\n  Lazy.lastSetAgoMs = function lastSetAgoMs() {\n    return lastSetTs == null ? undefined : Date.now() - lastSetTs\n  }\n\n  Lazy.hasPrior = function hasPrior() {\n    return lastSetTs != null\n  }\n\n  return Lazy\n}\n","export function getOrSet<K, V>(\n  m: Map<K, V> | WeakMap<any, V>,\n  k: K,\n  valueThunk: () => V\n): V {\n  if (k == null) throw new Error(\"null key\")\n  if (m.has(k)) {\n    return m.get(k)!\n  } else {\n    const v = valueThunk()\n    if (v != null) m.set(k, v)\n    return v\n  }\n}\n\nexport function deleteIf<K, V>(\n  m: Map<K, V>,\n  predicate: (key: K, value: V) => boolean\n) {\n  for (const [k, v] of m.entries()) {\n    if (predicate(k, v)) {\n      m.delete(k)\n    }\n  }\n}\n","import { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toS } from \"./toS\"\n\nexport function map<T, U>(obj: MaybeNull<T>, f: (t: T) => U): Maybe<U> {\n  // isNaN({a:1}) === true\n  return obj == null ? undefined : f(obj)\n}\n\nexport function mapTry<T, U>(f: () => MaybeNull<T>, g: (t: T) => U): Maybe<U> {\n  try {\n    return map(f(), g)\n  } catch {\n    return\n  }\n}\n\nexport function map2<T1, T2, U>(\n  t1: MaybeNull<T1>,\n  t2: MaybeNull<T2>,\n  f: (ea1: T1, ea2: T2) => U\n): Maybe<U> {\n  return t1 == null || t2 == null ? undefined : f(t1, t2)\n}\n\nexport function map3<T1, T2, T3, U>(\n  t1: MaybeNull<T1>,\n  t2: MaybeNull<T2>,\n  t3: MaybeNull<T3>,\n  f: (ea1: T1, ea2: T2, ea3: T3) => U\n): Maybe<U> {\n  return t1 == null || t2 == null || t3 == null ? undefined : f(t1, t2, t3)\n}\n\nexport function orElse<T>(obj: MaybeNull<T>, defaultValue: ThunkOrT<T>): T {\n  return obj != null ? obj : tot(defaultValue)\n}\n\nexport function mapOr<T, U>(\n  obj: MaybeNull<T>,\n  f: (t: T) => U,\n  defaultValue: ThunkOrT<U>\n): U {\n  return obj != null ? f(obj) : tot(defaultValue)\n}\n\nexport function map2Or<T1, T2, U>(\n  t1: MaybeNull<T1>,\n  t2: MaybeNull<T2>,\n  f: (ea1: T1, ea2: T2) => U,\n  defaultValue: () => U\n): U {\n  return orElse(map2(t1, t2, f), defaultValue)\n}\n\n// https://www.typescriptlang.org/docs/handbook/advanced-types.html#predefined-conditional-types\n\nexport type Diff<T, U> = T extends U ? never : T\n\nexport type Unpick<T, U> = { [P in keyof T]: P extends U ? never : T[P] }\n\nexport type Defined<T> = Diff<T, null | undefined | void>\n\n/**\n * @return true iff all `objects` are not `null` or `undefined`\n */\nexport function defined<T>(object: T): object is Defined<T> {\n  return object != null\n}\n\n/**\n * Like `map`, but calls `f` if `obj` is not `undefined`.\n *\n * To clarify, if `obj` is `null`, `f` will be called with `null`.\n */\nexport function ifDefined<T, U>(obj: T | undefined, f: (t: T) => U): Maybe<U> {\n  return obj === undefined ? undefined : f(obj)\n}\n\nexport function allDefined<T>(arr: T[]): arr is Defined<T>[] {\n  return arr != null && arr.every(defined)\n}\n\nexport function firstDefined<T>(...objects: MaybeNull<T>[]): Maybe<T> {\n  return objects.find(defined)\n}\n\nexport function denull<T>(t: T | undefined | null): T | undefined {\n  return t == null || toS(t) === \"null\" ? undefined : t\n}\n\nexport function nulled<T>(t: T | undefined | null): T | null {\n  return t == null ? null : t\n}\n","import {\n  filterInPlace,\n  isEmpty,\n  isNotEmpty,\n  pushUniq,\n  sum,\n  uniq\n} from \"./Array\"\nimport { sortBy } from \"./ArraySort\"\nimport { eql } from \"./Eql\"\nimport { stringify } from \"./JSON\"\nimport { getOrSet } from \"./Map\"\nimport { map } from \"./Maybe\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { Primitive } from \"./Primitive\"\nimport { isString } from \"./String\"\nimport { toA } from \"./toA\"\n\n/**\n * Multi-valued Map.\n */\nexport class MultiMap<K, V> {\n  readonly store: Map<K, V[]>\n\n  constructor(store = new Map<K, V[]>()) {\n    this.store = store\n  }\n\n  get(key: K): V[] | undefined {\n    return this.store.get(key)\n  }\n\n  has(key: K): boolean {\n    return this.store.has(key)\n  }\n\n  includes(key: K, value: V): boolean {\n    return this.store.get(key)?.includes(value) === true\n  }\n\n  /**\n   * @return the number of unique keys in this store\n   */\n  keyCount(): number {\n    return this.store.size\n  }\n\n  /**\n   * @return the number of values in this store\n   */\n  valueCount(): number {\n    return sum(\n      [...this.store.values()].map(ea => ea.length),\n      ea => ea\n    )\n  }\n\n  add(key: K, ...values: V[]): V[] {\n    const store = getOrSet(this.store, key, () => [])\n    store.push(...values)\n    return store\n  }\n\n  addUniq(key: K, ...values: V[]): V[] {\n    return pushUniq(\n      getOrSet(this.store, key, () => []),\n      ...values\n    )\n  }\n\n  set(key: K, values: V[]) {\n    this.store.set(key, values)\n  }\n\n  delete(key: K, value?: V): boolean {\n    if (value == null) {\n      return this.store.delete(key)\n    } else {\n      const arr = this.store.get(key)\n      if (arr == null) {\n        return false\n      } else {\n        const result = arr.filter(ea => !eql(ea, value))\n        if (result.length === 0) {\n          this.store.delete(key)\n        } else {\n          this.store.set(key, result)\n        }\n        return arr.length !== result.length\n      }\n    }\n  }\n\n  clear(): this {\n    this.store.clear()\n    return this\n  }\n\n  keys(): IterableIterator<K> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<K> {\n      for (const [k, v] of self.store.entries()) {\n        if (v.length > 0) {\n          yield k\n        }\n      }\n    }\n    return iter()\n  }\n\n  values(): IterableIterator<V[]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<V[]> {\n      for (const [, v] of self.store.entries()) {\n        if (v.length > 0) {\n          yield v\n        }\n      }\n    }\n    return iter()\n  }\n\n  vacuum(f: (key: K, values: V[]) => Maybe<V[]> = (_k, v) => uniq(v)) {\n    for (const k of this.keys()) {\n      const prior = this.store.get(k)\n      const arr = prior == null ? [] : f(k, prior)\n      if (isEmpty(arr)) {\n        this.store.delete(k)\n      } else {\n        this.store.set(k, arr)\n      }\n    }\n  }\n\n  flatValues(): IterableIterator<V> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<V> {\n      for (const [, arr] of self.store.entries()) {\n        if (arr.length > 0) {\n          for (const ea of arr) {\n            yield ea\n          }\n        }\n      }\n    }\n    return iter()\n  }\n\n  entriesArray(): [K, V[]][] {\n    return [...this.store.entries()].filter(([, v]) => isNotEmpty(v))\n  }\n\n  entries(): IterableIterator<[K, V[]]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<[K, V[]]> {\n      for (const [k, v] of self.store.entries()) {\n        if (v.length > 0) {\n          yield [k, v]\n        }\n      }\n    }\n    return iter()\n  }\n\n  tuples(): IterableIterator<[K, V]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<[K, V]> {\n      for (const [k, v] of self.store.entries()) {\n        for (const ea of toA(v)) {\n          if (ea != null) yield [k, ea]\n        }\n      }\n    }\n    return iter()\n  }\n\n  filterInPlace(predicate: (key: K, value: V) => boolean): boolean {\n    let changed = false\n    for (const [k, arr] of this.store.entries()) {\n      const len = arr.length\n      filterInPlace(arr, v => predicate(k, v))\n      changed = changed || len !== arr.length\n      if (arr.length === 0) {\n        this.store.delete(k)\n      }\n    }\n    return changed\n  }\n\n  inverse(): MultiMap<V, K> {\n    const m = new MultiMap<V, K>()\n    for (const [k, v] of this.store.entries()) {\n      for (const ea of v) {\n        m.add(ea, k)\n      }\n    }\n    return m\n  }\n\n  findKeyByTuple(predicate: (key: K, value: V) => boolean): Maybe<K> {\n    for (const [k, v] of this.tuples()) {\n      if (predicate(k, v)) return k\n    }\n    return\n  }\n\n  filterKeysByTuple(predicate: (key: K, value: V) => boolean): K[] {\n    const result: K[] = []\n    for (const [k, arr] of this.entries()) {\n      if (arr.some(v => predicate(k, v))) result.push(k)\n    }\n    return result\n  }\n\n  toJSON(): Record<string, V[]> {\n    const result: Record<string, V[]> = {}\n    for (const [k, v] of this.entries()) {\n      result[isString(k) ? k : stringify(k)] = v\n    }\n    return result\n  }\n}\n\n/**\n * Groups the given enumeration\n * @return a copy of arr, sorted by the given constraint\n */\nexport function groupBy<K extends Primitive, V>(\n  arr: V[],\n  f: (t: V) => Maybe<K>\n): MultiMap<K, V> {\n  const m = new MultiMap<K, V>()\n  arr.forEach(ea => map(f(ea), k => m.add(k, ea)))\n  return m\n}\n\nexport function groupByValues<K extends Primitive, V>(\n  arr: V[],\n  f: (t: V) => Maybe<K>\n): V[][] {\n  const g = groupBy(arr, f)\n  return sortBy(toA(g.values()), ea => f(ea[0]))\n}\n","const g = globalThis as any\n\nexport const isBrowser =\n  typeof g?.window === \"object\" && typeof g?.document === \"object\"\n\nexport const isNode = typeof g?.process?.versions?.node === \"string\"\n","import { sort } from \"./ArraySort\"\nimport { blank } from \"./Blank\"\nimport { orElse } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toS } from \"./toS\"\n\nexport function isNumber(o: any): o is number {\n  return typeof o === \"number\" && !isNaN(o) && isFinite(o)\n}\n\nexport function isInvalidNumber(o: any): o is number {\n  return typeof o === \"number\" && (isNaN(o) || !isFinite(o))\n}\n\n// thinking about adding toNumber? Please use toInt or toFloat instead.\n\nconst numeralRE = /^\\d+$/\nexport function isDigits(o: any): boolean {\n  return toS(o).match(numeralRE) != null\n}\n\nconst nonNumericRE = /[^-.\\d\\s]/\n\nexport function isNumeric(o: any): boolean {\n  return toS(o).match(nonNumericRE) == null && toFloat(o) != null\n}\n\nexport function isBigInt(o: any): o is bigint {\n  return typeof o === \"bigint\"\n}\n\nexport function mapFinite<T>(i: Maybe<number>, f: (ea: number) => T): Maybe<T> {\n  return isNumber(i) ? f(i) : undefined\n}\n\nconst mapPredicate =\n  (f: (lhs: number, rhs: number) => boolean) =>\n  (lhs: MaybeNull<number>, rhs: MaybeNull<number>) =>\n    isNumber(lhs) && isNumber(rhs) && f(lhs, rhs)\n\nexport const lt = mapPredicate((i, j) => i < j)\nexport const lte = mapPredicate((i, j) => i <= j)\nexport const gt = mapPredicate((i, j) => i > j)\nexport const gte = mapPredicate((i, j) => i >= j)\n\nexport function finiteOrElse<T>(i: Maybe<number>, defaultValue: T): number | T {\n  return isNumber(i) ? i : defaultValue\n}\n\nexport function diff(i: Maybe<number>, j: Maybe<number>): Maybe<number> {\n  return isNumber(i) && isNumber(j) ? i - j : undefined\n}\n\nexport function absdiff(i: Maybe<number>, j: Maybe<number>): Maybe<number> {\n  return isNumber(i) && isNumber(j) ? Math.abs(i - j) : undefined\n}\n\nexport function safeDivide(numerator: number, denominator: number): number {\n  return numerator / (denominator === 0 ? 1e-8 : denominator)\n}\n\n/**\n * @return true iff a is within ((1-minCoeff)*b)±b\n */\nexport function approximates(\n  a: MaybeNull<number>,\n  b: MaybeNull<number>,\n  minCoeff: number = 0.95\n): boolean {\n  if (!isNumber(a) || !isNumber(b)) return false\n  if (a === b) return true\n  if (minCoeff >= 1) return false // it doesn't match!\n  const delta = (b === 0 ? 1e-5 : b) * (1 - minCoeff)\n  return within(b - delta, b + delta, a)\n}\n\n/**\n * @param min inclusive\n * @param max inclusive\n */\nexport function within(min: number, max: number, n: any): n is number {\n  if (n == null || !isNumber(n)) return false\n  ;[min, max] = sort([min, max])\n  return lte(min, n) && gte(max, n)\n}\n\nexport function max_(...arr: Maybe<number>[]): number {\n  let max: Maybe<number>\n  for (const ea of arr) {\n    if (isNumber(ea) && (max == null || max < ea)) max = ea\n  }\n  if (max == null) throw new Error(\"no numbers given to max()\")\n  else return max\n}\n\n/**\n * @return true iff expected is within ±delta of actual\n */\nexport function closeTo(\n  expected: MaybeNull<number>,\n  actual: MaybeNull<number>,\n  delta: number\n): boolean {\n  return isNumber(expected) && isNumber(actual)\n    ? // if the delta is _less than or equal to_, pass.\n      Math.abs(expected - actual) <= delta\n    : false\n}\n\nexport function trunc(n: Maybe<number>): Maybe<number> {\n  if (!isNumber(n)) return undefined\n  const i = Math.trunc(n)\n  return i === 0 ? Math.abs(i) : i\n}\n\nexport interface ToNumber {\n  toNumber(): number\n}\n\nexport function isToNumber(v: any): v is ToNumber {\n  return typeof v?.toNumber === \"function\"\n}\n\nfunction toNumber(\n  value: MaybeNull<number | bigint | string | ToNumber>,\n  opts: {\n    defaultValue: Maybe<number>\n    nton: (n: number) => number\n    ston: (s: string) => Maybe<number>\n  }\n): Maybe<number> {\n  if (blank(value)) return opts.defaultValue\n  if (isNumber(value)) return opts.nton(value)\n  if (isBigInt(value)) {\n    // CAREFUL! Old Safari will keel over due to lack of BigInt support: it's\n    // OK here, because the value typeof is \"bigint\", which would only be true\n    // where BigInt *is* supported.\n    if (\n      value > BigInt(Number.MAX_SAFE_INTEGER) ||\n      value < BigInt(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new Error(\"precision loss for \" + value)\n    }\n    return opts.nton(Number(value))\n  }\n  if (isToNumber(value)) return opts.nton(value.toNumber())\n  try {\n    const i = opts.ston(toS(value).trim())\n    return isNumber(i) ? opts.nton(i) : opts.defaultValue\n  } catch {\n    return opts.defaultValue\n  }\n}\n\n/**\n * @param value if a number, will be truncated. If anything else, will be\n * passed to {@link toS}, trimmed, and parsed. Note that trailing non-numeric\n * characters will be silently ignored.\n */\nexport function toInt(\n  value: MaybeNull<number | bigint | string | ToNumber>,\n  opts?: { defaultValue?: number }\n): Maybe<number> {\n  // note that toNumber does a trim() on value if necessary.\n  return toNumber(value, {\n    defaultValue: undefined,\n    nton: i => trunc(i)!,\n    ston: parseInt,\n    ...opts\n  })\n}\n\nexport function toFloat(\n  value: MaybeNull<number | string>,\n  opts?: { defaultValue?: number }\n): Maybe<number> {\n  return toNumber(value, {\n    defaultValue: undefined,\n    nton: i => i,\n    ston: parseFloat,\n    ...opts\n  })\n}\n\n/**\n * @return `Math.trunc(n)` if n is a positive integer, else undefined\n */\nexport function toGt0(n: any): Maybe<number> {\n  const i = toInt(n)\n  return i != null && i > 0 ? i : undefined\n}\n\nexport function toGt0f(n: any): Maybe<number> {\n  const i = toFloat(n)\n  return i != null && i > 0 ? i : undefined\n}\n\nexport function lt0(n: any): n is number {\n  return isNumber(n) && n < 0\n}\n\nexport function gt0(n: any): n is number {\n  return isNumber(n) && n > 0\n}\n\nexport function firstGt0(...arr: any[]): Maybe<number> {\n  for (const ea of arr) {\n    if (gt0(ea)) return ea\n    const i = toInt(ea)\n    if (gt0(i)) return i\n  }\n  return\n}\n\nexport function gtOrElse(\n  n: Maybe<number>,\n  mustBeGreaterThan: number\n): Maybe<number> {\n  return isNumber(n) && isNumber(mustBeGreaterThan) && n > mustBeGreaterThan\n    ? n\n    : undefined\n}\n\nexport function lte0(n: any): n is number {\n  return isNumber(n) && n <= 0\n}\n\nexport function gte0(n: any): n is number {\n  return isNumber(n) && n >= 0\n}\n\nexport function toGte0(n: any): Maybe<number> {\n  return gte0(n) ? n : undefined\n}\n\nexport function mapInt<T>(o: any, f: (i: number) => T): Maybe<T> {\n  // PERF: UNROLLED FROM opt()\n  const i = toInt(o)\n  return i == null ? undefined : f(i)\n}\n\nexport function mapFloat<T>(o: any, f: (i: number) => T): Maybe<T> {\n  // PERF: UNROLLED FROM opt()\n  const i = toFloat(o)\n  return i == null ? undefined : f(i)\n}\n\n/**\n * @return a stringified `value` iff `value` is a positive integer\n */\nexport function id(value: Maybe<number | string>): Maybe<string> {\n  const i = toInt(value)\n  return gt0(i) ? String(i) : undefined\n}\n\nexport function mapIntOr<T>(o: any, f: (i: number) => T, orElseF: () => T): T {\n  return orElse(mapInt(o, f), orElseF)\n}\n\nexport function mapNumeric<T>(o: any, f: (i: number) => T): Maybe<T> {\n  return isNumber(o) ? f(o) : undefined\n}\n\nexport function map2Numeric<T>(\n  i: any,\n  j: any,\n  f: (ea1: number, ea2: number) => T\n): Maybe<T> {\n  return mapNumeric(i, ea1 => mapNumeric(j, ea2 => f(ea1, ea2)))\n}\n\nexport function mapNumericOr<T>(\n  o: any,\n  f: (i: number) => T,\n  defaultValue: T\n): T {\n  return isNumber(o) ? f(o) : defaultValue\n}\n\nexport function numericOr(o: any, defaultValue: ThunkOrT<number>): number {\n  return isNumber(o) ? o : tot(defaultValue)\n}\n\nexport function round(i: number): number {\n  // Workaround for bug in javascript (Math.round(-1.5) === -1 (!!)):\n  return !isNumber(i) ? 0 : i < 0 ? -Math.round(-i) : Math.round(i)\n}\n\n/**\n * @see Number#toFixed\n */\nexport function toFixed(i: Maybe<number>, decimals: number): Maybe<number> {\n  try {\n    return mapNumeric(i, ea => round(ea * 10 ** decimals) / 10 ** decimals)\n  } catch (err) {\n    return\n  }\n}\n\n/**\n * Just like Number.toFixed, without extraneous padded zeroes\n *\n * @see Number#toFixed\n */\nexport function toFixedStr(i: number, fractionDigits: number) {\n  // this is NOT a general-purpose zero-stripper-RegExp!\n  return i.toFixed(fractionDigits).replace(/\\.0*$|(?<=\\d+\\.\\d+)0+$/, \"\")\n}\n\n/**\n * @see Number#toPrecision\n */\nexport function toPrecision(i: number, decimalPlaces: number): number {\n  if (i == null) return 0\n  // pow should be 1 for decimalPlaces = 0\n  const pow = Math.pow(10, decimalPlaces)\n  return round(i * pow) / pow\n}\n\nexport function toPrecisionMaybe(\n  i: Maybe<number>,\n  decimalPlaces: number\n): Maybe<number> {\n  return mapFinite(i, ea => toPrecision(ea, decimalPlaces))\n}\n\nexport function sigFigs(i: number, digits: number): number {\n  if (i === 0 || digits === 0) {\n    return 0\n  }\n  const exp = digits - round(Math.ceil(Math.log10(Math.abs(i))))\n  const pow = Math.pow(10, Math.abs(exp))\n  // Prevent 120.000000001:\n  return exp < 0 ? round(i / pow) * pow : round(i * pow) / pow\n}\n\nexport function base2Ceil(i: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(i)))\n}\n\nexport function base10Ceil(i: number): number {\n  return Math.pow(10, Math.ceil(Math.log10(i)))\n}\n\nexport function clamp(min: number, max: number, value: number): number {\n  if (min > max || !isNumber(min) || !isNumber(max))\n    throw new Error(`invalid clamp(${min}, ${max}, ${value})`)\n  if (!isNumber(value)) return (min + max) / 2\n  return value < min ? min : value > max ? max : value\n}\n\n/**\n * Accumulate the result of `f`, called `count` times. `f` receives a\n * zero-indexed argument.\n */\nexport function times<T>(count: number, f: (i: number) => T): T[] {\n  if (!gt0(count)) return []\n  const c = Math.round(count)\n  if (c <= 0) return []\n  return [...Array(c)].map((_, i) => f(i))\n}\n\nexport function pct(numerator: Maybe<number>, denominator: number): number {\n  return clamp(\n    0,\n    100,\n    gt0(denominator)\n      ? round((100 * (gt0(numerator) ? numerator : 0)) / denominator)\n      : 0\n  )\n}\n\nexport function fmtPct(i: Maybe<number>, maxValid = 100): Maybe<string> {\n  const rnd = Math.round(i ?? -1)\n  return within(0, maxValid, rnd) ? rnd + \"%\" : undefined\n}\n\nexport function roundEven(i: number): number {\n  return Math.round(i / 2) * 2\n}\n","import { compact, isEmpty, uniq } from \"./Array\"\nimport { sort } from \"./ArraySort\"\nimport { blank, notBlank } from \"./Blank\"\nimport { isFunction } from \"./isFunction\"\nimport { Defined, defined, map, Unpick } from \"./Maybe\"\nimport {\n  DefinedValued,\n  Maybe,\n  MaybeNull,\n  MaybeValued,\n  ReqValued\n} from \"./MaybeTypes\"\nimport { MultiMap } from \"./MultiMap\"\nimport { isPrimitive } from \"./Primitive\"\nimport { toS } from \"./toS\"\n\nexport type Valued<T> = Record<string, T>\n\nexport type KeyOf<T> = string & keyof T\n// export type KeyOf<T> = Extract<keyof T, string>\n\nexport type StringValued = Valued<Maybe<string>>\nexport type StrBoolValued = Valued<Maybe<string | boolean>>\nexport type NativeValued = Valued<Maybe<string | boolean | number>>\n\nexport type Obj = Record<string, any>\n\nexport function isObject(o: any): o is object {\n  return o != null && typeof o === \"object\"\n}\n\nexport function tap<T>(o: T, block?: (t: T) => void): T {\n  if (block != null) {\n    block(o)\n  } else {\n    if (typeof o === \"string\") {\n      console.log(o)\n    } else {\n      console.dir(o, { depth: null })\n    }\n  }\n  return o\n}\n\nexport function keys<T extends Obj>(obj: Maybe<T>): KeyOf<T>[] {\n  // `typeof null === \"object\"` because js wants to F*CK YOU UP\n  if (obj == null || typeof obj !== \"object\") return []\n  return Object.keys(obj).filter(\n    k =>\n      typeof k === \"string\" &&\n      (obj[\"propertyIsEnumerable\"] == null ||\n        obj[\"propertyIsEnumerable\"](k) === true)\n  )\n}\n\nexport function keysWithDefinedValues<T extends Obj>(\n  obj: Maybe<T>\n): KeyOf<T>[] {\n  return obj == null ? [] : keys(obj).filter(k => obj[k] !== undefined)\n}\n\n/**\n * @return true iff o is null, undefined, or only has keys associated to an\n * `undefined` value\n */\nexport function isEmptyObj(o: any): o is undefined {\n  if (o == null || typeof o !== \"object\") return true\n  for (const k in o) {\n    if (o[k] !== undefined) return false\n  }\n  return true\n}\n\nexport function notEmptyObj(o: any): o is Obj {\n  return !isEmptyObj(o)\n}\n\nexport function mapCompactObj<T>(o: Maybe<Obj>, f: (_o: Obj) => T): Maybe<T> {\n  const c = compactValues(o)\n  return notEmptyObj(c) ? f(c) : undefined\n}\n\nexport function values<T extends Obj>(o: T): T[KeyOf<T>][] {\n  return keys(o).map(k => o[k]) as any\n}\n\n// polyfill for Object.entries. Does no nullish-value compaction!\nexport function entries<T extends Obj>(obj: T): [KeyOf<T>, T[KeyOf<T>]][] {\n  return obj == null\n    ? []\n    : Object.entries?.(obj) ?? keys(obj ?? {}).map(ea => [ea, obj[ea]])\n}\n\nexport function fromEntries(\n  arr: MaybeNull<Iterable<Maybe<[Maybe<string>, any]>>>,\n  obj?: any\n): any {\n  if (arr == null) return obj\n  // don't use Object.create(null), json stringify will break!\n  for (const ea of arr) {\n    if (ea != null && Array.isArray(ea)) {\n      const [k, v] = ea\n      // allow NULL fields:\n      if (k != null && v !== undefined) {\n        if (typeof obj !== \"object\") obj = {}\n        obj[k] = v\n      }\n    }\n  }\n  return obj\n}\n\nexport function assignFields<T>(\n  dest: T,\n  src: Maybe<Partial<T>>,\n  opts?: { omitKeys?: string[]; assignNullish?: boolean }\n): T {\n  if (src == null) {\n    return dest\n  }\n  for (const [k, v] of entries(src)) {\n    if (opts?.omitKeys?.includes(k) === true) continue\n    if (v != null || true === opts?.assignNullish) (dest as any)[k] = v\n  }\n  return dest\n}\n\n/**\n * Only overwrite fields from src that are undefined in dest.\n */\nexport function assignUndefinedFields<T>(\n  dest: T,\n  src: Maybe<Pick<T, any>>,\n  ...srcKeys: KeyOf<T>[]\n): T {\n  if (src == null) {\n    return dest\n  }\n  for (const ea of srcKeys) {\n    const v = src[ea]\n    if (v !== undefined && dest[ea] === undefined) dest[ea] = v\n  }\n  return dest\n}\n\n/**\n * Assigns all keys from src to dest, even if they are null or undefined.\n */\nexport function assignAllFields<T>(dest: T, src: Maybe<Pick<T, any>>): T {\n  for (const [k, v] of entries(src ?? {})) {\n    ;(dest as any)[k] = v\n  }\n  return dest\n}\n\nexport function definedValues<T extends Obj>(\n  t: Maybe<T>\n): Maybe<DefinedValued<Partial<T>>> {\n  if (t == null) return undefined\n  const arr = entries(t)\n  if (arr.every(([, v]) => v !== undefined)) return t\n  const pairs = arr.filter(([, v]) => v !== undefined)\n  return isEmpty(pairs) ? undefined : fromEntries(pairs)\n}\n\nexport function compactValues<T extends Obj>(\n  t: Maybe<T>\n): Maybe<ReqValued<Partial<T>>> {\n  if (t == null) return undefined\n  const arr = entries(t)\n  if (arr.every(([, v]) => v != null)) return t\n  const pairs = arr.filter(([, v]) => v != null)\n  return isEmpty(pairs) ? undefined : fromEntries(pairs)\n}\n\nexport function compactValuesDeep(o: any): any {\n  if (o == null) return\n  if (isPrimitive(o)) return o\n  if (Array.isArray(o)) {\n    return compact(o.map(compactValuesDeep))\n  } else {\n    const arr = compact(\n      entries(o).map(([k, v]) => map(compactValuesDeep(v), ea => [k, ea]))\n    )\n    return arr.length === 0 ? undefined : fromEntries(arr as any)\n  }\n}\n\nexport function compactBlankValues<T extends Obj>(\n  t: Maybe<T>\n): Maybe<ReqValued<Partial<T>>> {\n  if (t == null) return undefined\n  const pairs = entries(t).filter(([k, v]) => k != null && notBlank(v))\n  return isEmpty(pairs) ? undefined : fromEntries(pairs)\n}\n\nexport function mapFields(\n  o: Obj,\n  f: (key: string, value: any) => Maybe<[string, any]>,\n  obj = {}\n): Obj {\n  // DON'T DELETE THIS SORT! This makes model upserts have the same prepared\n  // statements:\n\n  const arr = compact(sort(keys(o)).map(k => f(k, o[k])))\n  return fromEntries(\n    arr.filter(([k, v]) => k != null && v !== undefined), // < allow NULL values!\n    obj\n  )\n}\n\nexport function pick<T, K extends keyof T>(\n  obj: T,\n  ...keyNames: K[]\n): Pick<T, K> {\n  if (obj == null) return obj\n  const result = {} as any\n  for (const key of keyNames) {\n    const v = obj[key]\n    if (v !== undefined) result[key] = obj[key]\n  }\n  return result\n}\n\nexport function pickCompact<T, K extends keyof T>(\n  obj: T,\n  ...keyNames: K[]\n): Maybe<Pick<T, K>> {\n  if (obj == null) return\n  const result = {} as any\n  for (const key of keyNames) {\n    const v = obj[key]\n    if (v !== undefined) result[key] = obj[key]\n  }\n  return result\n}\n\n/**\n * @param keynames can be \"key.child.grandchild\" format to pick deep objects.\n */\nexport function pickDeep<T, K extends keyof T>(\n  obj: T,\n  ...keyNames: (K | string)[]\n): Pick<T, K> {\n  if (obj == null) return obj\n  if (Array.isArray(obj)) return obj.map(ea => pickDeep(ea, ...keyNames)) as any\n  const flat: string[] = []\n  const mm = new MultiMap<string, string>()\n  for (const key of keyNames.map(toS)) {\n    const indexOf = key.indexOf(\".\")\n    if (indexOf === -1) {\n      flat.push(key)\n    } else {\n      mm.add(key.slice(0, indexOf) as any, key.slice(indexOf + 1))\n    }\n  }\n  const result = {} as any\n  for (const key of flat) {\n    const v = obj[key as K]\n    // allow NULL values:\n    if (v !== undefined) {\n      result[key as K] = v\n    }\n  }\n  const deepKeysByLocalField = [...mm.entries()]\n  for (const [key, arr] of deepKeysByLocalField) {\n    const v = obj[key as K]\n    if (v != null) {\n      const ea = pickDeep(v as any, ...(arr as any))\n      // allow NULL values:\n      if (ea !== undefined) {\n        result[key] = ea\n      }\n    }\n  }\n  return result\n}\n\nexport function pickNonBlank<T, K extends keyof T>(\n  obj: T,\n  ...keyNames: K[]\n): Pick<T, K> {\n  if (obj == null) return obj\n  const result = {} as any\n  for (const key of keyNames) {\n    const v = obj[key as K]\n    if (notBlank(v)) {\n      result[key as K] = v\n    }\n  }\n  return result\n}\n\n/**\n * @return the first value in `obj` associated to `keyNames` that `predicate` returns true.\n */\nexport function pickFirst<T, K extends keyof T>(\n  obj: T,\n  keyNames: K[],\n  predicate: (v: T[K]) => boolean = defined\n): Maybe<T[K]> {\n  if (obj == null) return\n  for (const key of keyNames) {\n    if (predicate(obj[key])) return obj[key]\n  }\n  return\n}\n\nexport function omit<T extends Record<string, any>, S extends keyof T>(\n  t: Maybe<T>,\n  ...keysToOmit: S[]\n): Unpick<T, S> {\n  if (t == null || keysToOmit.every(ea => blank(t[ea]))) {\n    return t as any\n  }\n  const pairs = entries(t).filter(([k]) => !keysToOmit.includes(k as any))\n  return isEmpty(pairs) ? undefined : fromEntries(pairs)\n}\n\nexport function isReqValued<T>(t: MaybeValued<T>): t is ReqValued<T> {\n  return values(t as any).every(ea => ea != null)\n}\n\nexport function allKeysDefined<T, K extends keyof T>(\n  obj: Maybe<T>,\n  ...keyNames: K[]\n): obj is Defined<T> {\n  return obj != null && keyNames.every(k => obj[k] != null)\n}\n\n/**\n * @return t if it `isReqValued()`, otherwise undefined\n */\nexport function toReqValued<T>(t: MaybeValued<T>): Maybe<ReqValued<T>> {\n  return isReqValued(t) ? t : undefined\n}\n\nexport function reqValuedOrElse<T>(t: MaybeValued<T>): Maybe<ReqValued<T>> {\n  return isReqValued(t) ? t : undefined\n}\n\nexport function mapReqValued<T, U>(\n  t: MaybeValued<T>,\n  f: (ea: ReqValued<T>) => U\n): Maybe<U> {\n  return isReqValued(t) ? f(t) : undefined\n}\n\nexport function onlyReqValued<T>(arr: MaybeValued<T>[]): ReqValued<T>[] {\n  return arr.filter(isReqValued)\n}\n\nexport function filter<T extends Obj, K extends string & keyof T>(\n  obj: T,\n  predicate: (k: K, value: T[K]) => boolean\n): Partial<T> {\n  if (obj == null) return obj\n  return fromEntries(\n    entries(obj).filter(([k, v]) => predicate(k as K, v as T[K]))\n  )\n}\n\n/**\n * As opposed to .keys() which only returns fields directly associated to the\n * given Obj, `allKeys` returns all direct *and inherited* properties (if\n * `obj` is a class instance, for example)\n */\nexport function allKeys(obj: any): string[] {\n  const methods: string[] = keys(obj)\n  while (null != (obj = Reflect.getPrototypeOf(obj))) {\n    methods.push(\n      ...(Reflect.ownKeys(obj).filter(\n        key => typeof key === \"string\"\n      ) as string[])\n    )\n  }\n  return uniq(methods)\n}\n\nexport function maybeCall(o: any, method: string, ...args: any[]) {\n  const f = o?.[method]\n  return isFunction(f) ? f.bind(o)(...args) : undefined\n}\n\nexport function firstValueCaseInsensitive(o: any, key: string): any {\n  if (blank(key)) return\n  if (o[key] != null) return o[key]\n  const lckey = key.toLowerCase().normalize()\n  for (const k of keys(o)) {\n    if (lckey === k.toLowerCase().normalize() && o[k] != null) return o[k]\n  }\n  return\n}\n\n/**\n * Recursively reduce single-value objects to only their value, and retain\n * multi-value objects.\n */\nexport function flattenObject(o: any): any {\n  if (Array.isArray(o)) return o.map(flattenObject)\n  if (typeof o !== \"object\") return o\n  const f = mapFields(o, (key, value) => [key, flattenObject(value)])\n  const v = values(f)\n  return v.length === 1 ? v[0] : f\n}\n","import { Maybe, MaybeNull } from \"./MaybeTypes\"\n\n// Scala got a Some things right.\n// HUR HUR I AM HILLLARIOUS\n\n// \"Opt\" instead of \"Option\" due to Option being an html entity already\n\nexport type MaybeOpt<T> = Opt<T> | MaybeNull<T>\n\n/**\n * @see http://www.scala-lang.org/api/current/scala/Option.html\n */\nexport interface Opt<A> {\n  /**\n   * @return true if the option is an instance of Some, false otherwise\n   */\n  isDefined: boolean\n  /**\n   * @return true if the option is None, false otherwise\n   */\n  isEmpty: boolean\n  /**\n   * @return the option's value.\n   */\n  get(): Maybe<A>\n  /**\n   * @return true if this option is nonempty and the predicate `p` returns true\n   * when applied to this Option's value.\n   */\n  exists(p: (a: A) => boolean): boolean\n  /**\n   * @return a `Some` containing the result of applying `f` to this `Option`'s value\n   * if this `Option` is nonempty.\n   */\n  map<B>(f: (a: A) => B): Opt<B>\n  /**\n   * @return the result of applying `f` to this `Option`'s value if this\n   * `Option` is nonempty. By supporting `undefined` or `B`, we make caller's\n   * lives a little easier--we'll wrap the result in an `Option` for you.\n   */\n  flatMap<B>(f: (a: A) => MaybeOpt<B>): Opt<B>\n  /**\n   * @return this `Option` if it is both nonempty\n   * and applying the predicate `p` to this `Option`'s value returns true.\n   */\n  filter(p: (a: A) => boolean): Opt<A>\n  /**\n   * Apply the given procedure `f` to the `Option`'s value\n   * if this `Option` is nonempty.\n   * @return this (for fluent or chaining calls)\n   */\n  forEach(f: (a: A) => void): Opt<A>\n  /**\n   * @return this `Option`'s value if this `Option` is nonempty,\n   * otherwise return the result of evaluating `f`.\n   */\n  getOrElse(f: () => A): A\n  /**\n   * @return this `Option`'s value if this `Option` is nonempty,\n   * otherwise return the result of evaluating `f`.\n   */\n  orElse(f: () => MaybeOpt<A>): Opt<A>\n\n  /**\n   * @param f will only be invoked if both `this` and `b` are defined\n   */\n  zip1<B, T>(b: MaybeOpt<B>, f: (_a: A, _b: B) => MaybeOpt<T>): Opt<T>\n\n  zip2<B, C, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    f: (_a: A, _b: B, _c: C) => MaybeOpt<T>\n  ): Opt<T>\n\n  zip3<B, C, D, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    d: MaybeOpt<D>,\n    f: (_a: A, _b: B, _c: C, _d: D) => MaybeOpt<T>\n  ): Opt<T>\n}\n\nnamespace NoneImpl {\n  export const isDefined = false\n  export const isEmpty = true\n  export const get = () => undefined\n  export const exists = () => false\n  const noop = () => NoneImpl\n  export const map = noop\n  export const flatMap = noop\n  export const filter = noop\n  export const forEach = noop\n  export const getOrElse = <A>(f: () => A): A => f()\n  export const orElse = <A>(f: () => MaybeOpt<A>): Opt<A> => opt(f())\n  export const zip1 = noop\n  export const zip2 = noop\n  export const zip3 = noop\n}\n\nexport const None: Opt<any> = NoneImpl\n\nexport class Some<A> implements Opt<A> {\n  readonly isDefined = true\n  readonly isEmpty = false\n\n  constructor(private readonly a: A) {}\n\n  get(): A {\n    return this.a\n  }\n\n  exists(f: (a: A) => boolean): boolean {\n    return f(this.a)\n  }\n\n  map<B>(f: (a: A) => B): Opt<B> {\n    return new Some(f(this.a))\n  }\n\n  flatMap<B>(f: (a: A) => Opt<B> | MaybeNull<B>): Opt<B> {\n    const b = f(this.a)\n    return isOpt(b) ? b : opt(b)\n  }\n\n  filter(f: (a: A) => boolean): Opt<A> {\n    return opt(f(this.a) ? this.a : undefined)\n  }\n\n  forEach(f: (a: A) => void): this {\n    f(this.a)\n    return this\n  }\n\n  getOrElse(): A {\n    return this.a\n  }\n\n  orElse(): Opt<A> {\n    return this\n  }\n\n  zip1<B, T>(b: MaybeOpt<B>, f: (_a: A, _b: B) => MaybeOpt<T>): Opt<T> {\n    return opt(b).flatMap(eb => f(this.a, eb))\n  }\n\n  zip2<B, C, T>(\n    b: Opt<B>,\n    c: Opt<C>,\n    f: (_a: A, _b: B, _c: C) => MaybeOpt<T>\n  ): Opt<T> {\n    return opt(b).flatMap(eb => opt(c).flatMap(ec => f(this.a, eb, ec)))\n  }\n\n  zip3<B, C, D, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    d: MaybeOpt<D>,\n    f: (_a: A, _b: B, _c: C, _d: D) => MaybeOpt<T>\n  ): Opt<T> {\n    return opt(b).flatMap(eb =>\n      opt(c).flatMap(ec => opt(d).flatMap(ed => f(this.a, eb, ec, ed)))\n    )\n  }\n}\n\nexport function isOpt<A>(a: MaybeOpt<A>): a is Opt<A> {\n  return a instanceof Some || a === None\n}\n\n/**\n * @see http://www.scala-lang.org/api/current/scala/Option.html\n */\nexport function opt<A>(a: MaybeOpt<A>): Opt<A> {\n  return isOpt(a) ? a : a != null ? new Some(a) : None\n}\n","import { Maybe } from \"./MaybeTypes\"\nimport { toInt, within } from \"./Number\"\nimport { randomInt } from \"./Random\"\nimport { toS } from \"./toS\"\n\nexport const PrimesPerBin = 4\nexport const PrimeBins = 8\n\nexport const SeedCount = PrimesPerBin ** PrimeBins\n\nexport function prngSeed(): number {\n  return randomInt(0, SeedCount)\n}\n\nexport function toSeed(s: any): Maybe<number> {\n  const i = toInt(toS(s))\n  return within(0, SeedCount, i) ? i : undefined\n}\n","import { gte, isNumber, lt, round } from \"./Number\"\nimport { StringValued } from \"./Object\"\nimport { toS } from \"./toS\"\n\nconst pads: StringValued = {}\n\nexport function padding(char: string, length: number): string {\n  if (length < 1) return \"\"\n  if (!gte(pads[char]?.length, length)) {\n    let s = pads[char] ?? char\n    while (s.length < length) {\n      s += char\n    }\n    pads[char] = s\n  }\n  return pads[char]!.substring(0, length)\n}\n\n// first added for irony, then used nonironically:\nexport function leftPad(s: any, minLength: number, padChar: string): string {\n  if (padChar.length === 0) throw new Error(\"leftPad() given empty pad\")\n  if (lt(s, 0)) {\n    return \"-\" + leftPad(String(Math.abs(s)), minLength - 1, padChar)\n  }\n  const str = toS(s)\n  return padding(padChar, minLength - str.length) + str\n}\n\n/**\n * Left-zero-pad\n */\nexport function padNumeric(i: any, minLength: number): string {\n  return leftPad(isNumber(i) ? round(i) : \"0\", minLength, \"0\")\n}\n\nexport function pad2(s: any): string {\n  return padNumeric(s, 2)\n}\n\nexport function pad3(s: any): string {\n  return padNumeric(s, 3)\n}\n\nexport function pad4(s: any): string {\n  return padNumeric(s, 4)\n}\n","// TODO INLINE\nexport { parseJSON } from \"./JSON\"\n","import { blank } from \"./Blank\"\n\nconst irregular = new Map([\n  [\"child\", \"children\"],\n  [\"photo\", \"photos\"],\n  [\"video\", \"videos\"]\n])\nconst es = /([sxz]|ss|sh|ch)$/\nconst consonant_y = /[^aeiou]y$/\nconst vowel_y = /[aeiou]y$/\nconst is = /is$/\n\nexport function pluralize(singular: string) {\n  if (blank(singular)) return singular\n\n  const irr = irregular.get(singular)\n  if (irr != null) return irr\n\n  // https://www.grammarly.com/blog/plural-nouns/\n  if (singular.match(es) != null) {\n    return singular + \"es\"\n  }\n  if (singular.match(consonant_y) != null) {\n    return singular.replace(/y$/i, \"ies\")\n  }\n  if (singular.match(vowel_y) != null) {\n    return singular + \"s\"\n  }\n  if (singular.endsWith(\"o\")) {\n    return singular + \"es\"\n  }\n  if (singular.match(is) != null) {\n    return singular.replace(is, \"es\")\n  }\n\n  return singular + \"s\"\n}\n","import { isEmpty } from \"./Array\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { toS } from \"./toS\"\n\nexport type Primitive = number | string | boolean\nconst primitiveTypes = [\"number\", \"string\", \"boolean\"]\n\nexport interface PrimitiveValued {\n  [key: string]: Primitive\n}\n\nexport interface Primitivable {\n  valueOf(): Primitive\n}\n\nexport interface Primitivables {\n  valueOf(): Primitive[]\n}\n\n// HEY FUTURE ME, looking for something like DeepComparable? See the `Json` type in src/fe/JSON.ts\n\nexport type Comparable = Primitive | Date | Comparable[]\n\nexport function isPrimitive(obj: any): obj is Primitive {\n  return primitiveTypes.indexOf(typeof obj) !== -1\n}\n\nexport function mapPrimitive<T>(a: any, f: (t: Primitive) => T): Maybe<T> {\n  return isPrimitive(a) ? f(a) : undefined\n}\n\nexport function mapPrimitiveOr<T>(\n  a: any,\n  f: (t: Primitive) => T,\n  defaultValue: () => T\n): Maybe<T> {\n  return isPrimitive(a) ? f(a) : defaultValue()\n}\n\nexport function isPrimitiveArray(obj: any): obj is Primitive[] {\n  return Array.isArray(obj) && (obj as any[]).every(isPrimitive)\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\nconst TypeLevel = [\n  \"boolean\",\n  \"number\",\n  \"bigint\",\n  \"symbol\",\n  \"string\",\n  \"object\",\n  \"function\"\n] // typeof array is \"object\"\n\n/**\n * For string values, if both entry starts with this\n * value, the sort order is reversed.\n *\n * This is a ~~hack~~ workaround for the fact that numeric values are trivial\n * to reverse sort order, but string values are not.\n */\nexport const CmpReverseFlag = \"⤹\" // could be anything, as long as it's low-ascii and uncommon.\n\n/**\n * (null || undefined) < false < true < numbers < strings < arrays\n * @return 1 if a > b, -1 if a < b, 0 if a == b.\n */\nexport function cmp<T extends Maybe<Comparable> | Maybe<Comparable>[]>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): number {\n  // undefined == undefined:\n  if (a == null && b == null) return 0\n\n  // undefined should be < defined. We can't use typeof here because typeof null\n  // is \"object\" and typeof undefined = \"undefined\".\n  if (a == null) return -1\n  if (b == null) return 1\n\n  const aType = typeof a\n  const bType = typeof b\n\n  if (\n    (aType === \"string\" || aType === \"symbol\") &&\n    (bType === \"string\" || bType === \"symbol\")\n  ) {\n    // in German, ä sorts before z, in Swedish, ä sorts after z\n    const a_str = toS(a)\n    const b_str = toS(b)\n    const result = a_str.localeCompare(b_str)\n    return a_str[0] === CmpReverseFlag && b_str[0] === CmpReverseFlag\n      ? -result\n      : result\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return cmpArr(a, b)\n  }\n  if (aType !== bType) {\n    return TypeLevel.indexOf(aType) - TypeLevel.indexOf(bType)\n  } else {\n    return a > b ? 1 : a < b ? -1 : 0\n  }\n}\n\nexport function lt<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) < 0\n}\n\nexport function lte<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) <= 0\n}\n\nexport function gte<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) >= 0\n}\n\nexport function gt<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) > 0\n}\n\n/**\n * @return 1 if a > b, -1 if a < b, 0 if a == b.\n */\nexport function cmpArr<T extends Comparable | Comparable[]>(\n  a: T[],\n  b: T[],\n  shorterArrayIsLessThan = true\n): number {\n  if (isEmpty(a) && isEmpty(b)) return 0\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    const c = cmp(a[i], b[i])\n    if (c !== 0) {\n      return c\n    }\n  }\n  return cmp(a.length, b.length) * (shorterArrayIsLessThan ? 1 : -1)\n}\n","import { Defined } from \"./Maybe\"\nimport { Maybe } from \"./MaybeTypes\"\nimport {\n  MaybeNullSyncOrAsync,\n  MaybeSyncOrAsync,\n  SyncOrAsync\n} from \"./SyncOrAsync\"\nimport { toA } from \"./toA\"\n\n// Looking for UnwrapPromiseLike? See fe/UnwrapPromiseLike.ts\n\n/**\n * Safe calls for Optional promises:\n */\nexport async function thenMap<T1, T2>(\n  objP: MaybeNullSyncOrAsync<T1>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>\n): Promise<Maybe<T2>> {\n  const obj = await objP\n  return obj == null ? undefined : f(obj)\n}\n\n/**\n * Serialized promise gathering and compaction\n * @see ../core/async/Promise#tuples\n */\nexport async function thenCollect<T1, T2>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T1>[]>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>\n): Promise<Defined<T2>[]> {\n  const result: Defined<T2>[] = []\n  for (const eaP of toA(await arr)) {\n    if (eaP != null) {\n      const ea = await eaP\n      if (ea != null) {\n        const r = await f(ea)\n        if (r != null) result.push(r as any)\n      }\n    }\n  }\n  return result\n}\n\nexport async function thenTap<T>(\n  p: SyncOrAsync<T>,\n  f: (t: T) => any = console.dir.bind(console)\n): Promise<T> {\n  const result = await p\n  // We await f so if it raises errors, thenTap will propagate the error:\n  await f(result)\n  return result\n}\n\nexport function isPromiseLike(o: any): o is PromiseLike<any> {\n  return o != null && typeof o === \"object\" && typeof o[\"then\"] === \"function\"\n}\n\nexport function isPromise(o: any): o is Promise<any> {\n  return (\n    isPromiseLike(o) &&\n    typeof (o as any)[\"catch\"] === \"function\" &&\n    typeof (o as any)[\"finally\"] === \"function\"\n  )\n}\n\n/**\n * Only run `ifTrue` if `predicate` is true after `p` finishes.\n */\nexport async function thenIf<T, U>({\n  p,\n  predicate,\n  ifTrue\n}: {\n  p: Promise<T>\n  predicate: (t: T) => boolean\n  ifTrue: (t: T) => SyncOrAsync<U>\n}): Promise<Maybe<U>> {\n  const t = await p\n  return predicate(t) ? ifTrue(t) : undefined\n}\n","import { strEnum, StrEnumKeys } from \"./StrEnum\"\n\n/**\n * \"settled\" means either resolved or rejected.\n *\n * \"fulfilled\" is an alias for \"resolved.\" We use \"resolved\" as that matches\n * the Promise API terminology.\n *\n * @see\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n */\nexport const PromiseStates = strEnum(\"pending\", \"resolved\", \"rejected\")\nexport type PromiseState = StrEnumKeys<typeof PromiseStates>\n","import { isEmpty, sum } from \"./Array\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { gt0 } from \"./Number\"\n\nfunction rndInt(min: number, max: number): number {\n  // CAUTION: using Math.round() will give you a non-uniform distribution!\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\n  return Math.floor(Math.random() * (max - min)) + min\n}\n\n/**\n * @param min (inclusive)\n * @param max (exclusive)\n * @return a random integer between min (included) and max (excluded),\n * excluding the values in `excluded`.\n */\nexport function randomInt(\n  min: number,\n  max: number,\n  excluded?: number[]\n): number {\n  return randomInts(min, max, 1, excluded)[0]\n}\n\n/**\n * @param min (inclusive)\n * @param max (exclusive)\n * @return a set of `size` random integers between min (included) and max\n * (excluded), excluding the values in `excluded`.\n */\nexport function randomInts(\n  min: number,\n  max: number,\n  size: number,\n  excluded?: number[]\n): number[] {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n\n  if (max < min) {\n    throw new Error(`randomInts(): invalid range: ${min} > ${max}`)\n  }\n  const range = max - min\n  const excludeSet = new Set(excluded ?? [])\n\n  if (max === min && range === 0 && excludeSet.size === 0 && size === 1) {\n    return [min]\n  }\n\n  const slotsRemaining = range - excludeSet.size\n\n  if (size > slotsRemaining) {\n    throw new Error(\n      `randomInts(): cannot satisfy request: ${JSON.stringify({\n        max,\n        min,\n        range,\n        size,\n        slotsRemaining\n      })}`\n    )\n  }\n  // const luckThreshold = 0.6 // found with minSearch()\n  // if ((slotsRemaining - size) / range < luckThreshold) {\n\n  // HEY FUTURE ME: turns out that either implementation is fine, even for\n  // large ranges and large excluded sets, but the retained implementation\n  // uses less memory allocation, so it wins.\n\n  // const result = []\n  // const eligible = []\n  // for (let i = min; i < max; i++) {\n  //   if (!excludeSet.has(i)) {\n  //     eligible.push(i)\n  //   }\n  // }\n  // for (let i = 0; i < size; i++) {\n  //   const idx = rndInt(0, eligible.length)\n  //   result.push(eligible.splice(idx, 1)[0])\n  // }\n  // return result\n  // } else {\n  const result = new Set<number>()\n  while (result.size < size) {\n    const candidate = rndInt(min, max)\n    if (!excludeSet.has(candidate)) {\n      result.add(candidate)\n    }\n  }\n  return [...result]\n  // }\n}\n\nexport function randomBoolean(trueRatio = 0.5): boolean {\n  return Math.random() <= trueRatio\n}\n\n/**\n * @return a random float between `min` and `max`\n */\nexport function randomFloat(min: number, max: number) {\n  return Math.random() * (max - min) + min\n}\n\nexport const NumericChars = \"0123456789\"\nexport const LowercaseChars = \"abcdefghijkmnopqrstuvwxyz\"\n// No upper case to support case-insensitive filesystems. Exported for tests.\n// We could have used GeoRadix.numerals, but that's a possible circular dep.\nexport const RandomChars = NumericChars + LowercaseChars\n\n/**\n * @return a random string matching /[a-z0-9]{count}/\n */\nexport function randomChars(\n  count: number,\n  chars: string = RandomChars\n): string {\n  let result = \"\"\n  for (let i = 0; i < count; i++) {\n    result += randomChar(chars)\n  }\n  return result\n}\n\nexport function randomChar(chars: string = RandomChars): string {\n  return chars[randomInt(0, chars.length)]\n}\n\nexport function pickRandom<T>(arr: T[]): Maybe<T> {\n  return arr[randomInt(0, arr.length)]\n}\n\n/**\n * Fisher-yates shuffle on shallow clone of `arr`\n */\nexport function shuffle<T>(arr: T[]): T[] {\n  const r = [...arr]\n  for (let i = r.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1))\n    if (i !== j) [r[i], r[j]] = [r[j], r[i]]\n  }\n  return r\n}\n\nexport function sample<T>(arr: T[], size: number): T[] {\n  const result: T[] = []\n  for (const idx of randomInts(0, arr.length, size)) {\n    result.push(arr[idx])\n  }\n  return result\n}\n\nexport function pickWeightedRandom<T extends { priority?: number }>(\n  arr: T[]\n): Maybe<T> {\n  if (isEmpty(arr)) return\n  const nonZeroes = arr.filter(ea => gt0(ea.priority))\n  const totalPriority = sum(nonZeroes, ea => ea.priority!)\n  let rand = randomFloat(0, totalPriority)\n  return nonZeroes.find(ea => {\n    rand -= ea.priority!\n    return rand <= 0\n  })\n}\n","export function replaceAllMatches(\n  str: string,\n  regex: RegExp,\n  fn: (match: RegExpExecArray) => string\n): string {\n  let result = str\n  if (!regex.global) regex = new RegExp(regex, \"g\")\n\n  let m: RegExpExecArray | null = null\n  while ((m = regex.exec(str)) != null) {\n    // This is necessary to avoid infinite loops with zero-width matches\n    if (m.index === regex.lastIndex) {\n      regex.lastIndex++\n    }\n    result =\n      result.slice(0, m.index) + fn(m) + result.slice(m.index + m[0].length)\n  }\n  return result\n}\n","import { Maybe } from \"./MaybeTypes\"\nimport { isNumber } from \"./Number\"\n\n// This is ordered by popularity/likelihood of use\nexport const Rotations = [0, 90, 270, 180] as const\nexport type Rotation = (typeof Rotations)[number]\n\nexport function isRotation(r: any): r is Rotation {\n  return isNumber(r) && Rotations.includes(r as Rotation)\n}\n\n/** @return if set, rotation, normalized to [0, 360) */\nexport function normalizeRotation(r: Maybe<number>): Maybe<Rotation> {\n  if (!isNumber(r)) return\n  const mod = (Math.round(r / 90) * 90) % 360\n  // `<= 0` to avoid negative zero as a result\n  return (mod <= 0 ? (mod + 360) % 360 : mod) as Rotation\n}\n\n/**\n * @return true if the dimensions need to be flipped to respect the given\n * rotation\n */\nexport function swappableRotation(rotation: Maybe<number>) {\n  const r = normalizeRotation(rotation)\n  return r === 90 || r === 270\n}\n","import { strEnum, StrEnumKeys } from \"../fe/StrEnum\"\n\nexport const RunStates = strEnum(\n  /** starting up: show splash */\n  \"loading\",\n  /** no current library: show /welcome page */\n  \"welcome\",\n  /** library is open: show /tag home page */\n  \"ready\",\n  /** library isn't open: show /status page */\n  \"failed\"\n)\nexport type RunStateEnum = StrEnumKeys<typeof RunStates>\n\nexport type ApiSplashEvent = \"version\" | \"msg\" | \"settled\"\n","import { strEnum, StrEnumKeys } from \"./StrEnum\"\n\nexport const ServiceNames = strEnum(\n  \"main\",\n  \"desktop\",\n  \"web\",\n  \"sync\",\n  \"info\",\n  \"test\",\n  \"logcat\",\n  \"logtail\",\n  \"list\",\n  \"billing\",\n  \"worker\",\n  \"test-worker\"\n)\n\nexport type ServiceName = StrEnumKeys<typeof ServiceNames>\n","export function splitFirst(\n  s: string,\n  pattern: string\n): [string, string] | [string] {\n  const indexOf = s.indexOf(pattern)\n  return indexOf === -1\n    ? [s]\n    : [s.slice(0, indexOf), s.slice(indexOf + pattern.length)]\n}\n","import { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { fromEntries } from \"./Object\"\nimport { ThunkOrT, tot } from \"./Thunk\"\n\n// See https://basarat.gitbooks.io/typescript/content/docs/types/literal-types.html\n\nexport type StrEnumType<T extends string> = {\n  [K in T]: K\n}\n\nexport type StrEnumHelpers<T extends string> = {\n  values: T[]\n  length: number\n  /** synonym for includes */\n  has(s: MaybeNull<string>): s is T\n  includes(s: MaybeNull<string>): s is T\n  getCI(s: MaybeNull<string>): Maybe<T>\n  omit<O extends T>(...t: O[]): Exclude<T, O>[]\n  indexOf(s: MaybeNull<string>): Maybe<number>\n  ordinal(s: MaybeNull<string>): number\n  validOrElse<R>(s: MaybeNull<string>, defaultValue: ThunkOrT<R>): T | R\n  mapValid<R>(s: MaybeNull<string>, f: (t: T) => R): Maybe<R>\n  cmp(a: MaybeNull<string>, b: MaybeNull<string>): Maybe<number>\n}\n\nexport type StrEnum<T extends string> = StrEnumType<T> & StrEnumHelpers<T>\n\nexport type StrEnumKeys<Type> = Type extends StrEnum<infer X> ? X : never\n\nexport function strEnum<T extends string>(...o: T[]): StrEnum<T> {\n  const values = Object.freeze(o) as T[]\n  const valueToIndex = fromEntries(values.map((ea, idx) => [ea, idx]))\n\n  const dict: StrEnumType<T> = {} as any\n  for (const ea of values) {\n    dict[ea] = ea\n  }\n\n  // toLowerCase() is safe because we know all strEnum values are latin ASCII:\n  const getCI = (s: MaybeNull<string>) => {\n    if (s == null) return // < remember that some strEnum values are \"\"\n    s = s.toLowerCase()\n    return values.find(ea => ea.toLowerCase() === s)\n  }\n\n  const indexOf = (s: MaybeNull<string>) =>\n    s != null ? valueToIndex[s] : undefined\n\n  const ordinal = (s: MaybeNull<string>) => indexOf(s) ?? values.length\n\n  const includes = (s: MaybeNull<string>): s is T => indexOf(s) != null\n\n  const omit = (...t: T[]) => values.filter(ea => !t.includes(ea)) as any\n\n  const validOrElse = <R>(s: MaybeNull<string>, defaultValue: ThunkOrT<R>) =>\n    includes(s) ? s : tot(defaultValue)\n\n  const mapValid = <R>(s: MaybeNull<string>, f: (t: T) => R) =>\n    includes(s) ? f(s as T) : undefined\n\n  const cmp = (a: MaybeNull<string>, b: MaybeNull<string>) => {\n    const a_ = indexOf(a)\n    const b_ = indexOf(b)\n    return a_ == null || b_ == null ? undefined : a_ > b_ ? 1 : a_ < b_ ? -1 : 0\n  }\n\n  return {\n    ...dict,\n    values,\n    length: values.length,\n    has: includes, // alias for includes\n    includes,\n    getCI,\n    omit,\n    indexOf,\n    ordinal,\n    validOrElse,\n    mapValid,\n    cmp\n  }\n}\n\n/* \n\nExample usage:\n\nexport const Directions = strEnum(\"North\", \"South\", \"East\", \"West\")\nexport type Direction = StrEnumKeys<typeof Directions>\n\n*/\n","import { at } from \"./At\"\nimport { flatten } from \"./Flatten\"\nimport { countIterable, sliceIterable } from \"./Iterable\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { clamp, round } from \"./Number\"\nimport { Segmenter } from \"./Segmenter\"\nimport { toA } from \"./toA\"\nimport { toS } from \"./toS\"\n\nexport function isString(obj: any): obj is string {\n  return typeof obj === \"string\"\n}\n\n// safe for frontend (which doesn't have a Buffer)\nexport function isBuffer(obj: any): obj is Buffer {\n  return obj?.constructor?.name === \"Buffer\"\n}\n\n/**\n * @return true iff `s` only uses characters in the basic multilingual plane\n * @see https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane\n */\nexport function isBMP(s: string): boolean {\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s.charCodeAt(i) !== s.codePointAt(i)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function charAt(s: string, i: number): Maybe<string> {\n  if (isBMP(s)) {\n    i = Math.trunc(i) || 0\n    if (i < 0) i += s.length\n    if (i < 0 || i >= s.length) return undefined\n    return s[i]\n  } else {\n    return at([...toS(s)], i)\n  }\n}\n\nexport function strlen(s: string) {\n  const g = graphemeSegmenter()\n  if (g != null) return countIterable(g.segment(s))\n\n  // Crap, we have to do it the hard (buggy) way\n  if (isBMP(s)) return s.length\n  return [...s].length\n}\n\n// can't use lazy here--circular dependency.\nlet _graphemeSegmenter: Segmenter | null | undefined\n\nfunction graphemeSegmenter(): Segmenter | null {\n  // only try once:\n  if (_graphemeSegmenter === undefined) {\n    try {\n      // FIREFOX DOESN'T SUPPORT Intl.Segmenter (!!)\n      _graphemeSegmenter = new (Intl as any).Segmenter(undefined, {\n        granularity: \"grapheme\"\n      })\n    } catch {\n      // dang, no grapheme support in this environment\n      _graphemeSegmenter = null\n    }\n  }\n  return _graphemeSegmenter ?? null // < SITS, TS should have figured it out\n}\n\n/**\n * Returns a substring of the given string. Emoji and astral symbol friendly.\n *\n * @param from The starting position of the desired substring. The index of the\n * first character in the string is zero.\n * @param end The end index of the specified portion of the string. This is\n * exclusive of the element at the index 'end'. Negative values count from the\n * end index (like Array#slice). If end is undefined, then the returned value\n * extends to the end of the string.\n * @see https://mathiasbynens.be/notes/javascript-unicode\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length\n * @see https://blog.jonnew.com/posts/poo-dot-length-equals-two\n */\nexport function strslice(s: string, from: number, end?: number) {\n  if (isBMP(s)) {\n    // allow negative indexing from the end\n    if (from < 0) from += s.length\n    return s.slice(from, end)\n  } else {\n    const g = graphemeSegmenter()\n    if (g != null) {\n      const arr = sliceIterable(g.segment(s), from, end)\n      return arr.map((ea: any) => ea.segment).join(\"\")\n    }\n    // Sadness, no grapheme support. This doesn't work for compound emoji!\n    return [...toS(s)].slice(from, end).join(\"\")\n  }\n}\n\n/**\n * Gets a substring beginning at the specified location and having the specified length.\n * @param from The starting position of the desired substring. The index of the first character in the string is zero.\n * @param length The number of characters to include in the returned substring.\n */\nexport function substr(str: string, from: number, length?: number): string {\n  return isBMP(str)\n    ? str.slice(from, length == null ? undefined : from + length)\n    : strslice(str, from, length == null ? undefined : from + length)\n}\n\nexport function charArr(s: string): string[] {\n  const g = graphemeSegmenter()\n  return g == null\n    ? // unicode-friendly way of splitting a string into chars (ish):\n      [...toS(s)]\n    : [...g.segment(s)].map((ea: any) => ea.segment)\n}\n\nexport function trimRight(s: string): string {\n  return toS(s).replace(/\\s+$/, \"\")\n}\n\nexport function stripPrefix(s: string, prefix: string): string {\n  const str = toS(s)\n  const pfx = toS(prefix)\n  return pfx.length > 0 && str.startsWith(pfx) ? str.slice(pfx.length) : str\n}\n\nexport function stripPrefixes(s: string, prefixes: string[]): string {\n  if (s == null) return \"\"\n  const str = toS(s)\n  for (const pfx of prefixes) {\n    if (pfx != null && pfx.length > 0 && str.startsWith(pfx))\n      return stripPrefixes(str.slice(pfx.length), prefixes)\n  }\n  return str\n}\n\nexport function stripSuffix(s: string, suffix: string): string {\n  if (suffix == null) return s\n  const str = toS(s)\n  const sfx = toS(suffix)\n  return sfx.length > 0 && str.endsWith(sfx) ? str.slice(0, -sfx.length) : str\n}\n\nexport function stripPrefixSuffix(\n  s: string,\n  { prefix, suffix }: { prefix: string; suffix: string }\n): string {\n  return stripSuffix(stripPrefix(s, prefix), suffix)\n}\n\nexport function ensurePrefix(s: string, prefix: string): string {\n  if (prefix == null || prefix === \"\") return s\n  s = toS(s)\n  prefix = toS(prefix)\n  return s.startsWith(prefix) ? s : prefix + s\n}\n\nexport function ensureSuffix(s: string, suffix: string): string {\n  if (suffix == null || suffix === \"\") return s\n  s = toS(s)\n  suffix = toS(suffix)\n  return s.endsWith(suffix) ? s : s + suffix\n}\n\nexport function ensurePrefixSuffix(\n  s: string,\n  { prefix, suffix }: { prefix: string; suffix: string }\n): string {\n  return ensureSuffix(ensurePrefix(s, prefix), suffix)\n}\n\nexport function ellipsize(a: any, maxLen = 80, trailingChars = 0): string {\n  if (a == null) {\n    return \"\"\n  }\n  maxLen = Math.max(1, round(maxLen))\n  trailingChars = clamp(0, maxLen - 1, round(trailingChars))\n  const arr = charArr(a)\n  // ensure valid trailingChars\n  return arr.length <= maxLen\n    ? arr.join(\"\")\n    : arr.slice(0, maxLen - 1 - trailingChars).join(\"\") +\n        \"…\" +\n        (trailingChars > 0 ? arr.slice(-trailingChars).join(\"\") : \"\")\n}\n\nexport function newlineRe() {\n  return /\\r?\\n/g // this can't be a const as it has state\n}\n\nexport function trimLastNewline(s: string): string {\n  return toS(s).replace(/\\r?\\n$/, \"\")\n}\n\n/**\n * Returns the nearest occurrence of a substring to the left of a given position in the string.\n * @param haystack The string to search against.\n * @param needle The substring to search for.\n * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.\n */\nexport function leftIndexOf(\n  haystack: string,\n  needle: string,\n  position?: number\n) {\n  if (position == null) position = haystack.length\n  for (let i = position; i >= 0; i--) {\n    if (strslice(haystack, i).startsWith(needle)) return i\n  }\n  return -1\n}\n\nexport function wrap(\n  s: string | string[],\n  opts?: { maxLineLen?: number; prefix?: string }\n): string[] {\n  const maxLineLen = opts?.maxLineLen ?? 80\n  const prefix = opts?.prefix ?? \"\"\n\n  if (Array.isArray(s) || s.includes(\"\\n\")) {\n    const lines = flatten(toA(s).map(ea => toS(ea).split(newlineRe())))\n    return flatten(lines.map(ea => wrap(ea, opts)))\n  }\n  s = ensurePrefix(toS(s), prefix).trim()\n  if (s.length <= maxLineLen) {\n    return [s]\n  }\n  const leftSliceAt = leftIndexOf(s, \" \", maxLineLen)\n\n  if (leftSliceAt > prefix.length) {\n    return [\n      strslice(s, 0, leftSliceAt),\n      ...wrap(strslice(s, leftSliceAt + 1), opts)\n    ]\n  } else {\n    const rightSliceAt = s.indexOf(\" \", prefix.length + 1)\n    if (rightSliceAt > 0 && rightSliceAt < s.length - 1) {\n      return [\n        strslice(s, 0, rightSliceAt),\n        ...wrap(strslice(s, rightSliceAt + 1), opts)\n      ]\n    } else {\n      return [s]\n    }\n  }\n}\n\nexport function eqlStrings(a: string, b: string): boolean {\n  return a == null || b == null\n    ? false\n    : a === b || a.normalize() === b.normalize()\n}\n\nexport function replaceAll(\n  s: string,\n  searchValue: string | RegExp,\n  replaceValue: string\n): string {\n  if (searchValue === \"\") return s\n  return s.split(searchValue).join(replaceValue)\n}\n\nexport function compressWhitespace(...s: string[]): string {\n  return s.join(\" \").replace(/\\s+/g, \" \").trim()\n}\n\n/**\n * @return s.split(sep).at(-1)\n */\nexport function splitLast(s: string, sep: string): string {\n  s = toS(s)\n  const idx = s.lastIndexOf(sep)\n  return idx === -1 ? s : s.slice(idx + sep.length)\n}\n","import { fmtHMS } from \"./Date\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { maybeCall } from \"./Object\"\nimport { SyncOrAsync } from \"./SyncOrAsync\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { TimeoutError } from \"./TimeoutError\"\n\nexport const Timeout = Symbol(\"timeout\")\n\nexport function toNotTimeout<T>(p: T | typeof Timeout): Maybe<T> {\n  return p === Timeout ? undefined : p\n}\n\nexport async function thenOrTimeout<T>(\n  p: SyncOrAsync<T>,\n  timeoutMs: number,\n  unref = true\n): Promise<T | typeof Timeout> {\n  timeoutMs = Math.round(timeoutMs ?? 0)\n  return timeoutMs <= 0\n    ? p\n    : new Promise<T | typeof Timeout>(async (resolve, reject) => {\n        let pending = true\n        const t = setTimeout(() => {\n          if (pending) {\n            pending = false\n            resolve(Timeout)\n          }\n        }, timeoutMs)\n        try {\n          if (unref) maybeCall(t, \"unref\") // timeouts don't have an unref method on fe.\n          const result = await p\n          if (pending) {\n            pending = false\n            resolve(result)\n          }\n        } catch (err) {\n          if (pending) {\n            pending = false\n            reject(err)\n          }\n        } finally {\n          clearTimeout(t)\n        }\n      })\n}\n\nexport async function thenOrTimeoutAt<T>(\n  p: SyncOrAsync<T>,\n  timeoutAtTs: number,\n  unref = true\n): Promise<T | typeof Timeout> {\n  const timeoutMs = timeoutAtTs - Date.now()\n  return timeoutMs <= 0 ? Timeout : thenOrTimeout(p, timeoutMs, unref)\n}\n\nexport async function thenOrOnTimeout<T, U>(\n  p: SyncOrAsync<T>,\n  timeoutMs: number,\n  onTimeout: () => SyncOrAsync<U>\n): Promise<T | U> {\n  return new Promise<T | U>(async (resolve, reject) => {\n    let pending = true\n    try {\n      const t = setTimeout(async () => {\n        if (pending) {\n          pending = false\n          try {\n            resolve(await onTimeout())\n          } catch (err) {\n            reject(err)\n          }\n        }\n      }, timeoutMs)\n      maybeCall(t, \"unref\") // timeouts don't have an unref method on fe.\n      const result = await p\n      if (pending) {\n        pending = false\n        clearTimeout(t)\n        resolve(result)\n      }\n    } catch (err) {\n      if (pending) {\n        pending = false\n        reject(err)\n      }\n    }\n  })\n}\n\n/**\n * @param timeoutMs disable timeouts if <= 0\n */\nexport async function thenOrTimeoutError<T>(\n  p: SyncOrAsync<T>,\n  timeoutMs: number,\n  unref = true\n): Promise<T> {\n  const result = await thenOrTimeout(p, timeoutMs, unref)\n  if (result === Timeout) {\n    throw new TimeoutError(\"timeout (\" + fmtHMS(timeoutMs) + \")\")\n  } else {\n    return result as T\n  }\n}\n\nexport async function thenOrTimeoutAtError<T>(\n  p: SyncOrAsync<T>,\n  timeoutAtTs: number,\n  unref = true\n): Promise<T> {\n  const timeoutMs = timeoutAtTs - Date.now()\n  if (timeoutMs <= 0) {\n    throw new TimeoutError(\"timeout (\" + fmtHMS(timeoutMs) + \")\")\n  }\n  return thenOrTimeoutError(p, timeoutMs, unref)\n}\n\nexport async function thenOrTimeoutAs<T>({\n  f,\n  timeoutMs,\n  as,\n  unref = true\n}: {\n  f: SyncOrAsync<T>\n  timeoutMs: number\n  as: ThunkOrT<T>\n  unref?: boolean\n}): Promise<T> {\n  const result = await thenOrTimeout(f, timeoutMs, unref)\n  return result === Timeout ? tot(as) : result\n}\n","import { delay } from \"./Delay\"\nimport { Latch } from \"./Latch\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { isPromise } from \"./Promise\"\n\nexport interface Throttled<T> {\n  (...args: any[]): Maybe<T>\n  /**\n   * How many times has fn() been invoked?\n   */\n  count(): number\n  /**\n   * Would a call to apply() right now be throttled/ignored?\n   */\n  isThrottled(): boolean\n\n  /**\n   * Resolved when the current call to apply() is done.\n   */\n  donePromise(): Promise<void>\n\n  /**\n   * Wait for any prior call to finish, then re-apply with these args.\n   */\n  force(...args: any[]): Promise<T>\n\n  /**\n   * Minimum number of milliseconds betwee the end of the last application and\n   * the start of the next application\n   */\n  minCallDelayMs(): number\n\n  setMinCallDelayMs(millis: number): void\n}\n\n/**\n *\n */\nexport function throttle<T>({\n  f,\n  minCallDelayMs\n}: {\n  f: (...args: any[]) => T\n  minCallDelayMs: number\n}): Throttled<T> {\n  minCallDelayMs = Math.max(50, minCallDelayMs) // 50ms lower bound\n  let latch: Maybe<Latch>\n  let runTs = 0\n  let running = false\n  let count = 0\n\n  const onComplete = () => {\n    void latch?.resolve()\n    latch = undefined\n    runTs = Date.now()\n    running = false\n  }\n\n  const r = (...args: any[]) => {\n    if (running) return\n    const now = Date.now()\n    if (now >= runTs + minCallDelayMs) {\n      running = true\n      count++\n      try {\n        const result = f(...args)\n        if (isPromise(result)) {\n          void result.finally(onComplete)\n        } else {\n          onComplete()\n        }\n        return result\n      } catch (e) {\n        running = false\n        throw e\n      }\n    } else {\n      return\n    }\n  }\n\n  r.minCallDelayMs = () => minCallDelayMs\n  r.setMinCallDelayMs = (millis: number) => {\n    minCallDelayMs = Math.max(50, millis)\n  }\n\n  r.isThrottled = () => running || Date.now() <= runTs\n\n  r.donePromise = () => {\n    return running ? (latch ??= new Latch()) : Promise.resolve()\n  }\n\n  r.count = () => count\n\n  r.force = async (...args: any[]) => {\n    // wait for the prior run to finish:\n    while (true) {\n      if (running) {\n        // Push next out to not let others start while we wait in line:\n        runTs = Date.now() + minCallDelayMs * 10\n        await delay(50)\n      } else {\n        runTs = 0\n        return r(...args)! // < we know we will win\n      }\n    }\n  }\n  return r\n}\n","import { isFunction } from \"./isFunction\"\n\nexport interface Thunk<T> {\n  (): T\n}\n\nexport interface ThunkOrLater<T> {\n  (): T | Promise<T>\n}\n\nexport type ThunkOrT<T> = T | Thunk<T>\n\n/**\n * Convert a ThunkOrT into a T.\n *\n * Caution: Don't have T be a function type!\n */\nexport function tot<T>(t: ThunkOrT<T>): T {\n  return isFunction(t) ? t() : t\n}\n\n/**\n * Thunk Or Later\n */\nexport async function tol<T>(t: T | ThunkOrLater<T>): Promise<T> {\n  return isFunction(t) ? t() : t\n}\n\nexport interface ThunkMaybe<T> {\n  (): T | undefined\n}\n\nexport function firstDefinedThunk<T>(\n  iter: Iterable<ThunkMaybe<T>>\n): T | undefined {\n  for (const f of iter) {\n    const result = f()\n    if (result != null) return result\n  }\n  return\n}\n\nexport function firstDefinedSuccess<T>(\n  iter: Iterable<ThunkMaybe<T>>\n): T | undefined {\n  for (const f of iter) {\n    try {\n      const result = f()\n      if (result != null) return result\n    } catch {\n      //\n    }\n  }\n  return\n}\n\nexport const NoOp = () => undefined\n","export class TimeoutError extends Error {}\n","// Note that \"pslib\" is not a schema that is registered by IANA, but it doesn't\n// collide with anything there, so we should be fine. See\n// https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml\n\n// Node URL parsing uses \"protocol\" instead of \"scheme\", and protocol is always\n// suffixed with a colon.\n\n/**\n * URI scheme used for asset files found in the PhotoStructure Library directory\n * hierarchy\n */\nexport const PS_LIBRARY_SCHEME = \"pslib\"\nexport const PS_LIBRARY_PROTOCOL = PS_LIBRARY_SCHEME + \":\"\n\n/**\n * URI scheme used for asset files found on a local disk volume\n */\nexport const PS_LOCAL_FILE_SCHEME = \"psfile\"\nexport const PS_LOCAL_FILE_PROTOCOL = PS_LOCAL_FILE_SCHEME + \":\"\n\n/**\n * URI scheme used for asset files found on a network filesystem\n */\nexport const PS_NETWORK_FILESYSTEM_SCHEME = \"psnet\"\nexport const PS_NETWORK_FILESYSTEM_PROTOCOL = PS_NETWORK_FILESYSTEM_SCHEME + \":\"\n\n/**\n * URI scheme only used for tests to reference exemplar photos and videos\n */\n\nexport const PS_EXAMPLES_SCHEME = \"examples\"\n","import { compact } from \"./Array\"\nimport { blank } from \"./Blank\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { Valued } from \"./Object\"\nimport { toS } from \"./toS\"\n\nexport function isURLSearchParams(o: any): o is URLSearchParams {\n  return o?.constructor?.name === \"URLSearchParams\"\n}\n\nexport type URLSearchParamable =\n  | string[][]\n  | Valued<string | (string | null)[]>\n  | string\n  | URLSearchParams\n\nexport function toURLSearchParams(\n  o: Maybe<URLSearchParamable>\n): Maybe<URLSearchParams> {\n  return o == null\n    ? undefined\n    : isURLSearchParams(o)\n    ? o\n    : new URLSearchParams(o as any)\n}\n\nexport function mergeURLSearchParams(\n  ...params: Maybe<URLSearchParamable>[]\n): Maybe<URLSearchParams> {\n  const arr = compact(params.map(toURLSearchParams))\n  const result = arr.shift()\n  if (result == null) return\n  for (const ea of arr) {\n    for (const [k, v] of ea.entries()) {\n      result.set(k, v)\n    }\n  }\n  return result\n}\n\n/**\n * fullPath is /path?query#anchor of https://host.com/path/?query#anchor\n */\nexport function assembleFullPath(\n  path: string,\n  ...queries: Maybe<URLSearchParamable>[]\n): string {\n  const q = toS(mergeURLSearchParams(...queries))\n  return path + (blank(q) ? \"\" : \"?\" + q)\n}\n\nexport function addQueryToFullpath(\n  fullPath: string,\n  ...queries: Maybe<URLSearchParamable>[]\n) {\n  const q = toS(mergeURLSearchParams(...queries))\n  return blank(q)\n    ? fullPath\n    : fullPath + (fullPath.includes(\"?\") ? \"&\" : \"?\") + q\n}\n","import { blank, mapNotBlank } from \"./Blank\"\nimport { lazy } from \"./Lazy\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { isNumber, round, sigFigs, toInt } from \"./Number\"\nimport { pluralize } from \"./Pluralize\"\nimport { StrEnumKeys, strEnum } from \"./StrEnum\"\nimport { replaceAll } from \"./String\"\n\n// these instances are expensive to create, and can be reused for a given\n// locale.\nconst numberFormat = lazy(() => new Intl.NumberFormat())\n\nexport const thousandsSep = lazy(() =>\n  replaceAll(numberFormat().format(1111), \"1\", \"\").charAt(0)\n)\n\nexport const decimalSep = lazy(() =>\n  replaceAll(numberFormat().format(1.1), \"1\", \"\").charAt(0)\n)\n\nexport function bytesToMB(...bytes: Maybe<number>[]) {\n  let sum = 0\n  for (const ea of bytes) {\n    if (isNumber(ea)) sum += ea / MB\n  }\n  return round(sum)\n}\n\nexport function fmt(i: number): string {\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat\n  return numberFormat().format(i)\n}\n\n/**\n * Like `Number.toInt`, but accepts `fmt`ed strings by stripping thousands\n * separators before parsing.\n */\nexport function fmtToInt(s: Maybe<string>): Maybe<number> {\n  return mapNotBlank(s, ea => toInt(replaceAll(ea, thousandsSep(), \"\")))\n}\n\n// See https://en.wikipedia.org/wiki/Mebibyte\nexport const KB = 1000\nexport const MB = KB * 1000\nexport const GB = MB * 1000\nexport const TB = GB * 1000\n\nexport const KiB = 1024\nexport const MiB = KiB * 1024\nexport const GiB = MiB * 1024\nexport const TiB = GiB * 1024\n\nconst byteUnits = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"]\nconst mebiUnits = [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"]\n\nexport function fmtMB(megabytes: number, sigfigs = 3): string {\n  return fmtBytes(megabytes * MB, sigfigs)\n}\n\nexport function fmtBytes(bytes: number, sigfigs = 3): string {\n  if (bytes === 0) return \"0\"\n  if (!isNumber(bytes)) return \"-\"\n  const l = Math.floor(Math.log10(bytes))\n  const mag = Math.floor(l / 3)\n  const val = Math.pow(10, mag * 3)\n  const name = byteUnits[mag]\n  return sigFigs(bytes / val, sigfigs) + \" \" + name\n}\n\nexport function fmtMebi(bytes: number, sigfigs = 3): string {\n  if (bytes === 0) return \"0\"\n  const l = Math.floor(Math.log2(bytes))\n  const mag = Math.floor(l / 10)\n  const val = Math.pow(2, mag * 10)\n  const name = mebiUnits[mag]\n  return sigFigs(bytes / val, sigfigs) + \" \" + name\n}\n\nexport const MP = 1e6\n\nexport function megapixels(pixels: number): number {\n  return sigFigs(pixels / MP, 2)\n}\n\nexport const SizeDescriptions = strEnum(\n  \"tiny\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"original\"\n)\nexport type SizeDescription = StrEnumKeys<typeof SizeDescriptions>\n\nexport function pixels2size(pixels: number): SizeDescription {\n  return pixels < 320 * 240 // qvga\n    ? \"tiny\"\n    : pixels < 720 * 480 // wvga\n    ? \"small\"\n    : pixels < 1920 * 1080 // fhd\n    ? \"medium\"\n    : \"large\"\n}\n\nexport function plur(\n  i: Maybe<number>,\n  singular: Maybe<string>,\n  plural?: string\n) {\n  if (i == null) return \"\"\n  if (blank(singular)) return fmt(i)\n  return (\n    fmt(i) + \" \" + (i === 1 ? singular : (plural ?? pluralize(singular)).trim())\n  )\n}\n\nexport interface Metric {\n  count: string\n  desc: string\n}\n\nexport function plurMetric(i: number, singular: string, plural?: string) {\n  plural ??= pluralize(singular)\n  return { count: fmt(i), desc: i === 1 ? singular : plural }\n}\n","export class UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`)\n    this.name = \"UnreachableCaseError\"\n  }\n}\n","import { maybeCall } from \"./Object\"\n\nexport function setUnrefTimeout(callback: (args: void) => void, ms?: number) {\n  const t = setTimeout(callback, ms)\n  return maybeCall(t, \"unref\") ?? t\n}\n","import { lazy } from \"./Lazy\"\nimport { toS } from \"./toS\"\n\nexport const ua = lazy(() => toS((globalThis as any)?.navigator?.userAgent))\n","import { Maybe } from \"./MaybeTypes\"\n\n// file deepcode ignore reDOS: <these RE can't cause a DOS>\n\nconst chromeRE = /\\bChrome\\b/\nconst safariRE = /\\bSafari\\b/\nconst firefoxRE = /\\bFirefox\\b/\nconst ipadRE = /\\biPad\\b/\nconst iphoneRE = /\\biPhone\\b/\n\nfunction matches(ua: Maybe<string>, re: RegExp): boolean {\n  return ua != null && String(ua).match(re) != null\n}\n\nexport function isChrome(ua: Maybe<string>): boolean {\n  return matches(ua, chromeRE)\n}\n\nexport function isSafari(ua: Maybe<string>): boolean {\n  return matches(ua, safariRE) && !isChrome(ua) && !isFirefox(ua)\n}\n\nexport function isFirefox(ua: Maybe<string>): boolean {\n  return matches(ua, firefoxRE)\n}\n\n// NOPE https://developer.apple.com/forums/thread/119186\nexport function isIpad(ua: Maybe<string>): boolean {\n  return matches(ua, ipadRE)\n}\n\nexport function isIphone(ua: Maybe<string>): boolean {\n  return matches(ua, iphoneRE)\n}\n","import { map2Or } from \"../Maybe\"\nimport { Maybe } from \"../MaybeTypes\"\nimport { isNumber } from \"../Number\"\nimport { AssetId } from \"./Asset\"\n\nexport interface ID {\n  id: number\n  v: number\n}\n\nexport type IDish = ID | number | AssetId | { tagId: number }\n\n/**\n * @returns numeric id\n */\nexport function id2id(id: Maybe<IDish>): Maybe<number> {\n  const a = id as any\n  // ids may be negative for stream placeholders, so don't use gt0:\n  return isNumber(id)\n    ? id\n    : isNumber(a.id)\n    ? a.id\n    : isNumber(a.assetId)\n    ? a.assetId\n    : isNumber(a.tagId)\n    ? a.tagId\n    : undefined\n}\n\n/**\n * An ID is \"equal\" to a number if the number equals the `id`.\n *\n * If both are numbers, or both are instances of ID, use `eql`.\n */\nexport function idEql(a: IDish, b: IDish): boolean {\n  return map2Or(\n    id2id(a),\n    id2id(b),\n    (i, j) => i === j,\n    () => false\n  )\n}\n","import { strEnum, StrEnumKeys } from \"../StrEnum\"\n\nexport const SyncStatuses = strEnum(\"processing\", \"paused\", \"done\")\nexport type SyncStatus = StrEnumKeys<typeof SyncStatuses>\n\nexport const RebuildingURI = \"rebuilding://\"\nexport const EmptyDeletedURI = \"emptydeleted://\"\nexport const EmptyRemovedURI = \"emptyremoved://\"\n\nexport function isRebuildProgress(obj?: { uri?: string }): boolean {\n  return RebuildingURI === obj?.uri\n}\n\nexport function noRecentAssetIdsProgress(obj?: { uri?: string }): boolean {\n  return [EmptyDeletedURI, EmptyRemovedURI].includes(obj?.uri as any)\n}\n\nexport interface Percents {\n  /**\n   * Percent of the found assets that have been processed\n   */\n  completePct?: number\n  /**\n   * Percent of the found assets that remain to be processed\n   */\n  incompletePct?: number\n  /**\n   * Percent of the current volume that has **not yet** been scanned. If\n   * \"scanning\" isn't relevant for this task, like library rebuilding or\n   * emptying trash, this should be 0.\n   */\n  scanningPct?: number\n}\n\n// Called \"ProgressState\" rather than \"SyncState\" because it sometimes holds\n// \"oes noes I'm paused\" or \"hey I'm starting now yay\"\nexport interface ProgressState extends Percents {\n  uri?: string\n  /** aka mountpoint. \"C:\" or \"/homes/matthew/Pictures\" or \"🗑️\" */\n  volume: string\n  state?: SyncStatus\n  /** heading/title for the progress panel */\n  hed?: string\n  /** deck (sentence or two description) */\n  dek?: string[]\n}\n\nexport interface ProgressStateWithAssets extends ProgressState {\n  recentAssetIds: number[]\n}\n\nexport const ProgressWithAssetsProps: (keyof ProgressStateWithAssets)[] = [\n  \"uri\",\n  \"volume\",\n  \"state\",\n  \"hed\",\n  \"dek\",\n  \"completePct\",\n  \"incompletePct\",\n  \"scanningPct\",\n  \"recentAssetIds\"\n]\n","import { strEnum, StrEnumKeys } from \"../StrEnum\"\n\n// in order of goodness:\nexport const S = strEnum(\"plus\", \"lite\")\nexport type SubscriptionTier = StrEnumKeys<typeof S>\n","import { sort } from \"../ArraySort\"\nimport { notBlank } from \"../Blank\"\nimport { stringify } from \"../JSON\"\nimport { mapNumeric } from \"../Number\"\nimport { Valued } from \"../Object\"\nimport { strEnum, StrEnumKeys } from \"../StrEnum\"\nimport { isString } from \"../String\"\nimport { ThumbFit } from \"../ThumbFit\"\nimport { assembleFullPath, URLSearchParamable } from \"../URLSearchParams\"\nimport { AssetId } from \"./Asset\"\n\n// TODO: this should be adaptive based on size of the client window\nexport const ThumbsPerSample = 128\n\nexport const BeforeAfterStreamLimit = 8 // NOTE: must match gallery-grid SCSS\n\n/**\n * Response object from /api/tag/:tagId.json\n */\nexport interface ApiTag {\n  tagId: number // root is 0\n  tagPath: string[]\n  description?: string\n  displayPath: string[]\n  assetCount: number\n  releasedAt?: number // millis timestamp, used for sorting albums\n}\n\n// we used to page via capturedAtLt, but for tags that include > ThumbsPerSample\n// of the same capturedAtLocal, paging broke.\n// See https://forum.photostructure.com/t/thumbnails-missing-server-install/675/16?u=mrm\nexport interface TagAssetsCriteria {\n  offset: number\n  // don't need seed here: we're just paging through.\n}\n\n// Returned from /api/t/:tagId/assets?capturedAtLt=456\nexport interface TagAssets {\n  tagId: number\n  assetIds: AssetId[] // may be paged, not prng'ed\n  // TODO: prevAssets?: TagAssetsCriteria // /api/tag/:tagId/assets.json?capturedAtGt=123\n  nextAssets?: TagAssetsCriteria // /api/tag/:tagId/assets.json?capturedAtLt=123\n}\n\nexport function nextAssetsUrl(tagId: number, crit: TagAssetsCriteria): string {\n  const params: Valued<string> = {}\n  mapNumeric(crit.offset, lt => (params.offset = lt.toString()))\n  // we don't call it \"/api/tag/$tagId\" because it's ambiguous with the tag-path\n  // endpoint:\n  return assembleFullPath(`/api/t/${tagId}/assets`, params)\n}\n\nexport interface ChildTagCriteria {\n  tagId: number\n  seed: number\n  limit?: number\n  offset?: number\n}\n\nexport type ChildTag = ApiTag & TagAssets\n\n// Returned from /api/t/:tagId/child-tags?seed=123&offset=0\nexport interface ChildTags {\n  tagId: number\n  childTagCount: number\n  childTags: ChildTag[]\n  nextChildTags?: ChildTagCriteria\n}\n\nexport function nextChildTagsUrl(\n  tagId: number,\n  crit: ChildTagCriteria\n): string {\n  const params: URLSearchParamable = {}\n  mapNumeric(crit.seed, ea => (params.seed = ea.toString()))\n  mapNumeric(crit.limit, ea => (params.limit = ea.toString()))\n  mapNumeric(crit.offset, ea => (params.offset = ea.toString()))\n  // we don't call it \"/api/tag/$tagId\" because it's ambiguous with the tag-path\n  // endpoint:\n  return assembleFullPath(`/api/t/${tagId}/child-tags`, params)\n}\n\n// Returned from /api/tag/:tagPath\nexport interface ApiTagGallery extends ApiTag, TagAssets, ChildTags {\n  fullPath: string\n  emptyLibrary?: boolean\n  startingUp?: boolean\n  fit: ThumbFit\n}\n\nexport const TagGalleryProps: (keyof ApiTagGallery)[] = [\n  \"tagId\",\n  \"tagPath\",\n  \"assetCount\",\n  \"assetIds\",\n  \"nextAssets\",\n  \"childTags\",\n  \"nextChildTags\"\n]\n\nexport interface TagGalleryContext {\n  seed: number\n  tagIds: number[]\n}\n\nexport function ctxToS(ctx: TagGalleryContext): string {\n  return stringify({ seed: ctx.seed, tagIds: sort([...ctx.tagIds]) })\n}\n\nexport interface TagRef {\n  name: string\n  displayName?: string\n  ordinal?: number\n  description?: string\n  releasedAt?: number // millis timestamp\n}\n\nexport function isTagRef(t: any): t is TagRef {\n  return t != null && !isString(t) && notBlank(t.name)\n}\n\nexport type TagPath = (string | TagRef)[]\n\nexport const TagRoots = strEnum(\n  \"When\",\n  \"Who\",\n  \"Where\",\n  \"What\",\n  \"Camera\",\n  \"Lens\",\n  \"Albums\",\n  \"Keywords\",\n  \"Type\",\n  \"fs\"\n)\nexport type TagRoot = StrEnumKeys<typeof TagRoots>\n\nexport const LibraryTagName = \"Library\"\n\nexport const NotInfoPanelTags: string[] = [\n  TagRoots.When,\n  TagRoots.Camera,\n  TagRoots.Lens,\n  TagRoots.Type,\n  TagRoots.fs\n]\n\nexport function isInfoTag(rootNameOrTag: string | ApiTag) {\n  if (rootNameOrTag == null) return false\n  const root = isString(rootNameOrTag)\n    ? rootNameOrTag\n    : rootNameOrTag.tagPath?.[0]\n  return !NotInfoPanelTags.includes(root)\n}\n","import { isEmpty } from \"../Array\"\nimport { lazy } from \"../Lazy\"\nimport { Maybe } from \"../MaybeTypes\"\nimport { isDigits } from \"../Number\"\nimport { prngSeed } from \"../PRNG\"\nimport {\n  assembleFullPath,\n  toURLSearchParams,\n  URLSearchParamable\n} from \"../URLSearchParams\"\n\n// for tests:\nexport const urlSeed = lazy(prngSeed, 100)\n\nfunction ensureSeed(query: Maybe<URLSearchParamable>, forceNewSeed: boolean) {\n  const usp = toURLSearchParams(query)\n  if (forceNewSeed || !isDigits(usp?.get(\"seed\"))) {\n    const seed = urlSeed().toString()\n    usp?.set(\"seed\", seed)\n    return usp ?? { seed }\n  }\n  // we already have a seed, yay:\n  return usp\n}\n\n/**\n * @return fullPath for home page (NO PROTOCOL OR HOSTNAME!)\n */\nexport function mkHomeFullPath(query?: URLSearchParamable) {\n  return mkTagFullPath([], query, true)\n}\n\nexport function mkTagFullPath(\n  tagPath: string[],\n  query?: URLSearchParamable,\n  forceNewSeed: boolean = false\n) {\n  const o = mkTagUri(tagPath, query, forceNewSeed)\n  return assembleFullPath(o.path, o.query)\n}\n\nexport function mkTagUri(\n  tagPath: string[],\n  query?: URLSearchParamable,\n  forceNewSeed: boolean = false\n) {\n  return {\n    path:\n      \"/tag/\" +\n      (isEmpty(tagPath) ? \"\" : tagPath.map(encodeURIComponent).join(\"/\")),\n    query: ensureSeed(query, forceNewSeed)\n  }\n}\n","export function isError(obj: any): obj is Error {\n  return obj != null && obj instanceof Error\n}\n","// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(obj: any): obj is Function {\n  return typeof obj === \"function\"\n}\n","import { isIterable } from \"./Iterable\"\nimport { isString } from \"./String\"\n\nexport type Arrayish<T> = ArrayLike<T> | Iterable<T> | Set<T>\n\nexport type OneOrMore<T> = T | Arrayish<T>\n\nexport function toA<T>(arr: undefined | null | Arrayish<T> | T): T[] {\n  return Array.isArray(arr) // < strings are not arrays\n    ? (arr as T[])\n    : arr == null\n    ? []\n    : isString(arr) // < don't rely on isIterable rejecting Strings\n    ? [arr as T]\n    : isIterable(arr)\n    ? Array.from(arr)\n    : [arr as T]\n}\n","import { compact } from \"./Array\"\nimport { isError } from \"./isError\"\nimport { toA } from \"./toA\"\nimport { toS } from \"./toS\"\n\nexport function toErr(obj: any): Error | undefined {\n  return obj == null ? undefined : isError(obj) ? obj : new Error(toS(obj))\n}\n\nexport function toErrs(...objs: any[]): Error[] {\n  return compact(toA(objs).map(toErr))\n}\n","import { stringify } from \"./JSON\"\n\n/**\n * Similar to `String(a)`, but `undefined` and `null` render as \"\", arrays are\n * comma-separated with no square bracket prefix/suffix\n */\nexport function toS(a?: any | any[]): string {\n  return toStr(a, \",\")\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst DefaultToString = {}.toString\n\n// types: \"undefined\" \"object\" \"boolean\" \"number\" \"bigint\" \"string\" \"symbol\" \"function\" \"object\"\nexport function toStr(a: any | any[], joinChar = \",\"): string {\n  if (a == null) {\n    return \"\"\n  } else {\n    switch (typeof a) {\n      case \"string\":\n        return a\n      case \"boolean\":\n      case \"number\":\n      case \"bigint\":\n      case \"symbol\":\n        return String(a)\n      default: // \"function\" or \"object\"\n        if (Array.isArray(a)) {\n          return a.map(ea => toStr(ea, joinChar)).join(joinChar)\n        } else if (a.toString !== DefaultToString) {\n          return a.toString()\n        } else {\n          return stringify(a)\n        }\n    }\n  }\n}\n","import { mapAsync } from \"../core/async/Promise\"\nimport { libraryPreviewsDirPosixFile } from \"../core/dir/LibraryDirs\"\nimport { isSharedStateFileOrDir } from \"../core/event/SharedState\"\nimport { FileCleanup } from \"../core/fs/FileCleanup\"\nimport { defaultFsAdvisoryLockDir } from \"../core/fs/FsAdvisoryLocks\"\nimport { isPsLockFileOrDir } from \"../core/fs/FsLockDir\"\nimport { PosixFile } from \"../core/fs/PosixFile\"\nimport { readdirCacheDir, ReadDirCacheName } from \"../core/fs/Readdir\"\nimport { isWip } from \"../core/fs/WIP\"\nimport { imageCacheDir_, ImageCacheName } from \"../core/img/ImageCache\"\nimport { lazy } from \"../core/Lazy\"\nimport { LogDirCleanup } from \"../core/log/LogDirCleanup\"\nimport { mkLogger } from \"../core/Logger\"\nimport { Pids, ProcCleaner } from \"../core/Pids\"\nimport { isDbJanitorService } from \"../core/ServiceNames\"\nimport { Settings } from \"../core/settings/Settings\"\nimport { compact } from \"../fe/Array\"\nimport { hourMs } from \"../fe/Date\"\nimport { Library } from \"./Library\"\nimport { vacuumStatDbDirs } from \"./StatsDbDir\"\nimport { forceRunTagMaintenance } from \"./tag/TagSql\"\n\nconst logger = lazy(() => mkLogger(\"Cleanup\"))\n\nexport async function cleanup_() {\n  const library = Library.instance()\n  if (library == null) {\n    logger().info(\"No library to vacuum.\")\n  } else {\n    logger().info(\"Running tag and search maintenance...\")\n    await forceRunTagMaintenance()\n    logger().info(\"Vacuuming db...\")\n    await (await library.dbModelSetup_()).db.vacuum()\n    if (isDbJanitorService()) {\n      logger().info(\"Running database maintenance...\")\n      await library.runDbBackup()\n    }\n  }\n\n  logger().info(\"Cleaning child processes...\")\n  await Pids.instance()?.killOldProcs()\n\n  logger().info(\"Cleaning stale stat db directories...\")\n  await vacuumStatDbDirs()\n\n  logger().info(\"Cleaning stale and temp files...\")\n  await mapAsync({\n    name: \"fileCleanup\",\n    arr: fileCleanups(),\n    f: ea => ea.cleanup()\n  })\n}\n\nexport const imageCacheCleanup = lazy(\n  () =>\n    new FileCleanup(\n      \"imageCacheCleanup\",\n      imageCacheDir_,\n      Settings.imageCacheMs.valueOrDefault,\n      f => f.pathnames.includes(ImageCacheName)\n    )\n)\n\nexport const readdirCleanup = lazy(\n  () =>\n    new FileCleanup(\n      \"readdirCacheCleanup\",\n      async () => PosixFile.for(readdirCacheDir()),\n      Settings.readdirCacheMs.valueOrDefault,\n      f => f.pathnames.includes(ReadDirCacheName)\n    )\n)\n\nexport const sharedFileCleanup = lazy(\n  () =>\n    new FileCleanup(\n      \"sharedFileCleanup\",\n      () => PosixFile.forMaybe(Settings.sharedStateDir.valueOrDefault),\n      hourMs,\n      isSharedStateFileOrDir\n    )\n)\n\nexport const previewWipCleanup = lazy(\n  () =>\n    new FileCleanup(\n      \"previewWipCleanup\",\n      libraryPreviewsDirPosixFile,\n      hourMs,\n      f => isPsLockFileOrDir(f) || isWip(f)\n    )\n)\n\nexport const advisoryLockWipCleanup = lazy(\n  () =>\n    new FileCleanup(\n      \"advisoryLockWipCleanup\",\n      defaultFsAdvisoryLockDir,\n      hourMs,\n      isPsLockFileOrDir\n    )\n)\n\nexport function fileCleanups() {\n  return compact([\n    imageCacheCleanup(),\n    readdirCleanup(),\n    sharedFileCleanup(),\n    previewWipCleanup(),\n    advisoryLockWipCleanup(),\n    LogDirCleanup()\n  ])\n}\n\nexport const scheduleFileAndProcCleanups = lazy(() => {\n  ProcCleaner()\n  for (const ea of fileCleanups()) {\n    ea.scheduleInterval()\n  }\n})\n","import { AssetFileVersion, AssetVersion } from \"../core/PhotoStructureVersions\"\nimport { Asset } from \"./model/Asset\"\nimport { AssetFile } from \"./model/AssetFile\"\nimport { Operation, OperationNames } from \"./model/Operation\"\n\nexport function forceRebuildLibrary() {\n  Asset.dbl.runf(q => q.update({ version: 0 }))\n  AssetFile.dbl.runf(q => q.update({ version: 0 }))\n  Operation.dbl.runf(q =>\n    q\n      .where({\n        name: OperationNames.enqueueAssetFileUpdates,\n        version: AssetFileVersion\n      })\n      .orWhere({\n        name: OperationNames.enqueueAssetUpdates,\n        version: AssetVersion\n      })\n      .delete()\n  )\n}\n","import { end, Endable, EndableRanks, ending } from \"../core/async/Endable\"\nimport { EndableWrapper } from \"../core/async/EndableWrapper\"\nimport { exit } from \"../core/async/Exit\"\nimport { setupLuxon } from \"../core/date/SetupLuxon\"\nimport { pathToDb } from \"../core/db/Schemas\"\nimport {\n  libraryDataDirPosixFile,\n  libraryOriginalsDirPosixFile,\n  libraryPreviewsDirPosixFile,\n  setupLibraryDirs_\n} from \"../core/dir/LibraryDirs\"\nimport { FatalErrorFlag } from \"../core/error/ErrorFlags\"\nimport { WrappedError } from \"../core/error/WrappedError\"\nimport { BaseFile } from \"../core/fs/BaseFile\"\nimport { nativePathsEqlSync } from \"../core/fs/NativePathsEql\"\nimport { PosixFile } from \"../core/fs/PosixFile\"\nimport { HealthCheck } from \"../core/health/HealthCheck\"\nimport { imageCacheDir_ } from \"../core/img/ImageCache\"\nimport { Previews } from \"../core/img/Previews\"\nimport { lazy } from \"../core/Lazy\"\nimport {\n  isDbService,\n  isStatsDbService,\n  isSyncService\n} from \"../core/ServiceNames\"\nimport { Settings } from \"../core/settings/Settings\"\nimport {\n  _libraryHasSettings,\n  readLibrarySettings\n} from \"../core/settings/SettingsIO\"\nimport { bestVolumeForPath } from \"../core/volumes/Volumes\"\nimport { commandTimeoutMs } from \"../core/volumes/VolumeTtls\"\nimport { clearMaxWorkCaches } from \"../core/work/MaxCpus\"\nimport { blank } from \"../fe/Blank\"\nimport { isTrue } from \"../fe/Boolean\"\nimport { minuteMs } from \"../fe/Date\"\nimport { Latch } from \"../fe/Latch\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { tap } from \"../fe/Object\"\nimport { DbModelJanitor } from \"./db/DbModelJanitor\"\nimport { dbModelSetup_ } from \"./db/DbModelSetup\"\nimport { libraryHealthCheckSetup } from \"./health/LibraryHealthChecks\"\nimport { statsDbJanitor } from \"./stats/StatsDbJanitor\"\nimport { statsDbDir_ } from \"./StatsDbDir\"\nimport { AssetFileRepository } from \"./sync-file/AssetFileRepository\"\n\n// DON'T DO THIS! LibrarySettings will take care of this.\n// Settings.libraryDir.addListener(() => Library.onLibraryDirChange())\n\n/**\n * Given a library root directory, provides paths and factory methods for\n * library services, like the SeenFileFilter, Previews, and database setup.\n *\n * Note that a given process only supports a single library, so this should\n * be a singleton. Most likely the singleton will be managed by a singleton\n * instance of `Service`.\n */\nexport class Library extends EndableWrapper implements Endable {\n  readonly start = Date.now()\n  static #priorInstance: Maybe<Library>\n\n  // This must not be async to ensure only one instance is currently live:\n  static instance(): Maybe<Library> {\n    const libraryDir = Settings.libraryDir.valueOrDefault\n    const priorDir = this.#priorInstance?.rootDir.nativePath\n    const priorWasOpen = this.#priorInstance?.isReadySync() === true\n    const priorEnded = this.#priorInstance?.ended === true\n\n    if (nativePathsEqlSync(priorDir, libraryDir) && !priorEnded) {\n      // Prior instance is valid!\n      return this.#priorInstance\n    }\n\n    if (isSyncService() && priorWasOpen) {\n      void exit({\n        reason: `Library changed mid-run. Shutting down to pick up new library at ${libraryDir}.`,\n        status: 0\n      })\n      return\n    }\n\n    // Prior instance is wrong: end it and spin up a new one.\n    void end(this.#priorInstance) // < (we don't need to wait for it to end)\n\n    return (this.#priorInstance =\n      blank(libraryDir) || !_libraryHasSettings(libraryDir)\n        ? undefined\n        : new Library(libraryDir))\n  }\n\n  static get priorInstance() {\n    return this.#priorInstance\n  }\n\n  static endPriorInstance() {\n    const prior = this.#priorInstance\n    this.#priorInstance = undefined\n    return end(prior)\n  }\n\n  static async instanceReady() {\n    const i = Library.instance()\n    await i?.ready\n    return i\n  }\n\n  static instanceRequired() {\n    const l = Library.instance()\n    if (l == null) {\n      throw new Error(\"Library is undefined\" + FatalErrorFlag)\n    } else {\n      return l\n    }\n  }\n\n  readonly readyLatch = new Latch()\n  readonly rootDir: PosixFile\n  readonly dataDir: PosixFile\n\n  constructor(rootDir: string | BaseFile) {\n    super(`library.Library(${rootDir})`, () => this.onEnd(), EndableRanks.predb)\n    this.rootDir = PosixFile.for(rootDir)\n    this.dataDir = libraryDataDirPosixFile(this.rootDir)!\n    this.logger.info(\"new()\")\n    void this.#setup()\n  }\n\n  get isPendingSetup() {\n    return this.readyLatch.isPending()\n  }\n\n  readonly #setup = lazy(async () => {\n    const throwIfEnding = () => {\n      if (this.ended || ending()) throw new Error()\n    }\n    try {\n      this.logger.debug(\"setup() started\")\n\n      throwIfEnding()\n\n      await readLibrarySettings(this.rootDir.nativePath)\n      await setupLibraryDirs_(this.rootDir)\n\n      // pre-emptively cache the locale, so that we don't have to wait for it\n      // later\n      await setupLuxon()\n\n      // Prevent health checks from initially failing by setting up all these\n      // directories in setup():\n      await this.statsDbDir_()\n      await imageCacheDir_()\n\n      throwIfEnding()\n\n      const previewsVol = await bestVolumeForPath(\n        libraryPreviewsDirPosixFile(this.rootDir)\n      )\n      if (isTrue(previewsVol?.remote)) {\n        const max = Settings.maxConcurrentImportsWhenRemote.valueOrDefault\n        if (!Settings.maxConcurrentImports.hasValue()) {\n          Settings.maxConcurrentImports.tmpValue = max\n          clearMaxWorkCaches()\n        }\n        this.logger.warn(\n          `Library previews are on a remote volume. Setting maxSyncFileJobsMax to ${max}.`\n        )\n      }\n\n      throwIfEnding()\n\n      if (isDbService()) {\n        await this.dbModelJanitor()\n      }\n\n      this.previews()\n\n      throwIfEnding()\n\n      if (isStatsDbService()) {\n        await this.statsDb()\n      }\n      if (this.readyLatch.isPending()) {\n        this.logger.info(\"Library.setup() finished.\")\n        void this.readyLatch.resolve()\n      }\n      await libraryHealthCheckSetup()\n      setImmediate(() => HealthCheck.awaitSettled())\n    } catch (error) {\n      this.logger.error(\"setup() failed:\", { error })\n      if (!this.ended && !ending()) {\n        HealthCheck.addError(error)\n        void this.readyLatch.reject(\n          new WrappedError(\"Failed to start library\", {\n            cause: error\n          })\n        )\n      }\n    }\n  })\n\n  get ready() {\n    return this.readyLatch.promise\n  }\n\n  isReadySync() {\n    return this.readyLatch.isResolved()\n  }\n\n  readonly statsDbDir_ = lazy(() => statsDbDir_() as Promise<PosixFile>)\n\n  readonly previews = lazy(() =>\n    tap(new Previews(libraryPreviewsDirPosixFile(this.rootDir)!), ea =>\n      Previews.instance.set(ea)\n    )\n  )\n\n  readonly originalsDir = lazy(\n    () => libraryOriginalsDirPosixFile(this.rootDir)!\n  )\n\n  readonly assetFileRepository = lazy(() => {\n    return new AssetFileRepository(this.originalsDir())\n  })\n\n  readonly libraryDbFile = lazy(() => pathToDb(this.dataDir, \"models\"))\n\n  readonly dbModelSetup_ = lazy(async () => {\n    if (isDbService()) {\n      return dbModelSetup_(this.rootDir)\n    } else {\n      throw new Error(\"Not a db service\")\n    }\n  })\n  readonly dbFsLock = lazy(async () => {\n    return (await this.dbModelSetup_()).fslock\n  })\n  readonly useReplica = lazy(async () => {\n    return (await this.dbModelSetup_()).useReplica\n  })\n  readonly modelDb = lazy(async () => {\n    return (await this.dbModelSetup_()).db\n  })\n  readonly dbModelJanitor = lazy(async () => {\n    const info = await this.dbModelSetup_()\n    return new DbModelJanitor(info.db, info.fslock, info.libraryDbFile)\n  })\n  async runDbBackup() {\n    return (await this.dbModelJanitor())?.backup_()\n  }\n\n  readonly statsDb = lazy(async () => statsDbJanitor(await this.statsDbDir_()))\n  readonly statsDbFile = lazy(() => this.statsDb().then(ea => ea.dbFile))\n\n  // Used when library path changes and by tests:\n  private readonly onEnd = lazy(async () => {\n    for (const { ea, t } of [\n      { ea: this.statsDb.clear(), t: commandTimeoutMs() },\n      { ea: this.dbModelJanitor.clear(), t: 5 * minuteMs },\n      { ea: this.dbFsLock.clear(), t: commandTimeoutMs() }\n    ]) {\n      await end(ea, t)\n    }\n    this.logger.info(\"onEnd(): finished.\")\n  })\n}\n","import { PosixFile } from \"../core/fs/PosixFile\"\nimport { expensiveFileFiltersFor } from \"../core/fs/PosixFileFilters\"\nimport { isValidFile } from \"../core/img/ValidFile\"\nimport { PredicateBundle } from \"../core/predicates/Predicates\"\nimport { modelDb } from \"./model/ModelDb\"\nimport { notBlocklistedSha } from \"./model/ShaBlocklist\"\n\nexport function libraryFileFiltersFor(\n  file: PosixFile,\n  { validateFile = false }: { validateFile?: boolean } = {}\n): PredicateBundle<PosixFile> {\n  const arr = expensiveFileFiltersFor(file)\n  if (modelDb() != null) arr.push({ notBlocklistedSha })\n  if (validateFile) arr.push({ isValidFile })\n  return arr\n}\n","import { lazy } from \"../core/Lazy\"\nimport { isProd } from \"../core/NodeEnv\"\nimport { isEnvTrue } from \"../core/env/GetEnv\"\nimport { isPacked } from \"../core/platform/IsPacked\"\nimport { Settings } from \"../core/settings/Settings\"\nimport { later } from \"../fe/Delay\"\n\nexport const sentryEnabled = lazy(\n  () =>\n    isEnvTrue(\"ENABLE_SENTRY\" as any) || // < allow for manual testing\n    (isProd && isPacked() && Settings.reportErrors.valueOrDefault)\n)\n\nlater(() => {\n  Settings.reportErrors.watchLater(() => sentryEnabled.clear())\n})\n","import * as Sentry from \"@sentry/node\"\nimport { Breadcrumb, Event, EventHint, SeverityLevel } from \"@sentry/types\"\nimport os from \"os\"\nimport process from \"process\"\nimport { lazy } from \"../core/Lazy\"\nimport { locale } from \"../core/Locale\"\nimport { mkLogger } from \"../core/Logger\"\nimport { memoryUsageMb, memoryUsageRssMb } from \"../core/Memory\"\nimport { nodeEnv } from \"../core/NodeEnv\"\nimport { CPUs, osFullName } from \"../core/OperatingSystem\"\nimport { processName, serviceName } from \"../core/ServiceNames\"\nimport { runtimeMs } from \"../core/StartTs\"\nimport { ellipsize, isString, stripAnsiEsc } from \"../core/String\"\nimport { release, version } from \"../core/Version\"\nimport { EndableRanks, ending } from \"../core/async/Endable\"\nimport { EndableWrapper } from \"../core/async/EndableWrapper\"\nimport { serviceExitTimeoutMs } from \"../core/child/ServiceExitTimeoutMs\"\nimport { errorToS } from \"../core/error/Error\"\nimport { ErrorStore, StoredError } from \"../core/error/ErrorStore\"\nimport { isDoNotSendError } from \"../core/error/ErrorTypes\"\nimport { onError } from \"../core/error/OnError\"\nimport { ee } from \"../core/event/EventEmitter\"\nimport { ffmpegVersionDescription } from \"../core/img/ffmpeg\"\nimport { getEmail } from \"../core/licensing/Email\"\nimport { allRecentLogEntries } from \"../core/log/AllRecentLogEntries\"\nimport { DefaultLogFlushMs } from \"../core/log/LogCommon\"\nimport { LogEntry } from \"../core/log/LogEntry\"\nimport { LogLevel, LogLevels } from \"../core/log/LogLevel\"\nimport { isElectron } from \"../core/platform/Platform\"\nimport { isDocker } from \"../core/platform/isDocker\"\nimport {\n  compact,\n  compactBlankish,\n  compactBlanks,\n  isEmpty,\n  mapNotEmpty,\n  uniq\n} from \"../fe/Array\"\nimport { blank, notBlank } from \"../fe/Blank\"\nimport { secondMs } from \"../fe/Date\"\nimport { delay } from \"../fe/Delay\"\nimport { stringify } from \"../fe/JSON\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { fmtBytes } from \"../fe/Units\"\nimport { toA } from \"../fe/toA\"\nimport { toS } from \"../fe/toS\"\nimport { sentryEnabled } from \"./SentryEnabled\"\nimport { Service } from \"./Service\"\n\nconst logger = lazy(() => mkLogger(\"Sentry\"))\n\nconst MaxBreadcrumbs = 100\n\nexport async function installSentry(service: Service) {\n  try {\n    if (!sentryEnabled()) return false\n    Sentry.init({\n      // See https://sentry.io/settings/photostructure-inc/projects/photostructure-for-desktop/keys/\n\n      dsn: isElectron\n        ? \"https://0652cdd351054fe9853ff944b1f54e2c@o130922.ingest.sentry.io/289071\"\n        : \"https://5f52aefec1b3439eaed2e77b2d1210a8@o130922.ingest.sentry.io/1828379\",\n      shutdownTimeout: serviceExitTimeoutMs(service.name),\n      release: release, // Must match webpack and bin/release\n      environment: nodeEnv,\n      maxBreadcrumbs: MaxBreadcrumbs,\n      integrations: [], // we do everything\n      beforeSend: eventFilter().beforeSend,\n      onFatalError: (error: Error) => onError(\"sentry.onFatalError\", error)\n    })\n    logger().info(\"Sentry initialized\", { isElectron })\n    return true\n  } catch (error) {\n    logger().warn(\"Failed to set up sentry\", { error })\n    return false\n  }\n}\n\nexport function sendToSentry(error: Error) {\n  if (sentryEnabled() && error != null && true !== isDoNotSendError(error)) {\n    Sentry.captureException(error)\n  }\n}\n\nexport const eventFilter = lazy(() => new EventFilter())\n\nexport class EventFilter {\n  constructor() {\n    ee().on(\"fatal\", sendToSentry)\n    ee().on(\"nonFatal\", sendToSentry)\n    new EndableWrapper(\"EventFilter\", () => this.end(), EndableRanks.first)\n  }\n\n  private end() {\n    return map(Sentry.getCurrentHub().getClient(), ea => ea.close(5 * secondMs))\n  }\n\n  readonly beforeSend = async (\n    event: Event,\n    hint?: EventHint\n  ): Promise<Event | null> => {\n    // < this must satisfy the beforeSend API\n    if (!sentryEnabled()) {\n      logger().warn(\"Sentry.beforeSend(): not sending event\", event)\n      return null\n    }\n\n    if (true === (await ErrorStore.instance()?.eventQuotaExceeded(event))) {\n      logger().warn(\"Sentry.beforeSend(): event quota exceeded\", event)\n      return null\n    }\n\n    const message = extractMessage(event, hint)\n\n    if (true === isDoNotSendError(message)) {\n      logger().info(\"Sentry.beforeSend(): event not sendable. vetoing\", {\n        event,\n        hint,\n        msg: message\n      })\n      return null\n    }\n    if (blank(event.message)) {\n      event.message = ellipsize(message, 256)\n    }\n    const e = await annotateEvent(event as any)\n    return (await ErrorStore.instance()?.maybeSendEvent(e)) ?? null\n  }\n}\n\nexport function extractMessage(event: Event, hint?: EventHint): string {\n  return uniq(\n    compactBlankish([\n      event.message,\n      ...toA(sentryExceptionsToS(event.exception?.values)),\n      errorToS(hint?.originalException)\n    ])\n  ).join(\": \")\n}\n\nexport function sentryExceptionsToS(\n  e: Maybe<Sentry.Exception[]>\n): Maybe<string[]> {\n  return mapNotEmpty(e, arr => compactBlanks(arr.map(sentryExceptionToS)))\n}\n\nexport function sentryExceptionToS(e: Maybe<Sentry.Exception>): Maybe<string> {\n  return mapNotEmpty(\n    compactBlanks(\n      [e?.type, e?.value].filter(ea => toS(ea).toLowerCase() !== \"error\")\n    ),\n    arr => arr.join(\": \")\n  )\n}\n\n// NOTE: Calling annotateEvent twice on an Event must be idempotent\nexport async function annotateEvent(\n  event: Event & { message: string }\n): Promise<Event & StoredError> {\n  const email = await getEmail()\n  if (notBlank(email)) {\n    if (event.user == null) event.user = {}\n    event.user.email = email\n  }\n\n  if (isEmpty(event.breadcrumbs)) event.breadcrumbs = await mkBreadcrumbs()\n\n  const extra = event.extra ?? {}\n  extra.pid = process.pid\n  extra.serviceName = serviceName()\n  extra.serviceEnding = ending()\n  extra.runtimeMs = runtimeMs()\n  extra.version = version\n  extra.os = osFullName()\n  extra.isDocker = isDocker()\n  extra.nodeVersion = process.versions.node\n  extra.locale = await locale()\n  extra.cpus = CPUs()\n  extra.memoryUsageMb = memoryUsageMb()\n  extra.memoryUsageRssMb = memoryUsageRssMb()\n  extra.systemMemory = fmtBytes(os.freemem()) + \" / \" + fmtBytes(os.totalmem())\n  extra.ffmpeg = await ffmpegVersionDescription()\n  extra.argv = stringify(process.argv)\n\n  event.extra = extra\n\n  return {\n    timestamp: Date.now() / secondMs,\n    ...event\n  }\n}\n\nexport async function mkBreadcrumbs() {\n  // wait for fs flush:\n  await delay(DefaultLogFlushMs * 3)\n  const entries = await allRecentLogEntries()\n  return compact(entries.map(logEntryToBreadcrumb))\n}\n\nexport function logEntryToBreadcrumb(le: LogEntry): Maybe<Breadcrumb> {\n  return map(logLevelToSeverity(le.l), level => ({\n    timestamp: le.ts / secondMs, // sentry is unixtime (seconds)\n    level,\n    category: le.from ?? processName(),\n    message: stripAnsiEsc(le.ctx + \": \" + le.msg),\n    data:\n      // SITS: why does Sentry require a data object?\n      typeof le.meta === \"object\"\n        ? le.meta\n        : { value: isString(le.meta) ? stripAnsiEsc(le.meta) : le.meta }\n  }))\n}\n\nconst level2sev = new Map<LogLevel, SeverityLevel>([\n  [LogLevels.fatal, \"fatal\"],\n  [LogLevels.error, \"error\"],\n  [LogLevels.warn, \"warning\"],\n  [LogLevels.info, \"info\"],\n  [LogLevels.debug, \"debug\"]\n])\n\nexport function logLevelToSeverity(l: LogLevel): Maybe<SeverityLevel> {\n  return level2sev.get(l)\n}\n","import cluster from \"cluster\"\nimport process from \"process\"\nimport { addDefaultJsonRevivers } from \"../core/JsonSetup\"\nimport { lazy } from \"../core/Lazy\"\nimport { logStartup } from \"../core/LogStartup\"\nimport { Logger, mkLogger } from \"../core/Logger\"\nimport { setProcessTitle } from \"../core/ProcessTitle\"\nimport {\n  isLibraryRequiredService,\n  isMainService,\n  isServiceThatAcceptsFatalErrors\n} from \"../core/ServiceNames\"\nimport { setServiceName } from \"../core/SetServiceName\"\nimport { stdoutWrite } from \"../core/StdoutWrite\"\nimport { version } from \"../core/Version\"\nimport { ending } from \"../core/async/Endable\"\nimport { exit } from \"../core/async/Exit\"\nimport { PromiseTimer, time } from \"../core/async/PromiseTimer\"\nimport { Promises } from \"../core/async/Promises\"\nimport { ChildServiceExitCommand } from \"../core/child/ChildServiceExitCommand\"\nimport { setupLibraryDirs_ } from \"../core/dir/LibraryDirs\"\nimport { getEnv } from \"../core/env/GetEnv\"\nimport { errorToS } from \"../core/error/Error\"\nimport { FatalErrorFlag } from \"../core/error/ErrorFlags\"\nimport { addErrorFlags } from \"../core/error/ErrorTypes\"\nimport { onError } from \"../core/error/OnError\"\nimport { WrappedError } from \"../core/error/WrappedError\"\nimport { ee } from \"../core/event/EventEmitter\"\nimport { LineReader } from \"../core/fs/LineReader\"\nimport { HealthCheck } from \"../core/health/HealthCheck\"\nimport { mergeUserDataDirs_ } from \"../core/settings/MergeConfigDirs\"\nimport { Settings } from \"../core/settings/Settings\"\nimport { setSettingsDefaults } from \"../core/settings/SettingsDefaults\"\nimport { readSettings } from \"../core/settings/SettingsIO\"\nimport { loadCuss } from \"../core/words/Cuss\"\nimport { pause, resume } from \"../core/work/IsPaused\"\nimport { mapNotBlank } from \"../fe/Blank\"\nimport { secondMs } from \"../fe/Date\"\nimport { later } from \"../fe/Delay\"\nimport { Latch } from \"../fe/Latch\"\nimport { map } from \"../fe/Maybe\"\nimport { ServiceName } from \"../fe/ServiceNames\"\nimport { toErr } from \"../fe/toErr\"\nimport { toS } from \"../fe/toS\"\nimport { installSentry } from \"./SentrySetup\"\n\nexport const setupEventHandlers = lazy(() => {\n  // listen for timing information:\n  PromiseTimer.instance()\n  ee().on(\"resume\", () => resume())\n  ee().on(\"pause\", () => pause())\n  ee().on(\"exit\", () => exit({ reason: \"exit() event\", status: 0 }))\n})\n\nexport interface ServiceOptions {\n  name: ServiceName\n  stdinReceiver?: (stdin: string) => any\n  maxErrorsPerMinute?: number\n}\n\n/**\n * Framework for creating services that accept async commands from stdin and\n * emit results to stdout. Every process will have a Service instance.\n *\n * The initial service will only be the webservice, propped up in \"libraryless\"\n * mode.\n *\n * The constructor doesn't take an interface with ready and shutdown fields\n * because the services depend on the library that this service creates, which\n * creates a circular dependency.\n */\nexport class Service {\n  readonly name: ServiceName\n  readonly #logger: Logger\n  readonly #ready = new Latch()\n  readonly promises: Promises\n  #exitted = false\n\n  private readonly inputHandlers = new Map<string, (input: string) => any>()\n\n  constructor(readonly opts: ServiceOptions) {\n    this.name = this.opts.name\n\n    // This must not be called by the billing service--it requires ExifTool.\n    setSettingsDefaults()\n\n    // TODO: FIXME: SITS: service name is being set in both CLI and here:\n    setServiceName(this.name)\n    this.#logger = mkLogger(\"Service(\" + this.name + \")\")\n\n    this.addDefaultInputHandlers()\n\n    // NOTE: if we re-use the ChunkedWorkRunner's promises instance, we wedge\n    // randomly :\\\n    this.promises = new Promises(this.name)\n\n    // By pushing the setup job onto this.jobs, we get two things:\n    // 1) exit() can wait for setup()\n    // 2) onLine() will implicitly wait for setup.\n\n    // Note also: we're not enqueuing: we're pushing: no need to wait for anything!\n    void this.promises.push(\"Service.setup()\", () => this.setup())\n  }\n\n  get ready(): Promise<void> {\n    return this.#ready.promise\n  }\n\n  get isReady(): boolean {\n    return this.#ready.isResolved()\n  }\n\n  get exitted() {\n    return this.#exitted\n  }\n\n  readonly setup = lazy<Promise<void>>(() =>\n    time(\"Service.setup()\", () => this.#setup())\n  )\n\n  async #setup() {\n    const canContinue = () => !this.#exitted && !ending()\n\n    try {\n      // set up crash handlers\n      {\n        // Test crash handler (see https://gitlab.com/photostructure/photostructure/issues/163)\n        mapNotBlank(getEnv((\"PS_FATAL_\" + this.name) as any), message => {\n          throw new WrappedError(message, { fatal: true })\n        })\n        mapNotBlank(getEnv((\"PS_CRASH_\" + this.name) as any), message => {\n          later(() => {\n            throw new WrappedError(message)\n          }, 5 * secondMs)\n        })\n      }\n\n      setProcessTitle()\n\n      addDefaultJsonRevivers()\n\n      if (isMainService()) {\n        await mergeUserDataDirs_()\n      }\n\n      await readSettings()\n\n      // set up error handling as early as we can, but only after we've read the\n      // library settings:\n      await this.#setupErrorHandling()\n\n      // log after we've read settings:\n      logStartup()\n\n      setupEventHandlers()\n\n      if (isLibraryRequiredService()) {\n        await setupLibraryDirs_()\n      }\n\n      // run in background\n      void loadCuss()\n\n      this.#stdinReadline()\n\n      if (Settings.startPaused.valueOrDefault) pause()\n\n      const reject = !canContinue()\n      if (reject) {\n        void this.#ready.reject()\n      } else {\n        void this.#ready.resolve()\n      }\n    } catch (err) {\n      console.error(errorToS(err))\n      void this.#ready.reject(toErr(err)!)\n      // We couldn't start up. No need to wait for jobs:\n      void exit({\n        reason: addErrorFlags(\n          this.name + \" setup failed: \" + errorToS(err),\n          FatalErrorFlag\n        ),\n        status: 14\n      })\n    }\n  }\n\n  async #setupErrorHandling() {\n    if (isServiceThatAcceptsFatalErrors()) {\n      ee().on(\"fatal\", error => exit({ error, status: 12 }))\n    }\n\n    process.on(\"unhandledRejection\", err =>\n      map(err, ea => onError(\"unhandledRejection\", ea as any))\n    )\n    process.on(\"uncaughtException\", err =>\n      map(err, ea => onError(\"uncaughtException\", ea))\n    )\n\n    process.on(\"SIGINT\", () => exit({ reason: \"SIGINT\", status: 0 }))\n    process.on(\"SIGTERM\", () => exit({ reason: \"SIGTERM\", status: 0 }))\n    // If the Node.js process is spawned with an IPC channel (see the Child\n    // Process and Cluster documentation), the 'disconnect' event will be\n    // emitted when the IPC channel is closed.\n    if (cluster.isWorker) {\n      process.on(\"disconnect\", () => exit({ reason: \"disconnect\", status: 0 }))\n    }\n\n    // 20220425 don't bother listening to stdout/stdin/stderr disconnections!\n\n    await installSentry(this)\n\n    return\n  }\n\n  readonly #stdinReadline = lazy(() => {\n    const rl = process.stdin.pipe(new LineReader())\n    rl.on(\"data\", line => this.onLine(toS(line)))\n    return rl\n  })\n\n  setInputHandler(command: string, f: (input: string) => any) {\n    this.inputHandlers.set(command.trim().toLowerCase(), f)\n  }\n\n  private addDefaultInputHandlers() {\n    this.setInputHandler(\"--version\", () => stdoutWrite({ version }))\n    {\n      // if the commands are via the stdin, it's safe to assume they want the\n      // jobs to complete, so the following should waitForJobs:\n      this.setInputHandler(ChildServiceExitCommand, () =>\n        // later this so we aren't considered a job to wait for (which causes exit() to hang):\n        later(() =>\n          exit({\n            reason: ChildServiceExitCommand + \" from stdin\",\n            status: 0\n          })\n        )\n      )\n    }\n\n    this.setInputHandler(\"--times\", () =>\n      stdoutWrite(PromiseTimer.instance().report())\n    )\n\n    this.setInputHandler(\"--health\", () => stdoutWrite(HealthCheck.summary()))\n  }\n\n  // This shouldn't be async, so this.stdinReadline().pause() can take effect.\n  private onLine(line: string) {\n    this.#logger.debug(\"onLine()\", { line, ending: this.#exitted || ending() })\n    return this.promises.serial(\"Service.onLine()\", async () => {\n      await this.setup()\n      if (line.startsWith(\"--\")) {\n        const cmd = line.split(\" \", 1)[0]\n        const f = this.inputHandlers.get(cmd)\n        if (f == null) {\n          this.#logger.error(\"onLine(): unknown command\", {\n            line,\n            knownCommands: [...this.inputHandlers.keys()]\n          })\n          console.warn(\"unknown command \" + line)\n        } else {\n          await f(line.slice(cmd.length).trim())\n        }\n      } else {\n        try {\n          await map(this.opts.stdinReceiver, f => f(line))\n        } catch (error) {\n          this.#logger.error(\"onLine(): failed to process\", { line, error })\n        }\n      }\n      return\n    })\n  }\n}\n","import { lazy } from \"../core/Lazy\"\nimport { mkLogger } from \"../core/Logger\"\nimport { durationHMS } from \"../core/date/Date\"\nimport {\n  libraryOriginalsDirPosixFile,\n  libraryPreviewsDirPosixFile\n} from \"../core/dir/LibraryDirs\"\nimport { Settings } from \"../core/settings/Settings\"\nimport { libraryHasSettings } from \"../core/settings/SettingsIO\"\nimport { volumeMetadataTtlMs } from \"../core/volumes/VolumeTtls\"\nimport { bestVolumeForPath, volumes } from \"../core/volumes/Volumes\"\nimport { dayMs, secondMs } from \"../fe/Date\"\nimport { clamp } from \"../fe/Number\"\nimport { GB, fmtBytes } from \"../fe/Units\"\n\nconst logger = lazy(() => mkLogger(\"SetVolumesTTL\"))\n\nexport async function setVolumesTTL() {\n  const defaultTTL = volumeMetadataTtlMs()\n  const ttl = await calcVolumesTTL()\n  volumes.setTTL(Math.max(ttl ?? defaultTTL, defaultTTL))\n}\n\nexport async function calcVolumesTTL() {\n  if (!libraryHasSettings()) return\n\n  // we can relax the volume timeout if there's tons of free disk on both the previews and originals directories.\n  const volFree: number[] = []\n  const vols = await volumes()\n  const minFreeDefaultBytes = Settings.minDiskFreeGb.defaultValue * GB\n  for (const dir of [\n    libraryOriginalsDirPosixFile(),\n    libraryPreviewsDirPosixFile()\n  ]) {\n    const vol = await bestVolumeForPath(dir, vols)\n    if (vol == null) {\n      logger().warn(\n        \"Can't find volume for \" + dir + \", using default TTL for volumes()\"\n      )\n      return\n    }\n    if (vol.available < minFreeDefaultBytes) {\n      logger().warn(\n        \"Volume for \" +\n          dir +\n          \" is almost full: using default TTL for volumes()\",\n        {\n          free: fmtBytes(vol.available),\n          minFree: fmtBytes(Settings.minDiskFreeGb.defaultValue * GB)\n        }\n      )\n      return\n    }\n    volFree.push(vol.available)\n  }\n  const excessFree = Math.min(...volFree) - minFreeDefaultBytes\n  // We won't write faster than 25MB/s\n  const secondsUntilFull = Math.round(excessFree / 25)\n  const newTTL = clamp(\n    volumeMetadataTtlMs(),\n    dayMs,\n    secondsUntilFull * secondMs\n  )\n  logger().info(\n    \"Min free volume is \" +\n      fmtBytes(Math.min(...volFree)) +\n      \". Extending volumes() TTL to \" +\n      durationHMS(newTTL),\n    { secondsUntilFull }\n  )\n  return newTTL\n}\n","import { lazy } from \"../core/Lazy\"\nimport { mkLogger } from \"../core/Logger\"\nimport { AssetFileVersion, AssetVersion } from \"../core/PhotoStructureVersions\"\nimport { shortStringSha } from \"../core/StringHash\"\nimport { SqliteBase } from \"../core/db/Schemas\"\nimport { cacheDir_ } from \"../core/dir/CacheDir\"\nimport { PosixFile } from \"../core/fs/PosixFile\"\nimport { LibraryUIDStore, SystemUIDStore } from \"../core/fs/UIDStore\"\nimport { writeTextfile_ } from \"../core/fs/WriteFile\"\nimport { TokenRadix } from \"../core/math/Radix\"\nimport { max } from \"../core/math/Vector\"\nimport { Settings } from \"../core/settings/Settings\"\nimport { libraryHasSettings } from \"../core/settings/SettingsIO\"\nimport { dayMs } from \"../fe/Date\"\nimport { stringify } from \"../fe/JSON\"\nimport { PromiseMaybe } from \"../fe/MaybeTypes\"\n\nconst logger = lazy(() => mkLogger(\"library.StatsDbDir\"))\n\nexport const CacheDirPrefix = \"sync-state-\"\n\nexport function statDbDirs(): PromiseMaybe<PosixFile[]> {\n  return PosixFile.for(cacheDir_())\n    .clear()\n    .children(ea => ea.name.startsWith(CacheDirPrefix))\n}\n\n// TCBH: By including the settings in the cache dir, we reset the cache dir if\n// the settings change. Note that this is a short SHA, as there won't be many\n// items (therefore not many chances for collisions). 3 chars of SHA goodness\n// would be most likely be fine.\n/**\n * @throws if the directory can't be created.\n */\nexport async function statsDbDir_(\n  createIfMissing = true\n): PromiseMaybe<PosixFile> {\n  if (!libraryHasSettings()) return\n\n  // Really only library settings should invalidate a cache dir:\n  // Rather than push the version, we'll push db versions, which only change\n  // when something in the asset processing pipeline changes to warrant\n  // re-syncing everything.\n  const values = {\n    AssetVersion,\n    AssetFileVersion,\n    LibraryUID: await LibraryUIDStore()?.readUid_(),\n    SystemUID: await SystemUIDStore()?.readUid_()\n  }\n  const suffix = shortStringSha(stringify(values), 10, TokenRadix)\n  const dir = PosixFile.for(cacheDir_()).join(CacheDirPrefix + suffix)\n  if (!createIfMissing) return dir\n  await writeTextfile_(\n    dir.join(\"README.txt\").nativePath,\n    \"\",\n    \"This folder holds state for library synchronization of\",\n    \"\",\n    Settings.libraryDir.value!,\n    \"\",\n    \"Don't edit the contents of this directory while PhotoStructure is running.\",\n    \"\",\n    \"If you have any questions, please visit https://forum.photostructure.com\",\n    \"\",\n    stringify(values, undefined, 2)\n  )\n  logger().info(\"Set up statsDbDir dir \" + dir)\n  return dir\n}\n\nasync function rmStatDbDir(dir: PosixFile) {\n  if (true === dir.name.startsWith(CacheDirPrefix)) {\n    await dir.rmrf()\n  } else {\n    logger().warn(\"rmStatDbDir(): refusing to rm \" + dir)\n  }\n}\n\nexport async function vacuumStatDbDirs() {\n  const currentCacheDir = await statsDbDir_()\n  for (const dir of (await statDbDirs()) ?? []) {\n    if (dir.eql(currentCacheDir)) continue\n    // don't delete the directory if it's been recently touched:\n    const newestTs = max(\n      await Promise.all([\n        dir.join(\"README.txt\").mtimeMs(),\n        dir.join(SqliteBase).mtimeMs()\n      ])\n    )\n    if (newestTs == null || newestTs < Date.now() - dayMs)\n      await rmStatDbDir(dir)\n  }\n}\n\nexport async function rmStatDbDirs() {\n  for (const dir of (await statDbDirs()) ?? []) {\n    logger().warn(\"deleting cache dir \" + dir)\n    await rmStatDbDir(dir)\n  }\n}\n","import { Rate } from \"batch-cluster\"\nimport events from \"events\"\nimport { lazy } from \"../core/Lazy\"\nimport { isTest } from \"../core/NodeEnv\"\nimport { ShortCommandTimeoutMs } from \"../core/ShortCommandTimeoutMs\"\nimport { sortIgnoreCase } from \"../core/String\"\nimport { TTLArray } from \"../core/TTLArray\"\nimport { EndableRanks } from \"../core/async/Endable\"\nimport { EndableInterval } from \"../core/async/EndableInterval\"\nimport { Promises } from \"../core/async/Promises\"\nimport { InternalError } from \"../core/error/InternalError\"\nimport { onError } from \"../core/error/OnError\"\nimport { ee } from \"../core/event/EventEmitter\"\nimport { TypedEventEmitter } from \"../core/event/TypedEventEmitter\"\nimport { Average } from \"../core/math/Average\"\nimport { isTooBusy } from \"../core/work/CpuUsage\"\nimport { doNotRun, whyDoNotRun } from \"../core/work/DoNotRun\"\nimport { isPaused } from \"../core/work/IsPaused\"\nimport { maxConcurrentImports } from \"../core/work/MaxCpus\"\nimport { compactBlanks, isEmpty } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { minuteMs, secondMs } from \"../fe/Date\"\nimport { stringify } from \"../fe/JSON\"\nimport { Latch } from \"../fe/Latch\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { gt0, round } from \"../fe/Number\"\nimport { SyncOrAsync } from \"../fe/SyncOrAsync\"\nimport { throttle } from \"../fe/Throttle\"\nimport { Queue, WorkItem } from \"./stats/Queue\"\nimport { QueueItem } from \"./stats/QueueItem\"\n\nexport interface WorkQueueEvents {\n  processed: (qi: QueueItem, elapsedMs: number) => void\n  drain: () => void\n}\n\n/**\n * Class that feeds work from a Queue to SyncFile jobs.\n *\n * Used for importing new files and updating assets and asset files.\n */\nexport class WorkQueue extends EndableInterval {\n  readonly processRate = new Rate()\n  readonly processMs = new Average()\n\n  readonly ee = new events.EventEmitter() as TypedEventEmitter<WorkQueueEvents>\n\n  // Support non-async isDone():\n  #isDone = false\n\n  // The Deferred payloads are used to track current QueueItems:\n  readonly p: Promises\n\n  readonly recentlyProcessed = new TTLArray<QueueItem>(minuteMs)\n\n  static mk(args: {\n    queueNames: string[]\n    processItem: (qi: QueueItem) => SyncOrAsync<any>\n    concurrent?: boolean\n    endWhenDone?: boolean\n  }) {\n    const queueNames = sortIgnoreCase(compactBlanks(args.queueNames))\n    if (isEmpty(queueNames))\n      throw new Error(\"WorkQueue.mk: internal error: blank queueNames\")\n    return new WorkQueue(\n      queueNames,\n      args.processItem,\n      args.concurrent,\n      args.endWhenDone\n    )\n  }\n\n  /**\n   * @param _itemIsReady `true` if the given item can run\n   */\n  private constructor(\n    readonly queueNames: string[],\n    private readonly _processItem: (qi: QueueItem) => SyncOrAsync<any>,\n    concurrent: boolean = true,\n    endWhenDone?: boolean\n  ) {\n    const name = `WorkQueue(${queueNames.join(\",\")})`\n    super({\n      name,\n      callback: () => this.#runChunkLater(),\n      intervalMs: isTest ? 250 : minuteMs,\n      onEnd: () => this.#onEnd(),\n      rank: EndableRanks.first,\n      endTimeoutMs: ShortCommandTimeoutMs\n    })\n    this.p = new Promises(name, concurrent ? maxConcurrentImports : () => 1)\n    this.p.ee.on(\"vacancy\", () => this.#runChunkLater())\n    this.p.ee.on(\"drain\", () => this.#checkIfDone())\n    if (endWhenDone === true) {\n      void this.awaitDrain().then(() => this.end())\n    }\n    ee().on(\"resume\", this.#onResume)\n  }\n\n  #onEnd(): any {\n    ee().off(\"resume\", this.#onResume)\n    return this.awaitDrain()\n  }\n\n  readonly on = this.ee.on.bind(this.ee)\n\n  readonly queues = lazy(() =>\n    Queue.ops().upsert(compactBlanks(this.queueNames).map(name => ({ name })))\n  )\n\n  readonly queueIds = lazy(() => this.queues().map(ea => ea.id!))\n\n  async awaitDrain() {\n    if (this.isDone()) return\n    const l = new Latch()\n    this.ee.once(\"drain\", () => l.resolve())\n    void this.#runChunk()\n    await l.promise\n  }\n\n  isDone() {\n    return this.ended || this.#isDone\n  }\n\n  #checkIfDone() {\n    if (this.ended) return true\n    const priorDone = this.#isDone\n    this.#isDone =\n      0 === this.currentWorkCount() &&\n      0 === this.queueItemCount() &&\n      0 === this.queueItemCount.refresh()\n\n    if (!priorDone && this.#isDone) {\n      this.#logState.refresh()\n      this.ee.emit(\"drain\")\n    }\n    return this.#isDone\n  }\n\n  isRunnable() {\n    return !this.isDone() && !this.p.isFull()\n  }\n\n  #clearCaches() {\n    this.queueItemCount.unset()\n  }\n\n  findQueue_(queueName?: string): Queue {\n    const arr = this.queues()\n    if (blank(queueName)) return arr[0]\n    const q = arr.find(ea => ea.name === queueName)\n    if (q == null) {\n      throw new InternalError(\n        \"WorkQueue: unknown queue name \" + stringify(queueName)\n      )\n    } else {\n      return q\n    }\n  }\n\n  enqueueWork(items: WorkItem[], queueName?: string): QueueItem[] {\n    const queue = this.findQueue_(queueName)\n    this.logger.debug(\"enqueueWork()\", { items, queue })\n    const upserted = queue.upsertWorkItems(items)\n    this.#isDone = false\n    this.#clearCaches()\n    this.#runChunkLater()\n    return upserted\n  }\n\n  postProcessItem(item: QueueItem) {\n    // make sure the sync queue doesn't have this content scheduled:\n    item.delete()\n    this.logger.info(\"postProcessItem()\", { item })\n    this.#clearCaches()\n    if (!this.#checkIfDone()) this.#runChunkLater()\n  }\n\n  get recentFileProgress(): Maybe<string[]> {\n    return this.recentlyProcessed.map(ea => ea.contents)\n  }\n\n  processedCount() {\n    return this.processRate.eventCount\n  }\n\n  currentWorkCount() {\n    return this.p.pendingWithName(this.name).length\n  }\n\n  /**\n   * AKA the count of \"not started\" work items\n   */\n  pendingWorkCount() {\n    return this.queueItemCount() - this.currentWorkCount()\n  }\n\n  /**\n   * @return the total number of items in the queue (including those items\n   * currently being processed)\n   */\n  readonly queueItemCount = lazy(() => {\n    const queueIds = this.queueIds()\n    return QueueItem.dbl.pluckFirstf<number>(qb =>\n      qb.countDistinct(\"id\").whereIn(\"queueId\", queueIds)\n    )\n  })\n\n  percents() {\n    const done = this.processedCount()\n    const todo = this.queueItemCount()\n    // this.eta.push(mapGt0(this.processRate.msPerEvent, ea => ea * todo))\n    const completePct = round(100 * (done / (todo + done)))\n    return { done, todo, completePct, incompletePct: 100 - completePct }\n  }\n\n  currentQueueItems(): QueueItem[] {\n    return this.p.payloadsWithName(this.name)\n  }\n\n  currentQueueContents() {\n    return this.currentQueueItems().map(ea => ea.contents)\n  }\n\n  private currentQueueItemIds() {\n    return this.currentQueueItems().map(ea => ea.id)\n  }\n\n  etaMs() {\n    const p84 = this.processMs.n <= 6 ? undefined : this.processMs.p84\n    return p84 == null ? undefined : this.queueItemCount() * p84\n  }\n\n  state() {\n    return {\n      ...this.p.stats(),\n      isDone: this.#checkIfDone(),\n      freeSlots: this.p.freeSlots(),\n      currentWork: this.currentQueueContents(),\n      pendingWork: this.queueItemCount(),\n      next10: this.#next(10).map(ea => ea.contents),\n      recentlyProcessedLast10: this.recentlyProcessed\n        .slice(-10)\n        .map(ea => ea.contents),\n      isRunnable: this.isRunnable(),\n      ...this.percents(),\n      etaMs: this.etaMs()\n    }\n  }\n\n  // lazy to prevent too many status log entries\n  readonly #logState = lazy(\n    () => {\n      this.logger.debug(\"status\", this.state())\n    },\n    (isTest ? 1 : 30) * secondMs\n  )\n\n  #next(limit?: number): QueueItem[] {\n    return QueueItem.ops().allf(q => {\n      q = q\n        .distinct()\n        .whereIn(\"queueId\", this.queueIds())\n        .andWhere(q1 => q1.whereNotIn(\"id\", this.currentQueueItemIds()))\n        .orderBy(\"id\")\n      if (gt0(limit)) {\n        q = q.limit(limit)\n      }\n      return q\n    })\n  }\n\n  // This starts runChunk later if it's not already been enqueued.\n  #runChunkLater(delayMs = 10) {\n    setTimeout(() => this.#runChunk(), delayMs)\n  }\n\n  readonly #onResume = () => this.#runChunkLater()\n\n  readonly #logNoOp = lazy(\n    () =>\n      this.logger.info(\"runChunk(): no-op\", {\n        whyDoNotRun: whyDoNotRun(this),\n        isFull: this.p.isFull(),\n        pendingWorkCount: this.pendingWorkCount(),\n        queueItemCount: this.queueItemCount(),\n        freeSlots: this.p.freeSlots()\n      }),\n    (isTest ? 1 : 30) * secondMs\n  )\n\n  doNotStartMoreWork() {\n    return (\n      isPaused() ||\n      this.p.isFull() ||\n      isTooBusy() ||\n      doNotRun(this) ||\n      this.pendingWorkCount() === 0\n    )\n  }\n\n  // WorkRunner will call this to make sure we pop work off.\n  readonly #runChunk = throttle({\n    minCallDelayMs: 10,\n    f: () => {\n      // AVOID INFINITE LOOPS: MAKE SURE NONE OF THIS CODE WRAPS AROUND AND\n      // DIRECTLY CALLS #runChunk(): (runChunkLater is OK)\n\n      if (isPaused()) return // do not check if done, do not pass go\n\n      if (isTooBusy() && !this.p.isFull() && this.pendingWorkCount() > 0) {\n        // special case: we have work to do, but something else is making us\n        // busy. Check system load a couple seconds:\n        this.#runChunkLater(7 * secondMs)\n        this.#logNoOp()\n      } else if (this.doNotStartMoreWork()) {\n        this.#logNoOp()\n      } else {\n        this.#logState()\n        const next = this.#next(this.p.freeSlots())\n        this.logger.debug(\"runChunk():\", { next })\n        // Try to fetch the next N items from the queue\n        for (const payload of next) {\n          void this.p.enqueue({\n            name: this.name,\n            payload,\n            l: () => this.#processItem(payload)\n          })\n        }\n      }\n      this.#checkIfDone()\n    }\n  })\n\n  async #processItem(item: QueueItem) {\n    try {\n      const start = Date.now()\n      await this._processItem(item)\n      const elapsedMs = Date.now() - start\n      this.recentlyProcessed.push(item)\n      this.processRate.onEvent()\n      this.processMs.push(elapsedMs)\n      this.ee.emit(\"processed\", item, elapsedMs)\n    } catch (error) {\n      onError(this.name + \" failed to process item \" + item.contents, error)\n    } finally {\n      this.postProcessItem(item)\n    }\n  }\n}\n","import { Command } from \"commander\"\nimport { CommandPlugin } from \"../../core/cli/CLI\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { Obj } from \"../../fe/Object\"\n\n/**\n * Used by sync\n */\nexport const DropWorkQueuesArg: CommandPlugin = {\n  beforeParse: (cmd: Command) =>\n    cmd.option(\n      \"--drop-queues\",\n      \"Before starting, all previously-enqueued, incomplete work will be deleted.\"\n    ),\n  afterParse: async (opts: Obj) => {\n    if (isTrue(opts.dropQueues)) {\n      Settings.dropWorkQueues.envValue = true\n    }\n  }\n}\n","// (separated into own file to break dep circles)\nexport const ExitWhenDone = \"--exit-when-done\"\n","import { Command } from \"commander\"\nimport { CommandPlugin } from \"../../core/cli/CLI\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { Obj } from \"../../fe/Object\"\nimport { ExitWhenDone } from \"./ExitWhenDone\"\n\n/**\n * Used by sync and sync-file\n */\nexport const ExitWhenDoneArg: CommandPlugin = {\n  beforeParse: (cmd: Command) =>\n    cmd.option(\n      ExitWhenDone,\n      \"Exit after jobs are completed. Defaults to false unless paths are specified on the command line.\"\n    ),\n  afterParse: (opts: Obj) => {\n    if (isTrue(opts.exitWhenDone)) {\n      Settings.exitWhenDone.envValue = true\n    }\n  }\n}\n","import { Command } from \"commander\"\nimport { CommandPlugin } from \"../../core/cli/CLI\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { Obj } from \"../../fe/Object\"\n\n/**\n * Used by sync\n */\nexport const ForceArg: CommandPlugin = {\n  beforeParse: (cmd: Command) =>\n    cmd.option(\n      \"--force\",\n      \"Deletes prior cached directory metadata, and forces directory contents to be re-scanned.\"\n    ),\n  afterParse: async (opts: Obj) => {\n    if (isTrue(opts.force)) {\n      Settings.forceSync.envValue = true\n    }\n  }\n}\n","import { Command } from \"commander\"\nimport { isMainService, isSyncService } from \"../../core/ServiceNames\"\nimport { CommandPlugin } from \"../../core/cli/CLI\"\nimport { isDaemon } from \"../../core/cli/IsDaemon\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { Obj } from \"../../fe/Object\"\n\nfunction supportsTail() {\n  return isMainService() || isSyncService()\n}\n\nexport const LogArgs: CommandPlugin = {\n  beforeParse: (cmd: Command) => {\n    const maybeLogStdout =\n      (supportsTail() ? `, \"PS_TAIL_LOGS=true\"` : \"\") +\n      ` and \"PS_LOG_STDOUT=true\".`\n\n    if (supportsTail()) {\n      cmd.option(\n        \"-v, --verbose\",\n        `Verbose logging from all processes. Shortcut for \"--info --tail\". Caution: noisy during imports!`\n      )\n    } else {\n      cmd.option(\"-v, --verbose\", `Verbose logging. Equivalent to --info.`)\n    }\n    cmd.option(\n      \"--error\",\n      `Emit \"error\" messages from this process to stdout. Sets \"PS_LOG_LEVEL=error\"${maybeLogStdout}`\n    )\n    cmd.option(\n      \"--warn\",\n      `Emit \"warn\" and \"error\" messages from this process to stdout. Sets \"PS_LOG_LEVEL=warn\"${maybeLogStdout}`\n    )\n    cmd.option(\n      \"--info\",\n      `Emit \"info\", \"warn\", and \"error\" messages from this process to stdout. Sets \"PS_LOG_LEVEL=info\"${maybeLogStdout}`\n    )\n    cmd.option(\n      \"--debug\",\n      `Emit \"debug\", \"info\", \"warn\", and \"error\" messages from this process to stdout. CAUTION: VERY NOISY. Sets \"PS_LOG_LEVEL=debug\"${maybeLogStdout}}`\n    )\n    cmd.option(\n      \"--trace\",\n      `Emit \"trace\", \"debug\", \"info\", \"warn\", and \"error\" messages from this process to stdout. CAUTION: VERY VERY NOISY. Sets \"PS_LOG_LEVEL=trace\"${maybeLogStdout}}`\n    )\n    if (supportsTail()) {\n      cmd.option(\n        \"--tail\",\n        `Emit log messages from both this process and all other concurrently running PhotoStructure processes on this host to stdout. This can be really helpful in seeing how PhotoStructure's processes are coordinating work. Caution: very noisy especially during imports. Sets \"PS_TAIL_LOGS=true\".`\n      )\n    }\n\n    return cmd\n  },\n\n  afterParse: (opts: Obj) => {\n    const error = isTrue(opts.error)\n    const warn = isTrue(opts.warn)\n    const info = isTrue(opts.info) || isTrue(opts.verbose) || isTrue(opts.v)\n    const debug = isTrue(opts.debug)\n    const trace = isTrue(opts.trace)\n\n    // these should win: use envValue\n    if (trace) {\n      Settings.logLevel.envValue = \"trace\"\n    } else if (debug) {\n      Settings.logLevel.envValue = \"debug\"\n    } else if (info) {\n      Settings.logLevel.envValue = \"info\"\n    } else if (warn) {\n      Settings.logLevel.envValue = \"warn\"\n    } else if (error) {\n      Settings.logLevel.envValue = \"error\"\n    }\n\n    if (isDaemon(opts as any)) {\n      // don't log to stdout if we're a daemon. Use .envValue to set to false but not persist\n      Settings.tailLogs.envValue = false\n      Settings.logStdout.envValue = false\n    } else {\n      if (isTrue(opts.tail)) {\n        // they asked for it: do it.\n        Settings.tailLogs.envValue = true\n      }\n      if (error || warn || info || debug || trace) {\n        // not envValue, as it's not being asked for directly.\n        Settings.logStdout.tmpValue = true\n\n        if (supportsTail()) {\n          Settings.tailLogs.tmpValue = true\n        }\n      }\n\n      if (\n        (Settings.tailLogs.valueOrDefault ||\n          Settings.logStdout.valueOrDefault) &&\n        Settings.logLevel.isUnset()\n      ) {\n        Settings.logLevel.envValue = \"info\"\n      }\n    }\n  }\n}\n","import { Command } from \"commander\"\nimport { CommandPlugin } from \"../../core/cli/CLI\"\nimport { disableAllFilters } from \"../../core/settings/MetaSettings\"\nimport { isFalse } from \"../../fe/Boolean\"\nimport { Obj } from \"../../fe/Object\"\n\n/**\n * Used by sync and sync-file\n */\nexport const NoFilterArg: CommandPlugin = {\n  beforeParse: (cmd: Command) =>\n    cmd.option(\n      \"--no-filter\",\n      \"Disables import filters. All paths will try to be imported, even if they are too small or are missing tags. See https://photostructure.com/faq/why-is-my-file-missing/ .\"\n    ),\n  afterParse: async (opts: Obj) => {\n    if (isFalse(opts.filter)) {\n      disableAllFilters()\n    }\n  }\n}\n","import { Command } from \"commander\"\nimport { CommandPlugin } from \"../../core/cli/CLI\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { Obj } from \"../../fe/Object\"\n\n/**\n * Used by sync and sync-file\n */\nexport const RebuildArg: CommandPlugin = {\n  beforeParse: (cmd: Command) =>\n    cmd.option(\n      \"--rebuild\",\n      \"Rebuild your library by re-importing all your photos and videos (slow!) https://photostructure.com/faq/sync-vs-rebuild/\"\n    ),\n  afterParse: async (opts: Obj) => {\n    if (isTrue(opts.rebuild)) {\n      Settings.forceRebuildLibrary.envValue = true\n    }\n  }\n}\n","import { Command } from \"commander\"\nimport { CommandPlugin } from \"../../core/cli/CLI\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { Obj } from \"../../fe/Object\"\n\n/**\n * Used by sync and sync-file\n */\nexport const SkipUpdateArg: CommandPlugin = {\n  beforeParse: (cmd: Command) =>\n    cmd.option(\n      \"--skip-updates\",\n      \"DANGEROUS: If you want to immediately import specific files or directories and skip any pending library maintenance tasks (like library rebuilds), use this argument. Note that asset aggregation may be incorrect after using this command if there are updates pending.\"\n    ),\n  afterParse: (opts: Obj) => {\n    if (isTrue(opts.skipUpdates)) {\n      Settings.noModelUpdates.envValue = true\n    }\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { valpath } from \"../../core/Object\"\nimport { firstSubstringIgnoreCase } from \"../../core/String\"\nimport { mapAsyncSerial } from \"../../core/async/Promise\"\nimport { parseJsonDate } from \"../../core/date/ExtendedDate\"\nimport { mapValidDate } from \"../../core/date/ValidDate\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { readRawTags } from \"../../core/tags/ExifTool\"\nimport { splitKeywords } from \"../../core/tags/KeywordTags\"\nimport { commandTimeoutMs } from \"../../core/volumes/VolumeTtls\"\nimport { isEmpty, uniqBy } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { TagPath, TagRef, TagRoots } from \"../../fe/api/Tag\"\nimport { toS } from \"../../fe/toS\"\n\nconst logger = lazy(() => mkLogger(\"curators.TypeTagger\"))\n\nexport async function tagFilesWithAlbums(\n  files: PosixFile[]\n): Promise<TagPath[]> {\n  if (isEmpty(Settings.tagAlbumFilenames.values)) {\n    return []\n  }\n\n  const dirs = uniqBy(\n    files.map(ea => ea.parent()),\n    ea => ea.nativePath\n  )\n  const arr = flatten(\n    dirs.map(dir => Settings.tagAlbumFilenames.values.map(ea => dir.join(ea)))\n  )\n\n  return mapAsyncSerial({\n    name: \"tagFilesWithAlbums\",\n    arr,\n    f: albumFromFile,\n    timeoutMs: commandTimeoutMs()\n  })\n}\n\nexport async function albumFromFile(\n  file: PosixFile | string\n): PromiseMaybe<TagPath> {\n  return albumFromTags(await readRawTags(file, false))\n}\n\nexport function albumFromTags(t: any): Maybe<TagPath> {\n  if (t == null) return\n\n  const title = valpath(t, Settings.tagAlbumTitle.valueOrDefault)\n  const desc = valpath(t, Settings.tagAlbumDescription.valueOrDefault)\n\n  const titlePath: string[] = blank(title)\n    ? []\n    : Settings.tagAlbumTitleHierarchies.valueOrDefault\n    ? splitKeywords(title)\n    : [title]\n\n  const whyExclude = isEmpty(titlePath)\n    ? \"(blank title)\"\n    : firstSubstringIgnoreCase(\n        Settings.tagAlbumsExcluded.values,\n        [toS(title), toS(desc)].join(\" \")\n      )\n\n  const result: Maybe<TagPath> =\n    whyExclude == null ? [TagRoots.Albums, ...titlePath] : undefined\n\n  if (result != null) {\n    const tagref: TagRef = {\n      name: result[result.length - 1] as string,\n      description: desc\n    }\n\n    mapValidDate(\n      parseJsonDate(valpath(t, Settings.tagAlbumDate.valueOrDefault) as any),\n      (d: Date) => {\n        tagref.releasedAt = d.getTime()\n      }\n    )\n    result[result.length - 1] = tagref\n  }\n\n  return logger().tap({\n    level: \"info\",\n    msg: \"albumFromFile()\",\n    result,\n    meta: { title, desc, whyExclude }\n  })\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { thenMap } from \"../../core/async/Promise\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { CapturedAt } from \"../../core/tags/CapturedAt\"\nimport {\n  joinTagPath,\n  leafIsExcluded,\n  omitAncestorTags\n} from \"../../core/tags/TagPaths\"\nimport { uniqBy } from \"../../fe/Array\"\nimport { map } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { thenCollect } from \"../../fe/Promise\"\nimport { TagPath } from \"../../fe/api/Tag\"\nimport { Asset } from \"../model/Asset\"\nimport { tagFilesWithAlbums } from \"./AlbumTagger\"\nimport { cameraTagFile } from \"./CameraTagger\"\nimport { dateTagFile } from \"./DateTagger\"\nimport { tagAssetPaths } from \"./FilePathTagger\"\nimport { keywordTagFiles } from \"./KeywordTagger\"\nimport { lensTagFile } from \"./LensTagger\"\nimport { normalizeTagRoot, tagDeltas } from \"./Taggers\"\nimport { typeTagFiles } from \"./TypeTagger\"\nimport { whoTagFiles } from \"./WhoTagger\"\n\nexport interface AssetTaggingResult {\n  add: TagPath[]\n  remove: TagPath[]\n}\n\nconst logger = lazy(() => mkLogger(\"curators.AssetTagger\"))\n\n/**\n * should only be invoked from AssetPostUpsertTasks and specs\n */\nexport async function tagAndUpsertAsset_(\n  asset: Asset\n): PromiseMaybe<AssetTaggingResult> {\n  const assetFiles = (await asset.getExistingAssetFiles())!\n\n  logger().info(\"tagAndUpsertAsset()\", {\n    asset,\n    existing_uris: assetFiles.map(ea => ea.uri)\n  })\n\n  const existingPrimaryAssetFile = assetFiles.find(ea => ea.shown)\n  const primaryVariant = await existingPrimaryAssetFile?.posixFile_()\n\n  if (existingPrimaryAssetFile == null || primaryVariant == null) {\n    logger().throw(\"tagAndUpsertAsset(): no existing or primary asset file\", {\n      asset,\n      existingPrimaryAssetFile,\n      primaryVariant,\n      doNotSend: true,\n      fatal: false\n    })\n    return\n  }\n\n  const priorPrimaryAF = asset.getShown()\n\n  if (priorPrimaryAF?.id !== existingPrimaryAssetFile.id) {\n    logger().warn(\n      \"Changing primary asset we're using a different variant for tagging.\",\n      {\n        newPrimary: existingPrimaryAssetFile.uri,\n        priorPrimary: priorPrimaryAF?.uri\n      }\n    )\n    asset.setShown_(existingPrimaryAssetFile)\n  }\n\n  const files = await thenCollect(assetFiles, ea => ea.posixFile_())\n  const uris = asset.getAssetFiles().map(ea => ea.uri)\n\n  const priorTagPaths = asset.getTagPaths()\n  const capturedAts = await asset.getCapturedAts()\n\n  const tagResult = await tagAsset({\n    primaryVariation: primaryVariant,\n    files,\n    priorTagPaths,\n    capturedAts,\n    uris\n  })\n  logger().info(\"tagAndUpsertAsset\", tagResult)\n\n  const excludedTag = tagResult.add.find(ea =>\n    leafIsExcluded(ea, Settings.keywordBlocklist.values)\n  )\n  if (excludedTag != null) {\n    if (asset.shown === true) {\n      logger().info(\"this asset has an excluded tag, marking excluded\", {\n        excludedTag\n      })\n      asset.excludedAt = Date.now()\n    } else {\n      logger().info(\n        \"this asset has an excluded tag, and it wasn't shown yet, so we're removing it.\",\n        { excludedTag }\n      )\n      await Asset.remove({\n        assetId: asset.id!,\n        blocklistShas: false,\n        unlinkAssetFiles: false\n      })\n      return logger().throw(\n        \"tagAndUpsertAsset(): asset had excluded tag. Removed.\",\n        {\n          excludedTag,\n          uris,\n          files: files.map(ea => ea.nativePath)\n        }\n      )\n    }\n  }\n\n  const result = map(tagResult, async ea => {\n    Asset.addTags(asset.id!, ea.add)\n    Asset.removeTags(asset.id!, ea.remove)\n    asset.tags = undefined // < clear tags cache\n    return ea\n  })\n\n  await asset.updateFromFiles()\n  return result\n}\n\nexport async function tagAsset({\n  primaryVariation,\n  files,\n  priorTagPaths,\n  capturedAts,\n  uris\n}: {\n  primaryVariation: PosixFile\n  files: PosixFile[]\n  priorTagPaths: string[][]\n  capturedAts: CapturedAt[]\n  uris: string[]\n}): Promise<AssetTaggingResult> {\n  const tagPaths: TagPath[] = []\n\n  if (files.some(ea => ea.nativePath === primaryVariation.nativePath)) {\n    // good caller, GOOD\n  } else {\n    files.unshift(primaryVariation)\n  }\n\n  //\n  // NOTE: IF YOU CHANGE ANY TAGGERS, REMEMBER TO UPDATE AssetVersion!\n  //\n\n  if (Settings.tagCamera.valueOrDefault) {\n    await thenMap(cameraTagFile(primaryVariation), ea => {\n      logger().debug(\"Camera tag for \" + primaryVariation + \":\", ea)\n      tagPaths.push(ea)\n    })\n  }\n\n  if (Settings.tagLens.valueOrDefault) {\n    await thenMap(lensTagFile(primaryVariation), ea => {\n      logger().debug(\"Lens tag for \" + primaryVariation + \":\", ea)\n      tagPaths.push(ea)\n    })\n  }\n\n  await thenMap(dateTagFile(primaryVariation, capturedAts), ea => {\n    logger().debug(\"Date tag for \" + primaryVariation + \":\", ea)\n    tagPaths.push(ea)\n  })\n\n  const whoTags = (await whoTagFiles(files)) ?? []\n  logger().debug(\"whoTagFiles for \" + primaryVariation + \":\", whoTags)\n  tagPaths.push(...whoTags)\n\n  await thenMap(keywordTagFiles(files, whoTags), arr => {\n    logger().debug(\"Keyword tags for \" + primaryVariation + \":\", arr)\n    tagPaths.push(...arr)\n  })\n\n  if (Settings.tagFileType.valueOrDefault) {\n    await thenMap(typeTagFiles(files), arr => {\n      logger().debug(\"MIME type tags for \" + primaryVariation + \":\", arr)\n      tagPaths.push(...arr)\n    })\n  }\n\n  await thenMap(tagAssetPaths(uris), arr => {\n    logger().debug(\"file paths for uris\", { uris, arr })\n    tagPaths.push(...arr)\n  })\n\n  await thenMap(tagFilesWithAlbums(files), arr => {\n    logger().debug(\"Album tags for \" + primaryVariation + \":\", arr)\n    tagPaths.push(...arr)\n  })\n\n  const after = omitAncestorTags(\n    uniqBy(tagPaths.map(normalizeTagRoot), joinTagPath)\n  )\n\n  const result = await tagDeltas(priorTagPaths, after)\n  logger().info(\"tagAsset(\" + primaryVariation + \")\", {\n    priorTagPaths,\n    after,\n    result\n  })\n\n  return result\n}\n","import { PosixFile } from \"../../core/fs/PosixFile\"\nimport { ExifTags } from \"../../core/tags/ExifTags\"\nimport { readTags } from \"../../core/tags/ExifTool\"\nimport { TagRoots } from \"../../fe/api/Tag\"\nimport { compactBlankish } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\n\nexport function cameraTag(tags: Maybe<ExifTags>) {\n  return tags == null || blank(tags.Make) // < only require Make!\n    ? undefined\n    : compactBlankish([TagRoots.Camera, tags.Make, tags.Model])\n}\n\nexport async function cameraTagFile(file: PosixFile) {\n  return cameraTag(await readTags(file))\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { localeSync } from \"../../core/Locale\"\nimport { mapGt0 } from \"../../core/Number\"\nimport { stripSuffix } from \"../../core/String\"\nimport { Dated } from \"../../core/date/Dated\"\nimport { getDay, getMonth, getYear } from \"../../core/date/GetDateField\"\nimport { ee } from \"../../core/event/EventEmitter\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport {\n  CapturedAt,\n  bestCapturedAt,\n  capturedAtSrcFromStat\n} from \"../../core/tags/CapturedAt\"\nimport { readTags } from \"../../core/tags/ExifTool\"\nimport { isEmpty, range } from \"../../fe/Array\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { within } from \"../../fe/Number\"\nimport { TagPath, TagRef, TagRoots } from \"../../fe/api/Tag\"\nimport { toS } from \"../../fe/toS\"\n\nconst dtf = lazy(\n  () =>\n    new Intl.DateTimeFormat(localeSync(), {\n      month: \"short\"\n    })\n)\n\nconst months = lazy(() => {\n  const f = dtf()\n  // There are rendering bugs (!!) for 1998-4-1, 2003-4-1, 1998-11-1, 2003-11-1,\n  // ... so we just capture the month names once for a known-correct year.\n  return range(0, 12, i => f.format(new Date(2016, i, 1))).map(ea =>\n    // Some locales (like en-CA) end with period:\n    stripSuffix(ea, \".\")\n  )\n})\n\nee().on(\"clearCache\", () => {\n  dtf.unset()\n  months.unset()\n})\n\nexport function yearToOrdinal(year: number): number {\n  // Y10K COME AT ME BRO\n  return 10000 - year\n}\n\nexport function monthToOrdinal(oneIndexedMonth: number): number {\n  return 13 - oneIndexedMonth\n}\n\nexport function ordinalToMonth(monthTagOrdinal: number): number {\n  return 13 - monthTagOrdinal\n}\n\nexport function dayToOrdinal(oneIndexedMonth: number): number {\n  return 33 - oneIndexedMonth\n}\n\nexport function yearTagRef(year: number): Maybe<TagRef> {\n  return mapGt0(year, ea => ({ name: toS(ea), ordinal: yearToOrdinal(ea) }))\n}\n\nexport function monthTagRef(oneIndexedMonth: Maybe<number>): Maybe<TagRef> {\n  if (!within(1, 12, oneIndexedMonth)) return\n  return map(months()[oneIndexedMonth - 1], monthName =>\n    // ordinal makes months order in reverse chron:\n    ({\n      name: String(oneIndexedMonth),\n      displayName: monthName,\n      ordinal: monthToOrdinal(oneIndexedMonth)\n    })\n  )\n}\n\nexport function dayTagRef(day: Maybe<number>): Maybe<TagRef> {\n  return mapGt0(day, ea => ({ name: toS(ea), ordinal: dayToOrdinal(ea) }))\n}\n\nexport function dateTag(date: Maybe<Dated>): Maybe<TagPath> {\n  const s = toS(Settings.tagYMD.valueOrDefault).toLowerCase()\n\n  if (date == null || s === \"\" || s === \"off\" || s.startsWith(\"disable\")) return // date tagging is disabled\n\n  // i18n happens in a layer above this:\n  const result: TagPath = [TagRoots.When]\n\n  if (s.startsWith(\"y\")) {\n    const y = map(getYear(date), yearTagRef)\n    if (y == null) return\n    result.push(y)\n  }\n  if (s.startsWith(\"ym\")) {\n    const m = map(getMonth(date), monthTagRef)\n    if (m == null) return result // just take the year.\n    result.push(m)\n  }\n  if (s.startsWith(\"ymd\")) {\n    const m = map(getDay(date), dayTagRef)\n    if (m == null) return result // just take the month.\n    result.push(m)\n  }\n  return result\n}\n\nexport async function dateTagFile(\n  file: PosixFile,\n  capturedAts: Maybe<CapturedAt>[]\n): PromiseMaybe<TagPath> {\n  if (Settings.tagYMD.valueOrDefault === \"\") return\n\n  const arr = [...capturedAts]\n\n  if (isEmpty(capturedAts)) {\n    arr.push((await readTags(file))?.capturedAt)\n  }\n\n  const best = bestCapturedAt(arr)\n\n  if (\n    best == null ||\n    (capturedAtSrcFromStat(best.src) &&\n      !Settings.tagDateFromStat.valueOrDefault)\n  ) {\n    return\n  }\n\n  return dateTag(best.date)\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { tagRefToS } from \"../../core/tags/TagPaths\"\nimport { uriToTagPath } from \"../../core/web/UriToTagPath\"\nimport { compact } from \"../../fe/Array\"\nimport { PS_LOCAL_FILE_SCHEME } from \"../../fe/URI\"\nimport { TagPath, TagRoots } from \"../../fe/api/Tag\"\nimport { Asset } from \"../model/Asset\"\nimport { AssetFile } from \"../model/AssetFile\"\nimport { modelDb } from \"../model/ModelDb\"\nimport { displayNameForVolsha } from \"../tag/TagSql\"\n\nconst logger = lazy(() => mkLogger(\"curators.FilePathTagger\"))\n\nexport async function tagAssetPaths(uris: string[]): Promise<TagPath[]> {\n  const result: TagPath[] = []\n  for (const uri of uris) {\n    try {\n      const tp = uriToTagPath({ uri, isFile: true })\n      if (tp == null) continue\n      // `info` may not have spun up the db:\n      if (uri.startsWith(PS_LOCAL_FILE_SCHEME) && modelDb() != null) {\n        const volsha = tagRefToS(tp[1])\n        // Fix for https://forum.photostructure.com/t/volume-id-shows-as-a-tag/754\n        tp[1] = {\n          name: volsha,\n          displayName: await displayNameForVolsha(volsha)\n        }\n        logger().info(\"tagAssetPaths()\", { uri, tp })\n      }\n      result.push(tp)\n    } catch (err) {\n      logger().warn(\"Failed to parse asset file URI\", { uri })\n    }\n  }\n  return result\n}\n\nexport function isFsTag(t: TagPath): boolean {\n  return tagRefToS(t[0]).toLowerCase() === TagRoots.fs\n}\n\nexport function addFilesTagsToAsset(assetId: number) {\n  const uris = AssetFile.dbl.pluckAllf<string>(q =>\n    q.select(\"uri\").where({ assetId })\n  )\n  return addFileUriTagsToAsset(assetId, uris)\n}\n\nexport function addFileUriTagsToAsset(assetId: number, uris: string[]) {\n  return Asset.addTags(\n    assetId,\n    compact(uris.map(uri => uriToTagPath({ uri, isFile: true })))\n  )\n}\n","import { partition } from \"../../core/Array\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { escapeRegExp } from \"../../core/RegExp\"\nimport {\n  equalsIgnoreCase,\n  includesIgnoreCase,\n  isString,\n  uniqIgnoreCase\n} from \"../../core/String\"\nimport { lcdiff } from \"../../core/StringSimilarity\"\nimport { mapAsyncSerial, thenMap } from \"../../core/async/Promise\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { readRawTags } from \"../../core/tags/ExifTool\"\nimport { delimRe, pathSepRe, rawTagKeywords } from \"../../core/tags/KeywordTags\"\nimport { joinTagPath } from \"../../core/tags/TagPaths\"\nimport {\n  compact,\n  compactBlanks,\n  isNotEmpty,\n  uniq,\n  uniqBy2\n} from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { later } from \"../../fe/Delay\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { mapOr } from \"../../fe/Maybe\"\nimport { TagPath, TagRoots } from \"../../fe/api/Tag\"\nimport { toS } from \"../../fe/toS\"\nimport { normalizeTagRoot, stripTagRoot } from \"./Taggers\"\nimport { isWhoTag, nameTag } from \"./WhoTagger\"\n\nconst logger = lazy(() => mkLogger(\"curators.KeywordTagger\"))\n\nconst delimSpaceRe = lazy(() =>\n  mapNotBlank(\n    Settings.keywordDelimiters.valueOrDefault,\n    ea => new RegExp(`[ /${escapeRegExp(ea)}]`)\n  )\n)\n\nlater(() => {\n  Settings.keywordDelimiters.watchLater(() => delimSpaceRe.unset())\n})\n\nexport function extractDashDashTags(s: string): string[] {\n  return logger().tap({\n    msg: \"extractDashDashTags()\",\n    result: mapOr(\n      toS(s).split(\"--\")[1],\n      ea => compactBlanks(mapOr(delimSpaceRe(), re => ea.split(re), [ea])),\n      () => []\n    ),\n    meta: { s }\n  })\n}\n\n/**\n * Extract the \"dash-dash\" tags encoded in `f`'s path\n */\nexport function extractPathnameTags(f: PosixFile): string[] {\n  return [\n    ...extractDashDashTags(f.parent().posixPath),\n    ...extractDashDashTags(f.name)\n  ]\n}\n\n// doesn't handle things like news:alt.goth but those don't have slashes, so who cares\nconst UrlRE = /\\w{2,7}:\\/\\/\\S+/g\n\n/**\n * Given a bunch of flat or hierarchical strings, split, normalize, and dedupe\n * the paths.\n */\nexport function normalizeKeywordPaths(arr: (string | string[])[]): string[][] {\n  const result: string[][] = []\n\n  // handled as keywords:\n  const urls: string[] = []\n\n  const arr1: (string | string[])[] = []\n\n  for (const ea of compact(arr)) {\n    if (Array.isArray(ea)) {\n      arr1.push(ea)\n    } else {\n      // Pull out the URLs as keywords:\n      const s = toS(ea).replace(UrlRE, m => {\n        urls.push(m)\n        return \"\"\n      })\n      arr1.push(...mapOr(delimRe(), re => s.split(re), [s]))\n    }\n  }\n\n  // Split hierarchical paths:\n  const arr2 = mapOr(\n    pathSepRe(),\n    re => arr1.map(ea => (isString(ea) ? ea.split(re) : ea)),\n    arr1\n  )\n\n  // Convert all one-array-deep keywords to simple strings:\n  const arr3 = arr2.map(ea =>\n    Array.isArray(ea) && ea.length === 1 ? ea[0] : ea\n  )\n\n  // Split strings into paths that contain keywordPathSeparators.\n  const [paths1, kws1] = partition(arr3, Array.isArray) as [\n    string[][],\n    string[]\n  ]\n\n  const paths = paths1\n    .map(ea => compactBlanks(ea.map(ea1 => ea1.trim())))\n    .filter(isNotEmpty)\n\n  // DON'T USE LOWERCASE HERE. We want locale-aware matching.\n  const pathNames: string[] = uniqIgnoreCase(flatten(paths))\n\n  result.push(...paths)\n\n  const kws = [...kws1, ...urls]\n    .map(ea => ea.trim())\n    .filter(ea => notBlank(ea) && !includesIgnoreCase(pathNames, ea))\n\n  const copy = Settings.keywordReparenting.valueOrDefault === \"copy\"\n  const retain = Settings.keywordReparenting.valueOrDefault === \"retain\"\n  const aliases = Settings.rootTagKeywordsAliases.values\n\n  for (const ea of [...result]) {\n    if (includesIgnoreCase(aliases, ea[0])) {\n      // Normalize keyword roots:\n      ea[0] = TagRoots.Keywords\n    }\n    if (ea[0] !== TagRoots.Keywords) {\n      if (copy) {\n        result.push([TagRoots.Keywords, ...ea])\n      } else if (retain) {\n        ea.unshift(TagRoots.Keywords)\n      }\n    }\n  }\n\n  // For all elements that are just strings, delete those that are leafNames.\n  for (const kw of kws) {\n    // Push all elements that are still strings into [Keywords, $ea]\n    result.push([TagRoots.Keywords, kw])\n  }\n\n  return uniq(result)\n}\n\n/**\n * @return uniq paths, with most-cased-values winning over lowercase:\n */\nexport function dedupeKeywordPaths(arr: TagPath[]): TagPath[] {\n  return uniqBy2(\n    sortBy(arr.map(normalizeTagRoot), ea => {\n      const j = joinTagPath(ea)\n      return [j.normalize().toLowerCase(), -1 * lcdiff(j)]\n    }),\n    (a, b) => equalsIgnoreCase(joinTagPath(a), joinTagPath(b))\n  )\n}\n\n/**\n * Normalizes hierarchical paths, extracts Who tags, and returns deduped\n * TagPaths.\n */\nexport function processKeywords(\n  keywords: (string | string[])[],\n  whoTags: TagPath[]\n): TagPath[] {\n  // DigiKam craps into SEVEN TAGS for faces, *yay*\n  const [rawKwWhoTags, nonWhoKws] = partition(\n    normalizeKeywordPaths(keywords),\n    isWhoTag\n  )\n  const kwWhoTags = flatten(rawKwWhoTags.map(nameTag))\n\n  // Include both \"first last\" and \"last, first\"\n  const whoNames = uniq(\n    flatten(\n      [...kwWhoTags, ...whoTags].map(tagPath => {\n        const kw = stripTagRoot(tagPath)\n        return [kw.join(\", \"), kw.join(\" \"), [...kw].reverse().join(\" \")]\n      })\n    )\n  )\n\n  const result = dedupeKeywordPaths([\n    ...nonWhoKws.filter(\n      kw => !includesIgnoreCase(whoNames, stripTagRoot(kw).join(\" \"))\n    ),\n    ...kwWhoTags\n  ])\n\n  // console.log(\"processKeywords\", {\n  //   keywords,\n  //   whoTags,\n  //   rawKwWhoTags,\n  //   nonWhoKws,\n  //   kwWhoTags,\n  //   whoNames,\n  //   result\n  // })\n\n  return logger().tap({\n    msg: \"processKeywords()\",\n    level: \"info\",\n    result\n  })\n}\n\n/**\n * Main entry point: extract and dedupe all keywords for all given files.\n */\nexport async function keywordTagFiles(\n  files: PosixFile[],\n  whoTags: TagPath[]\n): Promise<TagPath[]> {\n  const pathnameKeywords = Settings.tagKeywordsFromPath.valueOrDefault\n    ? flatten(files.map(extractPathnameTags))\n    : []\n  const tagKeywords = Settings.tagKeywordsFromMetadata.valueOrDefault\n    ? flatten(\n        await mapAsyncSerial({\n          name: \"keywordTagFiles\",\n          arr: files,\n          f: f => thenMap(readRawTags(f), rawTagKeywords)\n        })\n      )\n    : []\n\n  return processKeywords([...pathnameKeywords, ...tagKeywords], whoTags)\n}\n","import { thenMap } from \"../../core/async/Promise\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { ExifTags } from \"../../core/tags/ExifTags\"\nimport { readTags } from \"../../core/tags/ExifTool\"\nimport { TagRoots } from \"../../fe/api/Tag\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { mapNotBlank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\n\nexport function lensTag(tags: Maybe<ExifTags>) {\n  return map(tags, t =>\n    mapNotBlank(t.lensMake, make =>\n      mapNotBlank(\n        compactBlanks(\n          Settings.tagFullLensModel.valueOrDefault\n            ? [t.lensModel, t.lensInfo]\n            : [t.lensInfo, t.lensModel]\n        )[0],\n        model => [TagRoots.Lens, make, model]\n      )\n    )\n  )\n}\n\nexport function lensTagFile(file: PosixFile) {\n  return thenMap(readTags(file), lensTag)\n}\n","import { Settings } from \"../../core/settings/Settings\"\nimport { tagDiff, tagPathsInclude, tagRefToS } from \"../../core/tags/TagPaths\"\nimport { TagPath, TagRef, TagRoots } from \"../../fe/api/Tag\"\nimport { filterInPlace, uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\n\nexport const WhenRoot = { name: TagRoots.When, ordinal: 1 } //  icon: \"event\"\nexport const AlbumsRoot = { name: TagRoots.Albums, ordinal: 2 } //\nexport const WhoRoot = { name: TagRoots.Who, ordinal: 4 }\nexport const KwRoot = { name: TagRoots.Keywords, ordinal: 7 }\n\nexport const Roots: TagRef[] = [\n  WhenRoot,\n  AlbumsRoot,\n  { name: TagRoots.fs, ordinal: 3 }, // filesystem\n  WhoRoot,\n  // { name: Where, ordinal: 3, icon: explore},\n  // { name: What, ordinal: 4, icon: nature},\n  { name: TagRoots.Camera, ordinal: 5 }, // icon: photo_camera\n  { name: TagRoots.Lens, ordinal: 6 },\n  KwRoot,\n  { name: TagRoots.Type, ordinal: 8 }\n]\n\n// export const WhereSynonyms = new CISet([\n//   \"country\",\n//   \"el país\",\n//   \"emplacement\",\n//   \"endroit\",\n//   \"gps\",\n//   \"les pays\",\n//   \"location\",\n//   \"locations\",\n//   \"ort\",\n//   \"pays\",\n//   \"place\",\n//   \"places\",\n//   \"platz\",\n//   \"posición\",\n//   \"region\",\n//   \"région\",\n//   \"site\",\n//   \"sitio\",\n//   \"stätte\",\n//   \"ubicación\",\n//   \"where\"\n// ])\n\n// export const WhatSynonyms = new CISet([\n//   \"article\",\n//   \"articles\",\n//   \"item\",\n//   \"items\",\n//   \"le sujet\",\n//   \"matière\",\n//   \"object\",\n//   \"objects\",\n//   \"objet\",\n//   \"objets\",\n//   \"subject\",\n//   \"subjects\",\n//   \"subjekt\",\n//   \"sujet\",\n//   \"sujeta\",\n//   \"sujeto\",\n//   \"what\"\n// ])\n\nconst rootNamesLowerCase = uniq(\n  [\n    ...TagRoots.values,\n    ...Settings.rootTagKeywordsAliases.values,\n    ...Settings.rootTagWhoAliases.values\n  ].map(ea => ea.toLowerCase())\n)\n\nexport function hasTagRoot(path: TagPath): boolean {\n  return rootNamesLowerCase.includes(tagRefToS(path[0]).toLowerCase())\n}\n\nexport function stripTagRoot(path: TagPath): TagPath {\n  return hasTagRoot(path) ? path.slice(1) : path\n}\n\nconst albumRootsLowerCased = uniq(\n  [TagRoots.Albums, ...Settings.rootTagAlbumsAliases.values].map(ea =>\n    ea.toLowerCase()\n  )\n)\n\nconst kwRootsLowerCased = uniq(\n  [TagRoots.Keywords, ...Settings.rootTagKeywordsAliases.values].map(ea =>\n    ea.toLowerCase()\n  )\n)\n\nconst whoRootsLowerCased = uniq(\n  [TagRoots.Who, ...Settings.rootTagWhoAliases.values].map(ea =>\n    ea.toLowerCase()\n  )\n)\n\nexport function normalizeTagRoot(path: TagPath): TagPath {\n  const root = tagRefToS(path[0]).toLowerCase()\n  if (blank(root)) return path\n  if (kwRootsLowerCased.includes(root)) return [KwRoot, ...path.slice(1)]\n  if (kwRootsLowerCased.includes(root)) return [KwRoot, ...path.slice(1)]\n  if (whoRootsLowerCased.includes(root)) return [WhoRoot, ...path.slice(1)]\n  if (albumRootsLowerCased.includes(root)) return [AlbumsRoot, ...path.slice(1)]\n\n  return path\n}\n\n/**\n * Determine which TagPaths need to be added and removed to make `before` become\n * `after`.\n */\nexport async function tagDeltas(\n  before: Maybe<Maybe<TagPath>[]>,\n  after: Maybe<Maybe<TagPath>[]>\n): Promise<{ add: TagPath[]; remove: TagPath[] }> {\n  const add = tagDiff(after, before)\n  const remove = tagDiff(before, after)\n\n  const excludedRootTags = Settings.excludedRootTags.valueOrDefault\n\n  filterInPlace(add, tagPath => {\n    const bad = excludedRootTags.includes(tagRefToS(tagPath[0]).toLowerCase())\n    if (bad && !tagPathsInclude(tagPath, remove)) {\n      remove.push(tagPath)\n      console.log(\"removing bad tag\", tagPath)\n    }\n    return !bad\n  })\n\n  return {\n    add,\n    remove\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { capitalize } from \"../../core/String\"\nimport { mapAsyncSerial } from \"../../core/async/Promise\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { readMimeType } from \"../../core/tags/ReadMimeType\"\nimport { compact, compactBlanks, uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { firstDefinedThunk } from \"../../fe/Thunk\"\nimport { TagRoots } from \"../../fe/api/Tag\"\n\nconst logger = lazy(() => mkLogger(\"curators.TypeTagger\"))\n\nexport async function typeTagFiles(files: PosixFile[]): Promise<string[][]> {\n  const mimetypes = uniq(\n    await mapAsyncSerial({ name: \"typeTagFiles\", arr: files, f: readMimeType })\n  )\n  return compact(mimetypes.map(mimeTypeToTag))\n}\n\nconst Cases = new Map(\n  [\"M2TS\", \"JPEG\", \"QuickTime\"].map(ea => [ea.toLowerCase(), ea])\n)\n\nexport function mimeTypeToTag(mt: string) {\n  const [t, st] = mt.split(\"/\")\n  if (blank(t) || blank(st)) return\n\n  return logger().tap({\n    msg: \"mimetypeToTag(\" + mt + \")\",\n    result: map(friendlySubtype(st, mt), arr =>\n      compactBlanks([TagRoots.Type, capitalize(t), ...arr])\n    )\n  })\n}\n\nconst Subtypes = lazy(\n  () =>\n    new Map<string, string[]>([\n      [\"image/x-adobe-dng\", [\"Raw\", \"DNG\"]],\n      [\"image/x-fuji-raf\", [\"Raw\", \"Fujifilm\"]],\n      [\"video/m2ts\", [\"MPEG-2\"]],\n      [\"video/mp2t\", [\"MPEG-2\"]],\n      [\"video/mp4\", [\"MPEG-4\"]],\n      [\"video/quicktime\", [\"QuickTime\"]],\n      [\"video/x-msvideo\", [\"AVI\"]]\n    ])\n)\n\nexport function friendlySubtype(subtype: string, fullMimeType: string) {\n  return firstDefinedThunk([\n    () => Subtypes().get(fullMimeType.trim().toLowerCase()),\n    () =>\n      map(subtype.match(/^x-(\\w{4,})-\\w{3}/), m => [\"Raw\", capitalize(m[1])]),\n    // () => map(subtype.match(/^\\w{3,4}/), () => [subtype.toUpperCase()]),\n    () => [\n      fixCase(subtype.replace(/^(?:x-|vnd\\.|prs\\.)/i, \"\").replace(/-/g, \" \"))\n    ]\n  ])!\n  // if (RawSubtypes().has(s.trim())) {\n  //   return [\"Raw\", capitalize(s.split(\"-\")[1])]\n  // }\n  // const c = Cases.get(s.toLowerCase())\n  // if (c != null) return [c]\n  // return s.replace(/^x-/i, \"\").split(\"-\").map(fixCase)\n}\n\nexport function fixCase(s: string) {\n  if (s.match(/[a-z\\d]{3,4}/i) != null) {\n    return s.toUpperCase()\n  }\n  return orElse(Cases.get(s.trim().toLowerCase()), () => capitalize(s))\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { valpath } from \"../../core/Object\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { readRawTags } from \"../../core/tags/ExifTool\"\nimport { readJsonSidecar } from \"../../core/tags/JsonSidecar\"\nimport { renderNameTag } from \"../../core/tags/Names\"\nimport { tagRefToS } from \"../../core/tags/TagPaths\"\nimport { isNotEmpty, uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { values } from \"../../fe/Object\"\nimport { TagPath, TagRoots } from \"../../fe/api/Tag\"\nimport { toA } from \"../../fe/toA\"\n\nconst logger = lazy(() => mkLogger(\"curators.WhoTagger\"))\n\nexport async function whoTagFiles(files: PosixFile[]): PromiseMaybe<TagPath[]> {\n  // Don't bother to read tags, just read JSON payloads:\n  const names: string[] = []\n\n  if (Settings.tagJsonFaces.valueOrDefault) {\n    const jsonSidecars: PosixFile[] = []\n    for (const f of files) {\n      jsonSidecars.push(...toA(await f.jsonSidecars()))\n    }\n    for (const ea of jsonSidecars) {\n      const tags = await readJsonSidecar(ea)\n      const arr = tags?.peopleNames\n      if (isNotEmpty(arr)) {\n        names.push(...arr)\n      }\n    }\n  }\n\n  if (Settings.tagFaceRegions.valueOrDefault) {\n    for (const f of files) {\n      const tags = await readRawTags(f, true) // include sidecars\n      // Expect something like\n      // {\n      //   \"Area\": {\n      //     \"H\": 0.0653789,\n      //     \"Unit\": \"normalized\",\n      //     \"W\": 0.0318743,\n      //     \"X\": 0.214086,\n      //     \"Y\": 0.178058\n      //   },\n      //   \"Name\": \"First Last\",\n      //   \"Type\": \"Face\"\n      // }\n\n      // or:\n      // \"Regions\": {\n      //   \"AppliedToDimensions\": {\n      //     \"H\": 1704,\n      //     \"Unit\": \"pixel\",\n      //     \"W\": 2272\n      //   },\n      //   \"RegionList\": [{\n      //     \"ALGArea\": {\n      //       \"H\": 0.176056,\n      //       \"W\": 0.132042,\n      //       \"X\": 0.363116,\n      //       \"Y\": 0.288146\n      //     },\n      //     \"DLYArea\": {\n      //       \"H\": 0.181338,\n      //       \"W\": 0.112236,\n      //       \"X\": 0.363116,\n      //       \"Y\": 0.290786\n      //     },\n      //     \"Name\": \"Joe Bloggs\",\n      //     \"NameAssignType\": \"manual\",\n      //     \"Type\": \"Face\"\n\n      if (tags != null) {\n        for (const v of values(tags)) {\n          const regionList = (v as any)?.RegionList\n          if (Array.isArray(regionList)) {\n            for (const region of regionList) {\n              if (region[\"Type\"] === \"Face\") {\n                names.push(region[\"Name\"])\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (isNotEmpty(Settings.whoTags.values)) {\n    for (const f of files) {\n      const tags = await readRawTags(f, true) // include sidecars\n      for (const field of Settings.whoTags.values) {\n        names.push(...toA(valpath(tags, field)))\n      }\n    }\n  }\n\n  const result = uniq(flatten(uniq(names).map(nameTag)))\n\n  return logger().tap({\n    msg: \"whoTagFiles()\",\n    level: \"info\",\n    result,\n    meta: { names, files: files.map(ea => ea.nativePath) }\n  })\n}\n\nconst whoRootsLowerCased = uniq(\n  [TagRoots.Who, ...Settings.rootTagWhoAliases.values].map(ea =>\n    ea.toLowerCase()\n  )\n)\n\nexport function isWhoTag(t: TagPath): boolean {\n  return whoRootsLowerCased.includes(tagRefToS(t[0]).toLowerCase())\n}\n\nexport function nameTag(s: string | string[]) {\n  if (blank(s)) return\n  if (Array.isArray(s)) {\n    if (isWhoTag(s)) {\n      s.shift()\n    }\n    return s.length === 0\n      ? undefined // < weird: just a \"Who\":\n      : s.length === 1\n      ? renderNameTag(s[0]) // < \"Who/First Last\"\n      : [[TagRoots.Who, ...s]] // < \"Who/Person/Name\": retain the specified hierarchy\n  } else {\n    return renderNameTag(s)\n  }\n}\n","import sqlite from \"better-sqlite3\"\nimport { max } from \"../../core/Array\"\nimport { lazy } from \"../../core/Lazy\"\nimport { isSyncService } from \"../../core/ServiceNames\"\nimport { EndableRanks, ending } from \"../../core/async/Endable\"\nimport { EndableWrapper } from \"../../core/async/EndableWrapper\"\nimport { time } from \"../../core/async/PromiseTimer\"\nimport { filestamp } from \"../../core/date/Filestamp\"\nimport { DatabaseWithUid } from \"../../core/db/DatabaseWithUid\"\nimport { dbBackupCold_ } from \"../../core/db/DbBackupCold\"\nimport { handleDbRetries } from \"../../core/db/DbRetries\"\nimport { mkdb_ } from \"../../core/db/MkDb\"\nimport { isDirSQLiteReadWrite } from \"../../core/db/SQLiteReadWrite\"\nimport { Schema } from \"../../core/db/Schemas\"\nimport { WrappedError } from \"../../core/error/WrappedError\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { HealthCheck } from \"../../core/health/HealthCheck\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { fmtPct, gt0 } from \"../../fe/Number\"\nimport { pick } from \"../../fe/Object\"\nimport { randomChars } from \"../../fe/Random\"\nimport { Migration } from \"./Migration\"\nimport { checkpoint_, escStr, repairDbFile_, verifyDb_ } from \"./SQLite\"\nimport { localTableInfo } from \"./TableInfo\"\n\n/**\n * Manages a SQLite database connection. If the connection closes (due to\n * external vacuuming), it will be automatically re-opened.\n */\nexport class Db extends EndableWrapper {\n  #count = 0\n  #db: Maybe<DatabaseWithUid>\n  readonly endTimeoutMs = minuteMs\n\n  /**\n   * @param _dataDir if not given, use `libraryDataDir()`\n   */\n  constructor(\n    readonly schema: Schema,\n    readonly dbFile: PosixFile\n  ) {\n    super(\"db.Db(\" + schema + \")\", () => this.closeDb(), EndableRanks.db)\n  }\n\n  toJSON() {\n    return pick(this, \"schema\", \"dbFile\")\n  }\n\n  get open() {\n    return this.#db != null && this.#db.open\n  }\n\n  get inTransaction() {\n    return this.open && true === this.#db?.inTransaction\n  }\n\n  prepare(source: string) {\n    return this.db.prepare(source)\n  }\n\n  pragma(pragma: string, options?: sqlite.PragmaOptions): any {\n    return this.logger.tapThunk({\n      msg: \"PRAGMA \" + pragma,\n      result: () => this.db.pragma(pragma, options)\n    })\n  }\n\n  get db(): DatabaseWithUid {\n    const priorWasNull = this.#db == null\n    if (!this.open) {\n      this.logger.info(\"setting up new db connection to \" + this.dbFile, {\n        priorWasNull\n      })\n      try {\n        this.#db = mkdb_({ nativePath: this.dbFile.nativePath })\n      } catch (cause) {\n        throw new WrappedError(\"Failed to set up \" + this.dbFile, {\n          cause,\n          path: this.dbFile.nativePath\n        })\n      }\n    }\n    if (\n      isSyncService() &&\n      Settings.dbAutoVacuumMode.valueOrDefault === \"INCREMENTAL\" &&\n      gt0(Settings.dbWalAutoCheckpoint.valueOrDefault) &&\n      ++this.#count % Settings.dbWalAutoCheckpoint.valueOrDefault === 0\n    ) {\n      this.#db?.pragma(\"incremental_vacuum\")\n    }\n    return this.#db!\n  }\n\n  verify_() {\n    return verifyDb_(this.db)\n  }\n\n  assertHeartbeat_() {\n    const str = randomChars(64)\n    const now = Date.now()\n    try {\n      this.db\n        .prepare(\n          \"INSERT INTO heartbeat (name, createdAt, updatedAt) VALUES (?,?,?)\"\n        )\n        .run(str, now, now)\n\n      const row = this.db\n        .prepare(\"SELECT * FROM heartbeat WHERE name = ?\")\n        .get(str) as any\n\n      if (row?.name !== str) {\n        throw new Error(\"heartbeat INSERT/SELECT roundtrip failed\")\n      }\n    } finally {\n      try {\n        this.db.prepare(\"DELETE FROM heartbeat WHERE name = ?\").run(str)\n      } catch {\n        // ignore\n      }\n    }\n  }\n\n  closeDb() {\n    try {\n      if (true === this.#db?.open) {\n        this.logger.info(\"closing db\", this.#db)\n        this.#db?.close()\n      }\n    } catch (err) {\n      this.logger.warn(\"closeDb(): .close() failed\", err)\n    }\n    this.#db = undefined\n  }\n\n  readonly onRetry = lazy(\n    () => this.closeDb(),\n    Settings.maxBusyDbMs.valueOrDefault / 4\n  )\n\n  #maxUpdatedAt(...tablenames: string[]): Maybe<number> {\n    const arr: number[] = []\n    for (const table of tablenames) {\n      try {\n        arr.push(\n          this.db\n            .prepare(\"SELECT MAX(updatedAt) FROM \" + escStr(table))\n            .pluck()\n            .get() as number\n        )\n      } catch (error) {\n        this.logger.warn(\n          `#maxUpdatedAt(): failed to get max updatedAt for ${table}`,\n          error\n        )\n      }\n    }\n    return max(arr)\n  }\n\n  readonly maxUpdatedAt = lazy(\n    () =>\n      this.schema === \"models\"\n        ? this.#maxUpdatedAt(\"Asset\", \"AssetFile\", \"Example\")\n        : 0,\n    5 * secondMs\n  )\n\n  async vacuum() {\n    try {\n      await handleDbRetries(\n        () => time(\"db.checkpoint\", () => checkpoint_({ db: this.db })),\n        this.onRetry\n      )\n      await handleDbRetries(\n        () => time(\"db.optimize\", () => this.db.pragma(\"OPTIMIZE\")),\n        this.onRetry\n      )\n      await handleDbRetries(\n        () => time(\"db.vacuum\", () => this.db.exec(\"VACUUM\")),\n        this.onRetry\n      )\n    } catch (error) {\n      this.logger.warn(\"vacuum(): failed\", { error })\n      throw error\n    }\n  }\n\n  /**\n   * Caller should have an exclusive lock on the database to prevent\n   * concurrent access.\n   */\n  async repair_() {\n    this.logger.warn(\"repair_(): Attempting restore of \" + this.dbFile)\n    this.closeDb()\n    await repairDbFile_(this.dbFile)\n    this.logger.info(\"repair_(): Database restoration was successful!\")\n  }\n\n  async #backupHot_(destFile: PosixFile) {\n    await destFile.parent().mkdirp_()\n    await this.db.backup(destFile.nativePath, {\n      progress: ea => {\n        this.logger.log(\n          ending() ? \"info\" : \"debug\",\n          \"backup() \" +\n            fmtPct(100 - (ea.remainingPages / ea.totalPages) * 100) +\n            \" completed\"\n        )\n        // This is the number of pages to backup per callback\n        return ending() ? 1000 : 100\n      }\n    })\n  }\n\n  async backup_(destDir: PosixFile, isDestDirRW?: boolean): Promise<PosixFile> {\n    const isRW = isDestDirRW ?? (await isDirSQLiteReadWrite(destDir))\n    const hotDestDb = (\n      isRW ? destDir : this.dbFile.parent().join(\"backups\", filestamp())\n    ).join(this.dbFile.base)\n    await this.#backupHot_(hotDestDb)\n    if (!isRW) {\n      await dbBackupCold_(hotDestDb, destDir)\n    }\n    return destDir.join(this.dbFile.base)\n  }\n\n  readonly migrate_ = lazy(async () => {\n    let repaired = false\n    const file = this.dbFile\n    if (this.dbFile == null) {\n      throw new Error(\"Cannot migrate database: missing db\")\n    }\n    let dbSetupError\n    if (await this.dbFile.isNonEmptyFile()) {\n      try {\n        verifyDb_(this.db) // < this will fail if the db is borked\n      } catch (error) {\n        this.logger.warn(\"verifyDb failed before attempting Migration.\", {\n          error\n        })\n        dbSetupError = error\n      }\n    }\n\n    if (dbSetupError != null || Settings.dbForceRecover.valueOrDefault) {\n      HealthCheck.addLoadingMsg(\"Repairing database...\")\n      await this.repair_()\n      repaired = true\n    }\n\n    const migration = new Migration(this.schema, this.db, file)\n    const appliedMigrations = await migration.apply_()\n    return this.logger.tap({\n      msg: \"migrate_\",\n      result: { appliedMigrations, migration, repaired }\n    })\n  })\n\n  readonly tableInfo_ = lazy(() => localTableInfo(this.db))\n}\n","import { isSuspended } from \"../../core/IsSuspended\"\nimport { Logger, mkLogger } from \"../../core/Logger\"\nimport { EndableRanks, ending } from \"../../core/async/Endable\"\nimport { EndableInterval } from \"../../core/async/EndableInterval\"\nimport { EndableWrapper } from \"../../core/async/EndableWrapper\"\nimport { filestamp } from \"../../core/date/Filestamp\"\nimport { dbBackupCold_ } from \"../../core/db/DbBackupCold\"\nimport { sqliteFiles } from \"../../core/db/SQLiteFiles\"\nimport { SqliteExt } from \"../../core/db/Schemas\"\nimport { isUpdateReadyToInstall } from \"../../core/event/UpdateReadyToInstall\"\nimport { FsLock, withLock_ } from \"../../core/fs/FsLock\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { fmtDuration } from \"../../fe/FmtDuration\"\nimport { runMaintenanceTasks } from \"../model/MaintenanceTasks\"\nimport { Db } from \"./Db\"\nimport { libraryDbInfoFromDbFile, libraryDbObjects_ } from \"./DbModelSetup\"\nimport { dbSetupErrors, hasDbSetupErrors } from \"./DbSetupErrors\"\n\nconst endTimeoutMs = 5 * minuteMs\n\nexport const NoWriteLock = Symbol(\"NoWriteLock\")\nexport const NoOp = Symbol(\"NoOp\")\nexport const Contested = Symbol(\"Contested\")\n\nexport class DbModelJanitor extends EndableInterval {\n  readonly backupsDir = this.libraryDbFile.sibling(\"backups\")\n  readonly logger: Logger = mkLogger(this.name)\n  readonly fslockRelease = new EndableWrapper(\n    \"db.DbModelJanitor.fslockRelease\",\n    () => this.dbFslock.release(),\n    EndableRanks.postdb,\n    endTimeoutMs\n  )\n\n  #lastUpdatedAt = 0\n\n  constructor(\n    readonly db: Db,\n    readonly dbFslock: FsLock,\n    readonly libraryDbFile: PosixFile = libraryDbObjects_().libraryDbFile,\n    readonly retentionCount: number = Settings.dbBackupRetentionCount\n      .valueOrDefault\n  ) {\n    super({\n      name: \"db.DbModelJanitor\",\n      callback: () => this.#onInterval(),\n      intervalMs: Settings.dbBackupIntervalMs.valueOrDefault,\n      initialDelayMs: minuteMs,\n      rank: EndableRanks.db,\n      endTimeoutMs: 5 * minuteMs, // 200MB to copy, 1MB/s, 3 minutes\n      onEnd: () => this.#teardown()\n    })\n    void this.dbFslock.tryAcquire_()\n  }\n\n  async vacuumBackups() {\n    const dbFiles =\n      (await this.backupsDir.childFiles(ea => ea.ext === SqliteExt)) ?? []\n    const victims = dbFiles.slice(0, -this.retentionCount)\n    for (const victim of victims) {\n      this.logger.info(\"backup(): removing stale backup \" + victim)\n      for (const ea of sqliteFiles(victim)) {\n        await ea.unlink()\n      }\n    }\n  }\n\n  get useReplica() {\n    return !this.db.dbFile.eql(this.libraryDbFile)\n  }\n\n  async #onInterval() {\n    try {\n      await this.backup_()\n    } catch (error) {\n      this.logger.error(\"backup_() failed\", { error })\n    }\n  }\n\n  async #teardown() {\n    const teardownLock = FsLock.for({\n      file: this.libraryDbFile.sibling(\"db-teardown\"),\n      timeoutMs: endTimeoutMs,\n      endableRank: EndableRanks.postdb,\n      noopIfContested: false // we want to wait for acquisition\n    })\n\n    await teardownLock.withLock_(async () => {\n      // Last one out needs to turn off the lights:\n      if (!(await this.dbFslock.iAmOnly_({ vacuum: true }))) {\n        this.logger.info(\n          \"#teardown(): no-op: other processes are still running\"\n        )\n        return\n      }\n      this.logger.info(\n        \"#teardown(): I'm the last one in. Running backup and cleanup.\"\n      )\n\n      await this.backup_()\n\n      // Only run replica cleanup if backup_() is successful!\n      if (this.useReplica) {\n        const dbInfoJson = libraryDbInfoFromDbFile(this.libraryDbFile)\n        const victims = [dbInfoJson, ...sqliteFiles(this.db.dbFile)]\n        this.logger.info(\"#teardown(): Removing replica artifacts\", { victims })\n        for (const ea of victims) {\n          await ea.unlink()\n        }\n      }\n    })\n\n    this.db.closeDb()\n  }\n\n  /**\n   * Are we under a deadline here?\n   */\n  #needToHurry() {\n    return this.ended || ending() || isSuspended() || isUpdateReadyToInstall()\n  }\n\n  forceBackup_(): Promise<\n    typeof NoOp | typeof NoWriteLock | typeof Contested | PosixFile\n  > {\n    return this.backup_(true)\n  }\n\n  async backup_(\n    force: boolean = false\n  ): Promise<typeof NoOp | typeof NoWriteLock | typeof Contested | PosixFile> {\n    return (\n      (await withLock_(\n        {\n          file: this.libraryDbFile.sibling(\"backup\"),\n          timeoutMs: 5 * minuteMs,\n          noopIfContested: !force\n        },\n        async () => {\n          // don't skip backup if maxUpdatedAt hasn't changed since last backup:\n          if (force) this.#lastUpdatedAt = 0\n          if (hasDbSetupErrors()) {\n            this.logger.warn(\n              \"backup_(): db has setup errors, skipping backup\",\n              {\n                errors: dbSetupErrors()\n              }\n            )\n            return NoOp\n          }\n          if (!(await this.dbFslock.tryAcquire_())) {\n            this.logger.info(\"backup_(): no-op: someone else has the fslock\", {\n              me: this.dbFslock.lockfile?.base,\n              owner: (await this.dbFslock.selfAndSiblingNames_())[0]\n            })\n            return NoWriteLock\n          }\n\n          if (!this.#needToHurry()) {\n            await runMaintenanceTasks()\n          }\n          const newMaxUpdatedAt = this.db.maxUpdatedAt()\n          if (\n            newMaxUpdatedAt != null &&\n            newMaxUpdatedAt > this.#lastUpdatedAt\n          ) {\n            if (!this.#needToHurry()) {\n              await this.db.vacuum()\n            } else {\n              this.logger.info(\"backup_(): posthaste: skipping vacuum\")\n            }\n            this.#lastUpdatedAt = newMaxUpdatedAt\n            const destDir = this.backupsDir.join(filestamp())\n            const destDbFile = await this.db.backup_(destDir, !this.useReplica)\n            if (this.useReplica) {\n              await dbBackupCold_(destDbFile, this.libraryDbFile.parent())\n            }\n            this.logger.info(\"backup_(): backup successful\", { destDbFile })\n            return destDbFile\n          } else {\n            this.logger.info(\n              \"backup_(): no update to the db since last backup\",\n              {\n                ago: fmtDuration(Date.now() - this.#lastUpdatedAt)\n              }\n            )\n            return NoOp\n          }\n        }\n      )) ?? Contested\n    )\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { getLiveDbDir_ } from \"../../core/db/CheckLocalDbReplica\"\nimport { dbBackupCold_ } from \"../../core/db/DbBackupCold\"\nimport { assertDirSQLiteReadWrite_ } from \"../../core/db/SQLiteReadWrite\"\nimport { Schemas, pathToDb } from \"../../core/db/Schemas\"\nimport { libraryDataDirPosixFile } from \"../../core/dir/LibraryDirs\"\nimport { errorToS } from \"../../core/error/Error\"\nimport {\n  DbSetupErrorFlag,\n  InternalErrorFlag,\n  NoLibraryErrorFlag\n} from \"../../core/error/ErrorFlags\"\nimport { FsLock, withLock_ } from \"../../core/fs/FsLock\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { SimpleFileOrString, toNativePath_ } from \"../../core/fs/SimpleFile\"\nimport { HealthCheck } from \"../../core/health/HealthCheck\"\nimport { LogLevels } from \"../../core/log/LogLevel\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { _libraryHasSettings } from \"../../core/settings/SettingsIO\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { blank, mapNotBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { modelDb } from \"../model/ModelDb\"\nimport { Db } from \"./Db\"\nimport { addDbSetupError, clearDbSetupErrors } from \"./DbSetupErrors\"\n\nconst logger = lazy(() => mkLogger(\"db.DbModelSetup\"))\n\nexport function libraryDbObjects_(\n  libraryDir = Settings.libraryDir.valueOrDefault\n) {\n  if (blank(libraryDir)) {\n    throw new Error(\"Library directory is not set\" + NoLibraryErrorFlag)\n  }\n  const dataDir = libraryDataDirPosixFile(libraryDir)\n  if (dataDir == null) {\n    throw new Error(\"missing library dataDir\" + NoLibraryErrorFlag)\n  }\n\n  if (!_libraryHasSettings(libraryDir)) {\n    throw new Error(\n      `Library at ${libraryDir} does not have a settings file` +\n        NoLibraryErrorFlag\n    )\n  }\n  return { dataDir, libraryDbFile: pathToDb(dataDir, \"models\") }\n}\n\nexport function fsLockForDb(dbFile: PosixFile) {\n  // using .for() here to ensure the _same instance_ gets returned for the\n  // same path:\n  return FsLock.for({\n    file: dbFile,\n    timeoutMs: 0,\n    noopIfContested: false\n  })\n}\n\nasync function libraryDbLockObjects_(\n  libraryDir = Settings.libraryDir.valueOrDefault\n) {\n  const result = libraryDbObjects_(libraryDir)\n  return {\n    ...result,\n    fslock: fsLockForDb(result.libraryDbFile)\n  }\n}\n\nexport function libraryDbInfoJsonFile(\n  libraryDir = Settings.libraryDir.valueOrDefault\n): PosixFile {\n  const dataDir = libraryDataDirPosixFile(libraryDir)\n  if (dataDir == null) {\n    throw new Error(\"missing library dir\" + NoLibraryErrorFlag)\n  } else {\n    return libraryDbInfoFromDbFile(pathToDb(dataDir, \"models\"))\n  }\n}\n\nexport function libraryDbInfoFromDbFile(dbFile: PosixFile) {\n  return dbFile.sibling(\"db-info.json\")\n}\n\nexport async function assertValidDbInfo_(\n  infoJsonFile = libraryDbInfoJsonFile(),\n  expectedLiveDbFile?: PosixFile\n): Promise<{ liveDbFile: PosixFile }> {\n  try {\n    const priorInfo = await infoJsonFile.readJson<DbSetupInfo>(LogLevels.info)\n    if (priorInfo == null) {\n      throw new Error(infoJsonFile + \" is missing\" + DbSetupErrorFlag)\n    }\n    if (\n      expectedLiveDbFile != null &&\n      !(await expectedLiveDbFile.equalsUri_(priorInfo.uri))\n    ) {\n      throw new Error(\n        infoJsonFile +\n          \" expects the live db to be \" +\n          priorInfo.uri +\n          \" but the live db is \" +\n          (await expectedLiveDbFile.uri_()) +\n          DbSetupErrorFlag\n      )\n    }\n\n    const liveDbFile = await PosixFile.forUri(priorInfo.uri)\n    if (liveDbFile == null) {\n      throw new Error(\n        infoJsonFile +\n          \" expects the live db to be \" +\n          priorInfo.uri +\n          \" but that URI cannot be resolved.\" +\n          DbSetupErrorFlag\n      )\n    }\n    try {\n      await assertDirSQLiteReadWrite_(liveDbFile.parent())\n    } catch (error) {\n      logger().error(\n        \"assertValidDbInfo_(): failed to assert live dir was r/w\",\n        { error, liveDbFile, infoJsonFile }\n      )\n      throw new Error(\n        \"Failed to validate that the live database directory, \" +\n          liveDbFile.dir +\n          \", was read-writable by SQLite: \" +\n          errorToS(error) +\n          DbSetupErrorFlag\n      )\n    }\n\n    // Don't clear db errors here: we do that in dbModelSetup_() after\n    // migration is successful:\n    return {\n      liveDbFile\n    }\n  } catch (error) {\n    addDbSetupError(error)\n    throw error\n  }\n}\n\nexport interface DbSetupInfo {\n  uri: string\n  useReplica: boolean\n}\n\n/**\n * Handles opening the SQLite model database.\n *\n * @throws if the library directory is missing, or if the library does not\n * have a settings file, or there is a problem opening the database.\n */\nexport async function dbModelSetup_(\n  libraryDir: Maybe<SimpleFileOrString> = Settings.libraryDir.valueOrDefault\n): Promise<{\n  db: Db\n  useReplica: boolean\n  libraryDbFile: PosixFile\n  fslock: FsLock\n}> {\n  const { libraryDbFile, fslock } = await libraryDbLockObjects_(\n    mapNotBlank(libraryDir, toNativePath_)\n  )\n\n  // This isn't a lock as much as a way to coordinate who currently has the\n  // library database open:\n  await fslock.tryAcquire_()\n\n  let useReplica: boolean | undefined\n  let db: Db | undefined\n\n  const infoJsonFile = libraryDbInfoFromDbFile(libraryDbFile)\n\n  try {\n    await withLock_(\n      { file: infoJsonFile, timeoutMs: 5 * minuteMs },\n      async () => {\n        const priorInfo = await infoJsonFile.readJson<DbSetupInfo>(\n          LogLevels.info\n        )\n\n        useReplica = priorInfo?.useReplica\n\n        // We want to prevent \"split brain\" issues where multiple processes\n        // read/write from different sqlite files.\n\n        if (priorInfo != null) {\n          const { liveDbFile } = await assertValidDbInfo_(\n            infoJsonFile,\n            libraryDbFile\n          )\n\n          db = new Db(Schemas.models, liveDbFile)\n        }\n\n        if (useReplica == null || db == null) {\n          const liveDbInfo = await getLiveDbDir_(libraryDir)\n          const uri = await liveDbInfo.db.uri_()\n          useReplica = liveDbInfo.useReplica\n          if (useReplica) {\n            await HealthCheck.traceLater_(\n              \"Setting up local replica database\",\n              dbBackupCold_(libraryDbFile, liveDbInfo.db.parent())\n            ).catch(error =>\n              logger().throw(\"Failed to set up replica db\" + DbSetupErrorFlag, {\n                src: libraryDbFile,\n                dest: liveDbInfo.db,\n                error\n              })\n            )\n          }\n          db = new Db(Schemas.models, liveDbInfo.db)\n          await infoJsonFile.writeJson_({ uri, useReplica })\n        }\n      }\n    )\n\n    if (db == null || useReplica == null) {\n      return logger().throw(\n        \"Failed to open model db\" + DbSetupErrorFlag + InternalErrorFlag,\n        {\n          libraryDir\n        }\n      )\n    }\n\n    if (await fslock.tryAcquire_()) {\n      // migrate_() runs a repair if any checks fail.\n      const result = await db.migrate_()\n      if (\n        useReplica &&\n        (result.repaired || isNotEmpty(result.appliedMigrations))\n      ) {\n        // Only copy back if we repaired or applied migrations:\n        await db.backup_(libraryDbFile.parent(), !useReplica)\n      }\n      // YAY EVERYTHING IS GREAT\n      clearDbSetupErrors()\n    }\n    // ALL IS WELL let's go!\n    modelDb.set(db)\n  } catch (error) {\n    logger().error(\"Failed to set up model db\", { error })\n    addDbSetupError(error)\n    fslock.release()\n    throw error\n  }\n\n  return logger().tap({\n    msg: \"dbModelSetup()\",\n    result: {\n      db,\n      useReplica,\n      libraryDbFile,\n      fslock\n    }\n  })\n}\n","import { RunResult, Statement } from \"better-sqlite3\"\nimport { Knex } from \"knex\"\nimport { FifoCache } from \"../../core/FifoCache\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { isTest } from \"../../core/NodeEnv\"\nimport { ending } from \"../../core/async/Endable\"\nimport { mkElapsed } from \"../../core/async/PromiseTimer\"\nimport { defaultLogLevel } from \"../../core/log/LogFilter\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { ellipsize, replaceAll } from \"../../fe/String\"\nimport { TableName } from \"../model/TableName\"\nimport { Db } from \"./Db\"\nimport { DbValue, DbValued } from \"./DbValued\"\nimport { knex } from \"./Knex\"\nimport { Queryish, SqlQuery, sqlQueryToS, toSqlQuery } from \"./SqlQuery\"\n\n// SQLite max params is 100 and max variables is 1000.\n\n// This limit is just to prevent memory bloat. It can be larger than SQLite\n// batch size. It's small in test to prove we do windowing correctly:\nexport const MaxBatchSize = isTest ? 25 : 1000\n\nconst logger = lazy(() => mkLogger(\"db.DbRequest\"))\n\nexport class DbRequest {\n  private readonly cachedStatements = new FifoCache<Statement>(256)\n  constructor(\n    readonly db: () => Db,\n    private readonly tableName?: TableName\n  ) {}\n\n  qb() {\n    return knex()(this.tableName)\n  }\n\n  private prep(q: Queryish, pluck = false): { sq: SqlQuery; stmt: Statement } {\n    const sq = toSqlQuery(q)\n    try {\n      const stmt = this.cachedStatements.getOrSet(\n        this.db().db.__uid + \":\" + (pluck === true ? \"pluck:\" : \"\") + sq.sql,\n        () => {\n          const result = this.db().prepare(sq.sql)\n          return pluck === true ? result.pluck() : result\n        }\n      )\n      if (!stmt.database.open) {\n        this.cachedStatements.clear()\n        return this.prep(q, pluck)\n      } else {\n        return {\n          sq,\n          stmt\n        }\n      }\n    } catch (error) {\n      return logger().throw(\"prep() failed\", {\n        error,\n        sqlQuery: sq,\n        retriable: false\n      })\n    }\n  }\n\n  // private caller() {\n  //   return stack().filter(\n  //     ea =>\n  //       ea.match(\n  //         /DbRequest|transactions|dbRetries|asyncRetry|ModelOps|Promise/i\n  //       ) == null\n  //   )\n  // }\n\n  private wrap({\n    q,\n    pluck,\n    m\n  }: {\n    q: Queryish\n    pluck?: boolean\n    m: \"run\" | \"get\" | \"all\"\n  }) {\n    try {\n      // HEY FUTURE ME: don't put the catch /in/ the tx: that can prevent errors\n      // from being retried correctly.\n      const { sq, stmt } = this.prep(q, pluck)\n      if (Settings.logSql.valueOrDefault)\n        logger().log(\n          defaultLogLevel(),\n          m + \"(): \" + sqlQueryToS(sq)\n          // this.caller()\n        )\n      const meth = stmt[m].bind(stmt) as any\n      // PERF: INLINED FROM mapOr\n      return sq.bindings == null ? meth() : meth(sq.bindings)\n    } catch (err: any) {\n      if (true === err.message?.includes(\"AdvisoryLock\")) {\n        // expect errors from AdvisoryLock!\n        throw err\n      } else {\n        logger().throw(err, { method: m, ...toSqlQuery(q) })\n      }\n    }\n  }\n\n  run(q: Queryish): RunResult {\n    return this.wrap({ q, m: \"run\" })\n  }\n\n  runScript(lines: string[], ignorable: string = \"\") {\n    const e = mkElapsed(\"db.runScript()\")\n    // Don't block anything with a big transaction boundary:\n    for (const sql of lines) {\n      if (blank(sql) || sql.trim().startsWith(\"--\")) continue\n      this.run({ sql })\n      // Only fetch the first part of the query (so temp tables don't pollute\n      // the times):\n      const msg = replaceAll(ellipsize(sql, 60), ignorable, \"\")\n      e.elapsed(msg)\n    }\n  }\n\n  mapRun(queries: Queryish[]): RunResult[] {\n    return queries.map(q => {\n      const { sq, stmt } = this.prep(q)\n      return sq.bindings == null ? stmt.run() : stmt.run(sq.bindings)\n    })\n  }\n\n  runf(f: (q: Knex.QueryBuilder) => Knex.QueryBuilder): RunResult {\n    return this.wrap({ q: f(this.qb()), m: \"run\" })\n  }\n\n  upsert(f: (q: Knex.QueryBuilder) => Knex.QueryBuilder): RunResult {\n    const q = toSqlQuery(f(this.qb()))\n    // https://sqlite.org/lang_insert.html\n    // https://sqlite.org/lang_update.html\n    q.sql = q.sql.replace(\n      /^(?:update|insert)\\b/i,\n      ea => ea.toUpperCase() + \" OR REPLACE \"\n    )\n    return this.wrap({ q, m: \"run\" })\n  }\n\n  first(q: Queryish): DbValued {\n    return this.wrap({ q, m: \"get\" })\n  }\n\n  firstf(f: (q: Knex.QueryBuilder) => Knex.QueryBuilder): Promise<DbValued> {\n    return this.wrap({ q: f(this.qb()), m: \"get\" })\n  }\n\n  mapAll(queries: Queryish[]): DbValued[] {\n    return flatten(\n      queries.map(q => {\n        const { sq, stmt } = this.prep(q)\n        return stmt.all(sq.bindings) as DbValued[]\n      })\n    )\n  }\n\n  all(q: Queryish): DbValued[] {\n    return this.wrap({ q, m: \"all\" })\n  }\n\n  allf(f: (q: Knex.QueryBuilder) => Knex.QueryBuilder): DbValued[] {\n    return this.wrap({ q: f(this.qb()), m: \"all\" })\n  }\n\n  batched<T>(opts: {\n    onResults: (ids: T[]) => any\n    qb: (q: Knex.QueryBuilder, prior: Maybe<T[]>) => Knex.QueryBuilder\n  }) {\n    let prior: Maybe<T[]>\n    do {\n      prior = this.wrap({\n        q: opts.qb(this.qb(), prior).limit(MaxBatchSize),\n        m: \"all\"\n      })\n      if (isNotEmpty(prior)) {\n        opts.onResults(prior)\n      }\n    } while (isNotEmpty(prior) && !ending())\n  }\n\n  pluckFirst<T = DbValue>(q: Queryish): T {\n    return this.wrap({ q, pluck: true, m: \"get\" })\n  }\n\n  pluckFirstf<T extends DbValue = DbValue>(\n    f: (q: Knex.QueryBuilder) => Knex.QueryBuilder\n  ): T {\n    return this.wrap({ q: f(this.qb()), pluck: true, m: \"get\" })\n  }\n\n  pluckAll<T = DbValue>(q: Queryish): T[] {\n    return this.wrap({ q, pluck: true, m: \"all\" })\n  }\n\n  pluckAllf<T = DbValue>(f: (q: Knex.QueryBuilder) => Knex.QueryBuilder): T[] {\n    return this.wrap({ q: f(this.qb()), pluck: true, m: \"all\" })\n  }\n\n  pluckBatched<T extends number | string>(opts: {\n    onResults: (ids: T[]) => any\n    qb: (q: Knex.QueryBuilder, prior: Maybe<T[]>) => Knex.QueryBuilder\n  }) {\n    let prior: Maybe<T[]>\n    do {\n      prior = this.wrap({\n        q: opts.qb(this.qb(), prior).limit(MaxBatchSize),\n        pluck: true,\n        m: \"all\"\n      })\n      if (isNotEmpty(prior)) {\n        opts.onResults(prior)\n      }\n    } while (isNotEmpty(prior))\n  }\n}\n","import bs = require(\"better-sqlite3\")\nimport _path from \"path\"\nimport { diffEql } from \"../../core/Array\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { Schema } from \"../../core/db/Schemas\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { ProjectPath } from \"../../core/fs/ProjectPath\"\nimport { diff, isNotEmpty } from \"../../fe/Array\"\nimport { andList } from \"../../fe/FmtList\"\nimport { plur } from \"../../fe/Units\"\nimport { dbModelHealthCheck } from \"../health/DbModelHealthCheck\"\nimport { Db } from \"./Db\"\nimport { TableInfo, localTableInfo } from \"./TableInfo\"\n\nconst logger = lazy(() => mkLogger(\"db.DbSchemaValid\"))\n\nexport function schemaJsonFile(schema: Schema) {\n  // NOT SORTED!\n  return PosixFile.for(_path.join(ProjectPath.Data(), schema + \"-schema.json\"))\n}\n\ninterface JsonContents {\n  info: string\n  tableInfo: TableInfo[]\n}\n\nexport async function assertValidDbSchema_(db: Db) {\n  try {\n    await db.migrate_()\n    const actualTableInfo = localTableInfo(db.db)\n    const actualTableNames = actualTableInfo.map(t => t.tableName)\n    const expectedTableInfo = (\n      await schemaJsonFile(db.schema).readJson_<JsonContents>()\n    ).tableInfo\n    {\n      const expectedTableNames = expectedTableInfo.map(t => t.tableName)\n      const missing = diff(expectedTableNames, actualTableNames)\n      if (isNotEmpty(missing)) {\n        logger().throw(\n          \"Db is missing \" +\n            plur(missing.length, \"table\") +\n            \" : \" +\n            andList(missing)\n        )\n      }\n    }\n    for (const table of actualTableInfo) {\n      const exp = expectedTableInfo.find(t => t.tableName === table.tableName)\n      if (exp == null) {\n        logger().warn(\"Unexpected table in db\", table)\n      } else {\n        const missing = diffEql(exp.columns, table.columns)\n        if (isNotEmpty(missing)) {\n          logger().error(\"Missing columns\", { expected: exp, actual: table })\n          logger().throw(\n            \"Db is missing \" +\n              plur(missing.length, \"column\") +\n              \" from table \" +\n              table.tableName +\n              \" : \" +\n              andList(missing.map(ea => ea.name))\n          )\n        }\n      }\n    }\n    logger().info(\"Validated schema.\")\n  } catch (err: any) {\n    // We can't recover from this!\n    dbModelHealthCheck().reset()\n    throw err\n  }\n}\n\nexport function writeSchemaJsonFile_(schema: Schema, db: bs.Database) {\n  return schemaJsonFile(schema).writeJson_(\n    {\n      info: \"This is used in validating PhotoStructure library databases after repair and restore operations.\",\n      tableInfo: localTableInfo(db)\n    } satisfies JsonContents,\n    { spaces: 2 }\n  )\n}\n","import { errorToS } from \"../../core/error/Error\"\nimport { blank } from \"../../fe/Blank\"\nimport { isError } from \"../../fe/isError\"\n\nexport const _dbSetupErrors = new Set<string>()\nconst listeners: (() => void)[] = []\n\nexport function dbSetupErrors() {\n  return [..._dbSetupErrors.values()]\n}\n/**\n * Allow out-of-caller-stack errors to be added to the modelDbHealthCheck\n */\n\nexport function addDbSetupError(error: Error | any) {\n  if (isError(error) || !blank(error)) {\n    _dbSetupErrors.add(errorToS(error))\n    for (const ea of listeners) ea()\n  }\n}\n\nexport function clearDbSetupErrors({\n  notifyListeners = true\n}: { notifyListeners?: boolean } = {}) {\n  _dbSetupErrors.clear()\n  if (notifyListeners) for (const ea of listeners) ea()\n}\n\nexport function hasDbSetupErrors() {\n  return _dbSetupErrors.size > 0\n}\n\nexport function addDbSetupErrorListener(listener: () => void) {\n  listeners.push(listener)\n}\n","import { isDated } from \"../../core/date/Dated\"\nimport { datedToMillis } from \"../../core/date/DatedToMillis\"\nimport { includes } from \"../../fe/Array\"\nimport { entries, mapFields } from \"../../fe/Object\"\n\n// SQLite can only store numbers or strings, but let's also take booleans to\n// simplify constructors\nexport type DbValue = number | string | boolean | Date\n\nexport interface DbValued {\n  [key: string]: DbValue | undefined | null\n}\n\nexport function isDbValue(obj: any): obj is DbValue {\n  return obj === null || includes([\"number\", \"string\"], typeof obj)\n}\n\nexport function isDbValued(obj: any): obj is DbValued {\n  return obj != null && Array.isArray(obj)\n    ? obj.every(isDbValued)\n    : entries(obj).every(([, value]) => isDbValue(value))\n}\n\nexport function toDbValued(obj: any): DbValued {\n  return mapFields(obj, (key, value) => {\n    if (key.startsWith(\"$\")) return\n    if (typeof value === \"boolean\") return [key, value ? 1 : 0]\n    if (isDbValue(value)) return [key, value]\n    if (isDated(value)) return [key, datedToMillis(value)]\n    return\n  }) as DbValued\n}\n","import { Database } from \"better-sqlite3\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { countChars, stripSuffix } from \"../../core/String\"\nimport {\n  TagSep,\n  joinTagPath,\n  splitTagPath,\n  tagPathLeaf\n} from \"../../core/tags/TagPaths\"\nimport { compactBlanks, isEmpty } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { MultiMap } from \"../../fe/MultiMap\"\nimport { gt0 } from \"../../fe/Number\"\nimport { toS } from \"../../fe/toS\"\n\nconst logger = lazy(() => mkLogger(\"db.DedupeTags\"))\n\nexport function mergeTags_(db: Database, tagIds: number[]) {\n  if (isEmpty(tagIds)) {\n    logger().warn(\"mergeTags(): empty tagIds\", { tagIds })\n  }\n\n  logger().info(\"mergeTags() starting\", { tagIds })\n\n  function run(sql: string) {\n    return db.prepare(sql).run()\n  }\n\n  const arr = db\n    .prepare(\n      \"SELECT id, _path, parentId FROM Tag WHERE id IN (\" +\n        tagIds.join(\",\") +\n        \") ORDER BY ID\"\n    )\n    .all() as { id: number; _path: string; parentId: number | null }[]\n\n  // With the v0.8 test db, we have a {id: 1, parentId: null, path: \"kw\"} and {id: 400,\n  // parentId: 1, path: \"kw/\"}. If id:400 wins, it must assume a null parentId.\n  // BAD THINGS happen if we pick a winner whose parent id is one of the\n  // losers (the id === parentId!), so we need to avoid that case. We avoid\n  // this by assuming null for the parentId if any of the tags have a null parentId.\n  // Capitalized base should win. sort is asciibetical, so capitals come first.\n  const leafs = compactBlanks(arr.map(ea => tagPathLeaf(ea._path)).sort())\n\n  // It doesn't matter which tag wins, because we're about to fix the\n  // parentId and path. Let's arbitrarily pick the lowest id.\n  const winner = arr[0]\n  const losers = arr.slice(1)\n  const winnerId = winner?.id\n  if (isEmpty(leafs) || isEmpty(losers) || winner == null || !gt0(winnerId)) {\n    logger().warn(\"mergeTags(): missing winner\", {\n      winner,\n      winnerId,\n      leafs,\n      losers\n    })\n    return\n  }\n\n  const parentTagPath = splitTagPath(winner._path).slice(0, -1)\n  const winnerTagPath = [...parentTagPath, leafs[0]]\n  winner._path = joinTagPath(winnerTagPath)\n  winner.parentId =\n    parentTagPath.length === 0\n      ? null\n      : (db\n          .prepare(\"SELECT id from Tag where _path LIKE ?\")\n          .pluck()\n          .get(joinTagPath(parentTagPath)) as number) ?? winner.parentId\n\n  logger().info(\"mergeTags()\", { winner, losers, winnerTagPath, leafs })\n\n  const loserIds = losers.map(ea => ea.id).join(\",\")\n  run(\n    `UPDATE OR IGNORE AssetTag SET tagId = ${winnerId} WHERE tagId in (${loserIds})`\n  )\n  run(\n    `UPDATE OR IGNORE Tag SET parentId = ${winnerId} WHERE parentId in (${loserIds})`\n  )\n  run(\n    `UPDATE OR IGNORE Tag SET parentId = ${winnerId} WHERE parentId in (${loserIds})`\n  )\n  run(`DELETE FROM AssetTag WHERE tagId in (${loserIds})`)\n  run(`DELETE FROM Tag WHERE id in (${loserIds})`)\n\n  db.prepare(\n    \"UPDATE Tag SET parentId = :parentId, _path = :path WHERE id = :id\"\n  ).run({ parentId: winner.parentId, path: winner._path, id: winnerId })\n\n  const children = db\n    .prepare(\n      \"SELECT id, _path FROM Tag WHERE id != :winnerId AND _path LIKE :like COLLATE NOCASE\"\n    )\n    .all({\n      winnerId,\n      like: winner._path + \"%\"\n    }) as { id: number; _path: string }[]\n\n  for (const ea of children) {\n    const priorChildPath = splitTagPath(ea._path)\n    const fromParentPath = priorChildPath.slice(winnerTagPath.length)\n    const newPath = joinTagPath([...winnerTagPath, ...fromParentPath])\n    if (ea._path !== newPath) {\n      logger().info(\"mergeTags(): repairing tag path\", { ea, newPath })\n      db.prepare(\n        // the OR IGNORE should not be needed:\n        \"UPDATE OR IGNORE Tag SET _path = :path, updatedAt = :updatedAt WHERE id = :id\"\n      ).run({\n        id: ea.id,\n        updatedAt: Date.now(),\n        path: newPath\n      })\n    }\n  }\n\n  return logger().tap({\n    msg: \"mergeTags()\",\n    level: \"info\",\n    result: { winner, losers: arr }\n  })\n}\n\nexport function dedupeTags_(db: Database) {\n  // Unfortunately, there isn't a way to do unicode normalization in SQLite, so we need to do this:\n  const mm = new MultiMap<string, number>()\n  for (const { id, _path } of db\n    .prepare(\"SELECT id, _path FROM Tag ORDER BY id\")\n    .iterate() as IterableIterator<{ id: number; _path: string }>) {\n    mm.add(stripSuffix(toS(_path).trim(), TagSep).toLowerCase().normalize(), id)\n  }\n  const dupes = sortBy(\n    mm.entriesArray().filter(([, ids]) => ids.length > 1),\n    // Do longest paths first, or child repair isn't going to work (unique\n    // constraints will fail!)\n    ([path]) => [-countChars(path, TagSep), -path.length, path]\n  )\n  for (const [, ids] of dupes) {\n    mergeTags_(db, ids)\n  }\n}\n","import _k, { Knex } from \"knex\"\nimport { lazy } from \"../../core/Lazy\"\nimport { thenMap } from \"../../core/async/Promise\"\nimport { map } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { values } from \"../../fe/Object\"\n\nexport const knex = lazy(() =>\n  _k({ client: \"sqlite3\", useNullAsDefault: true })\n)\n\nexport async function firstMigratedAt(k: Knex): PromiseMaybe<Date> {\n  return thenMap(k(\"migrations\").min(\"migration_time\").first(), d =>\n    map(values(d as any)[0], ea => new Date(ea as any))\n  )\n}\n","import { Database, Statement } from \"better-sqlite3\"\nimport { randomInt } from \"crypto\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Logger, mkLogger } from \"../../core/Logger\"\nimport { isProd } from \"../../core/NodeEnv\"\nimport { gitDate } from \"../../core/Version\"\nimport { thenOrTimeout } from \"../../core/async/ThenOrTimeout\"\nimport { Schema } from \"../../core/db/Schemas\"\nimport { getDevEnvFlag } from \"../../core/env/DevEnvFlags\"\nimport { InternalErrorFlag } from \"../../core/error/ErrorFlags\"\nimport { onError } from \"../../core/error/OnError\"\nimport { WrappedError } from \"../../core/error/WrappedError\"\nimport { ee } from \"../../core/event/EventEmitter\"\nimport { BaseFile } from \"../../core/fs/BaseFile\"\nimport { withLock_ } from \"../../core/fs/FsLock\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { ProjectPath } from \"../../core/fs/ProjectPath\"\nimport { HealthCheck } from \"../../core/health/HealthCheck\"\nimport { compactBlanks, isNotEmpty } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { delay } from \"../../fe/Delay\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { lt } from \"../../fe/Primitive\"\nimport { isFunction } from \"../../fe/isFunction\"\nimport { addDbSetupError } from \"./DbSetupErrors\"\nimport { Migrations, migrationNameToDate } from \"./Migrations\"\nimport { foreignKeyCheck_ } from \"./SQLite\"\n\nconst CreateMigration = `\nCREATE TABLE IF NOT EXISTS migrations (\n  id integer NOT NULL PRIMARY KEY, \n  name varchar(255) NOT NULL, \n  migration_time integer NOT NULL \n)\n`\n\n// MAGICK NAMING CONVENTIONS:\n\n// \"_nofk\" migrations are applied with foreign keys disabled.\n\nfunction isDisabledForeignKeysMigration(migrationFile: BaseFile) {\n  return migrationFile.name.includes(\"_nofk\")\n}\n\nexport class Migration {\n  private readonly logger: Logger\n  readonly migrationsDir: PosixFile\n  constructor(\n    readonly schema: Schema,\n    readonly db: Database,\n    readonly dbFile: PosixFile\n  ) {\n    this.logger = mkLogger(\n      \"db.Migration(\" +\n        stringify({\n          schema,\n          db: dbFile.nativePath\n        }) +\n        \")\"\n    )\n    this.migrationsDir = PosixFile.for(ProjectPath.Migrations()).join(\n      this.schema\n    )\n  }\n\n  async pendingMigrationFiles_(): Promise<BaseFile[]> {\n    const inDb = this.migrationsInDatabase_()\n    const inFs = await this.fsMigrations_()\n    return inFs.filter(ea => !inDb.includes(ea.name))\n  }\n\n  readonly fsMigrations_ = lazy(() =>\n    // .children_ gives us sorted results!\n    this.migrationsDir\n      .children_(ea => ea.isFile && ea.basename.endsWith(\".sql\"))\n      .catch(error =>\n        this.logger.throw(\n          \"Failed to read migration directory, \" +\n            this.migrationsDir +\n            InternalErrorFlag,\n          { error }\n        )\n      )\n  )\n\n  readonly ensureMigrationTable_ = lazy(() => {\n    this.db.exec(CreateMigration)\n  })\n\n  migrationsInDatabase_(): string[] {\n    this.ensureMigrationTable_()\n    return this.db\n      .prepare(\"SELECT name from migrations\")\n      .pluck()\n      .all() as string[]\n  }\n\n  readonly unknownMigrations_ = lazy(() =>\n    this.migrationsInDatabase_().filter(\n      ea => !lt(migrationNameToDate(ea), gitDate)\n    )\n  )\n\n  readonly assertKnownMigrations_ = lazy(() => {\n    // If any migrations are from after this version was built, the library is\n    // from a newer version.\n    const unknownMigrations = this.unknownMigrations_()\n    if (isNotEmpty(unknownMigrations)) {\n      const err = new WrappedError(\n        \"Please upgrade PhotoStructure to a newer version to open this library: Unknown migrations: \" +\n          unknownMigrations.join(\",\")\n      )\n      onError(err)\n      throw err\n    }\n  })\n\n  async apply_(onBeforeMigrate?: (migrationFile: BaseFile) => Promise<any>) {\n    return withLock_(\n      {\n        file: this.dbFile.sibling(\"migrate\"),\n        timeoutMs: 2 * minuteMs\n      },\n      () => this.#apply(onBeforeMigrate)\n    )\n  }\n\n  async #apply(\n    onBeforeMigrate?: (migrationFile: BaseFile) => Promise<any>\n  ): Promise<string[]> {\n    try {\n      this.ensureMigrationTable_()\n\n      if (isProd) this.assertKnownMigrations_()\n\n      const appliedMigrations: string[] = []\n\n      const p = this.db.prepare(\n        \"INSERT INTO migrations (name, migration_time) VALUES (?, ?)\"\n      )\n\n      for (const migrationFile of await this.pendingMigrationFiles_()) {\n        await HealthCheck.traceLater_(\n          \"Upgrading database (\" + migrationFile.name + \")\",\n          async () => {\n            if (getDevEnvFlag(\"PS_SLOMO\")) {\n              // prove that splash is showing migrations:\n              await delay(randomInt(secondMs, 3 * secondMs))\n            }\n            await map(onBeforeMigrate, ea => ea(migrationFile))\n            await thenOrTimeout(\n              this.applyMigration_(migrationFile, p),\n              minuteMs,\n              () => {\n                throw new WrappedError(\n                  \"Migration \" + migrationFile.name + \" timed out.\",\n                  {\n                    fatal: true,\n                    ignorable: false\n                  }\n                )\n              }\n            )\n          }\n        )\n        appliedMigrations.push(migrationFile.base)\n      }\n\n      this.logger.info(\"Migration complete\", { appliedMigrations })\n      return appliedMigrations\n    } catch (cause: any) {\n      const err = new WrappedError(\n        \"Migrating the \" + this.schema + \" db failed\",\n        { cause }\n      )\n      addDbSetupError(err)\n      HealthCheck.addError(err)\n      throw err\n    }\n  }\n\n  //\n  // Migrations that name-collide with a function in the Migrations namespace\n  // assume to be a javascript-based migration, rather than a SQL migration.\n  //\n  async applyMigration_(f: BaseFile, addMigrationStmt: Statement) {\n    try {\n      const start = Date.now()\n      const m = (Migrations as any)[f.name.replace(/^[\\d_-]+/, \"\")]\n      const codeMigration = isFunction(m)\n      if (codeMigration) {\n        await m.bind(Migrations)(this.db)\n      } else {\n        await this.#applySqlMigration_(f)\n      }\n      this.logger.debug(\"applyMigration() completed\", {\n        elapsedMs: Date.now() - start,\n        codeMigration,\n        migration: f.baseWithParent\n      })\n      return addMigrationStmt.run(f.name, Date.now())\n    } catch (error) {\n      return this.logger.throw(\n        \"Failed to apply migration \" + f.baseWithParent,\n        { error }\n      )\n    } finally {\n      ee().emit(\"clearDbCache\")\n    }\n  }\n\n  async #applySqlMigration_(f: BaseFile) {\n    const disableForeignKeys = isDisabledForeignKeysMigration(f)\n    try {\n      const sql = await f.readTextFile()\n      if (blank(sql)) {\n        this.logger.error(\"Empty migration: \" + f)\n        return\n      }\n      if (disableForeignKeys) {\n        // See https://sqlite.org/lang_altertable.html\n        this.db.pragma(\"foreign_keys = OFF\")\n      }\n\n      // We don't run these inside a transaction, because SQLite doesn't respect\n      // boundaries:\n\n      // split DDL into statements to highlight what part was bad:\n      for (const ea of compactBlanks(sql.split(\";\"))) {\n        try {\n          this.db.exec(ea)\n        } catch (cause) {\n          throw new WrappedError(`Failed to apply: ${ea}`, {\n            cause,\n            fatal: true\n          })\n        }\n      }\n      if (disableForeignKeys) {\n        foreignKeyCheck_(this.db)\n      }\n    } finally {\n      if (disableForeignKeys) {\n        this.db.pragma(\"foreign_keys = ON\")\n      }\n    }\n  }\n}\n","import { Database } from \"better-sqlite3\"\nimport { batches, greatestBy } from \"../../core/Array\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { mapGt0 } from \"../../core/Number\"\nimport { escapeRegExp } from \"../../core/RegExp\"\nimport { countChars, isString } from \"../../core/String\"\nimport { toLabhash, unlabhash } from \"../../core/color/Colorspace\"\nimport { ModeBits } from \"../../core/color/ModeBits\"\nimport { ModeCount } from \"../../core/color/ModeCount\"\nimport { Triplet } from \"../../core/color/Triplet\"\nimport { datedToPrecisionMs, isoToDated } from \"../../core/date/Dated\"\nimport { isoToLocal } from \"../../core/date/Localtime\"\nimport { isoToOffsetMinutes } from \"../../core/date/Timezone\"\nimport { validYMD } from \"../../core/date/ValidDate\"\nimport { splitBits } from \"../../core/math/Bits\"\nimport { TagSep, normalizeTagPath } from \"../../core/tags/TagPaths\"\nimport { normalizeURI } from \"../../core/uri/UriNormalization\"\nimport { compact } from \"../../fe/Array\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { times, toInt } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { PS_NETWORK_FILESYSTEM_SCHEME } from \"../../fe/URI\"\nimport { toS } from \"../../fe/toS\"\nimport { dedupeTags_, mergeTags_ } from \"./DedupeTags\"\n\nconst logger = lazy(() => mkLogger(\"db.Migrations\"))\n\nconst psnetRe = new RegExp(\n  `^(${escapeRegExp(PS_NETWORK_FILESYSTEM_SCHEME)}://.*?/)(.*)$`\n)\n\n// exported for tests\nexport const lowercase_psnet_function = (s: any) =>\n  opt(s)\n    .filter(isString)\n    .flatMap(ea => psnetRe.exec(ea))\n    .map(m => m[1].toLowerCase() + m[2])\n    .getOrElse(() => s)\n\nfunction splitLabs(labModes: number, bits = ModeBits): Triplet[] {\n  return splitBits(labModes, bits).map(ea => unlabhash(ea, bits)) as Triplet[]\n}\n\nexport function plucklabmodeb6(labModes: number, index: number): Maybe<number> {\n  return mapGt0(labModes, () =>\n    map(splitLabs(labModes, 6)[index], ea => toLabhash(ea, ModeBits))\n  )\n}\n\nexport function migrationNameToDate(name: string): Maybe<Date> {\n  const [y, m, d] = [name.slice(0, 4), name.slice(4, 6), name.slice(6, 8)].map(\n    s => toInt(s)!\n  )\n  return validYMD(y, m, d) ? new Date(y, m - 1, d) : undefined\n}\n\nexport function tag_path_suffix(path: string): string {\n  return path.endsWith(TagSep) ? path : path + TagSep\n}\n\nexport function fix_root_tags(db: Database) {\n  for (const broken of db\n    .prepare(\"SELECT id, parentId, _path FROM Tag WHERE id = parentId\")\n    .iterate() as IterableIterator<{\n    id: number\n    parentId: number\n    _path: string\n  }>) {\n    logger().warn(\"fix_root_tags(): broken tag\", { broken })\n    if (countChars(broken._path, TagSep) < 2) {\n      db.prepare(\"UPDATE Tag set parentId = null where id = ?\").run(broken.id)\n    }\n  }\n}\n\nexport function isoToPrecisionMs(iso: string): number {\n  return map(isoToDated(iso), datedToPrecisionMs) ?? -1 // 0 is valid\n}\n\n/**\n * The functions exported in this namespace may be used by migrations that share\n * the same name as the function. \"Applying\" that migration will run that\n * function.\n */\nexport const Migrations = {\n  lowercase_psnet_hostname: (db: Database) => {\n    db.function(\n      \"lowercase_psnet_hostname\",\n      { deterministic: true },\n      lowercase_psnet_function\n    )\n    db.exec(\"DROP INDEX IF EXISTS assetfile_uri_udx\")\n    db.exec(\"UPDATE AssetFile SET uri = lowercase_psnet_hostname(uri)\")\n    db.exec(\"CREATE UNIQUE INDEX assetfile_uri_udx ON AssetFile(uri)\")\n  },\n\n  numeric_captured_at: (db: Database) => {\n    db.function(\"isoToLocal\", { deterministic: true }, isoToLocal as any)\n    db.function(\n      \"isoToOffsetMinutes\",\n      { deterministic: true },\n      isoToOffsetMinutes as any\n    )\n    db.function(\n      \"isoToPrecisionMs\",\n      { deterministic: true },\n      isoToPrecisionMs as any\n    )\n    db.exec(\"ALTER TABLE AssetFile ADD COLUMN capturedAtLocal bigint\")\n    db.exec(\"ALTER TABLE AssetFile ADD COLUMN capturedAtOffset integer\")\n    db.exec(\"ALTER TABLE AssetFile ADD COLUMN capturedAtPrecisionMs integer\")\n    db.exec(\"UPDATE AssetFile SET capturedAtLocal = isoToLocal(capturedAtISO)\")\n    db.exec(\n      \"UPDATE AssetFile SET capturedAtOffset = isoToOffsetMinutes(capturedAtISO)\"\n    )\n    db.exec(\n      \"UPDATE AssetFile SET capturedAtPrecisionMs = isoToPrecisionMs(capturedAtISO)\"\n    )\n    db.exec(\"DROP INDEX asset_captured_at_geohash_idx\")\n    db.exec(\"DROP INDEX assetfile_exifuid_idx\")\n    db.exec(\n      \"CREATE INDEX assetfile_capturedAtLocal_idx ON AssetFile(capturedAtLocal)\"\n    )\n  },\n\n  spread_modes: (db: Database) => {\n    db.function(\n      \"plucklabmodeb6\",\n      { deterministic: true },\n      plucklabmodeb6 as any\n    )\n\n    times(ModeCount, i =>\n      db.exec(\"ALTER TABLE AssetFile ADD COLUMN \" + `mode${i} integer`)\n    )\n    db.exec(\n      \"UPDATE AssetFile SET \" +\n        times(ModeCount, i => `mode${i} = plucklabmodeb6(mode8b6, ${i})`).join(\n          \", \"\n        )\n    )\n  },\n\n  normalize_asset_file_uris: (db: Database) => {\n    db.function(\"normalizeURI\", { deterministic: true }, normalizeURI as any)\n    const rows = db\n      .prepare(\n        \"SELECT normalizeURI(uri) AS nuri, count(*) AS cnt, GROUP_CONCAT(id) AS ids FROM AssetFile GROUP BY nuri HAVING cnt > 1\"\n      )\n      .all() as { nuri: string; cnt: number; ids: string }[]\n    const loserIds = []\n    for (const row of rows) {\n      const ids = toS(row.ids).split(\",\")\n      const afs = db\n        .prepare(\n          \"SELECT id, shown, version, updatedAt FROM AssetFile WHERE id in (\" +\n            ids.join(\",\") +\n            \")\"\n        )\n        .all() as {\n        id: number\n        shown: number\n        version: number\n        updatedAt: number\n      }[]\n      const winner = greatestBy(afs, ea => [ea.shown, ea.version, ea.updatedAt])\n      const losers = afs.filter(ea => ea.id !== winner?.id)\n      loserIds.push(...losers.map(ea => ea.id))\n    }\n    for (const ids of batches(loserIds, 256)) {\n      db.exec(\"DELETE FROM AssetFile WHERE id in (\" + ids.join(\",\") + \")\")\n    }\n    db.exec(\"UPDATE AssetFile SET uri = normalizeURI(uri)\")\n  },\n\n  dedupe_tag_paths: dedupeTags_,\n\n  suffix_tag_paths: (db: Database) => {\n    db.function(\n      \"tag_path_suffix\",\n      { deterministic: true },\n      tag_path_suffix as any\n    )\n    dedupeTags_(db)\n    db.exec(\"UPDATE Tag SET _path = tag_path_suffix(_path)\")\n  },\n\n  // fixes tags with empty interstitial paths (like `aaa//bbb/ccc/`)\n  normalize_tag_paths: (db: Database) => {\n    const badTags = db\n      .prepare(\n        \"SELECT id, _path FROM Tag WHERE _path LIKE '%' || char(31) || char(31) || '%'\"\n      )\n      .all() as { id: number; _path: string }[]\n    logger().info(\"normalize_tag_paths():\", { badTags })\n    for (const tag of badTags) {\n      const correctPath = normalizeTagPath(tag._path)\n      mergeTags_(\n        db,\n        compact([\n          tag.id,\n          ...(db\n            // handle case insensitivity with LIKE\n            .prepare(\"SELECT id FROM Tag WHERE _path LIKE ?\")\n            .pluck()\n            .all(correctPath) as number[])\n        ])\n      )\n    }\n  },\n\n  drop_tc_tables: (db: Database) => {\n    const re = /^(ct|taf|tag_counts)_[a-z\\d]{6}$/i\n    const tables = db\n      .prepare(\"SELECT name FROM sqlite_master WHERE type='table'\")\n      .pluck()\n      .all() as string[]\n    const victims = tables.filter(ea => re.exec(ea) != null)\n    logger().info(\"drop_tc_tables()\", { tables, victims })\n    for (const ea of victims) {\n      db.exec(\"DROP TABLE \" + ea)\n    }\n  },\n\n  // https://forum.photostructure.com/t/incorrectly-rotated-heic-images/34/15?u=mrm\n  rebuild_rotated_heic: (db: Database) => {\n    db.exec(\n      \"UPDATE AssetFile SET version = 0 WHERE mimetype = 'image/heif' AND rotation <> 0\"\n    )\n  },\n\n  rebuild_videos: (db: Database) => {\n    db.exec(\"UPDATE AssetFile SET version = 0 WHERE mimetype LIKE 'video/%'\")\n    db.exec(\n      \"UPDATE Asset SET version = 0 WHERE id IN (SELECT DISTINCT assetId from AssetFile where mimetype LIKE 'video/%')\"\n    )\n  },\n\n  copy_asset_duration: (db: Database) => {\n    db.exec(\"CREATE INDEX tmp_af_idx ON AssetFile (assetId, durationMs)\")\n    db.exec(\n      \"UPDATE Asset SET durationMs = (SELECT durationMs FROM AssetFile WHERE assetId = Asset.id AND durationMs IS NOT NULL LIMIT 1) WHERE durationMs IS NULL\"\n    )\n    db.exec(\"DROP INDEX tmp_af_idx\")\n\n    db.exec(\n      \"UPDATE AssetFile SET version = 0 WHERE mimetype LIKE 'video/%' and durationMs IS NULL\"\n    )\n    db.exec(\n      \"UPDATE Asset SET version = 0 WHERE id IN (SELECT DISTINCT assetId from AssetFile where version = 0)\"\n    )\n  }\n}\n","import { thenElapsed } from \"../../core/Elapsed\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { execFile, stdout_ } from \"../../core/child/ChildProcess\"\nimport { filestamp } from \"../../core/date/Filestamp\"\nimport { CheckpointType, CheckpointTypes } from \"../../core/db/CheckpointTypes\"\nimport { RepairMode, RepairModes } from \"../../core/db/RepairModes\"\nimport { sqliteFiles, sqliteSizeBytes } from \"../../core/db/SQLiteFiles\"\nimport { FatalErrorFlag } from \"../../core/error/ErrorFlags\"\nimport { WrappedError } from \"../../core/error/WrappedError\"\nimport { ellipsizePath } from \"../../core/fs/Path\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { SimpleFileOrString } from \"../../core/fs/SimpleFile\"\nimport { sqliteNativePath_ } from \"../../core/fs/Tools\"\nimport { PushProgressObserver } from \"../../core/progress/PushProgressObserver\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { commandTimeoutMs } from \"../../core/volumes/VolumeTtls\"\nimport { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { delay } from \"../../fe/Delay\"\nimport { eql } from \"../../fe/Eql\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Latch } from \"../../fe/Latch\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { thenCollect } from \"../../fe/Promise\"\nimport { isString } from \"../../fe/String\"\nimport { MiB } from \"../../fe/Units\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { modelDb } from \"../model/ModelDb\"\nimport { DbValue } from \"./DbValued\"\nimport { withDb, withDbSync } from \"./WithDb\"\nimport bs = require(\"better-sqlite3\")\n\nconst logger = lazy(() => mkLogger(\"db.SQLite\"))\n\n/**\n * Feed the given commands to the sqlite binary tool\n */\nexport async function sqlite({\n  dbFile,\n  sql,\n  args\n}: {\n  dbFile: PosixFile\n  sql: string\n  args?: string[]\n}): Promise<string> {\n  const path = await sqliteNativePath_()\n  const r = await thenElapsed(\n    // backups can take a while (hopefully never longer than a minute!)\n    stdout_(path, [...toA(args), dbFile.nativePath, sql], {\n      timeoutMs: 1 * minuteMs\n    })\n  )\n  logger().debug(\n    \"sqlite(\" + sql + \") on \" + dbFile + \" in \" + r.elapsedMs + \"ms\",\n    r.result\n  )\n  return r.result\n}\n\nexport function backupDbFile_(srcDbFile: PosixFile, destDb: PosixFile) {\n  return retryOnReject(() => _backupDbFile_(srcDbFile, destDb), {\n    maxRetries: 3,\n    retryDelay: secondMs,\n    timeoutMs: minuteMs,\n    errorIsRetriable: () => true\n  })\n}\n\nasync function _backupDbFile_(srcDbFile: PosixFile, destDb: PosixFile) {\n  try {\n    await destDb.parent().mkdirp_()\n    await destDb.unlink(\"trace\")\n    const bytes = await srcDbFile.size()\n    if (!gt0(bytes)) {\n      logger().warn(\"backupDbFile_(): \" + srcDbFile + \" is empty\")\n      return\n    }\n    await modelDb()?.end()\n    await withDb(\n      srcDbFile,\n      async db => db.exec(\"VACUUM INTO \" + escStr(destDb.nativePath)),\n      2 * minuteMs\n    )\n    logger().info(\"backupDbFile_(): Finished \" + srcDbFile + \" -> \" + destDb)\n  } catch (cause) {\n    throw new WrappedError(`Could not back up db ${srcDbFile} -> ${destDb}`, {\n      cause\n    })\n  }\n}\n\nfunction pragmaOrThrow_({\n  db,\n  pragma,\n  okResult\n}: {\n  db: bs.Database\n  pragma: string\n  okResult: any\n}): void {\n  const result = isString(okResult)\n    ? db.pragma(pragma, { simple: true })\n    : db.pragma(pragma)\n  if (!eql(result, okResult)) {\n    throw new Error(\n      `${pragma} failed for ${dbToPath(db)}: ${stringify(result)}`\n    )\n  }\n}\n\nfunction dbToPath(db: bs.Database): string {\n  return ellipsizePath({ p: db.name, maxLength: 80 })\n}\n\nexport function quickCheck_(db: bs.Database): void {\n  return pragmaOrThrow_({ db, pragma: \"quick_check\", okResult: \"ok\" })\n}\n\nexport function integrityCheck_(db: bs.Database): void {\n  return pragmaOrThrow_({ db, pragma: \"integrity_check\", okResult: \"ok\" })\n}\n\nexport function foreignKeyCheck_(db: bs.Database): void {\n  const badRows = toA(db.pragma(\"foreign_key_check\")) as {\n    table: string\n    rowid: number\n  }[]\n\n  if (badRows.length > Settings.dbInvalidFKThreshold.valueOrDefault) {\n    logger().throw(\n      \"foreignKeyCheck_(): too many invalid foreign keys to repair\",\n      {\n        dbInvalidForeignKeyThreshold:\n          Settings.dbInvalidFKThreshold.valueOrDefault,\n        badRowsCount: badRows.length,\n        badRows\n      }\n    )\n  }\n  for (const row of badRows) {\n    logger().warn(\"repairDbFile_(): deleting row with invalid foreign key\", {\n      row\n    })\n    db.prepare(`DELETE FROM ${escStr(row.table)} WHERE rowid = ?`).run(\n      row.rowid\n    )\n  }\n}\n\nexport function verifyDb_(db: bs.Database) {\n  quickCheck_(db)\n  integrityCheck_(db)\n  foreignKeyCheck_(db)\n}\n\n/**\n * @throw if the db is not valid\n */\nexport function verifyDbFile_(dbFile: PosixFile | string) {\n  return withDbSync(dbFile, verifyDb_, commandTimeoutMs())\n}\n\ntype CheckpointResult = { busy: number; log: number; checkpointed: number }\n\n/**\n * @see https://sqlite.org/pragma.html#pragma_wal_checkpoint\n *\n */\nexport async function checkpoint_({\n  db,\n  retries = 3,\n  checkpointType = Settings.dbWalCheckpointType.valueOrDefault as CheckpointType\n}: {\n  db: bs.Database\n  retries?: number\n  checkpointType?: CheckpointType\n}): PromiseMaybe<CheckpointResult> {\n  checkpointType = CheckpointTypes.validOrElse(\n    checkpointType,\n    CheckpointTypes.AUTO\n  )\n  if (checkpointType === CheckpointTypes.AUTO) return\n  const pragma = \"wal_checkpoint(\" + checkpointType + \")\"\n  const [result] = toA(db.pragma(pragma)) as CheckpointResult[]\n  logger().info(\"checkpoint()\", { pragma, result })\n  if (gt0(result?.busy) && retries > 0) {\n    await delay(250) // let things settle down?\n    return checkpoint_({ db, retries: retries - 1 })\n  } else {\n    return result\n  }\n}\n\nconst IgnorableDumpErrorRe = /no such table: sqlite_\\w+/i\n\n/**\n * Dump and restore to srcDb-new, then move src to ./invalid/, and rename the\n * new db to srcDb.\n *\n * The final db will have passed verification.\n *\n * @return where srcDb was moved to\n */\nexport async function repairDbFile_(\n  srcDbPath: SimpleFileOrString,\n  op: RepairMode = RepairModes.dump\n): Promise<PosixFile> {\n  const srcDbFile = PosixFile.for(srcDbPath)\n  const destDir = await srcDbFile\n    .parent()\n    .join(\"db-\" + op, filestamp())\n    .mkdirp_()\n  const destDbFile = destDir.join(srcDbFile.base)\n  logger().info(`repairDbFile_(${srcDbFile} -> ${destDbFile})`)\n  try {\n    const cmd = await sqliteNativePath_()\n    // SQL dumps are written as SQL INSERTs, which are < 2x the size of the\n    // db. 4x is certainly sufficient.\n    const maxBuffer = Math.min(20 * MiB, await sqliteSizeBytes(srcDbFile)) * 4\n    const obs = new PushProgressObserver(\n      { path: toS(srcDbFile), op: \"Repairing your database\" },\n      maxBuffer\n    )\n    const l = new Latch()\n\n    const dumpProc = execFile(\n      cmd,\n      [srcDbFile.nativePath, \".\" + op],\n      5 * minuteMs,\n      {\n        encoding: \"buffer\",\n        maxBuffer\n      }\n    )\n    dumpProc.stdout!.on(\"error\", cause => {\n      const err = toS(cause)\n      if (IgnorableDumpErrorRe.test(err)) {\n        logger().info(\"repairDbFile_(): ignoring stderr\", { err })\n      } else {\n        void l.reject(new Error(\"sqlite \" + op + \" failed: \" + err))\n      }\n    })\n    const load = execFile(cmd, [destDbFile.nativePath], 5 * minuteMs, {\n      encoding: \"buffer\",\n      maxBuffer\n    })\n    load.on(\"exit\", () => l.resolve())\n    dumpProc.stdout!.on(\"end\", () => {\n      load.stdin!.end(null)\n    })\n    dumpProc.stdout!.on(\"data\", buf => {\n      const len = (buf as string | Buffer).length\n      logger().info(\"repairDbFile_(): dump\", { len })\n      obs.incrProgress(len)\n      load.stdin!.write(buf)\n    })\n\n    await l\n    logger().info(`repairDbFile_(): recovered to ${destDbFile}.`)\n\n    verifyDbFile_(destDbFile)\n\n    logger().info(`repairDbFile_(): ${destDbFile} is valid, finishing repair.`)\n    const result = await thenCollect(sqliteFiles(srcDbFile), ea =>\n      ea.renameYMDHMS_({ subdir: \"needed-repair\" })\n    )\n    await thenCollect(sqliteFiles(destDbFile), ea => ea.mv_(srcDbFile.parent()))\n\n    return result.find(ea => ea.ext === \".db\" || ea.ext.startsWith(\".sqlite\"))!\n  } catch (error) {\n    return logger().throw(\n      \"failed to recover DB via dump and restore. Please see https://photostructure.com/faq/restore-db-from-backup/ \" +\n        FatalErrorFlag,\n      { error }\n    )\n  }\n}\n\nexport function escStr(s: DbValue): string {\n  return `'${toS(s).replace(/'/g, \"''\")}'`\n}\n","import { Knex } from \"knex\"\nimport { zip } from \"../../core/Array\"\nimport { escapeRegExp } from \"../../core/RegExp\"\nimport { isString } from \"../../core/String\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { stringify } from \"../../fe/JSON\"\nimport { keys, omit } from \"../../fe/Object\"\nimport { isFunction } from \"../../fe/isFunction\"\nimport { toS } from \"../../fe/toS\"\nimport { DbValued, isDbValued } from \"./DbValued\"\n\nexport function isSqlQuery(obj: any): obj is SqlQuery {\n  return (\n    obj != null &&\n    isString(obj.sql) &&\n    (obj.bindings == null || isDbValued(obj.bindings))\n  )\n}\n\nexport interface SqlQuery {\n  sql: string\n  bindings?: Knex.Value[] | DbValued\n  method?: \"select\" | \"raw\"\n}\n\nexport type Queryish = string | Knex.QueryBuilder | SqlQuery | Knex.Raw\n\nexport function toSqlQuery(sql: Queryish): SqlQuery {\n  if (sql == null) throw new Error(\"null sql\")\n  if (isSqlQuery(sql)) return sql\n  if (isString(sql)) {\n    return { sql }\n  } else if (isFunction(sql[\"toSQL\"])) {\n    return omit(sql.toSQL() as any, \"__knexQueryUid\") as any as SqlQuery\n  } else {\n    throw new Error(\"not queryish: \" + stringify(sql))\n  }\n}\n\nexport function sqlQueryToS(sq: SqlQuery) {\n  if (sq.bindings == null) return sq.sql\n  else if (Array.isArray(sq.bindings)) {\n    return (\n      flatten(\n        zip(\n          sq.sql.split(\"?\"),\n          sq.bindings.map(ea => stringify(ea))\n        )\n      )\n        // .map(ea => ea.trim())\n        .join(\"\")\n    )\n  } else {\n    let result = sq.sql\n    for (const key of keys(sq.bindings)) {\n      result = result.replace(\n        new RegExp(\"[@:$]\" + escapeRegExp(key), \"gi\"),\n        toS(sq.bindings[key])\n      )\n    }\n    return result\n  }\n}\n\nexport function isQueryBuilder(q: Queryish): q is Knex.QueryBuilder {\n  return isFunction((q as any)?.where) && isFunction((q as any)?.limit)\n}\n\n/**\n * Assume a \"heredoc\" with 1 or more queries.\n *\n * - Comment lines that start with `--` will be removed\n * - Individual queries are separated by a semicolon at the end of a line\n * - Whitespace is normalized to a single space.\n * - Empty lines are filtered out\n */\nexport function prepQueries(s: string) {\n  return s\n    .replace(/\\s*--.*\\n/g, \"\")\n    .split(\";\")\n    .map(q => q.replace(/\\s+/g, \" \").trim())\n    .filter(notBlank)\n}\n","import { Database } from \"better-sqlite3\"\nimport { blank } from \"../../fe/Blank\"\nimport { MultiMap } from \"../../fe/MultiMap\"\n\nexport interface TableInfo {\n  readonly tableName: string\n  readonly columns: ColumnInfo[]\n}\n\nexport interface ColumnInfo {\n  readonly name: string\n  readonly type: string\n  readonly notnull: boolean\n  readonly pk: boolean\n}\n\nexport function parseTableInfo(\n  arr: {\n    tableName: string\n    name: string\n    type: string\n    notnull: number\n    pk: number\n  }[]\n): TableInfo[] {\n  const mm = new MultiMap<string, ColumnInfo>()\n  for (const row of arr) {\n    if (\n      !row.tableName.includes(\"fts\") &&\n      !row.tableName.includes(\"sqlite_\") &&\n      !blank(row.name) &&\n      !blank(row.type)\n    ) {\n      mm.add(row.tableName, {\n        name: row.name,\n        type: row.type.toUpperCase().trim().replace(/\\s+/g, \"\"),\n        notnull: row.notnull === 1,\n        pk: row.pk === 1\n      })\n    }\n  }\n  return mm\n    .entriesArray()\n    .map(([tableName, columns]) => ({ tableName, columns }))\n}\n\nconst sql = `SELECT \nm.tbl_name as tableName,\np.*\nFROM sqlite_master AS m\nJOIN pragma_table_info(m.name) AS p\nORDER BY m.tbl_name, p.cid`\n\nexport function localTableInfo(db: Database): TableInfo[] {\n  return parseTableInfo(db.prepare(sql).all() as any[])\n}\n","import { Database } from \"better-sqlite3\"\nimport { mkdb_ } from \"../../core/db/MkDb\"\nimport { BaseFile } from \"../../core/fs/BaseFile\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { toS } from \"../../fe/toS\"\n\n/**\n * Should only be used by tests\n */\nexport function withDbSync<T>(\n  dbfile: BaseFile | string,\n  f: (db: Database) => T,\n  timeoutMs = Settings.dbBusyTimeoutMs.valueOrDefault\n): T {\n  const d = mkdb_({ nativePath: toS(dbfile), timeoutMs })\n  try {\n    return f(d)\n  } finally {\n    d.close()\n  }\n}\n\n/**\n * Should only be used by tests\n */\nexport async function withDb<T>(\n  dbfile: BaseFile | string,\n  f: (db: Database) => Promise<T>,\n  timeoutMs = Settings.dbBusyTimeoutMs.valueOrDefault\n): Promise<T> {\n  const d = mkdb_({ nativePath: toS(dbfile), timeoutMs })\n  try {\n    return await f(d)\n  } finally {\n    d.close()\n  }\n}\n","import { getDevEnvFlag } from \"../../core/env/DevEnvFlags\"\nimport { errorToS } from \"../../core/error/Error\"\nimport { HealthCheck } from \"../../core/health/HealthCheck\"\nimport { libraryHasSettings } from \"../../core/settings/SettingsIO\"\nimport { li, tt } from \"../../fe/BabyMarkdown\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { defer } from \"../../fe/Defer\"\nimport { Link } from \"../../fe/HealthChecks\"\nimport { Library } from \"../Library\"\nimport { Db } from \"../db/Db\"\nimport { assertValidDbSchema_ } from \"../db/DbSchemaValid\"\nimport {\n  addDbSetupErrorListener,\n  clearDbSetupErrors,\n  dbSetupErrors,\n  hasDbSetupErrors\n} from \"../db/DbSetupErrors\"\nimport { Heartbeat } from \"../model/Heartbeat\"\n\nconst dbRepairLink: Link = {\n  text: \"Attempt database repair\",\n  title: \"Run a dump and reload of your library database to try to repair it\",\n  type: \"button\",\n  method: \"POST\",\n  url: \"/admin/repair-db\",\n  icon: \"database\"\n}\n\nexport const dbModelHealthCheck = defer(() => {\n  const result = HealthCheck.for({\n    section: \"Library\",\n    id: \"library-db\",\n    ordinal: 1,\n    pendingMsg: \"Checking library database…\",\n    settings: [\"libraryDir\", \"forceLocalDbReplica\"],\n    ttlMs: minuteMs,\n    onReset: () => clearDbSetupErrors({ notifyListeners: false }),\n    links: [\n      {\n        text: \"Read about PhotoStructure and SQLite\",\n        icon: \"docs\",\n        url: \"https://forum.photostructure.com/t/whats-ps-force-local-db-replica/837\"\n      }\n    ],\n    later: async () => {\n      if (!libraryHasSettings()) {\n        return {\n          level: \"disabled\",\n          msg: [`Library database tests disabled: no library is open`]\n        }\n      }\n      let tryRepair = false\n      let db: Db | undefined\n      let l: Library | undefined\n      try {\n        const start = Date.now()\n\n        // if we can't open the library, we can't repair it.\n        tryRepair = false\n        l = Library.instanceRequired()\n        // if we can't open db , we can't repair it.\n        // const priorError = unrepairableLibraryDirs.get(j.db.dbFile.nativePath)\n        // if (priorError != null) {\n        //   return mkLibraryErrorResult({\n        //     libraryDir: l.rootDir.nativePath,\n        //     errorMsg: errorToHumanString(priorError),\n        //     error: priorError\n        //     // NO REPAIR\n        //   })\n        // }\n        if (hasDbSetupErrors()) {\n          return {\n            level: \"error\",\n            msg: [\n              \"Something is wrong with your library database.\",\n              li(dbSetupErrors())\n            ],\n            links: [dbRepairLink]\n          }\n        }\n        await l.ready\n        // This won't resolve until _after_ migration (whose errors we can't recover from)\n        db = await l.modelDb()\n\n        if (getDevEnvFlag(\"PS_FAIL_DB_HEALTH_CHECK\")) {\n          throw new Error(\"PS_FAIL_DB_HEALTH_CHECK\")\n        }\n\n        // if the schema is missing tables or columns, shit's gone real bad,\n        // yo. Don't attempt repair.\n        await assertValidDbSchema_(db)\n\n        // OK, so if db verify fails, or ping fails, _maybe_ verify will fix it?\n        tryRepair = true\n        db.verify_()\n\n        await db.vacuum()\n\n        Heartbeat.assertPing_()\n\n        const info = await l.dbModelSetup_()\n\n        return {\n          level: \"ok\",\n          msg: [\n            \"Library database is OK\",\n            li([\n              \"Schema validation, vacuum, optimize, and upsert round-trip took \" +\n                (Date.now() - start) +\n                \"ms\",\n              \"Live db is \" + tt(db.dbFile.nativePath),\n              \"Local replica mode is \" + tt(info.useReplica),\n              info.useReplica\n                ? \"Cold library db is \" + tt(info.libraryDbFile)\n                : undefined\n            ])\n          ]\n        }\n      } catch (error: any) {\n        return {\n          level: \"error\",\n          msg: [\n            \"Library database validation failed\",\n            (tryRepair ? \"\" : \"Unrecoverable: \") + errorToS(error),\n            db == null ? undefined : \"Live db is \" + tt(db.dbFile.nativePath),\n            l == null\n              ? undefined\n              : \"Local replica mode is \" + tt(await l.useReplica())\n          ],\n          links: tryRepair ? [dbRepairLink] : undefined\n        }\n      }\n    }\n  })\n  addDbSetupErrorListener(() => result.refresh())\n  return result\n})\n","import { lazy } from \"../../core/Lazy\"\nimport { healthCheckSetup } from \"../../core/health/HealthCheckSetup\"\nimport { readSettings } from \"../../core/settings/SettingsIO\"\nimport { dbModelHealthCheck } from \"./DbModelHealthCheck\"\nimport { syncHealthCheck } from \"./SyncHealthCheck\"\nimport { volumeUuidHealthCheck } from \"./VolumeUuidHealthCheck\"\n\nexport const libraryHealthCheckSetup = lazy(async () => {\n  await readSettings()\n  healthCheckSetup()\n  syncHealthCheck()\n  dbModelHealthCheck()\n  volumeUuidHealthCheck()\n})\n","import { findAsync } from \"../../core/Array\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { acceptParentAndFileAndSimple } from \"../../core/fs/PosixFileFilters\"\nimport { HealthCheck } from \"../../core/health/HealthCheck\"\nimport { libraryHasSettings } from \"../../core/settings/SettingsIO\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { li, tt } from \"../../fe/BabyMarkdown\"\nimport { defer } from \"../../fe/Defer\"\nimport { pathsToSync } from \"../sync/PathsToSync\"\n\nconst logger = defer(() => mkLogger(\"health.SyncHealthCheck\"))\n\nexport const syncHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"Library\",\n    id: \"library-nothing-to-sync\",\n    ordinal: 99,\n    rejectIsWarn: true,\n    settings: [\n      \"scanAllDrives\",\n      \"scanPaths\",\n      \"scanLibraryFirst\",\n      \"scanLibraryLast\"\n    ],\n    pendingMsg: \"Checking synced directories…\",\n    later: async () => {\n      if (!libraryHasSettings()) {\n        return {\n          level: \"disabled\",\n          msg: \"Library sync paths test disabled: no library is open\"\n        }\n      }\n      const paths = (await pathsToSync()).map(ea => ea.nativePath)\n      if (isEmpty(paths)) {\n        return {\n          level: \"warn\",\n          msg:\n            \"No paths are configured to scan\\n\" +\n            li([\n              tt(\"PS_SCAN_ALL_DRIVES\") + \" is false\",\n              tt(\"PS_SCAN_PATHS\") + \" is empty\",\n              \"both \" +\n                tt(\"PS_SCAN_LIBRARY_FIRST\") +\n                \" and \" +\n                tt(\"PS_SCAN_LIBRARY_LAST\") +\n                \" are false\"\n            ]),\n          links: [\n            {\n              text: \"Read more\",\n              url: \"https://photostructure.com/go/nothing-to-scan\"\n            }\n          ]\n        }\n      } else {\n        // We could run a quick DirectoryIterator here to see if any of the\n        // paths are empty, but let's just complain if no files or directories\n        // are found in _any_ scanned paths.\n\n        const posixFiles = paths.map(ea => PosixFile.for(ea))\n        logger().info(\"Checking if any paths are empty\", { posixFiles })\n        const firstNonEmpty = await findAsync(\n          posixFiles,\n          async dir =>\n            null !=\n            (await dir.someDescendant(\n              ea => ea.isDirectorySync() || acceptParentAndFileAndSimple(ea),\n              1\n            ))\n        )\n\n        if (firstNonEmpty == null) {\n          return {\n            level: \"warn\",\n            msg: [\n              \"No eligible files found in scanned paths\",\n              \"Checked paths:\",\n              li(paths.map(tt))\n            ],\n            links: [\n              {\n                text: \"Read more\",\n                url: \"https://photostructure.com/go/nothing-to-scan\"\n              }\n            ]\n          }\n        }\n\n        return {\n          level: \"ok\",\n          msg: [\n            \"At least one directory with eligible files is configured to be synced\",\n            \"Checked paths:\",\n            li(paths.map(tt))\n          ]\n        }\n      }\n    }\n  })\n)\n","import { mkLogger } from \"../../core/Logger\"\nimport { mapAsyncSerial } from \"../../core/async/Promise\"\nimport { HealthCheck } from \"../../core/health/HealthCheck\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { libraryHasSettings } from \"../../core/settings/SettingsIO\"\nimport { volsha } from \"../../core/uri/volsha\"\nimport { Volume } from \"../../core/volumes/Volume\"\nimport { commandTimeoutMs } from \"../../core/volumes/VolumeTtls\"\nimport { volumeUuidNotExpected } from \"../../core/volumes/VolumeUUID\"\nimport { bestVolumeForPath, volumes } from \"../../core/volumes/Volumes\"\nimport { compactBlanks, isEmpty, uniqBy } from \"../../fe/Array\"\nimport { li, tt } from \"../../fe/BabyMarkdown\"\nimport { defer } from \"../../fe/Defer\"\nimport { andList } from \"../../fe/FmtList\"\nimport { groupBy } from \"../../fe/MultiMap\"\nimport { pick } from \"../../fe/Object\"\nimport { scanPaths } from \"../sync/PathsToSync\"\n\nconst logger = defer(() => mkLogger(\"health.VolumeUUIDHealthCheck\"))\n\nexport const volumeUuidHealthCheck = defer(() =>\n  HealthCheck.for({\n    section: \"Library\",\n    id: \"volume-uuids\",\n    pendingMsg: \"Checking volumes…\",\n    settings: [\"scanAllDrives\"],\n    rejectIsWarn: true,\n    links: [\n      {\n        text: `What's a “volume”?`,\n        url: \"https://photostructure.com/faq/what-is-a-volume/\",\n        icon: \"docs\"\n      }\n    ],\n    later: async () => {\n      // If we don't have a library open right now, short-circuit.\n      if (!libraryHasSettings()) {\n        return {\n          level: \"disabled\",\n          msg: `Volume UUID test disabled: no library is open`\n        }\n      }\n\n      const vols: Volume[] = []\n      const noUriPaths: string[] = []\n      if (Settings.scanAllDrives.valueOrDefault) {\n        vols.push(...(await volumes()))\n      } else {\n        const obj = await scanPaths()\n        const arr = await mapAsyncSerial({\n          name: \"scannedVolumes\",\n          arr: obj.result.map(ea => ea.nativePath),\n          f: path => bestVolumeForPath(path),\n          timeoutMs: commandTimeoutMs()\n        })\n        vols.push(...uniqBy(arr, ea => ea.mountpoint))\n        noUriPaths.push(...obj.noUriPaths)\n      }\n\n      const duplicateUUIDVolumes = [\n        ...groupBy(vols, ea => ea.uuid).values()\n      ].filter(ea => ea.length > 1)\n\n      // We only care about uuids for scanned directories.\n      const missingUUIDs = vols\n        .filter(ea => ea.uuid == null && !volumeUuidNotExpected(ea))\n        .map(ea => ea.mountpoint)\n\n      const unhealthyVolumes = (await volumes())\n        .filter(ea => ea.ok === false)\n        .map(ea => compactBlanks([ea.mountpoint, ea.status]).join(\": \"))\n\n      logger().debug(\"volumeHealthCheck result\", {\n        missingUUIDs,\n        noUriPaths,\n        unhealthyVolumes,\n        scannedVolumes: vols.map(ea => pick(ea, \"uuid\", \"mountpoint\"))\n      })\n\n      if (\n        isEmpty(missingUUIDs) &&\n        isEmpty(duplicateUUIDVolumes) &&\n        isEmpty(noUriPaths) &&\n        isEmpty(unhealthyVolumes)\n      ) {\n        if (isEmpty(vols)) {\n          return {\n            msg: [\n              \"No volumes need UUIDs\",\n              tt(Settings.scanAllDrives.key) +\n                \" is false, and no volumes other than the library are configured to be scanned.\"\n            ],\n            level: \"ok\"\n          }\n        } else {\n          return {\n            msg: [\n              `All scanned volume UUIDs are OK`,\n              li(vols.map(ea => tt(volsha(ea.uuid) + \" ⮕ \" + ea.mountpoint)))\n            ],\n            level: \"ok\"\n          }\n        }\n      } else {\n        const msg: string[] = []\n        if (!isEmpty(unhealthyVolumes)) {\n          msg.push(\n            \"Some volumes are unhealthy\",\n            li(unhealthyVolumes.map(ea => tt(ea))) +\n              \"PhotoStructure may crash or hang when accessing unhealthy volumes.\"\n          )\n        }\n        if (!isEmpty(missingUUIDs)) {\n          msg.push(\n            \"Some volumes are missing UUIDs\",\n            li(missingUUIDs.map(ea => tt(ea))),\n            \"This can cause problems with deduplication and library portability.\"\n          )\n        }\n        if (!isEmpty(duplicateUUIDVolumes)) {\n          msg.push(\n            \"Some volumes have duplicate UUIDs\",\n            duplicateUUIDVolumes\n              .map(arr =>\n                li(\n                  andList(arr.map(ea => tt(ea.mountpoint))) +\n                    \" share UUID \" +\n                    tt(arr[0].uuid)\n                )\n              )\n              .join(\"\\n---\\n\"),\n            \"This can cause problems with deduplication and library portability.\"\n          )\n        }\n        if (!isEmpty(noUriPaths)) {\n          msg.push(\n            \"Some paths failed to have URIs generated\",\n            li(noUriPaths.map(ea => tt(ea))),\n            \"This will prevent these paths from being imported.\"\n          )\n        }\n        return {\n          level: \"warn\",\n          msg: msg.join(\"\\n---\\n\"),\n          links: [\n            {\n              text: \"How to manually add a UUID\",\n              icon: \"handyman\",\n              url: \"https://photostructure.com/faq/what-is-a-volume/#add-uuid\"\n            },\n            {\n              text: \"Rescan volumes\",\n              type: \"button\",\n              method: \"POST\",\n              url: \"/admin/clear-caches\",\n              icon: \"refresh\"\n            }\n          ]\n        }\n      }\n    }\n  })\n)\n","import { Knex } from \"knex\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { identity } from \"../../core/Object\"\nimport { AssetVersion } from \"../../core/PhotoStructureVersions\"\nimport { filterAsync, thenMap } from \"../../core/async/Promise\"\nimport { fmtLocalDateShort, localToDateObject } from \"../../core/date/Localtime\"\nimport { InternalErrorFlag } from \"../../core/error/ErrorFlags\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { trashOrUnlinkFileUris_ } from \"../../core/fs/Unlink\"\nimport { Previews } from \"../../core/img/Previews\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { CapturedAt } from \"../../core/tags/CapturedAt\"\nimport { readTags } from \"../../core/tags/ExifTool\"\nimport { ExifTagsWithSource, MergedTags } from \"../../core/tags/MergedTags\"\nimport { joinTagPath } from \"../../core/tags/TagPaths\"\nimport {\n  compact,\n  filterInPlace,\n  isEmpty,\n  isNotEmpty,\n  uniqBy\n} from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { assetSqImgAttrs, assetVideoLink } from \"../../fe/AssetUrls\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { ReducerName, ReducerNames } from \"../../fe/ImageReducers\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe, MaybePromiseMaybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0, gte } from \"../../fe/Number\"\nimport { StrBoolValued, StringValued, pick } from \"../../fe/Object\"\nimport { thenCollect } from \"../../fe/Promise\"\nimport { MaybeSyncOrAsync, SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { AssetId } from \"../../fe/api/Asset\"\nimport { ApiTag, TagPath } from \"../../fe/api/Tag\"\nimport { toA } from \"../../fe/toA\"\nimport { Library } from \"../Library\"\nimport { dateTag } from \"../curators/DateTagger\"\nimport { AssetFile } from \"./AssetFile\"\nimport { toAssetId } from \"./AssetId\"\nimport { AssetRevision } from \"./AssetRevision\"\nimport { AssetTag } from \"./AssetTag\"\nimport { upsertToShaBlockslist } from \"./ShaBlocklist\"\nimport { Tag } from \"./Tag\"\nimport { TaggedAssetStream, coalesceStreams } from \"./TaggedAssetStream\"\nimport { TimestampedModel } from \"./TimestampedModel\"\n\nexport interface AssetTagsParams {\n  assetId: number\n  tagPaths: TagPath[]\n}\n\nexport type RemovableColumn = \"deletedAt\" | \"excludedAt\"\n\nconst logger = lazy(() => mkLogger(\"model.Asset\"))\n\nconst Unhidden = {\n  \"Asset.shown\": 1,\n  \"Asset.hidden\": 0,\n  \"Asset.excludedAt\": null,\n  \"Asset.deletedAt\": null\n} as const\n\nexport class Asset extends TimestampedModel {\n  static override readonly $tableName = \"Asset\"\n  static override readonly $uniqueColumnName = \"id\"\n  static override readonly $booleanFields = [\"shown\", \"hidden\"]\n\n  capturedAtLocal!: number\n  // shown is set by sync, and is false during import or if all files are\n  // missing. It should be renamed to something like \"ready\":\n  shown?: boolean\n  rating?: number | null // [-1, 5]\n  // hidden is set by the user\n  hidden?: boolean\n  excludedAt?: number | null\n  deletedAt?: number | null\n\n  /** de-normalized from the shown assetfile */\n  durationMs?: number\n\n  /** This is the value of the AssetVersion constant at time of last sync. */\n  version?: number\n\n  /** This monotonically increases every time the primary asset file updates. */\n  updateCount?: number\n\n  // TODO: ADD so we don't have to hit json files at serving time:\n  // fitWidths: number[]\n  // sqWidths: number[]\n\n  assetFiles?: AssetFile[]\n  tags?: Tag[]\n\n  // For UI use (transient/not persisted):\n  streams?: TaggedAssetStream[]\n  attrs = {}\n  afterId?: AssetId\n  beforeId?: AssetId\n\n  readonly assetIdish = lazy(() => ({\n    assetId: this.id!,\n    v: this.updateCount,\n    capturedAtLocal: this.capturedAtLocal\n  }))\n  imgAttrs?: Map<ReducerName, StringValued>\n  /**\n   * The \"poster\" image for a video assets\n   */\n  poster?: string\n\n  static shownUnhidden(qb?: Knex.QueryBuilder): Knex.QueryBuilder {\n    return qb == null ? Asset.query().where(Unhidden) : qb.andWhere(Unhidden)\n  }\n\n  static findUnhiddenById(id: Maybe<number>) {\n    return gt0(id)\n      ? Asset.ops().firstf(qb => Asset.shownUnhidden(qb.where({ id })))\n      : undefined\n  }\n\n  static shownRemovable(\n    col: RemovableColumn,\n    qb?: Knex.QueryBuilder\n  ): Knex.QueryBuilder {\n    return (qb ?? Asset.query())\n      .whereNotNull(col)\n      .andWhere({ \"Asset.shown\": 1 })\n  }\n\n  // CAREFUL: if this is cached, be sure to invalidate regularly or else the\n  // \"library is empty\" message will show to first-time users.\n  static shownCount() {\n    return Asset.ops().count(Asset.shownUnhidden().countDistinct(\"Asset.id\"))\n  }\n\n  static #outdatedQuery() {\n    return Asset.shownUnhidden().andWhere(\"version\", \"<\", AssetVersion)\n  }\n\n  static deletePreviews(assetId: number) {\n    return Library.instance()!.previews().ap(assetId).deleteAll()\n  }\n\n  static async remove({\n    assetId,\n    blocklistShas,\n    unlinkAssetFiles\n  }: {\n    assetId: number\n    blocklistShas: boolean\n    unlinkAssetFiles: boolean\n  }) {\n    const l = mkLogger(\"Asset(\" + assetId + \").remove()\")\n    l.info(\"starting\", { blocklistShas, unlinkAssetFiles })\n    const afs = AssetFile.dbl.allf(q =>\n      q.select(\"sha\", \"uri\", \"mountpoint\").where({ assetId })\n    ) as Pick<AssetFile, \"sha\" | \"uri\" | \"mountpoint\">[]\n    if (blocklistShas) {\n      upsertToShaBlockslist(...afs.map(ea => ea.sha))\n    }\n    AssetTag.dbl.runf(q => q.delete().where({ assetId }))\n    AssetFile.dbl.runf(q => q.delete().where({ assetId }))\n    AssetRevision.dbl.runf(q => q.delete().where({ assetId }))\n    Asset.dbl.runf(q => q.delete().where({ id: assetId }))\n    try {\n      await Asset.deletePreviews(assetId)\n    } catch (error) {\n      l.error(\"Failed to delete previews\", {\n        error\n      })\n    }\n    const deletedMeta = unlinkAssetFiles\n      ? await trashOrUnlinkFileUris_(afs)\n      : []\n\n    return { deletedMeta, assetFileMeta: afs }\n  }\n\n  static async exclude(assetId: number) {\n    logger().info(\"Excluding asset \" + assetId)\n    return {\n      dbResult: Asset.dbl.runf(q =>\n        q.update({ excludedAt: Date.now() }).where({ id: assetId })\n      ),\n      deletedPreviews: await Asset.deletePreviews(assetId)\n    }\n  }\n\n  static nextOutdated(\n    q: (qb: Knex.QueryBuilder) => Knex.QueryBuilder = identity\n  ) {\n    return this.ops().findOne(q(this.#outdatedQuery()))\n  }\n\n  static nextOutdateds(q: (qb: Knex.QueryBuilder) => Knex.QueryBuilder) {\n    return this.ops().all(q(this.#outdatedQuery()))\n  }\n\n  static outdatedCount(\n    q: (qb: Knex.QueryBuilder) => Knex.QueryBuilder = identity\n  ) {\n    return this.dbl.pluckFirst<number>(q(this.#outdatedQuery()).count())\n  }\n\n  static findFirstByFile(f: (qb: Knex.QueryBuilder) => Knex.QueryBuilder) {\n    return this.ops().findOne(\n      f(\n        this.query()\n          .select(\"Asset.*\")\n          .join(\"AssetFile\", \"AssetFile.assetId\", \"Asset.id\")\n      )\n    )\n  }\n\n  static addTags(assetId: number, tagPaths: TagPath[]) {\n    const uniqTagPaths = uniqBy(tagPaths.filter(isNotEmpty), t =>\n      joinTagPath(t)\n    )\n    logger().debug(\"addTags()\", { assetId, tagPaths, uniqTagPaths })\n    if (isEmpty(uniqTagPaths)) return\n    const tags = uniqTagPaths.map(tp => Tag.findOrCreate(tp))\n    const tagIds = tags.map(ea => ea.id!)\n    return AssetTag.addTagsToAsset(assetId, tagIds)\n  }\n\n  static removeTags(assetId: number, tagPaths: TagPath[]) {\n    if (isEmpty(tagPaths)) return\n    const tags = compact(tagPaths.map(ea => Tag.findByPath(ea)))\n    logger().info(\"removeTags()\", {\n      assetId,\n      tags: tags.map(ea => pick(ea, \"id\", \"path\")),\n      tagPaths\n    })\n    return AssetTag.removeTagsFromAsset(assetId, compact(tags.map(ea => ea.id)))\n  }\n\n  static unshownAssetIds() {\n    return this.dbl.pluckAll<number>(`\n        SELECT DISTINCT af1.assetId\n        FROM AssetFile af1\n          LEFT JOIN (SELECT DISTINCT assetId FROM AssetFile WHERE shown = 1) AS af2 \n            ON af1.assetId = af2.assetId\n        WHERE af2.assetId IS NULL`)\n  }\n\n  static archive(assetId: number) {\n    const a = Asset.ops().findById(assetId)\n    if (a != null) {\n      AssetTag.dbl.runf(q => q.where({ assetId }).delete())\n      AssetFile.dbl.runf(q => q.where({ assetId }).delete())\n      Asset.dbl.runf(q => q.where({ id: assetId }).delete())\n    }\n  }\n\n  markUnshownAndUpsert() {\n    this.shown = false\n    this.version = AssetVersion // don't touch with modelDbUpdater.\n    this.upsert()\n  }\n\n  markShownAndUpsert_(shownAssetFile?: AssetFile) {\n    const priorShownId = this.getShown()?.id\n    if (shownAssetFile != null) {\n      const previouslyShown = shownAssetFile.shown\n      this.setShown_(shownAssetFile, { skipUpsert: true })\n      if (previouslyShown !== true) shownAssetFile.upsert()\n    }\n    this.shown = true\n    this.version = AssetVersion\n    if (priorShownId !== this.getShown()?.id) {\n      this.updateCount = (this.updateCount ?? 0) + 1\n    }\n    this.upsert()\n  }\n\n  readonly mergedTags = lazy(async () => {\n    // TODO: add other fields (like title, description, ...)\n    const tags: ExifTagsWithSource[] = []\n    for (const af of this.getAssetFiles()) {\n      const pf = await af.posixFile()\n      const t = await readTags(pf)\n      const mtime = await pf?.mtimeMs()\n      if (pf != null && t != null && mtime != null) {\n        tags.push({\n          ...t,\n          SourceFile: pf.nativePath,\n          sourceModifiedTime: mtime,\n          sourceIsPrimary: isTrue(af.shown)\n        })\n      }\n    }\n    const revisions = AssetRevision.ops().allf(q =>\n      q.where({ assetId: this.id })\n    )\n    // TODO: THIS NEEDS MORE TESTS!\n    const mt = new MergedTags(\"Asset:\" + this.id)\n    mt.addTag(...tags, ...this.assetFiles!)\n    mt.addRevision(...revisions)\n    return mt\n  })\n\n  async updateFromFiles() {\n    const mt = await this.mergedTags()\n    map(mt.get(\"rating\"), rating => {\n      this.logger().info(\"updateFromFiles()\", { rating })\n      this.rating = rating.value\n    })\n    // TODO: add title, description, keywords, ...\n  }\n\n  toAssetId(): AssetId {\n    return toAssetId(this)!\n  }\n\n  // get fitWidths() {\n  //   return mapNotBlank(this._fitWidths, ea => JSON.parse(ea) as number[])\n  // }\n\n  // set fitWidths(arr: number[]) {\n  //   this._fitWidths = stringify(arr)\n  // }\n\n  renderCaption(locale?: string) {\n    return map(\n      this.capturedAtLocal,\n      ea => \"Taken \" + fmtLocalDateShort(ea, locale)\n    )\n  }\n\n  // async whenApiTag(): PromiseMaybe<ApiTag> {\n  //   const ca = this.capturedAt\n  //   const path = await dateTag(ca)\n  //   const tag = path == null ? undefined : await Tag.findOrCreate(path)\n  //   return tag == null ? undefined : tag.toApiTag()\n  // }\n\n  async whenApiTag(): PromiseMaybe<ApiTag> {\n    const t = dateTag(localToDateObject(this.capturedAtLocal))\n    return t == null ? undefined : Tag.findOrCreate(t).toApiTag()\n  }\n\n  addTagPaths(tagPaths: TagPath[]) {\n    return Asset.addTags(this.id!, tagPaths)\n  }\n\n  findAssetFileByUri(uri: string): Maybe<AssetFile> {\n    return this.getAssetFiles()?.find(ea => ea.uri === uri)\n  }\n\n  addAssetFile(af: AssetFile): void {\n    // no dupe entries:\n    filterInPlace(\n      af.asset?.assetFiles ?? [],\n      ea => !(ea.id === af.id || ea.uri === af.uri)\n    )\n    af.assetId = this.id\n    af.asset = this\n    af.shown = false\n    this.getAssetFiles().push(af)\n    this.clear() // mergedTags will need to be reset\n    // Only set if we haven't set it yet:\n    this.capturedAtLocal ??= af.capturedAtLocal\n    this.rating ??= af.rating\n    this.durationMs ??= af.durationMs\n  }\n\n  /**\n   * @return prior AssetFile instance, or a new AssetFile that needs to be\n   * updated and upserted\n   */\n  async assetFileForFile_(\n    f: PosixFile,\n    opts?: { skipUpsert?: boolean }\n  ): Promise<AssetFile> {\n    const uri = await f.uri()\n    if (uri == null)\n      return this.logger().throw(\"assetFileForFile_(): null uri\", { f })\n    const prior = this.getAssetFiles().find(ea => ea.uri === uri)\n    if (prior != null) return prior\n    const af = new AssetFile()\n    this.addAssetFile(af)\n    if (opts?.skipUpsert !== true) {\n      await af.upsertIfNeeded_(f)\n    } else {\n      await af.setFile_(f)\n    }\n    return af\n  }\n\n  static getTags(assetId: number) {\n    return Tag.ops().all(\n      Tag.query()\n        .select(\"Tag.*\")\n        .join(\"AssetTag\", \"AssetTag.tagId\", \"Tag.id\")\n        .where(\"AssetTag.assetId\", assetId)\n        .orderByRaw(\"COALESCE(Tag.ordinal, Tag._path)\")\n    )\n  }\n\n  getTags() {\n    return (this.tags ??= Asset.getTags(this.id!))\n  }\n\n  /**\n   * Tags will be strings concatenated by `Tag.sep`\n   */\n  static getTagPaths(assetId: number) {\n    const q = Tag.query()\n      .select(\"Tag._path\")\n      .join(\"AssetTag\", \"AssetTag.tagId\", \"Tag.id\")\n      .where(\"AssetTag.assetId\", assetId)\n      .orderByRaw(\"COALESCE(Tag.ordinal, Tag._path)\")\n    return Tag.dbl.pluckAll(q) as MaybeSyncOrAsync<string[]>\n  }\n\n  tagPaths() {\n    const tags = this.getTags()\n    return tags.map(t => t.path.join(\"/\")).sort()\n  }\n\n  getStreams(limit: number): TaggedAssetStream[] {\n    if (this.streams == null) {\n      // const tags = (await this.getTags()).filter(ea => !isFsTag(ea.path))\n      const tags = this.getTags()\n      this.logger().info(\"getStreams(): fetched tags \" + tags, { limit })\n      const streams = tags.map(tag => tag.getAssetStream(this, limit))\n      this.streams = coalesceStreams(compact(streams))\n      // Backfill the ancestors:\n      for (const stream of this.streams) {\n        for (const tag of stream.tags) {\n          tag.getAncestors()\n        }\n      }\n    }\n    return this.streams\n  }\n\n  getBeforeAfterId() {\n    // Do we have multiple assets with the same capturedAt?\n    const sameIds = Asset.dbl.all(\n      Asset.shownUnhidden()\n        .clearSelect()\n        .select({ assetId: \"id\", v: \"updateCount\" })\n        .andWhere(\"capturedAtLocal\", this.capturedAtLocal)\n        .orderBy(\"assetId\")\n    ) as any as AssetId[]\n    this.afterId = sameIds.find(ea => ea.assetId > this.id!)\n    // use id as a secondary sort for capturedAt.\n    this.beforeId = sameIds.reverse().find(ea => ea.assetId < this.id!)\n    if (this.beforeId == null) this.#getBeforeId()\n    if (this.afterId == null) this.#getAfterId()\n  }\n\n  #getBeforeId() {\n    return (this.beforeId = Asset.dbl.first(\n      Asset.shownUnhidden()\n        .clearSelect()\n        .select({ assetId: \"id\", v: \"updateCount\" })\n        // This needs to be <, not <=. See getBeforeAfterId.\n        .andWhere(\"capturedAtLocal\", \"<\", this.capturedAtLocal)\n        .orderBy([\n          { column: \"capturedAtLocal\", order: \"desc\" },\n          // we have to add this if the prev is a batch of same-time assets:\n          { column: \"assetId\", order: \"desc\" }\n        ])\n    ) as any)\n  }\n\n  #getAfterId() {\n    return (this.afterId = Asset.dbl.first(\n      Asset.shownUnhidden()\n        .clearSelect()\n        .select({ assetId: \"id\", v: \"updateCount\" })\n        // This needs to be >, not >=. See getBeforeAfterId.\n        .andWhere(\"capturedAtLocal\", \">\", this.capturedAtLocal)\n        .orderBy([\n          { column: \"capturedAtLocal\", order: \"asc\" },\n          // we have to add this if the prev is a batch of same-time assets:\n          { column: \"assetId\", order: \"asc\" }\n        ])\n    ) as any)\n  }\n\n  getTagPaths() {\n    const tags = this.getTags()\n    return tags.map(tag => tag.path)\n  }\n\n  getAssetFiles({ refresh = false }: { refresh?: boolean } = {}) {\n    // If we have files, then return them (even if we're not saved!)\n    if (this.id != null) {\n      if (refresh) {\n        this.assetFiles = undefined\n      }\n      this.assetFiles ??= sortBy(\n        AssetFile.ops().findBy({ assetId: this.id }),\n        ea => [!isTrue(ea.shown), -ea.mtime]\n      )\n    }\n    return this.assetFiles ?? []\n  }\n\n  setShown_(af: number | AssetFile, opts?: { skipUpsert?: boolean }): void {\n    if (af instanceof AssetFile) {\n      // replace our copy with `af`.\n      this.getAssetFiles()\n      this.assetFiles?.some((ea, i) => {\n        const result = ea.id === af.id || ea.uri === af.uri\n        if (result) this.assetFiles![i] = af\n        return result\n      })\n    }\n    const afId = af instanceof AssetFile ? af.id : af\n    if (this.getShown()?.id === afId) {\n      this.logger().debug(\"setShown_(): no-op, already set\", { afId })\n      return\n    }\n    this.logger().info(\"setShown_()\", { assetId: this.id, assetFileId: afId })\n\n    if (!gt0(this.id) || !gt0(afId)) {\n      this.logger().throw(\n        \"setShown_(): invalid IDs: \" +\n          stringify({ assetId: this.id, assetFileId: afId }) +\n          InternalErrorFlag\n      )\n    }\n\n    // This is in lieu of\n\n    // UPDATE AssetFile SET shown = CASE id WHEN $assetFileId THEN 1 ELSE 0\n    // END, updatedAt = $updatedAt, WHERE assetId = $assetId\n\n    // but lets stay with knex here, it only adds one more db roundtrip.\n\n    const updatedAt = Date.now()\n\n    // Avoid fighting the unique constraint:\n    const r1 = AssetFile.dbl.runf(q =>\n      q.update({ shown: 0, updatedAt }).where({ assetId: this.id })\n    )\n    if (r1.changes <= 0) {\n      this.logger().warn(\"setShown_(): all asset files were already unshown\", {\n        afId\n      })\n    }\n    const r2 = AssetFile.dbl.runf(q =>\n      q.update({ shown: 1, updatedAt }).where({ id: afId })\n    )\n    if (r2.changes !== 1) {\n      this.logger().throw(\n        \"setShown_(): failed to update asset file: unexpected changed rows\",\n        { runResult: r2 }\n      )\n    }\n    const shownAF =\n      this.assetFiles?.find(ea => ea.id === afId) ??\n      this.getAssetFiles({ refresh: true }).find(ea => ea.id === afId)\n    if (shownAF == null) {\n      this.logger().throw(\"setShown_(): failed to find shown asset file\", {\n        af\n      })\n      return\n    }\n\n    // Override the prior field values with the show value:\n    this.capturedAtLocal = shownAF.capturedAtLocal\n    this.rating = shownAF.rating\n    this.durationMs = shownAF.durationMs\n\n    // Update the in-memory models:\n    for (const ea of this.assetFiles ?? []) {\n      ea.shown = ea.id === afId\n    }\n    if (opts?.skipUpsert !== true) {\n      this.upsert()\n    }\n    return\n  }\n\n  getShown(opts?: { refresh?: boolean }): Maybe<AssetFile> {\n    return this.getAssetFiles(opts)?.find(af => isTrue(af.shown))\n  }\n\n  getShownNativePath(): MaybePromiseMaybe<string> {\n    return this.getShown()?.getNativePath()\n  }\n\n  async getCapturedAts(): Promise<CapturedAt[]> {\n    return thenCollect(this.getAssetFiles(), ea => ea.capturedAt())\n  }\n\n  link(): string {\n    return \"/asset/\" + this.id\n  }\n\n  sqAttrs(lazyLoad: boolean = true): any {\n    return {\n      ...assetSqImgAttrs({ assetId: this.assetIdish(), lazyLoad }),\n      title: this.renderCaption(),\n      ...this.attrs\n    }\n  }\n\n  async getImgAttrs(previews: Previews, reducer: ReducerName, skipFs = false) {\n    if (this.imgAttrs == null)\n      this.imgAttrs = new Map<ReducerName, StringValued>()\n    if (this.imgAttrs.get(reducer) == null) {\n      const ap = previews.ap(this.id!)\n      await thenMap(ap.readInfo(), async info => {\n        if (info.mimetype.startsWith(\"video/\")) {\n          this.poster = await ap.posterLink()\n        }\n      })\n      const stat = true\n      this.imgAttrs.set(reducer, await ap.imgAttrs(reducer, stat, skipFs))\n    }\n    return this.imgAttrs.get(reducer)\n  }\n\n  async fitAttrs(previews: Previews): Promise<StrBoolValued> {\n    return {\n      ...(await this.getImgAttrs(previews, ReducerNames.fit)),\n      // title: this.renderCaption(),\n      ...this.attrs\n    }\n  }\n\n  isVideo(): boolean {\n    if (this.assetFiles == null) {\n      throw new Error(\".video called before getFiles()\")\n    }\n    return this.assetFiles.some(ea => ea.isVideo)\n  }\n\n  videoAttrs(): StrBoolValued {\n    return {\n      controls: true,\n      autoplay: true,\n      poster: this.poster,\n      ...this.attrs\n    }\n  }\n\n  async videoSources(): Promise<{ src: string; type: string }[]> {\n    // We need at least one video to be an mp4.\n    // 1. prefer the shown asset file if it's an mp4\n    // 2. if any siblings are an mp4, use that\n    // 3. otherwise, videolink the shown or first existing asset file with an \"mp4=\"\n\n    // Only take the first existing file for a given mimetype.\n    const result: { src: string; type: string }[] = []\n    let firstExistingAF: AssetFile | undefined\n    for (const af of this.getAssetFiles()) {\n      if (result.some(ea => ea.type === af.mimetype)) continue\n      if (await af.exists()) {\n        firstExistingAF ??= af\n        result.push({\n          src: assetVideoLink({\n            assetId: this.assetIdish(),\n            assetFileId: af.id!\n          }),\n          type: af.mimetype\n        })\n      }\n    }\n\n    if (\n      !result.some(ea => ea.type === \"video/mp4\") &&\n      firstExistingAF != null\n    ) {\n      result.unshift({\n        src:\n          assetVideoLink({\n            assetId: this.assetIdish(),\n            assetFileId: firstExistingAF.id!\n          }) + \".mp4\",\n        type: \"video/mp4\"\n      })\n    }\n    return result\n  }\n\n  async getPosixFiles(): PromiseMaybe<PosixFile[]> {\n    return thenCollect(this.getAssetFiles(), ea => ea.posixFile_())\n  }\n\n  async getExistingAssetFiles() {\n    return filterAsync({\n      name: \"getExistingAssetFiles\",\n      arr: this.getAssetFiles(),\n      f: af => af.exists()\n    })\n  }\n\n  async findOrCreateByFile(f: PosixFile) {\n    const uri = await f.uri_()\n    if (uri == null) return\n    const prior = toA(AssetFile.ops().findBy({ assetId: this.id!, uri }))[0]\n    return orElse<SyncOrAsync<AssetFile>>(prior, async () => {\n      const af = new AssetFile()\n      af.asset = this\n      af.assetId = this.id\n      await af.setFile_(f)\n      return af\n    })\n  }\n\n  partialSimpleAsset() {\n    return {\n      assetId: this.id!,\n      liked: gte(this.rating, Settings.likeRating.valueOrDefault),\n      hidden: isTrue(this.hidden),\n      excluded: this.excludedAt != null,\n      deleted: this.deletedAt != null\n    }\n  }\n\n  clear() {\n    // this _does not_ delete .assetFiles, as that may be un-upserted\n    // information.\n    this.imgAttrs = undefined\n    this.streams = undefined\n    this.tags = undefined\n    this.mergedTags.unset()\n    return this\n  }\n}\n","import { Knex } from \"knex\"\nimport { sep } from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { identity } from \"../../core/Object\"\nimport { AssetFileVersion } from \"../../core/PhotoStructureVersions\"\nimport { escapeRegExp } from \"../../core/RegExp\"\nimport { equalsIgnoreCase } from \"../../core/String\"\nimport {\n  assetFileStatFields_,\n  mkAssetFile_\n} from \"../../core/asset-file/AssetFileFactory\"\nimport {\n  AssetFileStatFields,\n  IAssetFile,\n  getAssetFileNativePath\n} from \"../../core/asset-file/IAssetFile\"\nimport { thenMap } from \"../../core/async/Promise\"\nimport { DominantColor } from \"../../core/color/DominantColor\"\nimport { fmtLocalDateShort } from \"../../core/date/Localtime\"\nimport { errorToS } from \"../../core/error/Error\"\nimport { InternalErrorFlag } from \"../../core/error/ErrorFlags\"\nimport { onError } from \"../../core/error/OnError\"\nimport { posixPathFromGrandparent } from \"../../core/fs/Path\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { whyRejectFile } from \"../../core/fs/PosixFileFilters\"\nimport {\n  AssetFileSyncState,\n  AssetFileSyncStates,\n  SyncFileStates\n} from \"../../core/fs/SyncReport\"\nimport { PreviewAssetFile } from \"../../core/img/AssetPreviewBuilder\"\nimport {\n  mkDownloadableTitle,\n  previewToDownloadable\n} from \"../../core/img/AssetPreviewInfo\"\nimport { ImageHash } from \"../../core/img/ImageHash\"\nimport { Previews } from \"../../core/img/Previews\"\nimport { ForceContext } from \"../../core/settings/ForceContext\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { CapturedAt } from \"../../core/tags/CapturedAt\"\nimport { isVideoMimeType } from \"../../core/tags/MimeTypes\"\nimport { uriExists } from \"../../core/uri/FileURI\"\nimport { URI } from \"../../core/uri/URI\"\nimport { uriIsEquivalent } from \"../../core/uri/UriNormalization\"\nimport { currentVolumeRoots } from \"../../core/volumes/CurrentVolumes\"\nimport { uriToTagPath } from \"../../core/web/UriToTagPath\"\nimport { compact, isEmpty, isNotEmpty, uniqBy } from \"../../fe/Array\"\nimport { at } from \"../../fe/At\"\nimport { blank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { secondMs } from \"../../fe/Date\"\nimport { fmtDim } from \"../../fe/Dimensions\"\nimport { eql } from \"../../fe/Eql\"\nimport { fmtDuration } from \"../../fe/FmtDuration\"\nimport { ReducerNames } from \"../../fe/ImageReducers\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { closeTo, gt0, gte0 } from \"../../fe/Number\"\nimport {\n  assignAllFields,\n  assignFields,\n  omit,\n  pick,\n  reqValuedOrElse\n} from \"../../fe/Object\"\nimport { gte } from \"../../fe/Primitive\"\nimport {\n  PS_LIBRARY_PROTOCOL,\n  PS_LIBRARY_SCHEME,\n  PS_LOCAL_FILE_SCHEME\n} from \"../../fe/URI\"\nimport {\n  ApiAssetFile,\n  AssetFilePathInfo,\n  Downloadable,\n  PathTag\n} from \"../../fe/api/Asset\"\nimport { LibraryTagName, TagRoots } from \"../../fe/api/Tag\"\nimport { Library } from \"../Library\"\nimport { mayCopyAssetsToLibrary } from \"../sync-file/AssetFileRepository\"\nimport { Asset } from \"./Asset\"\nimport { isShaBlockslisted } from \"./ShaBlocklist\"\nimport { Tag } from \"./Tag\"\nimport { TimestampedModel } from \"./TimestampedModel\"\n\nexport class AssetFile\n  extends TimestampedModel\n  implements IAssetFile, PreviewAssetFile\n{\n  static override readonly $tableName = \"AssetFile\"\n  static override readonly $uniqueColumnName = \"uri\"\n  static override readonly $booleanFields = [\"shown\"] as const\n  static override readonly $transientFields = [\n    \"nativePath\",\n    \"syncState\"\n  ] as const\n\n  static outdatedQuery(args: {\n    q?: Knex.QueryBuilder\n    maxUpdatedAt?: number\n    uris: string[]\n    mountpoints: string[]\n  }) {\n    let q = (args.q ?? this.query()).where(\"version\", \"<\", AssetFileVersion)\n    if (args.maxUpdatedAt != null) {\n      q = q.andWhere(\"updatedAt\", \"<\", args.maxUpdatedAt)\n    }\n    return q\n      .andWhere(q2 => {\n        if (isNotEmpty(args.mountpoints)) {\n          q2 = q2.whereIn(\"mountpoint\", args.mountpoints)\n        }\n        for (const ea of args.uris) {\n          q2 = q2.orWhereLike(\"uri\", ea + \"%\")\n        }\n        return q2\n      })\n      .orderBy(\"id\")\n  }\n\n  static async nextOutdated(\n    q: (qb: Knex.QueryBuilder) => Knex.QueryBuilder = identity\n  ) {\n    return this.ops().findOne(q(this.outdatedQuery(await currentVolumeRoots())))\n  }\n\n  static async outdatedCount(\n    q: (qb: Knex.QueryBuilder) => Knex.QueryBuilder = identity\n  ): Promise<number> {\n    const qb = this.outdatedQuery(await currentVolumeRoots())\n    return this.dbl.pluckFirst(q(qb.count(\"id\"))) as any // SITS TYPING\n  }\n\n  static shownAssetFileId(assetId: number) {\n    return this.dbl.pluckFirstf<number>(q =>\n      q.where({ assetId, shown: 1 }).limit(1)\n    )\n  }\n\n  static primaryForAssetId(assetId: Maybe<number>) {\n    return !gt0(assetId)\n      ? undefined\n      : AssetFile.ops().first(\n          Asset.shownUnhidden()\n            .join(\"AssetFile\", \"AssetFile.assetId\", \"Asset.id\")\n            .select(\"AssetFile.*\")\n            .where({ assetId, \"AssetFile.shown\": 1 })\n        )\n  }\n\n  static shownUnhidden({\n    uriRoot\n  }: { uriRoot?: string } = {}): Knex.QueryBuilder {\n    let q = Asset.shownUnhidden().join(\n      \"AssetFile\",\n      \"AssetFile.assetId\",\n      \"Asset.id\"\n    )\n    if (!blank(uriRoot)) {\n      q = q.andWhereLike(\"AssetFile.uri\", uriRoot + \"%\")\n    }\n    return q\n  }\n\n  /**\n   * Most recent 64 assetURIs, mapped to their asset id. Given we need at most\n   * 32 per progress bar, and there may be the end of one progress and the start\n   * of another, 64 should do it.\n   */\n  // static readonly uri2assetId = new BoundedMap<string, number>(\n  //   5 * minuteMs,\n  //   64,\n  //   true\n  // )\n  // static clear() {\n  //   this.uri2assetId.clear()\n  // }\n  static recentAssetIdsByUriRoot(\n    uriRoot: Maybe<string>,\n    ttlMs: number,\n    limit = 64\n  ): number[] {\n    const since = Date.now() - ttlMs\n    return this.dbl.pluckAll(\n      AssetFile.shownUnhidden({ uriRoot })\n        .distinct(\"AssetFile.assetId\")\n        .where(\"AssetFile.updatedAt\", \">\", since)\n        .orderBy(\"AssetFile.updatedAt\", \"desc\")\n        .limit(limit)\n    ) as number[]\n  }\n\n  static assetFileCountByMimeType(\n    uriRoot?: string\n  ): { mimetype: string; assetFileCount: number; assetCount: number }[] {\n    const qb = AssetFile.shownUnhidden({ uriRoot })\n      .select(\"mimetype\")\n      .countDistinct({\n        assetFileCount: \"AssetFile.id\",\n        assetCount: \"Asset.id\"\n      })\n      .groupBy(\"mimetype\")\n      .orderBy(\"mimetype\")\n    return this.dbl.all(qb) as any\n  }\n\n  static assetFileCountWithMimeType(\n    mimeRootOrType: string,\n    uriRoot?: string\n  ): { assetFileCount: number; assetCount: number } {\n    let qb = AssetFile.shownUnhidden({ uriRoot }).countDistinct({\n      assetFileCount: \"AssetFile.id\",\n      assetCount: \"Asset.id\"\n    })\n    qb = mimeRootOrType.endsWith(\"/\")\n      ? qb.andWhereLike(\"mimetype\", mimeRootOrType + \"%\")\n      : qb.andWhere(\"mimetype\", mimeRootOrType)\n    return this.dbl.first(qb) as any\n  }\n\n  /**\n   * Aggregate by \"image/\" and \"video/\"\n   */\n  static assetFileCountByMimeTypeRoots(\n    mimeRootOrTypes: string[] = [\"image/\", \"video/\"],\n    uriRoot?: string\n  ): { mimeTypeRoot: string; assetFileCount: number }[] {\n    return mimeRootOrTypes.map(mimeTypeRoot => ({\n      mimeTypeRoot,\n      assetFileCount:\n        AssetFile.assetFileCountWithMimeType(mimeTypeRoot, uriRoot)\n          ?.assetFileCount ?? 0\n    }))\n  }\n\n  static children(\n    uriParent: string,\n    q?: (qb: Knex.QueryBuilder) => Knex.QueryBuilder\n  ) {\n    const qb = this.query()\n      // the uri like allows the index to be used:\n      .whereLike(\"uri\", uriParent + \"/%\")\n      .andWhere(\"uri\", \"regexp\", `^${escapeRegExp(uriParent)}/[^/]+$}`)\n    return this.ops().all(q == null ? qb : q(qb))\n  }\n\n  static async sameShaInLibrary(f: PosixFile): PromiseMaybe<AssetFile[]> {\n    if (this.db() == null) return\n    const sha = await f.sha()\n    const fileSize = await f.size()\n    if (sha == null || fileSize == null) return\n    return this.ops().allf(q =>\n      q.where({ sha, fileSize }).andWhereLike(\"uri\", PS_LIBRARY_PROTOCOL + \"%\")\n    )\n  }\n\n  static sameAssetFileInLibrary(af: AssetFile): AssetFile[] {\n    return this.ops().allf(q =>\n      q\n        .where(pick(af, \"sha\", \"fileSize\"))\n        .andWhere(q2 => q2.whereLike(\"uri\", PS_LIBRARY_PROTOCOL + \"%\"))\n        .andWhere(q2 => q2.whereNot({ id: af.id }))\n    )\n  }\n\n  assetId?: number\n  asset?: Asset\n\n  /** shown is true iff it's the Asset's preview source */\n  shown!: number | boolean\n\n  uri!: string\n\n  mountpoint?: string // < not set for pslib: URIs. Helps reconstitute URIs for unmounted volumes.\n\n  mtime!: number\n  fileSize!: number\n  mimetype!: string\n  sha!: string\n\n  /**\n   * deci-second resolution in YYYYMMddHHmmssSS\n   */\n  capturedAtLocal!: number\n  capturedAtOffset?: number\n  capturedAtPrecisionMs?: number\n  capturedAtSrc!: string\n\n  focalLength?: string // 35 mm\n  aperture?: number // 4.8\n  shutterSpeed?: string // 1/100 (does this need to be cleaned up?)\n  iso?: number // 100\n  durationMs?: number\n  fps?: number\n\n  width!: number\n  height!: number\n  rotation?: number\n\n  make?: string\n  model?: string\n  cameraId?: string\n  imageId?: string\n  lensId?: string\n  geohash?: number\n  rating?: number\n\n  /**\n   * nullable because image hashing is optional\n   */\n  meanHash?: ImageHash[\"meanHash\"]\n  diffHash?: ImageHash[\"diffHash\"]\n  dctHash?: ImageHash[\"dctHash\"]\n  mode0?: number\n  mode1?: number\n  mode2?: number\n  mode3?: number\n  mode4?: number\n  mode5?: number\n  mode6?: number\n  mode0pct?: number\n  mode1pct?: number\n  mode2pct?: number\n  mode3pct?: number\n  mode4pct?: number\n  mode5pct?: number\n  mode6pct?: number\n\n  version!: number\n  updateCount?: number\n\n  // transient\n  nativePath!: string\n  syncState?: AssetFileSyncState\n\n  // afterUpsert() {\n  //   map(this.assetId, assetId =>\n  //     map(this.uri, uri => AssetFile.uri2assetId.set(uri, assetId))\n  //   )\n  // }\n\n  librarySiblings() {\n    return this.getAsset()\n      ?.getAssetFiles()\n      .filter(ea => ea.id !== this.id && ea.uri.startsWith(PS_LIBRARY_PROTOCOL))\n  }\n\n  capturedAtLocale(locale?: string) {\n    return fmtLocalDateShort(this.capturedAtLocal, locale)\n  }\n\n  get dominantColors(): DominantColor[] {\n    return DominantColor.fromModeData(this)\n  }\n\n  set dominantColors(dominantColors: DominantColor[]) {\n    // we want to assign both values and nulls here (in case there are fewer\n    // than 7 dominant colors)\n    assignAllFields(this as AssetFile, DominantColor.toModeData(dominantColors))\n  }\n\n  readonly uriObj = lazy(() => URI.parse(this.uri))\n\n  get posixPathFromGrandparent() {\n    return map(this.uriObj()?.fsPath, posixPathFromGrandparent)\n  }\n\n  /**\n   * You probably want checkForNoop instead -- this only checks if this row in\n   * the database looks OK.\n   */\n  async whyNotMatchesFile(file?: PosixFile): PromiseMaybe<string> {\n    const outdated = this.#whyOutdated()\n    if (outdated != null) return outdated\n\n    if (this.fileSize == null || this.mtime == null) {\n      return \"missing file metadata\"\n    }\n\n    if (file != null) {\n      const fileUri = await file.uri()\n      if (fileUri == null) {\n        return \"file has no URI\"\n      }\n      if (!(await uriIsEquivalent(this.uri, fileUri))) {\n        return \"file URI mismatch\"\n      }\n    }\n\n    try {\n      const pf = file ?? (await this.posixFile_())\n      const ff = await this.fileFields_(pf)\n      if (ff == null) {\n        if (true === (await pf?.isDeleted())) {\n          return \"file is deleted\"\n        } else {\n          return \"file is unreadable\"\n        }\n      }\n      if (ff.fileSize !== this.fileSize) {\n        return \"file size changed since last sync\"\n      }\n      if (!closeTo(ff.mtime, this.mtime, 2 * secondMs)) {\n        return \"file mtime changed since last sync\"\n      }\n      return\n    } catch (error) {\n      return errorToS(error)\n    }\n  }\n\n  async matchesFile(file?: PosixFile): Promise<boolean> {\n    const whyNot = await this.whyNotMatchesFile(file)\n    return this.logger().tap({\n      msg: \"matchesFile()\",\n      result: null == whyNot,\n      meta: { whyNot }\n    })\n  }\n\n  /**\n   * Respects `forceSync` and AssetFileVersion, and then delegates to @link whyNotMatchesFile\n   */\n  async whyNotInSyncWithFile(file?: PosixFile): PromiseMaybe<string> {\n    if (Settings.forceSync.valueOrDefault) {\n      return \"forceSync\"\n    }\n    if (this.version == null || this.version < AssetFileVersion) {\n      return \"outdated AssetFileVersion\"\n    }\n    return this.whyNotMatchesFile(file)\n  }\n\n  async inSyncWithFile(file?: PosixFile): Promise<boolean> {\n    const whyNotInSync = await this.whyNotInSyncWithFile(file)\n    return this.logger().tap({\n      msg: \"inSyncWithFile()\",\n      result: null == whyNotInSync,\n      meta: { whyNotInSync }\n    })\n  }\n\n  async fileFields_(file?: PosixFile): PromiseMaybe<AssetFileStatFields> {\n    const pf = file ?? (await this.posixFile_())\n    return pf == null ? undefined : await assetFileStatFields_(pf)\n  }\n\n  #whyOutdated() {\n    if (blank(this.uri)) {\n      return \"blank uri\"\n    }\n\n    if (blank(this.sha)) {\n      return \"blank sha\"\n    }\n\n    if (!gt0(this.width)) {\n      return \"missing width\"\n    }\n\n    if (!gt0(this.height)) {\n      return \"missing height\"\n    }\n\n    if (!gt0(this.capturedAtLocal)) {\n      return \"missing capturedAtLocal\"\n    }\n\n    if (!gte0(this.capturedAtPrecisionMs)) {\n      return \"missing capturedAtPrecisionMs\"\n    }\n\n    if (\n      Settings.useImageHashes.valueOrDefault &&\n      (blank(this.meanHash) || blank(this.diffHash) || blank(this.dctHash))\n    ) {\n      return \"missing image hashes\"\n    }\n\n    if (!this.isVersionUpToDate()) {\n      return \"outdated version\"\n    }\n\n    return\n  }\n\n  async isNoop(\n    ctx: ForceContext = {\n      forceSync: Settings.forceSync.valueOrDefault\n    }\n  ) {\n    const whyNotNoop = await this.whyNotNoop(ctx)\n    return this.logger().tap({\n      msg: \"isNoop()\",\n      result: null == whyNotNoop,\n      meta: { whyNotNoop }\n    })\n  }\n\n  /**\n   * Verifies that both this row in the database is in sync with the current\n   * running code, and that the file doesn't need to be copied into the\n   * library (if that setting is enabled)\n   */\n  async whyNotNoop(\n    ctx: ForceContext = {\n      forceSync: Settings.forceSync.valueOrDefault\n    }\n  ) {\n    if (true === ctx.forceSync) {\n      return \"forceSync is true\"\n    }\n\n    // SQLite ROWID starts at 1: https://www.sqlite.org/autoinc.html\n    if (!gt0(this.id)) {\n      return \"missing .id\"\n    }\n\n    if (!gt0(this.assetId)) {\n      return \"missing .assetId\"\n    }\n\n    const whyNotMatches = await this.whyNotMatchesFile()\n    if (whyNotMatches != null) {\n      return whyNotMatches\n    }\n\n    if (await mayCopyAssetsToLibrary()) {\n      const repo = Library.instanceRequired().assetFileRepository()\n      const why = repo.whyNotCopyFile(await this.posixFile_())\n      if (blank(why)) {\n        const af = await repo.existingLibraryAssetFile(this)\n        if (af == null) {\n          return \"need to copy into library\"\n        }\n      }\n    }\n\n    this.syncState = AssetFileSyncStates.noop\n    return\n  }\n\n  isVersionUpToDate() {\n    return gte(this.version, AssetFileVersion)\n  }\n\n  async siblingCount(): Promise<number> {\n    return AssetFile.dbl.pluckFirstf<number>(q =>\n      q.count().where({ assetId: this.assetId }).andWhereNot({ id: this.id })\n    )\n  }\n\n  async upsertIfNeeded_(\n    file?: PosixFile,\n    forceSync = Settings.forceSync.valueOrDefault\n  ): PromiseMaybe<this> {\n    if (file != null) {\n      await this.setFile_(file)\n    }\n    if ((await this.matchesFile()) && gt0(this.id) && !forceSync) {\n      this.upsert() // < update the updatedAt\n      this.syncState = AssetFileSyncStates.noop\n      return\n    }\n    const isDeleted = await this.isFileDeleted()\n    if (isDeleted === true) {\n      this.syncState = AssetFileSyncStates.deleted\n      this.delete()\n      return this\n    } else if (isDeleted === false) {\n      const updated = await this.updateFromFile_(file)\n      this.syncState ??=\n        updated == null\n          ? AssetFileSyncStates.skipped\n          : AssetFileSyncStates.synced\n      return this.upsert()\n    } else {\n      // we don't have this volume currently mounted.\n      this.syncState ??= AssetFileSyncStates.skipped\n      return this\n    }\n  }\n\n  async updateFileFields_(file?: Maybe<PosixFile>) {\n    assignFields(this as AssetFile, await this.fileFields_(file))\n  }\n\n  /**\n   * NOTE: DOES NOT UPSERT. See `upsertIfNeeded()`.\n   * @return if this assetFile should not be upserted (due to already being in sync, or source file missing)\n   */\n  async updateFromFile_(file?: PosixFile): PromiseMaybe<this> {\n    const start = Date.now()\n    const l = this.logger().addContext(\".updateFromFile_()\")\n    if (this.id != null && (await this.matchesFile(file))) {\n      l.info(\n        \"updateFromFile() no-op: up-to-date version and file stat matches since last update\"\n      )\n      return\n    }\n    if (file != null) {\n      await this.setFile_(file)\n    }\n    if (file == null) {\n      file = await this.posixFile_()\n    }\n\n    // only decide we're a no-op if we flush cache and it's still not there:\n    if (file == null || (await file.clear().notExists())) {\n      this.syncState = AssetFileSyncStates.deleted\n      l.info(\"no-op, \" + file + \" is missing\")\n      return\n    }\n\n    // this may throw!\n    const fields = await mkAssetFile_(file)\n\n    if (fields.uri !== this.uri) {\n      // It's OK to upgrade the URI from file: but not vice versa.\n      if (blank(this.uri) || true === this.uri?.startsWith(\"file:\")) {\n        this.logger().warn(\"updateFromFile() upgrading uri\", {\n          prior: this.uri,\n          new: fields.uri\n        })\n        this.uri = fields.uri\n      }\n    }\n\n    assignAllFields<AssetFile>(this, omit(fields, \"uri\"))\n\n    this.version = AssetFileVersion\n    this.syncState = SyncFileStates.synced\n\n    l.elapsed(\"finished\", Date.now() - start, this.toJSON())\n    return this\n  }\n\n  /**\n   * Skip exiftool and image hashing ops if the sibling is relevant and\n   * up-to-date.\n   */\n  async updateFromShaSibling_(sibling: AssetFile) {\n    const whySiblingIsInvalid = sibling.#whyOutdated()\n    if (whySiblingIsInvalid != null) {\n      this.logger().warn(\"updateFromShaSibling() sibling is invalid\", {\n        whySiblingIsInvalid\n      })\n      return\n    }\n    this.logger().debug(\"updateFromShaSibling\", sibling)\n    if (\n      sibling.sha != null &&\n      (await sibling.matchesFile()) &&\n      this.sha === sibling.sha\n    ) {\n      assignFields(\n        this as AssetFile,\n        omit(\n          sibling,\n          \"id\",\n          \"posixFile\",\n          \"uriObj\",\n          \"shown\",\n          \"uri\",\n          \"mtime\",\n          \"fileSize\",\n          \"mountpoint\",\n          \"createdAt\",\n          \"updatedAt\",\n          \"updateCount\",\n          ...AssetFile.$transientFields // includes nativePath\n        )\n      )\n      return this.updateFileFields_()\n    } else {\n      return this.updateFromFile_()\n    }\n  }\n\n  getAsset() {\n    return (this.asset ??= gt0(this.assetId)\n      ? Asset.ops().findById(this.assetId)\n      : undefined)\n  }\n\n  exists(): Promise<boolean> {\n    return uriExists(this.uri, this.mountpoint)\n  }\n\n  /**\n   * True if the volume is currently mounted and this file is missing.\n   */\n  async isFileDeleted(): PromiseMaybe<boolean> {\n    return (await this.posixFile_())?.isDeletedUri(this.uri)\n  }\n\n  whyRejected = lazy(async () => {\n    // if the SHA is bad, we don't care about anything else:\n    if (true === isShaBlockslisted(this.sha)) return \"blocklisted SHA\"\n    const pf = await this.posixFile_()\n    if (pf == null) return \"invalid URI\"\n    if (true === (await this.isFileDeleted())) return \"deleted\"\n    return whyRejectFile(pf)\n  })\n\n  async accepted() {\n    return blank(await this.whyRejected())\n  }\n\n  async setFile_(file: PosixFile): Promise<this> {\n    const uri = await file.uri_()\n    if (uri == null) {\n      return this.logger().throw(\"setFile(): no URI for \" + file)\n    }\n    // THIS MAY BE VALIDLY NULL if file lives in the originals or library\n    // directories!\n    const mountpoint = await file.mountpoint()\n\n    if (this.uri != null) {\n      // Verify the prior URI is equivalent:\n      if (!(await uriIsEquivalent(uri, this.uri))) {\n        return this.logger().throw(\n          \"setFile(): cannot reassign non-equivalent URI\",\n          { prior: this.uri, new: uri, file: file.nativePath }\n        )\n      }\n    }\n\n    const u = await file.uriObject_()\n    if (u == null) {\n      return this.logger().throw(\"failed to create URI for \" + file)\n    }\n\n    this.uri = uri\n    this.uriObj.set(u)\n    this.mountpoint = mountpoint?.nativePath\n    this.nativePath = file.nativePath\n\n    this.posixFile_.set(Promise.resolve(file))\n    return this\n  }\n\n  get basename() {\n    return blank(this.uri)\n      ? undefined\n      : decodeURIComponent(this.uri.slice(this.uri.lastIndexOf(\"/\") + 1))\n  }\n\n  readonly posixFile_ = lazy(async () =>\n    PosixFile.for(await this.getNativePath())\n  )\n\n  posixFile() {\n    return this.posixFile_().catch(() => undefined)\n  }\n\n  async getNativePath() {\n    if (blank(this.nativePath)) {\n      // DON'T BE GRUMPY IF MOUNTPOINT IS NULL. mountpoint will be null for\n      // library asset files!\n      if (this.uri == null) {\n        this.logger().error(\n          \".getNativePath() called before .setFile_()\" + InternalErrorFlag\n        )\n      } else {\n        this.nativePath = await getAssetFileNativePath(this)\n      }\n    }\n    return this.nativePath\n  }\n\n  async capturedAt() {\n    if (this.nativePath == null) await this.getNativePath()\n    return CapturedAt.fromAssetFile(this)\n  }\n\n  async originalDownloadable({\n    brief = false\n  }: { brief?: boolean } = {}): PromiseMaybe<Downloadable> {\n    const basename = this.basename\n    if (brief === true) {\n      // GO FAST\n      return basename == null\n        ? undefined\n        : {\n            href: `/dl/${this.assetId}/${this.id}`,\n            size: \"original\",\n            title: `Download ${basename}`,\n            basename,\n            description: \"Download original\"\n          }\n    }\n    const posixFile = await this.posixFile_()\n    return this.logger().tap({\n      msg: \"originalDownloadable()\",\n      level: \"info\",\n      result:\n        posixFile == null || (await posixFile.isEmpty())\n          ? undefined\n          : {\n              href: `/dl/${this.assetId}/${this.id}`,\n              size: \"original\",\n              title: brief\n                ? `Download ${posixFile.base}`\n                : mkDownloadableTitle(\n                    posixFile,\n                    \"original\",\n                    this.isVideo ? \"video\" : \"image\",\n                    { width: this.width, height: this.height }\n                  ),\n              basename: posixFile.base,\n              description: \"Download original\",\n              details: `(${fmtDim(this)} ${posixFile.ext})`\n            },\n      meta: {\n        posixFile\n      }\n    })\n  }\n\n  async downloadables(\n    previews: Previews,\n    shownSha?: string\n  ): Promise<Downloadable[]> {\n    try {\n      const posixFile = await this.posixFile_()\n      if (posixFile == null) return []\n\n      const ap = previews.ap(this.assetId!)\n\n      // If we can't get dimensions, the file is missing\n\n      const result: Downloadable[] = []\n      await thenMap(this.originalDownloadable(), ea => result.push(ea))\n\n      if (this.isVideo) return result\n\n      const shown = isTrue(this.shown) || this.sha === shownSha\n\n      if (!shown) return result\n\n      const arr = compact(\n        await Promise.all(\n          [...(await ap.previewInfos())]\n            .reverse()\n            .filter(ea => ea.reducer === ReducerNames.fit)\n            .map(ea => previewToDownloadable(posixFile.base, ea))\n        )\n      )\n\n      result.push(\n        ...uniqBy(\n          arr,\n          // arr.filter(ea => [\"large\", \"small\"].includes(ea.size)),\n          ea => ea.size\n        )\n      )\n      return result\n    } catch (err) {\n      onError(\"AssetFile.downloadables failed for \" + this.uri, err)\n      return []\n    }\n  }\n\n  /**\n   * @see AssetFilePathInfo\n   */\n  async pathInfo(): PromiseMaybe<AssetFilePathInfo> {\n    try {\n      const uri = URI.parse(this.uri)\n      const tag = map(uriToTagPath({ uri, isFile: true }), tagPath =>\n        Tag.findByPath(tagPath)\n      )\n      return this._pathInfo_(await tag?.toApiPathElements())\n    } catch (err) {\n      this.logger().warn(\"pathInfo(): failed\", err)\n      return\n    }\n  }\n\n  /**\n   * only exposed for tests\n   */\n  async _pathInfo_(\n    tagLineage: Maybe<PathTag[]>\n  ): PromiseMaybe<AssetFilePathInfo> {\n    // See https://forum.photostructure.com/t/image-filepath-not-correct-synology-docker-compose-alpha-branch/545\n\n    const posixFile = await this.posixFile_()\n    if (posixFile == null) {\n      return this.logger().throw(\"pathInfo(): no posixFile\", {\n        uri: this.uri\n      })\n    }\n\n    // for pslib://, it'll be the path from the library.\n    // for psfile://, it'll be the path from the mountpoint.\n\n    const nativePath = posixFile.nativePath\n    const u = URI.parse(this.uri)\n    const exists = await posixFile.exists()\n\n    if (tagLineage == null || isEmpty(tagLineage)) {\n      this.logger().warn(\n        \"pathInfo(): failed to find existing Tag. Returning a simple path.\",\n        {\n          uri: this.uri,\n          nativePath,\n          tagLineage\n        }\n      )\n      return {\n        nativePath,\n        pathElements: [],\n        nativePathSuffix: nativePath,\n        pathSep: sep,\n        exists\n      }\n    }\n\n    // The first tag element is \"fs\", we don't need that:\n    // (remember that slice returns a shallow copy of the array)\n    if (eql(tagLineage[0]?.tagPath, [TagRoots.fs])) {\n      tagLineage = tagLineage.slice(1)\n    }\n\n    function lastTagName() {\n      return at(at(tagLineage, -1)?.tagPath, -1)\n    }\n\n    const isLibraryUri = u.scheme === PS_LIBRARY_SCHEME\n\n    const filePaths = isLibraryUri\n      ? u.path.split(\"/\").slice(1)\n      : posixFile.pathnames\n\n    const nativePathSuffix: string = filePaths.pop()!\n\n    const pathElements: PathTag[] = []\n\n    // We expect almost all the paths to match, but there's shenanigans at the\n    // beginning of the paths due to the volsha and the initial library path:\n    while (\n      filePaths.length > 0 &&\n      equalsIgnoreCase(lastTagName(), at(filePaths, -1))\n    ) {\n      filePaths.pop()!\n      const t = tagLineage.pop()!\n      pathElements.unshift(t)\n      this.logger().debug(\"added matching tag\", t)\n    }\n\n    // fs/XXX tags can represent\n    if (isLibraryUri && lastTagName() === LibraryTagName) {\n      filePaths.pop()\n      const t = tagLineage.pop()!\n      pathElements.unshift(t)\n      this.logger().debug(\"pslib: added matching library tag\", t)\n    }\n\n    // Can we pop off the \"root\" of this volume?\n    if (u.scheme === PS_LOCAL_FILE_SCHEME) {\n      const thisVolSha = URI.parse(this.uri).authority\n      this.logger().debug(\"psfile: pop last?\", {\n        lastTagName: lastTagName(),\n        thisVolSha\n      })\n      if (lastTagName() === thisVolSha) {\n        filePaths.pop()\n        const t = tagLineage.pop()!\n        pathElements.unshift(t)\n      } else {\n        this.logger().warn(\n          \"weird: I expected to be able to include the volsha tag element, but it doesn't seem to match\",\n          {\n            thisVolSha,\n            tagVolSha: lastTagName()\n          }\n        )\n      }\n    }\n\n    return this.logger().tap({\n      msg: \"pathInfo()\",\n      result: {\n        nativePath,\n        pathElements,\n        nativePathSuffix,\n        pathSep: sep,\n        exists\n      }\n    })\n  }\n\n  async toApi(\n    previews: Previews,\n    shownSha?: string\n  ): PromiseMaybe<ApiAssetFile> {\n    return thenMap(this.pathInfo(), async pi =>\n      reqValuedOrElse({\n        assetId: this.assetId,\n        assetFileId: this.id,\n        ...pi,\n        mimetype: this.mimetype,\n        shown: isTrue(this.shown),\n        name: this.basename,\n        width: this.width,\n        height: this.height,\n        rotation: orElse(this.rotation, 0),\n        fileSize: this.fileSize,\n        mtime: this.mtime,\n        downloadables: await this.downloadables(previews, shownSha),\n        createdAtLocale: fmtMillis(this.createdAt!),\n        updatedAtLocale: fmtMillis(this.updatedAt!)\n      })\n    )\n  }\n\n  get isVideo(): boolean {\n    return isVideoMimeType(this.mimetype)\n  }\n}\n\nfunction fmtMillis(ms: Maybe<number>): Maybe<string> {\n  return map(ms, ea => fmtDuration(Date.now() - ea, 1) + \" ago\")\n}\n","import { durationHMS } from \"../../core/date/Date\"\nimport { AssetId } from \"../../fe/api/Asset\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, isNumber, toGt0 } from \"../../fe/Number\"\nimport { DbValued } from \"../db/DbValued\"\n\nexport function toAssetId(\n  obj:\n    | Maybe<{\n        id?: number\n        assetId?: number\n        capturedAtLocal: number\n        updatedAt?: number\n        updateCount?: number\n        v?: number\n        durationMs?: number\n      }>\n    | DbValued\n): Maybe<AssetId> {\n  const assetId = toGt0(obj?.assetId) ?? toGt0(obj?.id)\n  if (obj == null || assetId == null || !isNumber(obj?.capturedAtLocal)) return\n  const v =\n    (toGt0(obj.v) ?? toGt0(obj.updateCount) ?? toGt0(obj.updatedAt) ?? 0) % 1e6\n  const result: AssetId = { assetId, capturedAtLocal: obj.capturedAtLocal, v }\n  if (gt0(obj.durationMs)) {\n    result.durationHMS = durationHMS(obj.durationMs)\n  }\n  return result\n}\n","import {\n  PrimitiveRevision,\n  RevisionValue,\n  SetAddRevision,\n  SetDeleteRevision\n} from \"../../core/tags/MergedTags\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { parseJSON } from \"../../fe/ParseMaybe\"\nimport { Model } from \"./Model\"\n\nexport class AssetRevision extends Model {\n  static override readonly $tableName = \"AssetRevision\"\n\n  static insert(\n    ...arr: (Omit<\n      PrimitiveRevision | SetAddRevision | SetDeleteRevision,\n      \"createdAt\"\n    > & {\n      assetId: number\n    })[]\n  ) {\n    return AssetRevision.ops().insert(\n      arr.map(obj => ({\n        assetId: obj.assetId,\n        createdAt: Date.now(),\n        field: obj.field,\n        op: (obj as any).op,\n        _priorValueJson: stringify((obj as any).priorValue),\n        _newValueJson: stringify((obj as any).newValue)\n      }))\n    )\n  }\n\n  assetId?: number\n  createdAt!: number\n  field!: string\n  op?: \"add\" | \"delete\"\n  _priorValueJson?: string | null\n  _newValueJson?: string | null\n\n  get priorValue(): Maybe<RevisionValue> {\n    return parseJSON(this._priorValueJson)\n  }\n\n  get newValue(): Maybe<RevisionValue> {\n    return parseJSON(this._newValueJson)\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { gt0 } from \"../../fe/Number\"\nimport { Asset } from \"./Asset\"\nimport { ChangedTag } from \"./ChangedTag\"\nimport { Model } from \"./Model\"\nimport { Tag } from \"./Tag\"\n\nconst logger = lazy(() => mkLogger(\"model.AssetTag\"))\n\nexport class AssetTag extends Model {\n  static override readonly $tableName = \"AssetTag\"\n  static override readonly $uniqueColumnName = \"assetId,tagId\"\n  static override readonly $useCache = false\n\n  $pk() {\n    return [\n      orElse(this.assetId, () => map(this.asset, ea => ea.id)),\n      orElse(this.tagId, () => map(this.tag, ea => ea.id))\n    ].join(\":\")\n  }\n\n  asset!: Asset\n  assetId!: number\n\n  tag!: Tag\n  tagId!: number\n\n  static addTagsToAsset(assetId: number, tagIds: number[]) {\n    if (!gt0(assetId)) {\n      logger().warn(\"addTagsToAsset(): invalid assetId\")\n      return\n    }\n    tagIds = tagIds.filter(gt0)\n    if (isEmpty(tagIds)) return\n\n    ChangedTag.upsertChangedTagIds(tagIds)\n    return this.dbl.runf(q =>\n      q\n        .insert(tagIds.map(tagId => ({ assetId, tagId })))\n        .onConflict([\"assetId\", \"tagId\"])\n        .ignore()\n    )\n  }\n\n  static removeTagsFromAsset(assetId: number, tagIds: number[]) {\n    tagIds = tagIds.filter(gt0)\n    if (isEmpty(tagIds)) return\n    ChangedTag.upsertChangedTagIds(tagIds)\n    return this.dbl.runf(q =>\n      q.whereIn(\"tagId\", tagIds).andWhere({ assetId }).delete()\n    )\n  }\n}\n","import { mapNotEmpty } from \"../../fe/Array\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { compressWhitespace } from \"../../fe/String\"\nimport { AssetTag } from \"./AssetTag\"\nimport { Model } from \"./Model\"\n\nexport class ChangedTag extends Model {\n  static override readonly $tableName = \"ChangedTag\"\n  tagId!: number\n  updatedAt?: number\n\n  static upsertChangedTagIds(tagIds: number[]) {\n    const updatedAt = Date.now()\n    return mapNotEmpty(\n      tagIds.filter(gt0).map(tagId => ({ tagId, updatedAt })),\n      arr =>\n        ChangedTag.dbl.runf(q =>\n          q.insert(arr).onConflict(\"tagId\").merge({ updatedAt })\n        )\n    )\n  }\n\n  static onAssetRemoval(assetId: number) {\n    const tagIds = AssetTag.dbl.pluckAllf<number>(q =>\n      q.select(\"tagId\").where({ assetId })\n    )\n    return ChangedTag.upsertChangedTagIds(tagIds)\n  }\n\n  static getAllChangedTags(lagtimeMs?: number): ChangedTagPojo[] {\n    const updatedAt = Date.now() - (lagtimeMs ?? minuteMs)\n    return ChangedTag.dbl.all({\n      sql: compressWhitespace(\n        \" WITH RECURSIVE ancestors(id) AS (\",\n        \"   SELECT\",\n        \"     tagId\",\n        \"   FROM\",\n        \"     ChangedTag\",\n        \"   WHERE\",\n        \"     updatedAt <= \" + updatedAt,\n        \"   UNION\",\n        \"   SELECT\",\n        \"     Tag.parentId\",\n        \"   FROM\",\n        \"     Tag,\",\n        \"     ancestors\",\n        \"   WHERE\",\n        \"     Tag.id = ancestors.id\",\n        \" )\",\n        \" SELECT DISTINCT\",\n        \"   id as tagId,\",\n        \"   ct.updatedAt as updatedAt\",\n        \" FROM\",\n        \"   ancestors\",\n        \" LEFT JOIN ChangedTag AS ct on ct.tagId = ancestors.id\"\n      )\n    }) as any\n  }\n\n  static deleteChangedTag(t: Maybe<ChangedTagPojo>) {\n    return t == null || !gt0(t.tagId)\n      ? undefined\n      : ChangedTag.dbl.runf(q => q.delete().where(t))\n  }\n}\n\nexport type ChangedTagPojo = Pick<ChangedTag, \"tagId\" | \"updatedAt\">\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { mapGt0 } from \"../../core/Number\"\nimport { TagRoots } from \"../../fe/api/Tag\"\nimport { monthTagRef, ordinalToMonth } from \"../curators/DateTagger\"\nimport { Tag } from \"./Tag\"\n\nconst whenQuery = `'${TagRoots.When}' || char(31)`\nconst yearQuery = whenQuery + ` || '%' || char(31)`\nconst monthQuery = yearQuery + ` || '%' || char(31)`\nconst dayQuery = monthQuery + ` || '%' || char(31)`\n\nconst logger = lazy(() => mkLogger(\"model.DateTagNormalizer\"))\n\nexport function getMonthTags() {\n  return Tag.ops().allf(\n    q =>\n      q\n        .whereNotNull(\"ordinal\")\n        .andWhereRaw(\n          \"_path LIKE \" + monthQuery + \" AND _path NOT LIKE \" + dayQuery\n        )\n        .limit(200 * 12) // 200 years of month tags. We can fetch all 2400 into RAM, no need to batch.\n  )\n}\n\nexport async function normalizeDateTags() {\n  for (const ea of getMonthTags()) {\n    normalizeMonthTag(ea)\n  }\n}\n\nexport function normalizeMonthTag(tag: Tag) {\n  const tagRef = mapGt0(tag.ordinal, ord => monthTagRef(ordinalToMonth(ord)))\n  if (tagRef == null) {\n    logger().warn(\"failed to fix tag (no monthTagRef)\", { t: tag })\n  } else if (tagRef.name !== tag.name) {\n    logger().info(\"Fixing month name\", { tagRef, tag })\n    tag.changeName(tagRef.name)\n  }\n  tag.maybeUpsertDisplayName(tagRef?.displayName)\n}\n","import { NoLibraryErrorFlag } from \"../../core/error/ErrorFlags\"\nimport { secondMs } from \"../../fe/Date\"\nimport { lt } from \"../../fe/Number\"\nimport { TimestampedModel } from \"./TimestampedModel\"\n\nexport class Heartbeat extends TimestampedModel {\n  static override readonly $tableName = \"Heartbeat\"\n  static override readonly $uniqueColumnName = \"name\"\n  static override readonly $useCache = false\n\n  name?: string\n\n  static ping(name: string): Heartbeat {\n    return Heartbeat.ops().upsertOne({ name })\n  }\n\n  static assertPing_(name: string = \"ping-\" + Date.now()) {\n    if (Heartbeat.db() == null) {\n      throw new Error(\"no library is open\" + NoLibraryErrorFlag)\n    }\n    // Don't check if the db is open here. If it's not, the db will throw an\n    // error from this.ping().\n    try {\n      Heartbeat.ping(name)\n      const fromDb = Heartbeat.ops().findOneBy({ name })\n      if (\n        fromDb == null ||\n        fromDb.name !== name ||\n        lt(fromDb.updatedAt, Date.now() - 20 * secondMs)\n      ) {\n        throw new Error(\"Heartbeat row wasn't inserted\")\n      }\n    } finally {\n      try {\n        Heartbeat.dbl.runf(q => q.delete().where({ name }))\n      } catch {\n        // don't care, we're just trying to clean up\n      }\n    }\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { time } from \"../../core/async/PromiseTimer\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { hourMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { runTagMaintenance } from \"../tag/TagSql\"\nimport { normalizeDateTags } from \"./DateTagNormalizer\"\nimport { Progress } from \"./Progress\"\n\nexport async function runMaintenanceTasks({ force }: { force?: boolean } = {}) {\n  await _normalizeDateTags() // < never needs to be done more than once\n  await (force === true ? progressVacuum.refresh() : progressVacuum())\n  await (force === true ? runTagMaintenance.force() : runTagMaintenance())\n}\n\nconst _normalizeDateTags = lazy(() =>\n  time(\"db.normalizeDateTags\", normalizeDateTags)\n)\n\nconst progressVacuum = lazy(\n  () => time(\"db.Progress.vacuum\", () => Progress.vacuum()),\n  2 * hourMs\n)\n\nlater(() => {\n  Settings.libraryDir.watchLater(() => {\n    _normalizeDateTags.unset()\n    progressVacuum.unset()\n  })\n})\n","import { Knex } from \"knex\"\nimport { inspect } from \"util\"\nimport { Logger, mkLogger } from \"../../core/Logger\"\nimport { isProd, isTest } from \"../../core/NodeEnv\"\nimport { Constructor } from \"../../core/Object\"\nimport { uid } from \"../../core/UID\"\nimport { Schema } from \"../../core/db/Schemas\"\nimport { includes, notEmptyOr } from \"../../fe/Array\"\nimport { boolToInt, isTrue } from \"../../fe/Boolean\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { fromEntries } from \"../../fe/Object\"\nimport { isPrimitive } from \"../../fe/Primitive\"\nimport { toS } from \"../../fe/toS\"\nimport { Db } from \"../db/Db\"\nimport { DbRequest } from \"../db/DbRequest\"\nimport { DbValue, DbValued } from \"../db/DbValued\"\nimport { knex } from \"../db/Knex\"\nimport { PartialPojo } from \"../db/PartialPojo\"\nimport { modelDb } from \"./ModelDb\"\nimport { ModelInterface } from \"./ModelInterface\"\nimport { assignFromJSON, fromJSON } from \"./ModelJson\"\nimport { ModelOps } from \"./ModelOps\"\nimport { TableName } from \"./TableName\"\n\nexport interface ModelClass<M extends Model> extends Constructor<M> {\n  db(): Db\n  dbl: DbRequest\n  // NOTE TO FUTURE ME: .ops() can't be a getter, as I need to capture the\n  // <this> for typing. :(\n  ops(): ModelOps<M>\n  fromJSON(json: M | PartialPojo<M>): M\n  toJSON(json: M | PartialPojo<M>): DbValued\n  // TODO: remove these methods and make everything go through .ops()?\n  query(): Knex.QueryBuilder\n  queryBy(constraint: PartialPojo<M>): Knex.QueryBuilder\n  queryOneBy(constraint: PartialPojo<M>): Knex.QueryBuilder\n\n  $tableName: TableName\n  $schema: Schema\n  $ctor: string\n  $uniqueColumnName: string\n  $booleanFields?: string[] | readonly string[]\n  $transientFields?: string[] | readonly string[]\n  $useCache?: boolean\n}\n// let id = 0\n\nexport class Model implements ModelInterface {\n  // readonly $id = ++id\n  static readonly $tableName: TableName\n  static readonly $schema: Schema = \"models\"\n  static readonly db = modelDb\n  static readonly $uniqueColumnName: string\n  static readonly $booleanFields?: string[] | readonly string[]\n  static readonly $transientFields?: string[] | readonly string[]\n  static readonly $useCache?: boolean\n\n  static get $ctor() {\n    return this.$schema + \".\" + this.$tableName\n  }\n\n  static query() {\n    return knex()(this.$tableName)\n  }\n\n  static queryBy<M extends Model>(\n    this: ModelClass<M>,\n    constraint: PartialPojo<M>\n  ) {\n    return this.query().where(constraint)\n  }\n\n  static queryOneBy<M extends Model>(\n    this: ModelClass<M>,\n    constraint: PartialPojo<M>\n  ) {\n    return this.queryBy(constraint)\n  }\n\n  static ops<M extends Model>(this: Constructor<M>): ModelOps<M> {\n    return ((this as any)._ops ??= new ModelOps(this as any, (this as any).db))\n  }\n\n  static get dbl(): DbRequest {\n    return this.ops().dbl\n  }\n\n  static rows(): number {\n    return this.ops().rows()\n  }\n\n  static truncate() {\n    if (isProd) {\n      throw new Error(\"rejecting attempt to truncate in prod\")\n    }\n    this.dbl.run(\"DELETE FROM \" + this.$tableName)\n  }\n\n  $ops() {\n    return this.class().ops()\n  }\n\n  id?: number\n\n  // Can't be a getter because getters can't have args and we need to give it\n  // the this:\n  class<M extends Model>(this: M): ModelClass<M> {\n    return this.constructor as any\n  }\n\n  $pk(): string {\n    return toS(this.id)\n  }\n\n  $ucn(): DbValue {\n    return (this as any)[this.class().$uniqueColumnName]\n  }\n\n  $tableName(): string {\n    return this.class().$tableName\n  }\n\n  readonly $instanceId = isTest ? uid() : undefined\n\n  $uid(): string {\n    return `${this.$tableName()}(${this.id ?? this.$ucn()})${\n      (this as any).shown === true ? \"!\" : \"\"\n    }`\n  }\n\n  protected logger(): Logger {\n    return mkLogger(this.class().$schema + \".\" + toS(this.valueOf()))\n  }\n\n  [inspect.custom]() {\n    return { ...this.$toShallowJSON(), $instanceId: this.$instanceId }\n  }\n\n  toString(): string {\n    return this.$uid()\n  }\n\n  // We have to return Object to follow es5\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  valueOf(): Object {\n    return this.$uid()\n  }\n\n  /**\n   * Supports both db and rpc JSON representations\n   */\n  static fromJSON<M extends Model>(\n    this: Constructor<M>,\n    Obj: M | PartialPojo<M>\n  ): M {\n    return fromJSON(this as ModelClass<M>, Obj)\n  }\n\n  static toJSON<M extends Model>(\n    this: ModelClass<M>,\n    m: M | PartialPojo<M>\n  ): DbValued {\n    return this.fromJSON(m).toJSON()\n  }\n\n  $toShallowJSON() {\n    return this.$_toJSON({ encodeBool: isTrue })\n  }\n\n  $toDbJSON(colNames?: string[]): Record<keyof this, DbValue> {\n    return this.$_toJSON({\n      encodeBool: boolToInt,\n      includeCtor: false,\n      includeTransient: false,\n      colNames\n    }) as any\n  }\n\n  $clone(): this {\n    return fromJSON(this.class(), this.toJSON())\n  }\n\n  // used for RPC (millis dates to reduce unnecessary parsing work)\n  toJSON(): PartialPojo<this> {\n    // the m.valueOf removes circular reference errors.\n    // we want date in millis to make date parsing simpler.\n    return this.$_toJSON({ encodeBool: isTrue })\n  }\n\n  _get(\n    key: keyof this & string,\n    encodeBool: (b: any) => any,\n    includeTransient = true\n  ): Maybe<[string, DbValue | null]> {\n    const value = this[key]\n    if (value === null) {\n      return [key, null]\n    }\n    if (!isPrimitive(value)) {\n      // unexpected!\n      return\n    }\n    if (!includeTransient && includes(this.class().$transientFields, key)) {\n      return\n    }\n    if (includes(this.class().$booleanFields, key)) {\n      return [key, encodeBool(value)]\n    }\n    return [key, value]\n  }\n\n  $_toJSON({\n    encodeBool,\n    includeCtor = true,\n    includeTransient = true,\n    colNames\n  }: {\n    encodeBool: (b: any) => any\n    includeCtor?: boolean\n    includeTransient?: boolean\n    colNames?: string[]\n  }): PartialPojo<this> {\n    const mc = this.class()\n    const columnNames = notEmptyOr(colNames, mc.ops().columnNames())\n    return fromEntries(\n      columnNames.map(ea => this._get(ea as any, encodeBool, includeTransient)),\n      includeCtor ? { $ctor: mc.$ctor } : {}\n    ) as any\n  }\n\n  insert(): this {\n    this.logger().debug(\"insert()\", { self: this.toJSON() })\n    return this.class().ops().insertOne(this)\n  }\n\n  upsert(arg?: PartialPojo<this>): this {\n    if (arg != null) assignFromJSON(this, arg)\n    this.logger().debug(\"upsert()\", { self: this.toJSON(), arg })\n    const result = this.class().ops().upsertOne(this)\n    this.$afterUpsert()\n    return result\n  }\n\n  $beforeUpsert() {\n    // no-op, but Timestamped overrides.\n  }\n\n  $afterUpsert() {\n    // no-op, but Tag overrides.\n  }\n\n  reload() {\n    // reloadOne already assigns fetched values to `this`.\n    return this.class().ops().reloadOne(this)\n  }\n\n  delete() {\n    if (gt0(this.id)) {\n      this.class().ops().delete([this.id])\n    }\n  }\n}\n","import { pathToDb } from \"../../core/db/Schemas\"\nimport { libraryDataDirPosixFile } from \"../../core/dir/LibraryDirs\"\nimport { SimpleFileOrString } from \"../../core/fs/SimpleFile\"\nimport { lazy } from \"../../core/Lazy\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { Db } from \"../db/Db\"\n\nexport const modelDb = lazy<Db>(() => undefined as any)\n\nexport function libraryModelDbFile(libraryDir?: Maybe<SimpleFileOrString>) {\n  return map(libraryDataDirPosixFile(libraryDir), ldd =>\n    pathToDb(ldd, \"models\")\n  )\n}\n","import { mkLogger } from \"../../core/Logger\"\nimport { includes, uniq } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { opt } from \"../../fe/Opt\"\nimport { stripPrefixes } from \"../../fe/String\"\nimport { Model, ModelClass } from \"./Model\"\n\nconst ctor2class = new Map<string, ModelClass<any>>()\n\nexport function addModelClass(mc: ModelClass<any>) {\n  ctor2class.set(mc.$ctor, mc)\n}\n\n/**\n * Supports both db and rpc JSON representations\n */\nexport function fromJSON<M extends Model>(caller: ModelClass<M>, json: any): M {\n  if (json == null) {\n    throw new Error(\"json is null\")\n  }\n  if (\n    caller != null &&\n    notBlank(caller.$ctor) &&\n    !ctor2class.has(caller.$ctor)\n  ) {\n    addModelClass(caller)\n  }\n  if (json instanceof caller) {\n    return json as M\n  }\n\n  const mc = opt(json[\"$ctor\"])\n    .flatMap(ea => ctor2class.get(ea))\n    .getOrElse(() => caller)\n  if (json instanceof mc) return json\n  const m = new mc()\n  if (json == null) return m\n  return assignFromJSON(\n    m,\n    json,\n    uniq([caller.$tableName + \".\", mc.$tableName + \".\"])\n  )\n}\n\nexport function assignFromJSON<M extends Model>(\n  m: M,\n  json: any,\n  prefixes: string[] = []\n): M {\n  const mc = m.class()\n  for (const [k, v] of Object.entries(json)) {\n    if (k === \"$ctor\") continue\n    if (v === undefined) continue\n    const key = stripPrefixes(k, prefixes)\n    // If v is NULL, let it be null\n    ;(m as any)[key] =\n      v == null\n        ? v\n        : // if field is boolean, convert to boolean\n        includes(mc.$booleanFields, key)\n        ? isTrue(v)\n        : // otherwise pass through value from db:\n          v\n  }\n  return m\n}\n\nexport function toJSON(\n  m: Maybe<Model | Model[]>,\n  mc: ModelClass<any>,\n  key: string\n): any | any[] {\n  if (m == null) return\n  if (Array.isArray(m))\n    return m.map((ea, idx) => toJSON(ea, mc, `${key}[${idx}]`))\n  if (typeof m.toJSON === \"function\") return m.toJSON()\n  mkLogger(\"ModelJSON.toJSON()\").warn(\"Failed\", { m, key, mc: mc.$ctor })\n  return undefined\n}\n","import { RunResult } from \"better-sqlite3\"\nimport { Knex } from \"knex\"\nimport { batches } from \"../../core/Array\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Logger, mkLogger } from \"../../core/Logger\"\nimport { equalsIgnoreCase } from \"../../core/String\"\nimport { WeakCache } from \"../../core/WeakCache\"\nimport {\n  InternalErrorFlag,\n  NonRetriableErrorFlag\n} from \"../../core/error/ErrorFlags\"\nimport { ee } from \"../../core/event/EventEmitter\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { compact, diff, isNotEmpty, uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank, toNotBlank } from \"../../fe/Blank\"\nimport { flatten } from \"../../fe/Flatten\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map, mapOr } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, toGt0, toInt } from \"../../fe/Number\"\nimport { assignFields, isEmptyObj, keys, pick } from \"../../fe/Object\"\nimport { toA } from \"../../fe/toA\"\nimport { Db } from \"../db/Db\"\nimport { DbRequest } from \"../db/DbRequest\"\nimport { DbValue, toDbValued } from \"../db/DbValued\"\nimport { PartialPojo } from \"../db/PartialPojo\"\nimport { Queryish } from \"../db/SqlQuery\"\nimport { Model, ModelClass } from \"./Model\"\nimport { addModelClass } from \"./ModelJson\"\nimport { TableName } from \"./TableName\"\n\nexport class ModelOps<M extends Model> {\n  readonly dbl: DbRequest\n  readonly #logger: Logger\n  #cacheEnabled: boolean = true\n  readonly #cache = new WeakCache<string, M>()\n  readonly #deletedIds = new Set<number>()\n\n  constructor(\n    readonly model: ModelClass<M>,\n    readonly db: () => Db\n  ) {\n    this.#logger = mkLogger(`ModelOps(${model.$tableName})`)\n    addModelClass(model)\n    this.#cacheEnabled = model.$useCache ?? true\n    this.dbl = new DbRequest(this.db, model.$tableName)\n    ee().on(\"clearCache\", () => this.#cache.clear())\n    ee().on(\"clearDbCache\", () => this.#cache.clear())\n  }\n\n  #assign(dest: PartialPojo<M> | M, src: Maybe<PartialPojo<M> | M>) {\n    assignFields(dest, src, { omitKeys: [\"$instanceId\"], assignNullish: true })\n  }\n\n  clearDbCache() {\n    this.#cache.clear()\n  }\n\n  get $cache() {\n    return this.#cache\n  }\n\n  #maybeCache(m: M) {\n    if (this.#cacheEnabled) {\n      const prior = this.$cachedByJson(m)\n      if (prior != null) {\n        this.#assign(prior, m)\n        return prior\n      } else {\n        const k = this.$pickModelUcn(m) ?? m.id\n        if (k != null) {\n          this.#cache.set(stringify(k), m)\n        }\n      }\n    }\n    return m\n  }\n\n  $cachedByJson(json: M | Record<keyof M, DbValue>) {\n    if (json == null || !this.#cacheEnabled) return\n    const ucn = this.$pickModelUcn(json as any)\n    return (\n      (ucn == null ? undefined : this.#cache.get(stringify(ucn))) ??\n      this.$cachedById((json as any).id)\n    )\n  }\n\n  $cachedById(id: Maybe<number>) {\n    return gt0(id) && this.#cacheEnabled\n      ? this.#cache.get(stringify(id)) ??\n          this.#cache.findEntry(ea => ea.id === id)\n      : undefined\n  }\n\n  get dbOpen(): boolean {\n    return mapOr(\n      this.db(),\n      ea => ea.open,\n      () => false\n    )\n  }\n\n  readonly columnNames = lazy<string[]>(() =>\n    this.db()\n      .tableInfo_()\n      .find(ea => equalsIgnoreCase(ea.tableName, this.tableName))!\n      .columns.map(ea => ea.name)\n  )\n\n  readonly updatableColumnNames = lazy<string[]>(() =>\n    diff(this.columnNames(), this.immutableColumnNames)\n  )\n\n  private get tableName(): TableName {\n    return this.model.$tableName\n  }\n\n  query() {\n    return this.model.query()\n  }\n\n  toDbValued(obj: PartialPojo<M> | M) {\n    const m = this.model.fromJSON(obj)\n    const dbv = toDbValued(m)\n    return pick(dbv, ...this.columnNames())\n  }\n\n  private run(qb: Queryish) {\n    return this.dbl.run(qb)\n  }\n\n  fromJSON(obj: Maybe<any>): Maybe<M> {\n    if (isEmptyObj(obj)) return\n    const result = this.model.fromJSON(obj)\n    return this.#maybeCache(result)\n  }\n\n  fromJSONs(pojos: any[]): M[] {\n    return compact(pojos.map(ea => this.fromJSON(ea as any)))\n  }\n\n  first(qb: Knex.QueryBuilder): Maybe<M> {\n    return this.fromJSON(this.dbl.first(qb))\n  }\n\n  firstf(f: (qb: Knex.QueryBuilder) => Knex.QueryBuilder): Maybe<M> {\n    return this.first(f(this.query()))\n  }\n\n  all(qb: Queryish = this.query()): M[] {\n    return this.fromJSONs(this.dbl.all(qb))\n  }\n\n  allf(f: (qb: Knex.QueryBuilder) => Knex.QueryBuilder): M[] {\n    return this.all(f(this.query()))\n  }\n\n  findOne(qb: Knex.QueryBuilder): Maybe<M> {\n    return this.fromJSON(this.dbl.first(qb))\n  }\n\n  findOneBy(constraint: PartialPojo<M>): Maybe<M> {\n    return this.findOne(this.model.query().where(constraint))\n  }\n\n  findById(id: Maybe<number>, constraint?: PartialPojo<M>): Maybe<M> {\n    return this.findOneBy({ ...constraint, id } as any)\n  }\n\n  findByIds(ids: number[]): M[] {\n    ids = toA(ids).filter(gt0)\n    const cached: M[] = []\n    const uncachedIds: number[] = []\n    for (const id of ids) {\n      const prior = this.$cachedById(id)\n      if (prior != null) cached.push(prior)\n      else uncachedIds.push(id)\n    }\n    const results = batches(\n      uncachedIds,\n      Settings.dbBatchSelectSize.valueOrDefault\n    ).map(arr => this.dbl.all(this.query().whereIn(\"id\", arr)))\n    return sortBy([...cached, ...this.fromJSONs(flatten(results))], ea =>\n      ids.indexOf(ea.id!)\n    )\n  }\n\n  findBy(constraint: PartialPojo<M>): M[] {\n    return this.all(this.model.queryBy(constraint))\n  }\n\n  findWhereIn<K extends keyof M>(column: K, values: M[K][]): M[] {\n    // SITS TODO: remove the as any cast\n    return this.all(this.model.query().whereIn(column as any, values as any))\n  }\n\n  rows(qb?: Knex.QueryBuilder): number {\n    // don't apply count to qb (so countDistinct() will be respected):\n    return this.count(qb ?? this.model.query().count())\n  }\n\n  /**\n   * Count the rows in the given query,\n   */\n  count(qb: Knex.QueryBuilder): number {\n    return toGt0(this.dbl.pluckFirst(qb)) ?? 0\n  }\n\n  countf(f: (qb: Knex.QueryBuilder) => Knex.QueryBuilder): number {\n    return this.count(f(this.query()))\n  }\n\n  insert(arr: (M | PartialPojo<M>)[]): M[] {\n    return toA(arr).map(ea => this.insertOne(ea))\n  }\n\n  upsertOne(t: M | PartialPojo<M>) {\n    return this.modelSupportsUpsert\n      ? this.upsert([t])![0]\n      : this.insertOrUpdateOne(t)\n  }\n\n  insertOrUpdateOne(t: M | PartialPojo<M>) {\n    return t.id == null ? this.insertOne(t) : this.updateOne(t)\n  }\n\n  insertOne(t: M | PartialPojo<M>): M {\n    if (t.id != null) {\n      throw new Error(\n        \"insert called for \" + stringify(t) + NonRetriableErrorFlag\n      )\n    }\n    const m = this.fromJSON(t)\n    if (m == null) {\n      return this.#logger.throw(\n        \"insertOne(): fromJSON returned null\" + InternalErrorFlag,\n        { t }\n      )\n    }\n\n    // we want this instance to be cached:\n    if (m instanceof this.model) this.#maybeCache(m)\n\n    m.$beforeUpsert()\n    const dbJson = m.$toDbJSON(this.columnNames())\n    const runInfo = this.dbl.runf(q => q.insert(dbJson))\n    m.id = toInt(runInfo.lastInsertRowid)\n    m.$afterUpsert()\n    return m\n  }\n\n  unsetField(id: number, fieldName: keyof M) {\n    map(this.$cachedById(id), (ea: any) => {\n      ea[fieldName] = null\n    })\n    return this.dbl.runf(q => q.where({ id }).update(fieldName as string, null))\n  }\n\n  updateOne(t: M | PartialPojo<M>): M {\n    if (t.id == null) {\n      throw new Error(\n        \"update called for \" +\n          stringify(t) +\n          NonRetriableErrorFlag +\n          InternalErrorFlag\n      )\n    }\n    const m = this.model.fromJSON(t)\n    m.$beforeUpsert()\n    const updateRecord = m.$toDbJSON(this.updatableColumnNames())\n    this.dbl.runf(q => q.where({ id: t.id }).update(updateRecord))\n    // There shouldn't be anything to assign back to `t`.\n    m.$afterUpsert()\n    return this.#maybeCache(m) ?? m\n  }\n\n  /**\n   * unique column name (not ID): NOTE THAT THIS MAY BE MULTIPLE COLUMNS (see\n   * ProgressMeta: \"progressId,name\" or AssetTag: \"assetId,tagId\")\n   */\n  get ucn(): string {\n    return toNotBlank(this.model.$uniqueColumnName) ?? \"id\"\n  }\n\n  // TODO: make this return `(keyof M)[]`\n  ucnFieldNames = lazy(() => this.ucn.split(\",\"))\n\n  get modelSupportsUpsert() {\n    return this.ucn != null && this.ucn !== \"id\"\n  }\n\n  get ucnConstraint(): string {\n    return `(${this.ucn})`\n  }\n\n  get immutableColumnNames(): string[] {\n    return uniq([...this.ucnFieldNames(), \"id\", \"createdAt\"])\n  }\n\n  onConflictClause(cols: string[]) {\n    const skip = this.immutableColumnNames\n    const doUpdate = cols\n      .filter(ea => !skip.includes(ea))\n      .sort()\n      .map(ea => `${ea}=excluded.${ea}`)\n      .join(\",\")\n    // https://sqlite.org/lang_UPSERT.html\n    const onConflictArr = [\"ON CONFLICT\", this.ucnConstraint]\n    if (blank(doUpdate)) {\n      onConflictArr.push(\"DO NOTHING\")\n    } else {\n      onConflictArr.push(\"DO UPDATE SET\", doUpdate)\n    }\n    return onConflictArr.join(\" \")\n  }\n\n  #upsertDbJson(jsons: Record<keyof M, DbValue>[]) {\n    const insert = this.query().insert(jsons).toSQL()\n    const setKeys = new Set<string>()\n    for (const json of jsons) {\n      for (const key of keys(json)) {\n        setKeys.add(key)\n      }\n    }\n    const sql = insert.sql + \" \" + this.onConflictClause([...setKeys.values()])\n    const upsert = { sql, bindings: insert.bindings as Knex.Value[] }\n    // NOTE: lastInsertRowid DOES NOT WORK HERE, as the ID will be from a\n    // prior insert if the ON CONFLICT clause runs.\n    this.run(upsert)\n    for (const json of jsons) {\n      const prior = this.$cachedByJson(json)\n      if (prior != null) {\n        this.#assign(prior, this.model.fromJSON(json as any))\n      }\n    }\n  }\n\n  $pickModelUcn(m: Model): Maybe<PartialPojo<M>> {\n    const result: any = {}\n    for (const key of this.ucnFieldNames()) {\n      const v = (m as any)[key]\n      if (v == null) return\n      result[key] = v\n    }\n    return result\n  }\n\n  reloadOne(m: M): Maybe<M> {\n    if (this.#deletedIds.has((m as any).id)) return\n    const bk = this.$pickModelUcn(m)\n    if (bk != null) {\n      // m should win\n      const result = this.#maybeCache(m)\n      const fromDb = this.findOneBy(bk)\n      this.#assign(result, fromDb)\n      if (result !== m) {\n        this.#assign(m, result)\n      }\n      return result\n    } else {\n      this.#logger.warn(\".reloadOne(): failed to reload \" + stringify(m))\n      return // no business key: TODO: throw?\n    }\n  }\n\n  reload(arr: M[]): M[] {\n    return compact(arr.map(ea => this.reloadOne(ea)))\n  }\n\n  upsert(arr: (M | PartialPojo<M>)[], skipReturn = false): M[] {\n    if (!this.modelSupportsUpsert) {\n      return arr.map(ea => this.insertOrUpdateOne(ea))\n    }\n\n    const cols = this.columnNames()\n    const result: M[] = []\n    for (const batchArr of batches(\n      toA(arr),\n      Settings.dbBatchUpsertSize.valueOrDefault\n    )) {\n      const models = compact(batchArr.map(ea => this.fromJSON(ea)))\n      for (const ea of models) {\n        ea.$beforeUpsert()\n      }\n      this.#upsertDbJson(models.map(ea => ea.$toDbJSON(cols)))\n\n      for (const ea of models) {\n        const m = skipReturn ? ea : this.reloadOne(ea) ?? ea\n        m.$afterUpsert()\n        result.push(m)\n      }\n    }\n    return result\n  }\n\n  delete(ids: number[]): Maybe<RunResult> {\n    const arr = toA(ids).filter(gt0)\n    for (const ea of arr) {\n      this.#deletedIds.add(ea)\n    }\n    this.#cache.deleteValueIf(ea => arr.includes(ea.id!))\n    return this.run(this.model.query().delete().whereIn(\"id\", arr))\n  }\n\n  /**\n   * @param q the query will have an .orderBy(\"id\", \"asc\") added.\n   */\n  batched(opts: {\n    onResults: (arr: M[]) => any\n    qb: (q: Knex.QueryBuilder) => Knex.QueryBuilder\n  }) {\n    const limit = Settings.dbBatchSelectSize.valueOrDefault\n    let prior: Maybe<M[]>\n    let maxId: Maybe<number>\n    do {\n      prior = this.allf(q => {\n        q = opts.qb(q)\n        if (maxId != null) q = q.andWhere(\"id\", \">\", maxId)\n        return q.orderBy(\"id\", \"asc\").limit(limit)\n      })\n      if (isNotEmpty(prior)) {\n        maxId = Math.max(...prior.map(ea => ea.id!))\n        opts.onResults(prior)\n      }\n    } while (isNotEmpty(prior))\n  }\n}\n","import { Knex } from \"knex\"\nimport { ending } from \"../../core/async/Endable\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { identity } from \"../../core/Object\"\nimport { blank } from \"../../fe/Blank\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\nimport { SyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { PartialPojo } from \"../db/PartialPojo\"\nimport { TimestampedModel } from \"./TimestampedModel\"\n\n// TODO: rebuild, rebuild-assets (just rebuilds assets), sync-asset, ...\nexport const OperationNames = strEnum(\n  \"rebuildLibrary\",\n  \"forceRestartSync\",\n  \"enqueueAssetFileUpdates\",\n  \"enqueueAssetUpdates\",\n  \"applyNewTagger\",\n  // Actually exclude all excluded assets:\n  \"applyExcluded\",\n  // Actually delete all assets marked as deleted:\n  \"applyDeleted\"\n)\nexport type OperationName = StrEnumKeys<typeof OperationNames>\n\nconst logger = lazy(() => mkLogger(\"model.Operation\"))\n\n// TODO: REPLACE \"Operations\" with non-transient events?\n\nexport class Operation extends TimestampedModel {\n  static override readonly $tableName = \"Operation\"\n  static override readonly $uniqueColumnName = \"id\"\n  name!: OperationName\n  value?: string\n  version?: number\n  completedAt?: number\n\n  static incomplete() {\n    return this.ops().allf(q =>\n      q.whereIn(\"id\", q2 =>\n        q2.table(Operation.$tableName).min(\"id\").whereNull(\"completedAt\")\n      )\n    )\n  }\n\n  /**\n   * Ensure there's an incomplete/pending Operation with the given attributes\n   */\n  static ensurePendingOp(Obj: Pick<Operation, \"name\" | \"value\">): Operation {\n    return Operation.getFirstPendingOp(Obj) ?? Operation.ops().insertOne(Obj)\n  }\n\n  static getFirstPendingOp(crit?: PartialPojo<Operation>) {\n    return logger().tap({\n      msg: \"getFirstPendingOp\",\n      level: \"info\",\n      result: this.ops().firstf(q => {\n        // We want the earliest incomplete op (order by id desc)\n        const result = q.whereNull(\"completedAt\").orderBy(\"createdAt\", \"asc\")\n        return crit != null ? result.andWhere(crit) : result\n      }),\n      meta: { crit }\n    })\n  }\n\n  static markOpCompleted(\n    crit: Pick<Operation, \"name\" | \"value\" | \"version\">,\n    update?: Pick<Operation, \"value\">\n  ) {\n    if (blank(crit?.name))\n      return logger().throw(\"markOpCompleted(): bad query\", { crit })\n    return this.dbl.runf(q =>\n      q\n        .whereNull(\"completedAt\")\n        .andWhere(crit)\n        .update({ completedAt: Date.now(), ...update })\n    )\n  }\n\n  static async applyIfPending<T>(\n    crit: Pick<Operation, \"name\" | \"value\" | \"version\">,\n    f: (op: Operation) => Promise<T>\n  ): PromiseMaybe<T> {\n    const op = this.ops().firstf(q => q.whereNull(\"completedAt\").andWhere(crit))\n    logger().info(\"applyIfPending()\", { crit, op })\n    return op == null ? undefined : f(op)\n  }\n\n  static async applyOnce<T>(\n    crit: Pick<Operation, \"name\" | \"value\" | \"version\">,\n    f: (op: Operation) => SyncOrAsync<T>,\n    qb: (ea: Knex.QueryBuilder) => Knex.QueryBuilder = identity\n  ): PromiseMaybe<T> {\n    const priorCompleted = this.ops().firstf(q =>\n      qb(q.whereNotNull(\"completedAt\").andWhere(crit))\n    )\n\n    if (priorCompleted != null) {\n      logger().debug(\"applyOnce(): already done\", { priorCompleted })\n      return\n    }\n    const op = this.ops().insertOne(crit)\n    const result = await f(op)\n    if (!ending()) {\n      op.upsert({ completedAt: Date.now() })\n    }\n    return result\n  }\n}\n","import { hostname } from \"os\"\nimport { pid } from \"process\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { InternalErrorFlag } from \"../../core/error/ErrorFlags\"\nimport { isRaspberryPi } from \"../../core/platform/isRaspberryPi\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { maxCpus } from \"../../core/work/MaxCpus\"\nimport { compactBlanks, isNotEmpty } from \"../../fe/Array\"\nimport { dayMs, secondMs } from \"../../fe/Date\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, MaybePromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { fromEntries, omit } from \"../../fe/Object\"\nimport { parseJSON } from \"../../fe/ParseMaybe\"\nimport { thenCollect } from \"../../fe/Promise\"\nimport { compressWhitespace } from \"../../fe/String\"\nimport { ProgressState, SyncStatus } from \"../../fe/api/ProgressState\"\nimport { toA } from \"../../fe/toA\"\nimport { assignFromJSON } from \"./ModelJson\"\nimport { Operation, OperationNames } from \"./Operation\"\nimport {\n  ProgressMeta,\n  ProgressMetaName,\n  ProgressMetaRecord\n} from \"./ProgressMeta\"\nimport { TableName } from \"./TableName\"\nimport { TimestampedModel } from \"./TimestampedModel\"\n\nconst logger = lazy(() => mkLogger(\"model.Tag\"))\n\nexport interface ProgressPojo extends ProgressState {\n  id: number\n  uri: string\n  completedAt?: number\n}\n\nexport type ProgressUpdatePojo = Omit<ProgressState, \"volume\" | \"uri\"> &\n  Pick<Progress, \"updatedAt\" | \"completedAt\">\n\n// Slower progress rate if we don't have free CPUs:\nexport const ProgressRateMs = lazy(\n  () => secondMs * (isRaspberryPi() || maxCpus() <= 3 ? 5 : 2)\n)\n\nexport interface ProgressTimes {\n  uri: string\n  lastProgressId: number\n  lastStartedAt: number\n  lastUpdatedAt: number\n  lastCompletedAt: Maybe<number>\n}\n\nconst ProgressTimesQuery = compressWhitespace(`\nSELECT\n  p1.uri,\n  p1.id as lastProgressId,\n  p1.createdAt as lastStartedAt,\n  p1.updatedAt as lastUpdatedAt,\n  p3.lastCompletedAt\nFROM\n  Progress AS p1\n  JOIN (\n    SELECT\n      uri,\n      max(updatedAt) AS lastUpdatedAt\n    FROM\n      Progress\n    WHERE createdAt > :minCreatedAt\n    GROUP BY\n      1\n  ) AS p2 ON p1.uri = p2.uri\n  AND p1.updatedAt = p2.lastUpdatedAt\n  LEFT JOIN (\n    SELECT\n      uri,\n      max(completedAt) AS lastCompletedAt\n    FROM\n      Progress\n    WHERE\n      createdAt > :minCreatedAt\n      AND CAST(completedAt AS int) > 0\n    GROUP BY\n      1\n  ) AS p3 ON p1.uri = p3.uri\nWHERE p1.createdAt > :minCreatedAt\nGROUP BY\n  p1.uri`)\n\nfunction stringifyDek(dek: string[]) {\n  return stringify(compactBlanks(toA(dek)))\n}\n\nexport function defaultMinCreatedAt() {\n  const d = Settings.progressStaleDays.valueOrDefault\n  return d <= 0 ? 0 : Date.now() - d * dayMs\n}\n\n/**\n * Holds per-volume information rendered to the UI by progress-panel. We delete\n * records older than 90 days, so we expect max ~ new sync job every hour: 2,160\n * rows (so we only bother with an index on updatedAt to help performance of\n * ProgressRouter)\n */\nexport class Progress\n  extends TimestampedModel\n  implements Omit<ProgressPojo, \"id\">\n{\n  static override readonly $tableName: TableName = \"Progress\"\n  static override readonly $uniqueColumnName = \"id\" as const\n  uri!: string\n  hostname!: string\n  pid!: number\n  volume!: string\n  state?: SyncStatus\n  hed?: string\n  dekJSON?: string\n  completePct?: number\n  incompletePct?: number\n  scanningPct?: number\n  completedAt?: number\n\n  // we only look back 30 days for last-started-at times\n  static vacuum(\n    staleMs = Settings.progressRetentionDays.valueOrDefault * dayMs\n  ) {\n    const staleAt = Date.now() - staleMs\n    const victimIds = this.dbl.pluckAllf<number>(q =>\n      q.select(\"id\").where(\"createdAt\", \"<=\", staleAt)\n    )\n\n    const metaVictimIds = ProgressMeta.dbl.pluckAllf<number>(q =>\n      q.select(\"id\").whereIn(\"progressId\", victimIds)\n    )\n    ProgressMeta.ops().delete(metaVictimIds)\n    Progress.ops().delete(victimIds)\n  }\n\n  // don't cache this! Operations can be completed!\n\n  static minCreatedAt() {\n    const op = Operation.getFirstPendingOp({\n      name: OperationNames.forceRestartSync\n    })\n    return logger().tap({\n      msg: \"minCreatedAt\",\n      level: \"info\",\n      result: op?.createdAt ?? defaultMinCreatedAt(),\n      meta: { op }\n    })\n  }\n\n  static times(): Promise<ProgressTimes[]> {\n    const minCreatedAt = this.minCreatedAt()\n    return logger().tap({\n      msg: \"times()\",\n      result: this.dbl.all({\n        sql: ProgressTimesQuery,\n        bindings: { minCreatedAt }\n      }) as any,\n      meta: { minCreatedAt }\n    })\n  }\n\n  static async saveSyncState(sync: {\n    progress: () => MaybePromiseMaybe<Progress | Progress[]>\n  }): Promise<Progress[]> {\n    return thenCollect(toA(await sync.progress()), ea => {\n      if (ea.state === \"done\" && ea.completedAt == null) {\n        ea.completedAt = Date.now()\n      }\n      if (ea.id == null) {\n        return logger().throw(\n          \"saveSyncState() returned an unsaved Progress\" + InternalErrorFlag,\n          ea\n        )\n      }\n      return ea.upsert()\n    })\n  }\n\n  static insertNew(\n    obj: { uri: string; volume: string } & Partial<\n      Omit<ProgressPojo, \"uri\" | \"volume\">\n    >\n  ) {\n    const dekJSON = map(obj.dek, stringify)\n    return this.ops().insertOne({\n      ...omit(obj, \"dek\"),\n      pid,\n      hostname: hostname(),\n      dekJSON\n    })\n  }\n\n  // TODO: save recent asset ids to the db in this table, instead of requiring a\n  // query?\n\n  toSyncState(): ProgressPojo {\n    return {\n      id: this.id!,\n      uri: this.uri,\n      volume: this.volume,\n      state: this.state,\n      hed: this.hed,\n      dek: this.dek,\n      completePct: this.completePct,\n      incompletePct: this.incompletePct,\n      scanningPct: this.scanningPct\n    }\n  }\n\n  get dek(): string[] {\n    return compactBlanks(parseJSON<string>(this.dekJSON))\n  }\n\n  set dek(arr: string[]) {\n    this.dekJSON = stringifyDek(arr)\n  }\n\n  assignFromPojo(Obj: ProgressUpdatePojo) {\n    return assignFromJSON(this, omit(Obj as any, \"volume\", \"uri\"))\n  }\n\n  getThisMeta() {\n    return ProgressMeta.ops().allf(q =>\n      q.where({ progressId: this.id! }).orderBy(\"createdAt\")\n    )\n  }\n\n  getPriorIncompleteProgress() {\n    const minCreatedAt = Progress.minCreatedAt()\n    const prior = Progress.ops().firstf(q =>\n      q\n        .where({ hostname: this.hostname, uri: this.uri })\n        .andWhere(\"createdAt\", \">\", minCreatedAt)\n        .orderBy(\"updatedAt\", \"desc\")\n        .limit(1)\n    )\n    if (prior?.completedAt != null) {\n      return this.logger().tap({\n        msg: \"priorIncompleteProgress(): last Progress was complete\",\n        result: undefined,\n        meta: { prior }\n      })\n    } else {\n      return this.logger().tap({\n        msg: \"priorIncompleteProgress()\",\n        result: prior\n      })\n    }\n  }\n\n  getPriorIncompleteMeta() {\n    return this.getPriorIncompleteProgress()?.getThisMeta()\n  }\n\n  getMeta() {\n    const thisMeta = this.getThisMeta()\n    if (isNotEmpty(thisMeta)) {\n      return thisMeta\n    } else {\n      const priorMeta = this.getPriorIncompleteMeta()\n      if (isNotEmpty(priorMeta)) {\n        this.logger().info(\"getMeta(): inheriting prior progress\", priorMeta)\n        return ProgressMeta.ops().upsert(\n          priorMeta.map(ea => ({\n            progressId: this.id,\n            name: ea.name,\n            value: ea.value\n          })),\n          false\n        )\n      } else {\n        this.logger().info(\"getMeta(): no relevant prior progress\")\n        return []\n      }\n    }\n  }\n\n  setMeta(name: ProgressMetaName, value: string) {\n    this.logger().debug(\"setMeta()\", { progressId: this.id, name, value })\n    return ProgressMeta.ops().upsertOne({ progressId: this.id, name, value })\n  }\n\n  deleteMeta(...names: ProgressMetaName[]) {\n    this.logger().debug(\"deleteMeta()\", { progressId: this.id, names })\n    return ProgressMeta.dbl.runf(q =>\n      q.whereIn(\"name\", names).andWhere({ progressId: this.id }).delete()\n    )\n  }\n\n  deleteAllMeta() {\n    this.logger().debug(\"deleteAllMeta()\", { progressId: this.id })\n    return ProgressMeta.dbl.runf(q => q.where({ progressId: this.id }).delete())\n  }\n\n  getMetaAsRecord(): ProgressMetaRecord {\n    return this.logger().tap({\n      msg: \"getMetaAsRecord()\",\n      result: fromEntries(this.getMeta().map(ea => [ea.name, ea.value])) ?? {}\n    })\n  }\n}\n","import { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\nimport { TimestampedModel } from \"./TimestampedModel\"\n\nexport const ProgressMetaNames = strEnum(\n  \"lastScannedDirectory\",\n  \"scannedDirectoryCount\",\n  \"completedDirectoryScan\",\n  \"enqueuedStaleFiles\",\n  \"processedImageCount\",\n  \"processedVideoCount\",\n  \"completedDirectorySync\"\n)\nexport type ProgressMetaName = StrEnumKeys<typeof ProgressMetaNames>\n\nexport class ProgressMeta extends TimestampedModel {\n  static override readonly $tableName = \"ProgressMeta\"\n  static override readonly $uniqueColumnName = \"progressId,name\"\n  name!: ProgressMetaName\n  value!: string\n}\n\nexport type ProgressMetaRecord = Record<ProgressMetaName, string>\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { ee } from \"../../core/event/EventEmitter\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { SimpleFile } from \"../../core/fs/SimpleFile\"\nimport { isBadSha } from \"../../core/img/AssetPreviewBuilder\"\nimport { isEmpty, uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { DbRequest } from \"../db/DbRequest\"\nimport { modelDb } from \"./ModelDb\"\n\n// This is implementation doesn't extend from Model as it doesn't have an ID or\n// timestamps (or anything, really)\n\nconst logger = lazy(() => mkLogger(\"model.ShaBlocklist\"))\n\nconst dbr = lazy(() => new DbRequest(modelDb, \"ShaBlocklist\"))\n\nexport async function notBlocklistedSha(file: string | SimpleFile) {\n  if (modelDb() == null) return null\n  const result = isShaBlockslisted(await PosixFile.for(file).sha())\n  return result == null ? null : !result\n}\nexport function isShaBlockslisted(sha: Maybe<string>) {\n  if (modelDb() == null || blank(sha)) return false\n  return logger().tap({\n    msg: \"isShaBlockslisted\",\n    result: null != dbr().pluckFirstf(q => q.where({ sha }).limit(1)),\n    meta: { sha }\n  })\n}\n\nexport async function upsertFileToShaBlockslist(file: string | SimpleFile) {\n  if (modelDb() == null) return\n  const sha = await PosixFile.for(file).sha()\n  return sha == null ? undefined : upsertToShaBlockslist(sha)\n}\n\nexport function upsertToShaBlockslist(...shas: string[]) {\n  if (modelDb.prior() == null) return\n  const data = uniq(shas).map(sha => ({ sha }))\n  return isEmpty(data) ? undefined : dbr().upsert(q => q.insert(data))\n}\n\nexport const listenForInvalidFiles = lazy(() => {\n  ee().on(\"invalidFile\", upsertFileToShaBlockslist)\n})\n\nexport const installBadShaShim = lazy(() => {\n  isBadSha.setShim(isShaBlockslisted)\n})\n","import { Knex } from \"knex\"\nimport { ee } from \"../../core/event/EventEmitter\"\nimport { lazy, MemoizedThunk } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { prngOrderByClause } from \"../../core/math/PRNG\"\nimport { mapGt0 } from \"../../core/Number\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { ShortCommandTimeoutMs } from \"../../core/ShortCommandTimeoutMs\"\nimport { includesIgnoreCase } from \"../../core/String\"\nimport { joinTagPath, splitTagPath, TagSep } from \"../../core/tags/TagPaths\"\nimport { AssetId, PathTag } from \"../../fe/api/Asset\"\nimport {\n  ApiTag,\n  BeforeAfterStreamLimit,\n  ChildTagCriteria,\n  TagAssetsCriteria,\n  TagPath,\n  TagRef,\n  TagRoots,\n  ThumbsPerSample\n} from \"../../fe/api/Tag\"\nimport { compact, compactBlanks, isEmpty } from \"../../fe/Array\"\nimport { blank, mapNotBlank, toNotBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { eql } from \"../../fe/Eql\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, mapNumeric } from \"../../fe/Number\"\nimport { cmp } from \"../../fe/Primitive\"\nimport { thenCollect } from \"../../fe/Promise\"\nimport { compressWhitespace } from \"../../fe/String\"\nimport { fmt, plur } from \"../../fe/Units\"\nimport { Roots } from \"../curators/Taggers\"\nimport { knex } from \"../db/Knex\"\nimport { PartialPojo } from \"../db/PartialPojo\"\nimport { Asset } from \"./Asset\"\nimport { toAssetId } from \"./AssetId\"\nimport { AssetTag } from \"./AssetTag\"\nimport { TableName } from \"./TableName\"\nimport { TaggedAssetStream } from \"./TaggedAssetStream\"\nimport { TimestampedModel } from \"./TimestampedModel\"\n\nfunction orderBy(builder: Knex.QueryBuilder) {\n  return builder.orderByRaw(\"COALESCE(ordinal, _path) COLLATE NOCASE\")\n}\n\nconst logger = lazy(() => mkLogger(\"model.Tag\"))\n\nlater(() => {\n  ee().on(\"clearCache\", () => Tag.clear())\n  ee().on(\"clearDbCache\", () => Tag.clear())\n})\n\nconst AssetCountForTag = compressWhitespace(\n  \"WITH RECURSIVE descendants(id) AS (\",\n  \"  VALUES (:tagId)\",\n  \"  UNION\",\n  \"  SELECT Tag.id\",\n  \"  FROM Tag, descendants\",\n  \"  WHERE Tag.parentId = descendants.id\",\n  \")\",\n  \"SELECT\",\n  \"  count(DISTINCT Asset.id) AS assetCount\",\n  // \"  count(DISTINCT AssetFile.id) AS assetFileCount\",\n  \"FROM\",\n  \"  descendants\",\n  \"  JOIN AssetTag ON AssetTag.tagId = descendants.id\",\n  \"  JOIN Asset ON Asset.id = AssetTag.assetId\",\n  // \"  JOIN AssetFile ON AssetFile.assetId = Asset.id\",\n  \"WHERE\",\n  \"  Asset.shown = 1\",\n  \"  AND Asset.hidden = 0\",\n  \"  AND Asset.excludedAt IS NULL\",\n  \"  AND Asset.deletedAt IS NULL\"\n)\n\nexport class Tag extends TimestampedModel implements TagRef {\n  static override readonly $tableName: TableName = \"Tag\"\n  static override readonly $uniqueColumnName = \"_path\"\n  // Attempt to fix foreign key constraints failures error from @avdp:\n  // \"sql\":\"insert into Tag (_displayName, _path, assetCount, createdAt, id,\n  // ordinal, parentId, updatedAt) values (?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT\n  // (_path) DO UPDATE SET\n  // _displayName=excluded._displayName,assetCoun…tId,updatedAt=excluded.updatedAt\",\"bindings\":[\"Jan\",\"fs\\u001f\",0,1691671043786,3,12,2,1691671999051]}}\n  static override readonly $useCache = false\n\n  static readonly cmp = (a: Tag, b: Tag) =>\n    cmp(\n      [a.ordinal ?? Number.MAX_SAFE_INTEGER, ...a.path],\n      [b.ordinal ?? Number.MAX_SAFE_INTEGER, ...b.path]\n    )\n\n  static clear() {\n    this.root.unset()\n    this.roots.unset()\n    this._upsertDefaultRoots.unset()\n  }\n\n  static validate_() {\n    for (const bad of this.ops().allf(q => q.whereRaw(\"id = parentId\"))) {\n      logger().warn(\n        `Tag ${bad.id} has itself as parentId. Attempting to fix...`\n      )\n      const parentPath = bad.path.slice(0, -1)\n      const parent = isEmpty(parentPath)\n        ? undefined\n        : this.findOrCreate(parentPath)\n      bad.upsert({ parentId: parent?.id ?? null })\n    }\n    for (const ea of Tag.roots()) {\n      ea.validate_([])\n    }\n  }\n\n  validate_(expectedParentPath: string[]) {\n    const path = this.path\n    if (!eql(path.slice(0, -1), expectedParentPath)) {\n      throw new Error(\n        `Tag:${this.id} path ${path.join(\n          \"/\"\n        )} does not match expected parent ${expectedParentPath.join(\"/\")}`\n      )\n    }\n    for (const ea of this.getChildren()) {\n      ea.validate_(path)\n    }\n  }\n\n  static cacheTags(arr: Tag[]) {\n    return arr.map(ea => this.cacheTag(ea))\n  }\n\n  static cacheTag(tag: Maybe<Tag>): Maybe<Tag> {\n    // if (tag != null) this.recentTagsByPath.set(tag._path, tag)\n    if (tag?.parentId === 0) {\n      this.root.unset()\n    }\n    return tag\n  }\n\n  static readonly root = lazy(() => {\n    const root = new Tag()\n    root.id = 0\n    // root.name = \"\" // DON'T SET .name, it's always derived from _path.\n    root._path = TagSep\n    root.parentId = undefined\n    root.children = Tag.roots().filter(\n      ea =>\n        !includesIgnoreCase(Settings.hiddenHomeTags.valueOrDefault, ea.name) &&\n        !includesIgnoreCase(\n          Settings.hiddenHomeTags.valueOrDefault,\n          ea.description ?? \"\"\n        )\n    )\n    root.ancestors = []\n    root.assetCount = Asset.shownCount()\n    root.upsert = () => {\n      throw new Error(\"upsert not supported on root\")\n    }\n    return root\n  }, ShortCommandTimeoutMs) // so Tag.roots() gets refreshed\n\n  private static readonly _upsertDefaultRoots = lazy(() =>\n    Tag.ops().upsert(\n      Roots.map(\n        ea =>\n          ({\n            _path: joinTagPath([ea.name]),\n            ordinal: ea.ordinal\n          }) as PartialPojo<Tag>\n      )\n    )\n  )\n\n  static withNullAssetCount(): number[] {\n    return Tag.dbl.pluckAll({\n      sql: compressWhitespace(\n        \"WITH RECURSIVE ancestors(id) AS (\",\n        \"  SELECT id FROM Tag where assetCount IS NULL\",\n        \"  UNION ALL\",\n        \"  SELECT Tag.parentId as id\",\n        \"  FROM Tag, ancestors\",\n        \"  WHERE Tag.id = ancestors.id\",\n        \")\",\n        \"SELECT distinct(id)\",\n        \"FROM ancestors\"\n      )\n    })\n  }\n\n  static selfAndAncestorIds(ids: number[]): number[] {\n    return Tag.dbl.pluckAll({\n      sql: compressWhitespace(\n        \"WITH RECURSIVE ancestors(id) AS (\",\n        `  SELECT id FROM Tag where assetCount in (${ids\n          .filter(gt0)\n          .join(\",\")})`,\n        \"  UNION ALL\",\n        \"  SELECT Tag.parentId as id\",\n        \"  FROM Tag, ancestors\",\n        \"  WHERE Tag.id = ancestors.id\",\n        \")\",\n        \"SELECT distinct(id)\",\n        \"FROM ancestors\"\n      )\n    })\n  }\n\n  static updateAssetCount(tagId: number) {\n    if (!gt0(tagId)) return\n    const assetCount = Tag.dbl.pluckFirst({\n      sql: AssetCountForTag,\n      bindings: { tagId }\n    })\n    Tag.dbl.runf(q =>\n      q.update({ assetCount, updatedAt: Date.now() }).where({ id: tagId })\n    )\n    logger().debug(\"Updated asset counts for tag \", { tagId, assetCount })\n  }\n\n  // afterUpsert will only clear this if new root tags are added\n  static readonly roots = lazy<Tag[]>(() => {\n    Tag._upsertDefaultRoots() // < this is lazy, so\n    const tags = Tag.ops().all(orderBy(Tag.query().whereNull(\"parentId\")))\n    tags.forEach(ea => {\n      ea.parentId = undefined\n      ea.ancestors = []\n      Tag.cacheTag(ea)\n    })\n    return tags\n  }, ShortCommandTimeoutMs) // < TTL is important! Without this, tag counts don't update!\n\n  static #newTag(tagPath: TagPath): Tag {\n    const t = new Tag()\n    t._path = joinTagPath(tagPath)\n    const d = tagPath[tagPath.length - 1] as any\n    if (typeof d === \"object\") {\n      mapNotBlank(d.displayName, ea => (t._displayName = ea))\n      mapNumeric(d.ordinal, ea => (t.ordinal = ea))\n      mapNotBlank(d.description, ea => (t.description = ea))\n      mapNumeric(d.releasedAt, ea => (t.releasedAt = ea))\n    }\n    return t\n  }\n\n  static findByIdOrPath(tagId: Maybe<number>, tagPath: string[]) {\n    return tagId === 0\n      ? Tag.root()\n      : gt0(tagId)\n      ? this.findById(tagId)\n      : this.findByPath(tagPath)\n  }\n\n  static findById(tagId: number) {\n    return tagId === 0 ? Tag.root() : this.ops().findById(tagId)\n  }\n\n  static findByPath(tagPath: TagPath): Maybe<Tag> {\n    if (isEmpty(tagPath)) return Tag.root()\n    const _path = joinTagPath(tagPath)\n    return this.ops().firstf(q => q.whereLike(\"_path\", _path))\n    // return Tag.recentTagsByPath.getOrSet(_path, () =>\n    //   map(\n    //     // LIKE gives us case insensitivity:\n    //     this.ops().firstf(q => q.whereLike(\"_path\", _path)),\n    //     ea => Tag.tagById.set(ea.id!, ea)\n    //   )\n    // )\n  }\n\n  static getPagedAssets(tagId: number, crit: TagAssetsCriteria) {\n    const t = new Tag()\n    t.id = tagId\n    return t.getPagedAssetIds(crit)\n  }\n\n  static findOrCreate(tagPath: TagPath): Tag {\n    if (isEmpty(tagPath)) {\n      throw new Error(\"empty tagPath\")\n    }\n    // const path = joinTagPath(tagPath, \"/\")\n    const prior = this.findByPath(tagPath) as Tag\n    // this.logger().debug(\"_findOrCreate(\" + path + \")\", { prior })\n    if (prior != null) {\n      return prior\n    }\n\n    const newTag = this.#newTag(tagPath)\n    const parent =\n      newTag.depth <= 1 ? undefined : this.findOrCreate(tagPath.slice(0, -1))\n    map(parent, p => (newTag.parentId = p.id!))\n\n    const result = Tag.cacheTag(this.ops().upsertOne(newTag))!\n    // this.logger().debug(\"_findOrCreate(\" + path + \") upserted\", {\n    //   newTag,\n    //   result,\n    //   parent\n    // })\n    return result\n  }\n\n  id?: number\n  parentId?: number | null\n  ordinal?: number\n\n  // The _path is required and must be unique. It's used for navigation.\n  _path!: string\n\n  // \"_displayName\" is optional, and used when the \"canonical\" name differs from\n  // the \"display\" name.\n\n  // \"_displayName\" allows for more friendly tag names in the UI (for\n  // month name localization or to replace the \"volsha\" in filesystem paths with the label\n  // of the device).\n\n  _displayName?: string\n  description?: string\n  releasedAt?: number\n  assetCount?: number\n\n  parent?: Tag\n  root?: Tag\n  children?: Tag[]\n  ancestors?: Tag[]\n  assets?: Asset[]\n\n  /**\n   * Holds the last-fetched related assets from `getRelatedAssets`\n   */\n  relatedAssets?: Asset[]\n  nextBatchUrl?: string\n\n  clear() {\n    this.parent = undefined\n    this.root = undefined\n    this.children = undefined\n    this.ancestors = undefined\n    this.assets = undefined\n    this.relatedAssets = undefined\n    this.ancestorIds.unset()\n    return this\n  }\n\n  $afterUpsert() {\n    Tag.cacheTag(this)\n  }\n\n  siblingPath(name: string) {\n    return joinTagPath([...this.parentPath, name])\n  }\n\n  changeName(name: string) {\n    return this.changePath(this.siblingPath(name))\n  }\n\n  maybeUpsertDisplayName(displayName: Maybe<string>) {\n    return blank(displayName) || displayName === this._displayName\n      ? undefined\n      : this.upsert({ _displayName: displayName } as any)\n  }\n\n  changePath(newPath: string, finallyClear = true) {\n    const priorPath = this._path\n\n    // If a sibling already exists, they win.\n    const existingSibling = Tag.findByPath(splitTagPath(newPath))\n\n    this.logger().info(\"changePath(): \", {\n      priorPath,\n      newPath,\n      existingSibling\n    })\n\n    try {\n      if (existingSibling == null) {\n        Tag.dbl.runf(q =>\n          q.whereLike(\"_path\", priorPath + \"%\").update({\n            updatedAt: Date.now(),\n            _path: knex().raw(\"REPLACE(_path, ?, ?)\", [priorPath, newPath])\n          })\n        )\n        this._path = newPath\n      } else {\n        // OH NOES. I'm about to get deleted. Give my children to existingSibling.\n        newPath = existingSibling._path // < deal with case insensitivity\n        this.logger().info(\"changePath(): replacing with sibling\", newPath)\n\n        // Make sure my assets are still tagged:\n        AssetTag.dbl.upsert(q =>\n          q.where({ tagId: this.id }).update({ tagId: existingSibling.id })\n        )\n        AssetTag.dbl.runf(q => q.where({ tagId: this.id }).delete())\n\n        // TODO: make this one big batch command instead of doing it in node:\n        for (const ea of this.getChildren()) {\n          ea.changePath(joinTagPath([...existingSibling.path, ea.name]), false)\n        }\n\n        // At this point my child tags will have been either deleted, if they were duplicated by `existingSibling`, or they need to be re-parented:\n        Tag.dbl.runf(q =>\n          q\n            .where({ parentId: this.id })\n            .update({ parentId: existingSibling.id })\n        )\n        this.delete()\n      }\n    } finally {\n      if (finallyClear) Tag.clear()\n    }\n  }\n\n  get name(): string {\n    const p = this.path\n    return p[p.length - 1]\n  }\n\n  get path(): string[] {\n    return splitTagPath(this._path)\n  }\n\n  get displayName() {\n    return toNotBlank(this._displayName) ?? this.name\n  }\n\n  // Watch out for the root tag: it should be [], not [\"\"]!\n  readonly displayPath: MemoizedThunk<string[]> = lazy(() => {\n    const p = this.getParent()\n    return compactBlanks([\n      ...(p == null ? [] : p.displayPath()),\n      this.displayName\n    ])\n  })\n\n  get isRoot(): boolean {\n    return this.id === 0\n  }\n\n  get depth(): number {\n    return this.path.length\n  }\n\n  get parentPath(): string[] {\n    return this.path.slice(0, -1)\n  }\n\n  get sortBy() {\n    return [\n      this.depth,\n      this.ordinal == null ? 2 ** 51 : this.ordinal,\n      this.path.map(ea => ea.toLowerCase())\n    ]\n  }\n\n  $childrenQuery() {\n    return orderBy(Tag.query().where({ parentId: this.id }))\n  }\n\n  $assetsQuery() {\n    return Asset.shownUnhidden()\n      .columns(\"Asset.*\")\n      .join(\"AssetTag\", \"AssetTag.assetId\", \"Asset.id\")\n      .where({ tagId: this.id! })\n  }\n\n  $selectAssetIdColumns(qb: Knex.QueryBuilder): Knex.QueryBuilder {\n    return qb.clearSelect().select({\n      assetId: \"Asset.id\",\n      capturedAtLocal: \"Asset.capturedAtLocal\",\n      updateCount: \"Asset.updateCount\",\n      durationMs: \"Asset.durationMs\"\n    })\n  }\n\n  $assetIdsQuery() {\n    return this.$selectAssetIdColumns(this.$assetsQuery())\n  }\n\n  setAncestors(a: Tag[]) {\n    this.ancestors = a\n    this.parent = a[a.length - 1]\n    map(this.parent, p => p.setAncestors(a.slice(0, -1)))\n  }\n\n  async toApiPathElements(): Promise<PathTag[]> {\n    return thenCollect(this.getAncestorsAndSelf(), ea => ea.toPathTag())\n  }\n\n  toPathTag(): PathTag {\n    return {\n      tagPath: this.path,\n      displayName: this.displayName\n    }\n  }\n\n  toApiTag(): ApiTag {\n    return {\n      tagId: this.id!,\n      tagPath: this.path,\n      displayPath: this.displayPath(),\n      description: this.description,\n      assetCount: this.assetCount!\n      // assetFileCount: this.assetFileCount!\n    }\n  }\n\n  toStringId() {\n    return \"Tag(\" + this.path.join(\"/\") + \")\"\n  }\n\n  getParent() {\n    if (this.isRoot) return undefined\n    if (this.parentId != null && this.parent == null) {\n      return (this.parent = Tag.findById(this.parentId))\n    } else {\n      return this.parent\n    }\n  }\n\n  getPagedChildren(crit: ChildTagCriteria): Tag[] {\n    if (this.id === 0) {\n      // Root tag:\n      const begin = crit.offset ?? 0\n      const end = begin + (crit.limit ?? this.children!.length)\n      return [...this.children!].slice(begin, end)\n    }\n    const q = this.$childrenQuery()\n    mapGt0(crit.offset, offset => {\n      void q.offset(offset)\n    })\n    mapGt0(crit.limit, limit => void q.limit(limit))\n    const result = Tag.ops().all(q)\n    for (const ea of result) Tag.cacheTag(ea)\n    return result\n  }\n\n  getChildrenCount(): number {\n    return this.children != null\n      ? this.children.length\n      : (Tag.dbl.pluckFirstf(q =>\n          (this.isRoot\n            ? q.whereNull(\"parentId\")\n            : q.where({ parentId: this.id })\n          ).count()\n        ) as number)\n  }\n\n  getChildren() {\n    if (!this.isRoot) {\n      this.children = Tag.ops().all(this.$childrenQuery())\n      this.children.forEach(childTag => {\n        childTag.parent = this\n      })\n    }\n    return this.children!\n  }\n\n  link(): string {\n    return \"/tag/\" + this.path.map(encodeURIComponent).join(\"/\")\n  }\n\n  get rootName() {\n    return this.path[0]\n  }\n\n  get ancestorsAndSelf(): Tag[] {\n    return [...this.ancestors!, this]\n  }\n\n  /**\n   * @return nearest parent last\n   */\n  getAncestors() {\n    return (this.ancestors ??= this._getAncestors())\n    //   const result = this._getAncestors()\n    //   const\n    //   const ancestorPaths = ancestry(this.parentPath).map(ea => joinTagPath(ea))\n    //   const cachedAncestors = ancestorPaths.map(ea =>\n    //     Tag.recentTagsByPath.get(ea)\n    //   )\n    //   if (cachedAncestors.every(ea => ea != null)) {\n    //     return (this.ancestors = cachedAncestors as Tag[])\n    //   }\n    //   const q = Tag.query().whereIn(\"_path\", ancestorPaths).orderBy(\"_path\")\n    //   this.ancestors = Tag.ops().all(q)\n    //   Tag.cacheTags(this.ancestors)\n\n    //   this.parent = orElse(\n    //     this.parent,\n    //     this.ancestors[this.ancestors.length - 1]\n    //   )\n    // }\n    // return this.ancestors\n  }\n\n  getAncestorsAndSelf() {\n    return [...this.getAncestors(), this]\n  }\n\n  /**\n   * Doesn't cache ancestors.\n   * @return nearest parent last: [..., grandParent, parent]\n   */\n  _getAncestors() {\n    if (this.parentId === 0 || this.parentId == null) return []\n    return Tag.ops().all({\n      sql: compressWhitespace(\n        \"WITH RECURSIVE cte(id, level) AS (\",\n        \"  VALUES (:tagId, 0)\",\n        \"  UNION ALL\",\n        \"  SELECT Tag.parentId as id, cte.level + 1 as level\",\n        \"  FROM Tag, cte\",\n        \"  WHERE Tag.id = cte.id\",\n        \")\",\n        \"SELECT Tag.*\",\n        \"FROM Tag JOIN cte on cte.id = Tag.id\",\n        \"WHERE Tag.id <> :tagId\",\n        \"ORDER BY cte.level DESC\"\n      ),\n      bindings: { tagId: this.id }\n    })\n  }\n\n  /**\n   * @return nearest parentId last: [..., grandParentId, parentId]\n   */\n  readonly ancestorIds = lazy(() => {\n    if (this.parentId === 0 || this.parentId == null) return []\n    return Tag.dbl.pluckAll<number>({\n      sql: compressWhitespace(\n        \"WITH RECURSIVE cte(id, level) AS (\",\n        \"  VALUES (:tagId, 0)\",\n        \"  UNION ALL\",\n        \"  SELECT Tag.parentId as id, cte.level + 1 as level\",\n        \"  FROM Tag, cte\",\n        \"  WHERE Tag.id = cte.id\",\n        \")\",\n        \"SELECT Tag.id\",\n        \"FROM Tag JOIN cte on cte.id = Tag.id\",\n        \"WHERE Tag.id <> :tagId\",\n        \"ORDER BY cte.level DESC\"\n      ),\n      bindings: { tagId: this.id }\n    })\n  })\n\n  getPagedAssetIds(crit: TagAssetsCriteria): AssetId[] {\n    let q = this.$assetIdsQuery()\n\n    q = q.limit(ThumbsPerSample)\n    if (gt0(crit.offset)) {\n      q = q.offset(crit.offset)\n    }\n    q = q.orderBy([\n      { column: \"capturedAtLocal\", order: \"desc\" },\n      { column: \"assetId\" }\n    ])\n    return compact(Asset.dbl.all(q).map(toAssetId))\n  }\n\n  getAssets() {\n    // reverse chron:\n    const q: any = this.$assetsQuery().orderBy(\"capturedAtLocal\", \"desc\")\n    return Asset.ops().all(q)\n  }\n\n  async assetCountDesc(assets?: Asset[]) {\n    const assetCount = this.assetCount\n    return (\n      (assetCount == null ||\n      assets == null ||\n      assets.length === assetCount ||\n      assets.length === 0\n        ? \"\"\n        : fmt(assets.length) + \" of \") + plur(assetCount!, \"asset\")\n    )\n  }\n\n  readonly firstNonInterstitialTagId: MemoizedThunk<number> = lazy(() => {\n    if (\n      !this.isRoot &&\n      0 === this.directAssetCount() &&\n      1 === this.getChildrenCount()\n    ) {\n      const arr = this.getChildren()\n      if (arr?.length === 1) return arr[0].firstNonInterstitialTagId()\n    }\n    return this.id!\n  })\n\n  readonly directAssetCount = lazy(() =>\n    this.id === 0\n      ? 0\n      : Asset.dbl.pluckFirst<number>(\n          Asset.shownUnhidden()\n            .join(\"AssetTag\", \"AssetTag.assetId\", \"Asset.id\")\n            .where(\"AssetTag.tagId\", this.id)\n            .countDistinct(\"Asset.id\")\n        )\n  )\n\n  getAssetCount(): Promise<number> {\n    // fetching asset file counts more than doubles calculation time:\n    return this.id === 0\n      ? (Tag.dbl.pluckFirst({\n          sql: compressWhitespace(\n            \"SELECT\",\n            \"  count(DISTINCT Asset.id) AS assetCount\",\n            // \"  count(DISTINCT AssetFile.id) AS assetFileCount\",\n            \"FROM\",\n            \"  Asset\",\n            // \"  JOIN AssetFile ON AssetFile.assetId = Asset.id\",\n            \"WHERE\",\n            \"  Asset.shown = 1\",\n            \"  AND Asset.excluded = 0\",\n            \"  AND Asset.hidden = 0\",\n            \"  AND Asset.deletedAt IS NULL\"\n          )\n        }) as any)\n      : Tag.dbl.pluckFirst({\n          sql: AssetCountForTag,\n          bindings: { tagId: this.id }\n        })\n  }\n\n  $assetStreamQuery(asset: Asset, limit: number, op: \"<\" | \"=\" | \">\") {\n    let qb =\n      this.path[0] === TagRoots.When\n        ? Asset.shownUnhidden()\n        : this.$assetsQuery()\n    qb = qb\n      .distinct()\n      .where(\"capturedAtLocal\", op, asset.capturedAtLocal)\n      .andWhereNot(\"Asset.id\", asset.id)\n      .limit(op === \"=\" ? limit * 2 : limit) // in case both sides of the stream are all from the same time (!!!)\n\n    if (op === \"=\") {\n      return qb.orderByRaw(`ABS(Asset.id-${asset.id})`)\n    } else {\n      return qb.orderBy([\n        { column: \"capturedAtLocal\", order: op === \">\" ? \"asc\" : \"desc\" },\n        \"Asset.id\"\n      ])\n    }\n  }\n\n  getAssetStream(asset: Asset, limit: number): TaggedAssetStream {\n    limit = gt0(limit) ? limit : BeforeAfterStreamLimit\n    const [before, same, after] = ([\"<\", \"=\", \">\"] as const).map(op =>\n      compact(\n        Asset.ops()\n          .all(this.$assetStreamQuery(asset, limit, op))\n          .map(toAssetId)\n      )\n    )\n    for (const ea of same) {\n      if (ea.assetId! < asset.id!) {\n        before.push(ea)\n      } else {\n        after.push(ea)\n      }\n    }\n    return new TaggedAssetStream([this], before, after.reverse(), limit)\n  }\n\n  getRelatedAssetIds({\n    seed,\n    limit = ThumbsPerSample\n  }: {\n    seed: number\n    limit?: number\n  }): AssetId[] {\n    const max = Math.max(256, assetCount())\n    const results = compact(\n      AssetTag.dbl\n        .allf(q =>\n          Asset.shownUnhidden(this.$selectAssetIdColumns(q))\n            .distinct()\n            .join(\"Asset\", \"Asset.id\", \"AssetTag.assetId\")\n            .join(\"Tag\", \"Tag.id\", \"AssetTag.tagId\")\n            // TODO: is this faster?\n            // .whereIn(\"AssetTag.assetId\", await this.selfAndDescendantIds(txn))\n            .whereLike(\"_path\", this._path + \"%\")\n            .orderByRaw(\n              prngOrderByClause(seed + orElse(this.id, 0), \"Asset.id\", max)\n            )\n            .limit(limit)\n        )\n        .map(toAssetId)\n    )\n\n    this.logger().debug(\n      this.path + \": Found \" + results.length + \" related assets\"\n    )\n    return results\n  }\n\n  get attrs(): Record<string, string> {\n    return { href: this.link(), title: this.name }\n  }\n}\n\nconst assetCount = lazy(\n  () => Asset.dbl.pluckFirstf<number>(q => q.count()),\n  minuteMs\n)\n","import { isEmpty } from \"../../fe/Array\"\nimport { tag_fts_path, tag_fts_root } from \"../tag/TagFtsFns\"\nimport { Model } from \"./Model\"\nimport { Tag } from \"./Tag\"\n\n// FTS === Full Text Search\n\nexport class TagFts extends Model {\n  static override readonly $tableName = \"tag_fts\"\n  static override readonly $uniqueColumnName = \"rowid\"\n  static override readonly $booleanFields = []\n\n  root?: string\n  path?: string\n\n  static insertFts(tags: Tag[]) {\n    const arr = tags\n      // never need to index root tags:\n      .filter(tag => tag.parentId != null)\n      .map(tag => ({\n        rowid: tag.id,\n        root: tag_fts_root(tag._path),\n        path: tag_fts_path(tag._path)\n      }))\n    return isEmpty(arr) ? undefined : this.dbl.runf(q => q.insert(arr))\n  }\n\n  static async rebuild() {\n    const tn = TagFts.$tableName\n    this.dbl.runScript([`INSERT INTO ${tn}(${tn}) VALUES('delete-all')`])\n    Tag.ops().batched({\n      qb: q => q,\n      onResults: arr => this.insertFts(arr)\n    })\n  }\n}\n","import {\n  diceCoeff,\n  greatestBy,\n  retainFirstN,\n  retainLastN\n} from \"../../core/Array\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { ApiAssetStream, AssetId } from \"../../fe/api/Asset\"\nimport { pushUniqBy } from \"../../fe/Array\"\nimport { sortByInPlace } from \"../../fe/ArraySort\"\nimport { gtOrElse, times } from \"../../fe/Number\"\nimport { cmp } from \"../../fe/Primitive\"\nimport { thenCollect } from \"../../fe/Promise\"\nimport { toA } from \"../../fe/toA\"\nimport { Asset } from \"./Asset\"\nimport { Tag } from \"./Tag\"\n\nexport const cmpAssetAsc = (a: Asset, b: Asset) =>\n  cmp([a.capturedAtLocal, a.id], [b.capturedAtLocal, b.id])\n\nexport const cmpAssetDesc = (a: Asset, b: Asset) =>\n  cmp([b.capturedAtLocal, b.id], [a.capturedAtLocal, a.id])\n\nexport class TaggedAssetStream {\n  readonly logger = () =>\n    mkLogger(\"model.TaggedAssetStream(\" + this.toString() + \")\")\n\n  constructor(\n    readonly tags: Tag[],\n    readonly before: AssetId[],\n    readonly after: AssetId[],\n    readonly limit: number\n  ) {\n    this.logger().info(\"new\", this.toJSON())\n  }\n\n  vacuum() {\n    sortByInPlace(this.before, a => [-a.capturedAtLocal, -a.assetId])\n    retainFirstN(this.before, this.limit)\n    sortByInPlace(this.after, a => [-a.capturedAtLocal, -a.assetId])\n    retainLastN(this.after, this.limit)\n  }\n\n  toString() {\n    return this.tags.map(ea => ea.path.join(\"/\")).join(\",\")\n  }\n\n  valueOf() {\n    return this.toString()\n  }\n\n  get length() {\n    return toA(this.before).length + toA(this.after).length\n  }\n\n  leftPad(ids: AssetId[]): AssetId[] {\n    return [\n      ...times(this.limit - ids.length, ea => ({\n        assetId: -(ea + 1),\n        capturedAtLocal: -1,\n        v: 0\n      })),\n      ...ids\n    ]\n  }\n\n  rightPad(ids: AssetId[]): AssetId[] {\n    return [\n      ...ids,\n      ...times(this.limit - ids.length, ea => ({\n        assetId: -(ea + this.limit + 1),\n        capturedAtLocal: -1,\n        v: 0\n      }))\n    ]\n  }\n\n  toJSON() {\n    return {\n      tags: this.tags.map(tag => tag.toString()),\n      assetIdsAfter: this.after,\n      assetIdsBefore: this.before\n    }\n  }\n\n  mergeWith(tas: TaggedAssetStream) {\n    // this.logger().info(\"mergeWith()\", {\n    //   tas: tas.toJSON(),\n    //   beforeIds: this.before.map(briefAsset),\n    //   afterIds: this.after.map(briefAsset)\n    // })\n\n    pushUniqBy(this.tags, tas.tags, ea => ea.path)\n\n    // These are the thumbnails to the right of the current asset:\n    pushUniqBy(this.before, tas.before, ea => ea.assetId!)\n\n    // These are the thumbnails to the left of the current asset:\n    pushUniqBy(this.after, tas.after, ea => ea.assetId!)\n    this.logger().debug(\"mergeWith() complete\", {\n      tas: tas.toJSON(),\n      tags: this.tags.map(ea => ea.path),\n      beforeIds: this.before,\n      afterIds: this.after\n    })\n  }\n\n  async toApi(): Promise<ApiAssetStream> {\n    this.vacuum()\n    return this.logger().tap({\n      msg: \"toApi()\",\n      result: {\n        tags: await thenCollect(this.tags, ea => ea.toApiTag()),\n        assetIdsAfter: this.leftPad(this.after),\n        assetIdsBefore: this.rightPad(this.before)\n      }\n    })\n  }\n\n  streamCoeff(tas: TaggedAssetStream) {\n    return this.logger().tap({\n      msg: \"streamCoeff\",\n      meta: {\n        this: this.tags.map(ea => ea.path),\n        tas: tas.tags.map(ea => ea.path)\n      },\n      result: diceCoeff(\n        [...this.before, ...this.after],\n        [...tas.before, ...tas.after],\n        ea => ea.assetId!\n      )\n    })\n  }\n}\n\nexport function coalesceStreams(\n  streams: TaggedAssetStream[]\n): TaggedAssetStream[] {\n  const minStreamCorr = Settings.minStreamCorrPct.valueOrDefault / 100\n  const result: TaggedAssetStream[] = []\n  const prefilter = streams.filter(ea => ea.length > 5)\n  for (const stream of prefilter) {\n    const nearest = greatestBy(result, ea =>\n      gtOrElse(ea.streamCoeff(stream), minStreamCorr)\n    )\n    if (nearest == null) {\n      result.push(stream)\n    } else {\n      nearest.mergeWith(stream)\n    }\n  }\n  return result\n}\n","import { mapGt0 } from \"../../core/Number\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { gt0, toGt0 } from \"../../fe/Number\"\nimport { toA } from \"../../fe/toA\"\nimport { PartialPojo } from \"../db/PartialPojo\"\nimport { Model, ModelClass } from \"./Model\"\n\nexport class TimestampedModel extends Model {\n  static touch<M extends TimestampedModel>(\n    this: ModelClass<M>,\n    ids: number[],\n    Obj: PartialPojo<M> = {}\n  ) {\n    Obj.updatedAt ??= Date.now()\n    delete Obj.id\n    const arr = toA(ids).filter(gt0)\n    return isEmpty(arr)\n      ? undefined\n      : this.dbl.runf(q => q.whereIn(\"id\", arr).update(Obj))\n  }\n\n  createdAt?: number\n  updatedAt?: number\n\n  get createdAtDate() {\n    return mapGt0(this.createdAt, ea => new Date(ea))\n  }\n\n  get updatedAtDate() {\n    return mapGt0(this.updatedAt, ea => new Date(ea))\n  }\n\n  touch(Obj: PartialPojo<this> = {}) {\n    Obj.updatedAt ??= Date.now()\n    const id = this.id\n    if (id == null) {\n      this.upsert()\n    } else {\n      this.class().dbl.runf(q => q.where({ id }).update(Obj))\n    }\n  }\n\n  override $beforeUpsert() {\n    // overrides should always call super!\n    super.$beforeUpsert()\n    if (this.createdAt == null) {\n      this.createdAt = Date.now()\n    }\n    this.updatedAt = Date.now()\n    if (\"updateCount\" in this) {\n      const obj = this as any\n      const prior = obj.updateCount\n      obj.updateCount = (toGt0(obj.updateCount) ?? 0) + 1\n      this.logger().debug(\"$beforeUpsert(): incr updateCount\", {\n        prior,\n        now: obj.updateCount\n      })\n    }\n  }\n}\n","import { Knex } from \"knex\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { rateLimited } from \"../../core/RateLimited\"\nimport { errorToS } from \"../../core/error/Error\"\nimport { onError } from \"../../core/error/OnError\"\nimport { toWrappedError } from \"../../core/error/WrappedError\"\nimport { count } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { stringify } from \"../../fe/JSON\"\nimport { clamp, gt0 } from \"../../fe/Number\"\nimport { parseJSON } from \"../../fe/ParseMaybe\"\nimport { plur } from \"../../fe/Units\"\nimport { EmptyDeletedURI, EmptyRemovedURI } from \"../../fe/api/ProgressState\"\nimport { Asset, RemovableColumn } from \"../model/Asset\"\nimport { AssetFile } from \"../model/AssetFile\"\nimport { Operation } from \"../model/Operation\"\nimport { Progress } from \"../model/Progress\"\n\nconst logger = mkLogger(\"ops.ApplyExcluded\")\n\nexport async function maybeApplyExcluded() {\n  return Operation.applyIfPending({ name: \"applyExcluded\" }, op =>\n    applyRemovable(op, false)\n  )\n}\nexport async function maybeApplyDeleted() {\n  return Operation.applyIfPending({ name: \"applyDeleted\" }, op =>\n    applyRemovable(op, true)\n  )\n}\n\nasync function applyRemovable(op: Operation, unlinkAssetFiles: boolean) {\n  const progress = Progress.insertNew(\n    unlinkAssetFiles\n      ? {\n          uri: EmptyDeletedURI,\n          state: \"processing\",\n          volume: \"🗑️\",\n          scanningPct: 0,\n          hed: \"Removing deleted assets from library and disk\"\n        }\n      : {\n          uri: EmptyRemovedURI,\n          state: \"processing\",\n          volume: \"⏏️\",\n          scanningPct: 0,\n          hed: \"Removing excluded assets from library\"\n        }\n  )\n  // const unlinkAssetFiles = op.name === \"applyDeleted\"\n  const { assetCount, assetFileCount } = parseJSON(op.value) as any\n\n  if (!gt0(assetCount) || !gt0(assetFileCount)) {\n    logger.throw(\"Refusing to \" + op.name + \": invalid model counts\", {\n      op\n    })\n  }\n\n  const col: RemovableColumn = unlinkAssetFiles ? \"deletedAt\" : \"excludedAt\"\n  const qb = (q: Knex.QueryBuilder) =>\n    q.where(\"Asset.shown\", 0).andWhere(\"Asset.\" + col, op.createdAt!)\n\n  const assetIds = Asset.dbl.pluckAllf<number>(q => qb(q.select(\"Asset.id\")))\n  if (assetIds.length > assetCount) {\n    logger.throw(\"Refusing to \" + op.name + \": too many assets!\", {\n      op,\n      assetCount: assetIds.length\n    })\n  }\n\n  if (unlinkAssetFiles) {\n    const dbAssetFileCount = AssetFile.dbl.pluckFirstf<number>(q =>\n      qb(\n        q\n          .countDistinct(\"AssetFile.id\")\n          .join(\"Asset\", \"Asset.id\", \"AssetFile.assetId\")\n      )\n    )\n\n    if (dbAssetFileCount > assetFileCount) {\n      logger.throw(\"Refusing to \" + op.name + \": too many impacted files!\", {\n        op,\n        dbAssetFileCount\n      })\n    }\n  }\n\n  const deletedMeta: {\n    nativePath: string\n    unlinked: boolean\n  }[] = []\n\n  function mkDek(index: number) {\n    const total = assetIds.length\n    const dek = [\n      `Removed ${plur(total, \"asset\")} from your library.` +\n        (index >= total\n          ? \"\"\n          : ` ${plur(total - index, \"asset\")} need to be removed.`)\n    ]\n    if (unlinkAssetFiles) {\n      const deletedFiles = count(deletedMeta, ea => ea.unlinked)\n      dek.push(plur(deletedFiles, \"file\") + \" deleted from disk.\")\n      const notDeletedFiles = count(deletedMeta, ea => !ea.unlinked)\n      if (notDeletedFiles > 0) {\n        dek.push(\n          plur(deletedFiles, \"file\") +\n            \" could not be deleted from disk. Check the logs for details.\"\n        )\n      }\n    }\n    return dek\n  }\n\n  const maybeUpdateProgress = rateLimited({\n    name: \"applyRemovable\",\n    f: async (index: number) => {\n      if (index < 0) return\n      progress.completePct = clamp(0, 100, Math.round(index / assetIds.length))\n      progress.incompletePct = clamp(0, 100, 100 - progress.completePct)\n      progress.dek = mkDek(index)\n      progress.upsert()\n    },\n    minCallDelayMs: 500\n  })\n\n  logger.info(\"applying...\", { op, assetIds })\n  // We run this serially, as the database updates are going to be applied\n  // serially anyway:\n  try {\n    for (const assetId of assetIds) {\n      const result = await Asset.remove({\n        assetId,\n        blocklistShas: true,\n        unlinkAssetFiles\n      })\n      deletedMeta.push(\n        ...(result?.deletedMeta.filter(ea => notBlank(ea.nativePath)) as any)\n      )\n      await maybeUpdateProgress(assetIds.indexOf(assetId))\n    }\n    op.upsert({ completedAt: Date.now() })\n    progress.hed = unlinkAssetFiles\n      ? \"Emptied trash.\"\n      : \"Excluded assets removed.\"\n    progress.dek = mkDek(assetIds.length)\n    progress.state = \"done\"\n    progress.completedAt = Date.now()\n    progress.upsert()\n    logger.info(\"Complete!\", { op })\n  } catch (cause) {\n    const error = toWrappedError(\"Could not apply \" + stringify(op), { cause })\n    onError(error)\n    progress.upsert({\n      hed: \"Failed: \" + errorToS(error),\n      state: \"done\",\n      completedAt: Date.now()\n    })\n  }\n}\n","import { maybeApplyDeleted, maybeApplyExcluded } from \"./ApplyRemovable\"\n\nexport async function checkPendingOperations() {\n  await maybeApplyExcluded()\n  await maybeApplyDeleted()\n}\n","import { thenOrElse } from \"../../core/async/Promise\"\nimport {\n  AssetFileVersion,\n  AssetVersion\n} from \"../../core/PhotoStructureVersions\"\nimport { stripPrefix } from \"../../core/String\"\nimport { TableName } from \"../model/TableName\"\nimport { QueueItem } from \"./QueueItem\"\nimport { StatsModel } from \"./StatsModel\"\n\n// we can't Omit, because then we get all the Model fields too. :\\\nexport type WorkItem = Pick<QueueItem, \"contents\">\n\nexport function assetFileUpdatesUri2QueueName(uri: string) {\n  return `assetFileUpdates:${AssetFileVersion}:${uri}`\n}\n\nexport function assetFileUpdatesQueueName2uri(queueName: string) {\n  return stripPrefix(queueName, assetFileUpdatesUri2QueueName(\"\"))\n}\nexport function assetUpdatesUri2QueueName(uri: string) {\n  return `assetUpdates:${AssetVersion}:${uri}`\n}\nexport function assetUpdatesQueueName2uri(queueName: string) {\n  return stripPrefix(queueName, assetUpdatesUri2QueueName(\"\"))\n}\n\nexport class Queue extends StatsModel {\n  static override readonly $tableName: TableName = \"Queue\"\n  static override readonly $uniqueColumnName = \"name\"\n  id!: number\n  name!: string\n\n  static itemCountForQueues(queueNames: string[]) {\n    return thenOrElse(\n      QueueItem.dbl.pluckFirstf(q =>\n        q\n          .countDistinct(\"QueueItem.id\")\n          .join(\"Queue\", \"Queue.id\", \"QueueItem.queueId\")\n          .whereIn(\"Queue.name\", queueNames)\n      ),\n      () => 0\n    )\n  }\n\n  static truncate() {\n    QueueItem.dbl.runf(q => q.delete())\n    Queue.dbl.runf(q => q.delete())\n  }\n\n  items() {\n    return QueueItem.ops().allf(q => q.where({ queueId: this.id! }))\n  }\n\n  itemCount(): number {\n    return QueueItem.dbl.pluckFirstf<number>(q =>\n      q.where({ queueId: this.id! }).count()\n    )\n  }\n\n  upsertWorkItems(workItems: WorkItem[]): QueueItem[] {\n    return QueueItem.ops().upsert(\n      workItems.map(ea => ({ queueId: this.id!, ...ea }))\n    )\n  }\n}\n","import { Maybe } from \"../../fe/MaybeTypes\"\nimport { StatsModel } from \"./StatsModel\"\n\nexport class QueueItem extends StatsModel {\n  static override readonly $tableName = \"QueueItem\"\n  static override readonly $uniqueColumnName = \"queueId,contents\"\n  id!: number\n  queueId!: number\n  contents!: string\n  // HEY FUTURE ME: if you add a field here, add it to the WorkItem interface, too.\n\n  eql(qi: Maybe<QueueItem>) {\n    return (\n      qi != null &&\n      ((this.id != null && this.id === qi.id) ||\n        (this.contents === qi.contents && this.queueId === qi.queueId))\n    )\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { Db } from \"../db/Db\"\n\nexport const statsDb = lazy<Db>(() => undefined as any)\n","import { EndableRanks } from \"../../core/async/Endable\"\nimport { EndableInterval } from \"../../core/async/EndableInterval\"\nimport { Schemas, SqliteBase } from \"../../core/db/Schemas\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { isTest } from \"../../core/NodeEnv\"\nimport { isStatsDbMigrator } from \"../../core/ServiceNames\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { Db } from \"../db/Db\"\nimport { statsDb } from \"./StatsDb\"\n\nexport async function statsDbJanitor(dbDir: PosixFile): Promise<Db> {\n  const db = new Db(Schemas.stats, dbDir.join(SqliteBase))\n  // stats are only opened by sync:\n  if (isStatsDbMigrator()) {\n    await db.migrate_()\n    new EndableInterval({\n      name: \"statsDbJanitor vacuum\",\n      callback: () => db.vacuum(),\n      intervalMs: isTest ? 20 * secondMs : 5 * minuteMs,\n      rank: EndableRanks.service\n    })\n  }\n  statsDb.set(db)\n  return db\n}\n","import { Schema } from \"../../core/db/Schemas\"\nimport { Model } from \"../model/Model\"\nimport { statsDb } from \"./StatsDb\"\n\nexport class StatsModel extends Model {\n  static override readonly $schema: Schema = \"stats\"\n  static override readonly db = statsDb\n}\n","import { Knex } from \"knex\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Logger, mkLogger } from \"../../core/Logger\"\nimport { whyNotSameAsset } from \"../../core/asset-file/AssetFileComparator\"\nimport { thenMap } from \"../../core/async/Promise\"\nimport { time, timedLazy } from \"../../core/async/PromiseTimer\"\nimport { SerialLaterQueue } from \"../../core/async/SerialLaterQueue\"\nimport { InternalErrorFlag } from \"../../core/error/ErrorFlags\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { imageHash } from \"../../core/img/ImageHash\"\nimport { throwIfInvalidFile_ } from \"../../core/img/ValidFile\"\nimport {\n  ForceContext,\n  RequiredForceContext,\n  forceContextOrSetting\n} from \"../../core/settings/ForceContext\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { readTags } from \"../../core/tags/ExifTool\"\nimport { isNotEmpty, uniq } from \"../../fe/Array\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { blank } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { mapOr } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { MaybeSyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { Asset } from \"../model/Asset\"\nimport { AssetFile } from \"../model/AssetFile\"\n\nexport async function isFileInSync(\n  nativePath: PosixFile | string\n): Promise<boolean> {\n  return new AssetFileFinder(PosixFile.for(nativePath)).alreadySynced()\n}\n\nconst AssetIdCreationMutex = new SerialLaterQueue<number>()\n\nexport class AssetFileFinder {\n  readonly #logger: Logger\n  readonly #rejectedSiblingIds: Set<number> = new Set()\n\n  readonly ctx: RequiredForceContext\n\n  constructor(\n    readonly file: PosixFile,\n    ctx?: ForceContext\n  ) {\n    this.#logger = mkLogger(\n      \"sync-file.AssetFileFinder(\" + file.baseWithGrandparent + \")\"\n    )\n    this.ctx = forceContextOrSetting(ctx)\n  }\n\n  async prior() {\n    return this.byUri()\n  }\n\n  async priorIfSynced() {\n    if (this.ctx.forceSync) return undefined\n    const prior = await this.prior()\n    return true === (await prior?.matchesFile()) ? prior : undefined\n  }\n\n  readonly alreadySynced = timedLazy(\n    \"sync-file.AssetFileFinder.alreadySynced: \" + this.file,\n    async () =>\n      this.#logger.tap({\n        msg: \"alreadySynced\",\n        result: (await this.priorIfSynced()) != null\n      })\n  )\n\n  readonly newAssetFile_ = timedLazy(\n    \"sync-file.AssetFileFinder.newAssetFile: \" + this.file,\n    async () => {\n      const af = await new AssetFile().updateFromFile_(this.file)\n      if (af == null) {\n        return this.#logger.throw(\"AssetFile.updateFromFile returned null\", {\n          fatal: false\n        })\n      } else {\n        return af\n      }\n    }\n  )\n\n  /**\n   * @return a persisted AssetFile if `maybeAsset` resolves to a persisted Asset\n   */\n  async newAssetFileForAsset(maybeAsset: MaybeSyncOrAsync<Asset>) {\n    const asset = await maybeAsset\n    if (asset == null) {\n      // We expect the asset to be undefined if we do a query for a sibling\n      // asset file and miss.\n      return\n    } else if (asset.id == null) {\n      this.#logger.throw(\"newAssetFileForAsset(): given non-persisted Asset\")\n    } else {\n      const af = await this.newAssetFile_()\n      asset.addAssetFile(af)\n      af.insert()\n      this.#logger.debug(\"newAssetFileForAsset() upsert success!\", { af })\n      return af\n    }\n  }\n\n  readonly tags_ = lazy(async () => {\n    const t = await readTags(this.file)\n    if (t == null) {\n      throw new Error(this.file + \" doesn't have metadata\")\n    } else {\n      return t\n    }\n  })\n\n  async capturedAt_() {\n    return (await this.tags_()).capturedAt\n  }\n\n  readonly imageHash = lazy(() =>\n    Settings.useImageHashes.valueOrDefault ? imageHash(this.file) : undefined\n  )\n\n  readonly dominantLabhashes = lazy(() =>\n    thenMap(this.imageHash(), ih =>\n      // the uniq _shouldn't_ be needed, but we're backstopping against prior\n      // bad/buggy means:\n      uniq(ih.dominantColors.filter(ea => ea.pct > 5).map(ea => ea.labhash))\n    )\n  )\n\n  readonly capturedAtLocal = lazy(async () => {\n    const ca = await this.capturedAt_()\n    return this.#logger.tap({\n      msg: \"capturedAtLocal\",\n      result: ca?.local,\n      meta: { capturedAt: ca }\n    })\n  })\n\n  readonly mapSibling = (assetFile: Maybe<AssetFile>) =>\n    this.newAssetFileForAsset(assetFile?.getAsset())\n\n  readonly apply_ = timedLazy<Promise<AssetFile>>(\n    \"sync-file.AssetFileFinder: \" + this.file,\n    async () => {\n      if (blank(await this.file.uri_())) {\n        throw new Error(\"Cannot import, file URI is blank for \" + this.file)\n      }\n\n      {\n        // this throws if the file is invalid:\n        const withExistingAsset = await this.byExistingAsset_()\n        if (withExistingAsset != null) {\n          this.#logger.info(\"Found existing asset for file\")\n          return withExistingAsset\n        }\n      }\n\n      // this can be done outside the asset id creation mutex:\n      const af = await this.newAssetFile_()\n\n      const assetId = await AssetIdCreationMutex.enqueue(async () => {\n        // did a sibling file make an asset suitable for me while I was\n        // waiting for the mutex?\n        const withExistingAsset = await this.byExistingAsset_()\n        if (withExistingAsset?.assetId != null) {\n          this.#logger.info(\n            \"Found existing asset for file after acquiring lock\",\n            { withExistingAsset }\n          )\n          return withExistingAsset.assetId\n        }\n        const asset = new Asset()\n        // NOTE: we're not setting shown = true or version yet, because we haven't\n        // built previews:\n        asset.capturedAtLocal = af.capturedAtLocal\n        asset.addAssetFile(af) // < may adopt capturedAt and rating from this\n        asset.upsert()\n        return asset.id!\n      })\n\n      af.assetId = assetId\n      return af.upsert()\n    }\n  )\n\n  // DO NOT LAZY THIS! WE CALL IT TWICE.\n  private readonly byExistingAsset_ = () =>\n    time(\n      \"sync-file.AssetFileFinder.byExistingAsset: \" + this.file,\n      async () => {\n        const strategies = [\n          // URI is the business key, so if it exists, use that\n          {\n            name: \"byUri\",\n            f: () => this.byUri()\n          },\n          // DON'T THINK \"equivalent\" URIs ARE THE SAME ASSET FILE. You can't change\n          // URIs for existing AssetFiles: that's a different AssetFile!\n          {\n            name: \"byNormalizedPathUri\",\n            f: () => this.newAssetFileForAsset(this.assetByNormalizedPathUri())\n          },\n          // Same file contents must be adopted by the same asset\n          {\n            name: \"bySha\",\n            f: () => this.newAssetFileForAsset(this.assetBySha())\n          },\n          // OK, we haven't seen this SHA, so let's validate tags can be fetched:\n          {\n            name: \"hasTags\",\n            f: async () => {\n              await this.tags_()\n              return undefined\n            }\n          },\n          // OK, we haven't seen this SHA, so let's validate the image.\n          {\n            name: \"validFile\",\n            f: async () => {\n              await throwIfInvalidFile_(this.file)\n              return undefined\n            }\n          },\n          {\n            name: \"byCapturedAtOrImageHash\",\n            f: () =>\n              this.newAssetFileForAsset(this.assetByCapturedAtOrImageHash())\n          }\n        ]\n\n        for (const { name, f } of strategies) {\n          try {\n            const af = await time(\n              \"sync-file.assetFileFinder.\" + name + \": \" + this.file,\n              f\n            )\n            if (af == null) {\n              this.#logger.debug(\"apply(): \" + name + \": returned null\")\n            } else {\n              this.#logger.info(\"apply(): \" + name, {\n                assetFileId: af.id,\n                assetId: af.assetId\n              })\n              return af\n            }\n          } catch (err) {\n            this.#logger.debug(\"apply(): \" + name + \" rejected: \" + err)\n            throw err\n          }\n        }\n        return undefined\n      }\n    )\n\n  // Must not be cached (part of the double-checked advisory lock)\n  async byUri() {\n    const uri = await this.file.uri_()\n    if (uri == null) {\n      this.#logger.warn(\"byUri() uri is null\", { file: this.file })\n      return\n    }\n\n    // HEY FUTURE ME: I bet you want to search by SHA, right? DO NOT! The URI\n    // is different, and that's a different AssetFile.\n\n    // AssetFile.URIs are the business key--they can't change!\n\n    return (\n      AssetFile.ops().findOneBy({ uri }) ??\n      AssetFile.ops().findOneBy({ uri: this.file.fileuri() })\n    )\n  }\n\n  assetByNormalizedPathUri() {\n    return thenMap(this.file.normalizedPathUri_(), uri =>\n      Asset.findFirstByFile(qb => qb.where(\"AssetFile.uri\", uri))\n    )\n  }\n\n  // Must not be cached (part of the double-checked advisory lock)\n  assetBySha() {\n    return thenMap(this.file.sha(), sha =>\n      Asset.findFirstByFile(qb => qb.where(\"AssetFile.sha\", sha))\n    )\n  }\n\n  async assetByCapturedAtOrImageHash(): PromiseMaybe<Asset> {\n    const ca = await this.capturedAt_()\n    if (null == ca) {\n      // readTags is supposed to never return a Tags instance without a `.capturedAt` field.\n      return this.#logger.throw(\n        \"Cannot import, capturedAt is null\" + InternalErrorFlag\n      )\n    }\n\n    if (Settings.strictDeduping.valueOrDefault) {\n      return this.firstSimilarAsset(\n        AssetFile.ops().allf(q => q.where({ capturedAtLocal: ca.local }))\n      )\n    }\n\n    const limit = Settings.maxContemporaryAdoptionAssets.valueOrDefault\n\n    const qb = () => {\n      let q = AssetFile.query()\n      if (gt0(limit)) q = q.limit(limit)\n      return q.orderByRaw(`abs(capturedAtLocal - ${ca.local})`)\n    }\n\n    const delta = Math.max(\n      secondMs,\n      Settings.minCapturedAtPrecisionDifferentMimetypes.valueOrDefault\n    )\n\n    return time(\n      \"sync-file.AssetFileFinder.assetByCapturedAtAndImageHash: \" + this.file,\n      async () => {\n        {\n          const bounds = ca.localBoundaries({ delta })\n          if (bounds == null) {\n            this.#logger.warn(\n              \"Failed to fetch localBoundaries, cannot fetch similar assets by localtime\",\n              { ca, delta }\n            )\n          } else {\n            const result =\n              this.firstSimilarAssetByQuery(\n                \"captured-at\",\n                qb().whereBetween(\"capturedAtLocal\", [bounds.start, bounds.end])\n              ) ??\n              (Settings.checkBasenameMatches.valueOrDefault\n                ? this.firstSimilarAssetByQuery(\n                    \"basename\",\n                    qb().whereILike(\"uri\", \"%/\" + this.file.name + \"%\")\n                  )\n                : undefined)\n            if (result != null) return result\n          }\n        }\n\n        const ih = await this.imageHash()\n        if (ih == null) {\n          this.#logger.warn(\"assetByCapturedAtAndImageHash: no imageHash\")\n          return\n        }\n        const modes = await this.dominantLabhashes()\n        if (isNotEmpty(modes)) {\n          // Expand the captured-at delta but only for matching dominant colors:\n          const wideBounds = ca.localBoundaries({ delta: delta * 4 })\n          if (wideBounds == null) {\n            this.#logger.error(\n              \"Failed to fetch localBoundaries, cannot fetch similar assets by wide localtime + image hash\",\n              { ca, delta }\n            )\n          } else {\n            const result = this.firstSimilarAssetByQuery(\n              \"wide captured-at and dominant color\",\n              qb()\n                .whereBetween(\"capturedAtLocal\", [\n                  wideBounds.start,\n                  wideBounds.end\n                ])\n                .andWhere(b =>\n                  b\n                    .whereIn(\"mode0\", modes)\n                    .orWhereIn(\"mode1\", modes)\n                    .orWhereIn(\"mode2\", modes)\n                )\n            )\n            if (result != null) return result\n          }\n        }\n        // if it's exactly the same image hash, check those:\n        return this.firstSimilarAssetByQuery(\n          \"image hash\",\n          qb()\n            .where(\"meanHash\", ih.meanHash)\n            .orWhere(\"diffHash\", ih.diffHash)\n            .orWhere(\"dctHash\", ih.dctHash)\n        )\n      }\n    )\n  }\n\n  async firstSimilarAssetByQuery(context: string, qb: Knex.QueryBuilder) {\n    if (this.#rejectedSiblingIds.size > 0) {\n      qb = qb.whereNotIn(\"AssetFile.id\", Array.from(this.#rejectedSiblingIds))\n    }\n    const result = await this.firstSimilarAsset(AssetFile.ops().all(qb))\n    if (result != null) {\n      this.#logger.info(\"Found similar asset by \" + context, { result })\n    }\n    return result\n  }\n\n  async firstSimilarAsset(assetFiles: AssetFile[]) {\n    const thisAF = await this.newAssetFile_()\n    const cal = await this.capturedAtLocal()\n    if (thisAF == null) {\n      throw new Error(\"Failed to update from \" + this.file)\n    }\n    // Look at the nearest-captured-at-time first.\n    const sorted = sortBy(\n      assetFiles.filter(ea => !this.#rejectedSiblingIds.has(ea.id!)),\n      af => [\n        mapOr(\n          cal,\n          ea => Math.abs(af.capturedAtLocal - ea),\n          -af.capturedAtLocal\n        ),\n        af.id!\n      ]\n    )\n\n    for (const af of sorted) {\n      if (af != null) {\n        await af.getNativePath()\n        const siblings = AssetFile.ops().findBy({ assetId: af.assetId })\n        await Promise.all(siblings.map(ea => ea.getNativePath()))\n        const why = whyNotSameAsset(thisAF, af, siblings)\n        if (why == null) {\n          this.#logger.info(\"Found sibling AssetFile\", af)\n          return Asset.ops().findById(af.assetId!)\n        } else {\n          this.#rejectedSiblingIds.add(af.id!)\n          this.#logger.debug(\n            \"Contemporary assetFile not similar: \" + why,\n            af?.uri\n          )\n        }\n      }\n    }\n    return\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { AbortError } from \"../../core/async/AbortError\"\nimport {\n  DoNotSendErrorFlag,\n  NonRetriableErrorFlag\n} from \"../../core/error/ErrorFlags\"\nimport { UpdateAssetArgs } from \"../../core/event/PhotoStructureEvents\"\nimport { submitTask_ } from \"../../core/event/SharedState\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { whyRejectFile } from \"../../core/fs/PosixFileFilters\"\nimport {\n  AssetFileSyncStates,\n  SyncFileStates,\n  syncReport\n} from \"../../core/fs/SyncReport\"\nimport { whyInvalidFile } from \"../../core/img/ValidFile\"\nimport { ContextualLogger } from \"../../core/log/ContextualLogger\"\nimport {\n  ForceContext,\n  RequiredForceContext,\n  forceContextOrSetting\n} from \"../../core/settings/ForceContext\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { UnwrapPromiseLike } from \"../../fe/UnwrapPromiseLike\"\nimport { toA } from \"../../fe/toA\"\nimport { Library } from \"../Library\"\nimport { libraryFileFiltersFor } from \"../LibraryFileFilters\"\nimport { AssetFile } from \"../model/AssetFile\"\nimport { AssetFileFinder } from \"./AssetFileFinder\"\nimport { AssetFileRepository } from \"./AssetFileRepository\"\nimport { assetPostUpsertTasks_ } from \"./AssetPostUpsertTasks\"\nimport { ImportResult } from \"./ImportResult\"\n\nexport async function importFileToResult(\n  file: PosixFile,\n  ctx?: ForceContext\n): Promise<ImportResult> {\n  const l = Library.instanceRequired()\n  return syncReport().wrap_({\n    path: file.nativePath,\n    from: \"importFileToResult()\",\n    fn_: () =>\n      new AssetFileImporter(file, l.assetFileRepository(), ctx).apply_()\n  })\n}\n\n/**\n * AssetFileImporter actually imports a file into the database, and runs all\n * curators. If you want sync reporting, use importFileToResult() instead.\n */\nexport class AssetFileImporter {\n  readonly start = Date.now()\n  readonly #logger: ContextualLogger\n  readonly #assetFileFinder: AssetFileFinder\n  readonly ctx: RequiredForceContext\n  constructor(\n    readonly file: PosixFile,\n    readonly repo: Maybe<AssetFileRepository>,\n    ctx?: ForceContext\n  ) {\n    this.ctx = forceContextOrSetting(ctx)\n    this.#logger = mkLogger(\"sync-file.\" + this.toString())\n    this.#assetFileFinder = new AssetFileFinder(file, ctx)\n  }\n\n  // 8 is the current number of different calls to .increment in this file and\n  // UpdateAssetPreviews. Not all imports will increment to this value.\n\n  toString(): string {\n    return \"AssetFileImporter(\" + this.file.nativePath + \")\"\n  }\n\n  newAssetFile() {\n    return this.#assetFileFinder.newAssetFile_()\n  }\n\n  readonly whyRejected = lazy(async () => {\n    const rejected: string[] = []\n    const uri = await this.file.uri_()\n    if (uri == null) {\n      rejected.push(\n        \"Cannot make URI\" + DoNotSendErrorFlag + NonRetriableErrorFlag\n      )\n    } else {\n      const deleted = await this.file.isDeletedUri(uri)\n      // if deleted is undefined, we don't know if the file was deleted or not:\n      // it may be on an unmounted volume.\n      if (deleted === true) {\n        rejected.push(\"File was deleted\")\n      } else {\n        const result = await whyRejectFile(\n          this.file,\n          libraryFileFiltersFor(this.file)\n        )\n        if (result != null) rejected.push(result)\n      }\n\n      const prior = await this.prior()\n\n      // Only delete the asset file if we're deleted or filtered\n      if (isNotEmpty(rejected)) {\n        if (prior != null) {\n          this.#logger.info(\n            \"Deleting prior AssetFile, and requesting prior asset repair\",\n            { rejected, prior }\n          )\n          prior.delete()\n          const uaa: UpdateAssetArgs = {\n            assetId: prior.assetId!,\n            forceRebuildPreviews: isTrue(prior.shown)\n          }\n          void submitTask_(\"repairAsset\", uaa)\n        }\n      }\n\n      // Don't re-validate files already in the db.\n      // ForceSync and outdated versions should require a re-validation (so we use inSyncWithFile, not matchesFile)\n      if (\n        rejected.length === 0 &&\n        (prior == null || !(await prior.inSyncWithFile()))\n      ) {\n        const why = await whyInvalidFile(this.file.nativePath)\n        if (!blank(why)) {\n          rejected.push(why)\n        }\n      }\n    }\n\n    return rejected\n  })\n\n  /**\n   * Returns a db-persisted AssetFile if `this.file` is importable.\n   */\n  readonly assetFile_ = lazy<Promise<AssetFile>>(async () => {\n    // srcAssetFile will be upserted by assetFileFinder.\n    const result = await this.#assetFileFinder.apply_()\n    const asset = result.getAsset()\n    this.#logger.info(\"assetFileFinder.apply_() result\", {\n      asset,\n      assetFile: result\n    })\n    if (asset == null) {\n      return this.#logger.throw(\"assetFile.getAsset() was null\", {\n        srcAssetFile: result\n      })\n    }\n    if (asset.id == null) {\n      return this.#logger.throw(\"repoAssetFile asset has null id\", {\n        asset\n      })\n    }\n    return result\n  })\n\n  readonly prior = lazy(() => this.#assetFileFinder.prior())\n\n  /**\n   * Persists an Asset and AssetFile for `this.file`, builds previews, and\n   * associates tags.\n   *\n   * @throws error if the file was not imported.\n   */\n  readonly apply_ = lazy<Promise<ImportResult>>(() => this.#apply())\n\n  async #apply(): Promise<ImportResult> {\n    const why = await this.whyRejected()\n    if (isNotEmpty(why)) {\n      const details = why.join(\", \")\n      return {\n        path: this.file.nativePath,\n        state: SyncFileStates.rejected,\n        details\n      }\n    }\n\n    const prior = await this.prior()\n    if (prior != null && (await prior.isNoop(this.ctx))) {\n      return {\n        path: this.file.nativePath,\n        state: AssetFileSyncStates.noop,\n        assetId: prior.assetId!,\n        assetFileId: prior.id!,\n        assetFile: prior,\n        asset: prior.getAsset()!,\n        uri: prior.uri\n      }\n    }\n\n    // This step should only take a second or two to imageHash and do a couple\n    // database operations.\n    const assetFile = await this.assetFile_()\n    if (assetFile == null) {\n      return this.#logger.throw(\"_apply(): unexpected null assetFile\")\n    }\n    const assetFileId = assetFile.id!\n    if (assetFileId == null) {\n      return this.#logger.throw(\"_apply(): unexpected null assetFileId\")\n    }\n    const uri = assetFile.uri\n    if (uri == null) {\n      return this.#logger.throw(\"_apply(): unexpected null assetFile.uri\")\n    }\n\n    const asset = assetFile.getAsset()\n    if (asset == null) {\n      return this.#logger.throw(\n        \"_apply(): unexpected null assetFile.getAsset()\"\n      )\n    }\n\n    let postResult: UnwrapPromiseLike<ReturnType<typeof assetPostUpsertTasks_>>\n    try {\n      postResult = await assetPostUpsertTasks_(asset, this.ctx)\n    } catch (error) {\n      if (error instanceof AbortError) {\n        this.#logger.warn(\"aborted (caller after me will complete)\", { error })\n      } else {\n        this.#logger.throw(\"Post-upsert tasks failed\", { error })\n      }\n    }\n\n    return {\n      path: this.file.nativePath,\n      state: assetFile.syncState ?? SyncFileStates.synced,\n      assetId: asset.id!,\n      assetFileId,\n      assetFile,\n      asset,\n      uri,\n      uris: [uri, ...toA(postResult?.newAssetFileUris)]\n    }\n  }\n}\n","import { submitTask_ } from \"../../core/event/SharedState\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { SyncFileStates, syncReport } from \"../../core/fs/SyncReport\"\nimport { l, p } from \"../../core/licensing/Licensing\"\nimport { LogLevels } from \"../../core/log/LogLevel\"\nimport { Logger, mkLogger } from \"../../core/Logger\"\nimport { RequiredForceContext } from \"../../core/settings/ForceContext\"\nimport { pathToLibraryAsset } from \"../../core/settings/PathToLibraryAsset\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { readCapturedAt, readTags, sidecarEql } from \"../../core/tags/ExifTool\"\nimport { ensureInferredHistoryRecords } from \"../../core/tags/History\"\nimport { isMimeTypeIncluded } from \"../../core/tags/MimeTypes\"\nimport { readMimeType } from \"../../core/tags/ReadMimeType\"\nimport { mkAssetUrl } from \"../../core/web/WebUrls\"\nimport { compact, isEmpty, uniqBy } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toA } from \"../../fe/toA\"\nimport { PS_LIBRARY_PROTOCOL } from \"../../fe/URI\"\nimport { AssetFile } from \"../model/AssetFile\"\n\nexport async function mayCopyAssetsToLibrary() {\n  return Settings.copyAssetsToLibrary.valueOrDefault && (await p())\n}\n\n/**\n * Stores all found asset files in date-prefixed folder hierarchies.\n */\nexport class AssetFileRepository {\n  private readonly logger: Logger = mkLogger(\"AssetFileRepository\")\n\n  constructor(readonly originalsDir: PosixFile) {}\n\n  async shouldCopy(file: Maybe<PosixFile>) {\n    const whyNot = await this.whyNotCopyFile(file)\n    return this.logger.tap({\n      level: \"info\",\n      msg: \"shouldCopy()\",\n      result: whyNot == null,\n      meta: {\n        file: file?.nativePath,\n        whyNot\n      }\n    })\n  }\n\n  async whyNotCopyFile(src: Maybe<PosixFile>) {\n    if (src == null || blank(src.nativePath)) {\n      return \"blank nativePath\"\n    } else if (!Settings.copyAssetsToLibrary.valueOrDefault || (await l())) {\n      return \"copyAssetsToLibrary is false\"\n    } else if (await src.notExists({ refresh: true })) {\n      return \"file doesn't exist\"\n    } else if (src.isDescendantOf(this.originalsDir)) {\n      return src + \" already contained by \" + this.originalsDir\n    } else if (src.isDescendantOf(Settings.libraryDir.valueOrDefault)) {\n      return src + \" already contained by \" + Settings.libraryDir.valueOrDefault\n    }\n\n    const mt = await readMimeType(src)\n    if (mt == null) {\n      return \"readMimeType(\" + src + \") was null\"\n      // And we don't need to worry about the sidecar, either.\n    } else if (\n      !isMimeTypeIncluded(mt, Settings.copyToLibraryMimeTypes.values)\n    ) {\n      return \"mimetype \" + mt + \" is not included in copyToLibraryMimeTypes\"\n    }\n\n    return null\n  }\n\n  async existingLibraryAssetFile(af: AssetFile) {\n    if (af.uri.startsWith(PS_LIBRARY_PROTOCOL)) return af\n\n    const candidates = uniqBy(\n      toA(af.librarySiblings()?.filter(ea => ea.sha === af.sha)).concat(\n        AssetFile.sameAssetFileInLibrary(af)\n      ),\n      ea => ea.id\n    )\n    for (const prior of candidates) {\n      if (await prior.exists()) {\n        if (prior.assetId !== af.assetId) {\n          this.logger.warn(\n            \"Existing library asset file with a matching SHA is associated to a different asset. Requesting repair of the two impacted assets.\",\n            { af, prior }\n          )\n          const priorAssetId = prior.assetId\n          af.getAsset()?.addAssetFile(prior)\n          void submitTask_(\"repairAsset\", { assetId: priorAssetId! })\n        }\n        this.logger.info(\n          \"whyNotCopyAssetFile(\" + af.uri + \"): found existing db record\",\n          {\n            af,\n            prior\n          }\n        )\n        return prior\n      }\n    }\n    return null\n  }\n\n  // Try to find a file with the same contents\n  async findLibraryFileWithSameContents(src: PosixFile, dest: PosixFile) {\n    if (await src.matchesContent(dest)) return dest\n    let destDir = dest.parent()\n    while (destDir.isSelfOrDescendantOf(this.originalsDir)) {\n      const child = destDir.childWithSameContents(src)\n      if (child != null) return child\n      else destDir = destDir.parent()\n    }\n    return\n  }\n\n  /**\n   * @throws if there are any errors\n   */\n  async importFile_(src: PosixFile): Promise<PosixFile> {\n    // initial sanity check:\n\n    const dest = await this.#importFile_(src)\n    if (dest != null) {\n      await this.#handleSidecars(src, dest)\n      await this.#handleInferred(src, dest)\n    }\n    return dest\n  }\n  async #importFile_(src: PosixFile): Promise<PosixFile> {\n    const ca = await readCapturedAt(src)\n    const assetPath = pathToLibraryAsset(ca?.date, src)\n\n    this.logger.debug(\"importFile(\" + src + \")\", {\n      capturedAt: ca,\n      assetPath: assetPath\n    })\n\n    if (assetPath == null) {\n      throw new Error(src.nativePath + \" failed to create a library path\")\n    }\n    const dest = this.originalsDir.join(...assetPath)\n\n    // Does a file in that subdirectory already have the same filesize and SHA?\n    // This would only happen if the library db is not in sync with the library\n    // directory.\n    const existing = await this.findLibraryFileWithSameContents(src, dest)\n    if (existing != null) {\n      this.logger.debug(\"#importFile_(\" + src + \"): found existing file\", {\n        src,\n        existing\n      })\n      return existing\n    }\n\n    const uniqDest = await dest.ensureNew_()\n    this.logger.info(\"#importFile_(\" + src + \"): copying...\", {\n      uniqDest,\n      dest\n    })\n    return src.copyFile_(uniqDest)\n  }\n\n  async #handleSidecars(src: PosixFile, dest: PosixFile): Promise<PosixFile[]> {\n    const sidecars = await src.existingSidecars()\n    const results = []\n    for (const srcSidecar of sidecars) {\n      results.push(await this.#handleSidecar(srcSidecar, dest))\n    }\n    return compact(results)\n  }\n\n  async #handleSidecar(srcSidecar: PosixFile, dest: PosixFile) {\n    for (const destSidecar of await dest.existingSidecars()) {\n      if (await sidecarEql(srcSidecar, destSidecar)) {\n        this.logger.info(\"handleSidecar(): metadata already exists.\", {\n          srcSidecar,\n          destSidecar,\n          dest\n        })\n        // We don't touch to the same mtime, as they may be different file types.\n        return\n      }\n    }\n    const copyTo = await dest\n      .parent()\n      .join(dest.name + srcSidecar.ext)\n      .ensureNew_({ emptyIsNew: true })\n    return srcSidecar.copyFile_(copyTo)\n  }\n\n  async #handleInferred(src: PosixFile, dest: PosixFile) {\n    if (src == null || dest == null || src.eql(dest)) return\n    const t = await readTags(src)\n    if (t == null) {\n      this.logger.warn(\"#handleInferred(): Failed to read tags from \" + src, {\n        dest\n      })\n      return\n    }\n    // At least for now, only store inferred tags in the sidecar, so we know\n    // in the future that the tag source is not necessarily trustworthy.\n    return ensureInferredHistoryRecords(src, await dest.sidecar(), t.inferred)\n  }\n\n  /**\n   * @return undefined for no-op, rejection for internal error, or new upserted AssetFile if copied\n   */\n  async maybeCopyToLibrary_(\n    srcAssetFile: AssetFile,\n    ctx: RequiredForceContext\n  ): PromiseMaybe<AssetFile> {\n    const start = Date.now()\n    const src = await srcAssetFile.posixFile_()\n    if (src == null) {\n      this.logger.throw(\n        \"maybeCopyToLibrary_(\" + srcAssetFile.uri + \"): posixFile is null\",\n        {\n          ignorable: false,\n          retriable: false\n        }\n      )\n    }\n    {\n      const why = await this.whyNotCopyFile(src)\n      if (!blank(why)) {\n        return this.logger.tap({\n          level: LogLevels.info,\n          msg: \"maybeCopyToLibrary_(): not copying: \" + why,\n          result: undefined\n        })\n      }\n    }\n\n    const asset = srcAssetFile.getAsset()\n    if (asset == null) {\n      this.logger.throw(\n        \"maybeCopyToLibrary_(\" + srcAssetFile.uri + \"): null asset\"\n      )\n    }\n\n    {\n      const prior = await this.existingLibraryAssetFile(srcAssetFile)\n      if (prior != null) {\n        const dest = await prior.posixFile_()\n        if (dest == null) {\n          this.logger.warn(\n            \"existingLibraryAssetFile() returned an assetFile that could not be resolved to a PosixFile\",\n            { prior }\n          )\n        } else {\n          const copiedSidecars = await this.#handleSidecars(src, dest)\n          const copiedInferredMetadata =\n            null != (await this.#handleInferred(src, dest))\n          const upsertNeeded =\n            null != (await prior.upsertIfNeeded_(undefined, ctx.forceSync))\n          const noop =\n            !copiedInferredMetadata && isEmpty(copiedSidecars) && !upsertNeeded\n          if (!noop) {\n            syncReport().onProgress({\n              path: dest.nativePath,\n              from: \"maybeCopyToLibrary()\",\n              state: SyncFileStates.synced,\n              details:\n                \"Found and synced prior replica already in your library \" +\n                stringify({\n                  src: src.nativePath,\n                  upsertNeeded,\n                  copiedSidecars,\n                  copiedInferredMetadata\n                }),\n              elapsedMs: Date.now() - start,\n              url: mkAssetUrl(asset.id)?.toString()\n            })\n          }\n          return prior\n        }\n      }\n    }\n\n    const dest = await this.importFile_(src)\n    if (dest == null) {\n      this.logger.info(\"importFile() returned null\", { srcAssetFile })\n      return\n    }\n    if (dest.nativePath === src.nativePath) {\n      this.logger.info(\"importFile() returned the same nativePath as src\", {\n        srcAssetFile,\n        dest\n      })\n      return\n    }\n\n    const destAF = await asset.assetFileForFile_(dest, { skipUpsert: true })\n    await destAF.updateFromShaSibling_(srcAssetFile)\n    const result = destAF.upsert()\n    syncReport().onProgress({\n      path: dest.nativePath,\n      from: \"maybeCopyToLibrary()\",\n      state: SyncFileStates.copied,\n      details: \"Copied into your library from \" + src.nativePath,\n      elapsedMs: Date.now() - start,\n      url: mkAssetUrl(asset.id)?.toString()\n    })\n    return result\n  }\n}\n","import { mkLogger } from \"../../core/Logger\"\nimport { bestExistingAssetFile } from \"../../core/asset-file/AssetFileSorter\"\nimport { AbortError } from \"../../core/async/AbortError\"\nimport { LastOneInWins } from \"../../core/async/LastOneInWins\"\nimport { WrappedError } from \"../../core/error/WrappedError\"\nimport { AssetPreviewInfo } from \"../../core/img/AssetPreviews\"\nimport { Previews } from \"../../core/img/Previews\"\nimport { transcode_ } from \"../../core/img/Video\"\nimport { ContextualLogger } from \"../../core/log/ContextualLogger\"\nimport { RequiredForceContext } from \"../../core/settings/ForceContext\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { defer } from \"../../fe/Defer\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { Library } from \"../Library\"\nimport { AssetTaggingResult, tagAndUpsertAsset_ } from \"../curators/AssetTagger\"\nimport { Asset } from \"../model/Asset\"\nimport { mayCopyAssetsToLibrary } from \"./AssetFileRepository\"\nimport { updateAssetPreviews_ } from \"./UpdateAssetPreviews\"\n\nconst logger = defer(() => mkLogger(\"sync-file.AssetPostUpsertTasks\"))\nconst lastOneInWins = defer(() => new LastOneInWins<number>(\"Asset tasks\"))\n\nexport function assetPostUpsertTasks(asset: Asset, ctx: RequiredForceContext) {\n  try {\n    return assetPostUpsertTasks_(asset, ctx)\n  } catch (error) {\n    if (error instanceof AbortError) {\n      logger().warn(\"aborted, next caller will clean up my mess\", { error })\n      return\n    } else {\n      throw error\n    }\n  }\n}\n\n/**\n * Runs all the steps needed to finish importing a given asset:\n *\n * - copyAssetsToLibrary\n * - updateAssetPreviews\n * - video transcoding, if necessary\n * - tagAndUpsertAsset\n *\n * If all is well, the asset will be marked as shown. If anything fails, the\n * asset will be marked as unshown.\n */\nexport function assetPostUpsertTasks_(asset: Asset, ctx: RequiredForceContext) {\n  const log = logger().addContext(`.postUpsertAssetTasks_(Asset:${asset?.id})`)\n  if (ctx.skipPreviews && ctx.skipAssetTagging) {\n    log.info(\"skipped (skipPreviews && skipAssetTagging)\")\n    return\n  }\n  if (asset == null) {\n    return log.throw(\"unexpected null asset\", { asset })\n  }\n  const assetId = asset.id\n  if (assetId == null) {\n    return log.throw(\"unexpected null asset.id\", { asset })\n  } else {\n    return lastOneInWins().enqueue(assetId, async ac => {\n      try {\n        return _postUpsertAssetTasks_(log, asset, ctx, ac.signal)\n      } catch (error: any) {\n        // < TODO SITS TYPING\n        if (error instanceof AbortError) {\n          log.warn(\"aborted, next caller will clean up my mess\", { error })\n          return\n        }\n        const causes = [error]\n        log.error(\"failed, marking asset unshown\", { error })\n        try {\n          asset.markUnshownAndUpsert()\n        } catch (upsertError: any) {\n          log.error(\"failed to mark asset unshown\", { upsertError })\n          causes.push(upsertError)\n        }\n        throw new WrappedError(\"Failed to post-process assset \" + asset.id, {\n          causes\n        })\n      }\n    })\n  }\n}\n\nasync function _postUpsertAssetTasks_(\n  log: ContextualLogger,\n  asset: Asset,\n  ctx: RequiredForceContext,\n  ac: AbortSignal\n) {\n  const assetId = asset.id!\n  const assetFiles = asset.getAssetFiles({ refresh: true })\n  const result = {\n    newAssetFileUris: [] as string[],\n    previewsUpdated: false,\n    tagResult: undefined as Maybe<AssetTaggingResult>,\n    transcoded: false\n  }\n\n  log.throwIfAborted(ac)\n\n  if (isEmpty(assetFiles)) {\n    await Asset.remove({\n      assetId,\n      blocklistShas: false,\n      unlinkAssetFiles: false\n    })\n    log.throw(`Asset:${assetId} had no asset files. Deleted.`)\n  }\n\n  // copy valid files to the library: (must be before we do the previews, so\n  // we have a full set of asset files to work from)\n\n  if (await mayCopyAssetsToLibrary()) {\n    const repo = Library.instanceRequired().assetFileRepository()\n    for (const af of assetFiles) {\n      log.throwIfAborted(ac)\n      try {\n        if (await af.exists()) {\n          const libAf = await repo.maybeCopyToLibrary_(af, ctx)\n          if (libAf != null) {\n            result.newAssetFileUris.push(libAf.uri)\n          }\n        }\n      } catch (error) {\n        log.warn(\n          \"Failed to copy variation to library, but we'll try to continue\",\n          {\n            af,\n            error\n          }\n        )\n      }\n    }\n  }\n\n  const info = ctx.skipPreviews\n    ? undefined\n    : await updateAssetPreviews_({\n        asset,\n        assetFiles: asset.getAssetFiles(),\n        ...ctx,\n        ac\n      })\n  const primary = await primaryOrShownAssetFile_(asset, info)\n\n  if (primary == null) {\n    return log.throw(\"null primaryOrShownAssetFile_()\", { asset })\n  }\n\n  asset.markShownAndUpsert_(primary)\n  if (ctx.skipAssetTagging) {\n    log.info(\"skipping asset tagging\")\n  } else {\n    result.tagResult = await tagAndUpsertAsset_(asset)\n  }\n\n  if (ctx.skipPreviews !== true && asset.isVideo()) {\n    const primaryPosixFile = await asset.getShown()?.posixFile_()\n    if (primaryPosixFile == null) {\n      return log.throw(\"null asset.getShown().posixFile\", { asset })\n    }\n    result.transcoded =\n      null !=\n      (await transcode_(\n        primaryPosixFile,\n        Previews.instance()!.ap(assetId).mp4(),\n        { force: ctx.forceRebuildPreviews }\n      ))\n  }\n  return result\n}\n\nasync function primaryOrShownAssetFile_(\n  asset: Asset,\n  info: Maybe<AssetPreviewInfo>\n) {\n  // Can we pull from info?\n  if (gt0(info?.assetFileId)) {\n    const af = asset\n      .getAssetFiles({ refresh: true })\n      .find(ea => ea.id === info?.assetFileId)\n    if (af == null) {\n      return logger().throw(\"AssetPreviewInfo referenced unknown assetFileId\", {\n        asset,\n        info\n      })\n    } else {\n      return af\n    }\n  }\n  // I guess we need to check what's in the db already:\n  const prior = asset.getShown()\n  if (prior != null) return prior\n\n  // Crap, resort to best existing:\n  return bestExistingAssetFile(asset.getAssetFiles())\n}\n","import { SyncFileState, SyncFileStates } from \"../../core/fs/SyncReport\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { gt0 } from \"../../fe/Number\"\nimport { Asset } from \"../model/Asset\"\nimport { AssetFile } from \"../model/AssetFile\"\n\ninterface Result {\n  path: string\n  uri?: string\n  uris?: string[]\n  state: SyncFileState\n  details?: string\n}\n\nexport interface ImportRejectedResult extends Result {\n  state: typeof SyncFileStates.rejected\n}\n\nexport interface ImportSuccessResult extends Result {\n  assetId: number\n  assetFileId: number\n  assetFile: AssetFile\n  asset: Asset\n}\n\nexport interface ImportErrorResult extends Result {\n  error: string\n}\n\nexport type ImportResult =\n  | ImportRejectedResult\n  | ImportSuccessResult\n  | ImportErrorResult\n\nexport function isImportResult(obj: any): obj is ImportResult {\n  return obj != null && notBlank(obj.path) && SyncFileStates.has(obj.state)\n}\n\nexport function isErrorResult(obj: any): obj is ImportErrorResult {\n  return notBlank(obj.error) || obj.state === SyncFileStates.failed\n}\n\nexport function isSuccessResult(obj: any): obj is ImportSuccessResult {\n  return (\n    obj != null &&\n    !isErrorResult(obj) &&\n    gt0(obj.assetId) &&\n    gt0(obj.assetFileId) &&\n    isImportResult(obj) // < they have to be in this order\n  )\n}\n\nexport interface FileProcessor {\n  (nativePath: string, retries?: number): Promise<ImportResult>\n}\n","import { partition } from \"../../core/Array\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { AssetVersion } from \"../../core/PhotoStructureVersions\"\nimport { aggregateAssetFiles } from \"../../core/asset-file/AssetFileAggregator\"\nimport { isSimilarAssetFile } from \"../../core/asset-file/AssetFileComparator\"\nimport { sortAssetFiles } from \"../../core/asset-file/AssetFileSorter\"\nimport { mapAsync, partitionAsync } from \"../../core/async/Promise\"\nimport { UpdateAssetArgs } from \"../../core/event/PhotoStructureEvents\"\nimport { max, min } from \"../../core/math/Vector\"\nimport { forceContextOrSetting } from \"../../core/settings/ForceContext\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { compact, isEmpty, isNotEmpty, uniq } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { eql } from \"../../fe/Eql\"\nimport { Defined } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { Asset } from \"../model/Asset\"\nimport { AssetFile } from \"../model/AssetFile\"\nimport { assetPostUpsertTasks_ } from \"./AssetPostUpsertTasks\"\nimport { _updateAssetFile_ } from \"./UpdateAssetFile\"\nimport { UpdateResult, UpdateSuccessResult } from \"./UpdateResult\"\n\nexport async function updateAsset(cmd: UpdateAssetArgs): Promise<UpdateResult> {\n  try {\n    const result = await _updateAsset_(cmd)\n    return {\n      id: cmd.assetId,\n      skipped: result?.asset == null,\n      ...result\n    }\n  } catch (error: any) {\n    return {\n      id: cmd.assetId,\n      error\n    }\n  }\n}\n\nasync function _updateAsset_(cmd: UpdateAssetArgs): PromiseMaybe<\n  Omit<UpdateSuccessResult, \"id\"> & {\n    asset?: Asset\n  }\n> {\n  const ctx = forceContextOrSetting(cmd)\n  const assetId = cmd.assetId\n  const log = mkLogger(`sync-file.UpdateAsset(${assetId})`)\n\n  const asset = Asset.ops().findById(assetId)\n  if (asset == null) {\n    return log.throw(\"no such asset\")\n  }\n\n  // Capture the original state of the asset's primary asset file:\n  const originalAsset = asset.$clone()\n  const originalPrimaryAF = asset.getShown()?.$clone()\n\n  // first make sure all the asset files are up to date:\n  // NOTE: mapAsync here is OK! ModelDbUpdater updates assets serially.\n  const assetFileResults = await mapAsync({\n    name: \"UpdateAsset.updateAssetFile\",\n    arr: asset.getAssetFiles(),\n    f: af =>\n      _updateAssetFile_({\n        // we may be \"repairing\" an asset, so respect the forceSync:\n        ctx,\n        assetFileId: af.id!,\n        af\n      })\n  })\n\n  if (\n    assetFileResults.some(ea => isTrue(ea.deleted) || notBlank(ea.rejected))\n  ) {\n    // asset files were updated: reload from the db.\n    asset.clear()\n  }\n\n  await backfillUpdate(asset.getAssetFiles())\n\n  const sortedAssetFiles = sortAssetFiles(asset.getAssetFiles())\n\n  const bestAcceptedAF = sortedAssetFiles?.[0]\n\n  if (sortedAssetFiles == null || bestAcceptedAF == null) {\n    // we don't know if the files were deleted, so we can delete the asset.\n    log.warn(\"No existing files. Skipping for now.\")\n    asset.markUnshownAndUpsert()\n    return {\n      asset,\n      rejected:\n        \"Empty asset (no AssetFiles after sorting). Un-showing Asset:\" + assetId\n    }\n  }\n\n  if (!bestAcceptedAF.isVersionUpToDate()) {\n    log.warn(\n      \"Best file needs update, and we already tried to update all files. Skipping this asset.\",\n      { bestAcceptedAF }\n    )\n    asset.markUnshownAndUpsert()\n    return {\n      asset,\n      rejected: `Best AssetFile:${bestAcceptedAF.id}, could not be updated. Un-showing Asset:${assetId}`\n    }\n  }\n\n  const bestCapturedAt = await bestAcceptedAF.capturedAt()\n\n  if (bestCapturedAt == null) {\n    log.warn(\"Best file failed to extract a captured-at\", { bestAcceptedAF })\n    asset.markUnshownAndUpsert()\n    return {\n      asset,\n      rejected: `Best AssetFile:${bestAcceptedAF.id}, failed to extract a captured-at. Un-showing Asset:${assetId}`\n    }\n  }\n\n  const assetIdsToUpdate = new Set<number>()\n\n  // If we have some asset files present, and some asset files non-existant,\n  // assume we had clustered them correctly in the past, and leave them in the\n  // current asset.\n\n  // only care about the asset files that can be with bestAF:\n  const [retainAFs, rejectAFs] = await partitionAsync(\n    sortedAssetFiles,\n    ea => isSimilarAssetFile(ea, bestAcceptedAF)\n    // if the file is missing, kick it to another asset.\n  )\n\n  // shove all non-similar asset files into a new placeholder asset:\n  if (isNotEmpty(rejectAFs)) {\n    // 20220217: Don't worry about revalidating assets now. Just kick them some\n    // place else:\n\n    // cluster them and push into new Assets for later processing.\n\n    const rejectClusters = await aggregateAssetFiles(rejectAFs)\n    for (const arr of rejectClusters) {\n      if (isEmpty(arr)) continue\n      // We don't need to advisory-lock this new asset.\n      const rejectAsset = Asset.ops().insertOne({\n        capturedAtLocal: arr[0]!.capturedAtLocal,\n        shown: false,\n        version: 0\n      })\n      // Make sure we rebuild this asset later!\n      assetIdsToUpdate.add(rejectAsset.id!)\n\n      // update the in-memory asset files:\n      for (const af of arr) {\n        rejectAsset.addAssetFile(af)\n      }\n      // and rather than doing a bunch of upserts, update the db directly:\n      AssetFile.dbl.runf(q =>\n        q\n          .update({ assetId: rejectAsset.id, shown: 0 })\n          .whereIn(\"id\", compact(arr.map(ea => ea.id)))\n      )\n      log.info(\"Pushed rejected asset files into new asset\", {\n        rejectAssetId: rejectAsset.id,\n        rejectCluster: arr.map(ea => ({ id: ea.id, uri: ea.uri }))\n      })\n    }\n  }\n\n  function uniqFields<S extends keyof AssetFile>(\n    s: S\n  ): Defined<AssetFile[S]>[] {\n    return uniq(retainAFs.map(ea => ea[s]))\n  }\n\n  const capturedAts = await Promise.all(retainAFs.map(ea => ea.capturedAt()))\n  const delta = Settings.minCapturedAtPrecisionDifferentMimetypes.valueOrDefault\n  const boundaries = capturedAts.map(ea => ea?.localBoundaries({ delta }))\n  const startBoundary =\n    min(boundaries.map(ea => ea?.start)) ??\n    bestCapturedAt.localBoundaries({ delta })?.start\n  const endBoundary =\n    max(boundaries.map(ea => ea?.end)) ??\n    bestCapturedAt.localBoundaries({ delta })?.end\n\n  // fetch all assetfiles from other assets who have a common SHA or\n  // capturedAtLocal or image hash:\n  const externalAssetFiles = AssetFile.ops().all(\n    AssetFile.query()\n      .limit(Settings.maxContemporaryAdoptionAssets.valueOrDefault)\n      .orderByRaw(\n        `abs(AssetFile.capturedAtLocal - ${bestAcceptedAF.capturedAtLocal})`\n      )\n      .select(\"AssetFile.*\")\n      .distinct()\n      .join(\"Asset\", \"Asset.id\", \"AssetFile.assetId\")\n      // don't return our own asset files:\n      .where(\"AssetFile.assetId\", \"!=\", assetId)\n      // not updated yet\n      .andWhere(\"Asset.version\", \"!=\", AssetVersion)\n      .andWhere(qb1 => {\n        qb1 = qb1.whereIn(\"AssetFile.sha\", uniqFields(\"sha\")) // < same SHA is definitely the same asset\n\n        if (startBoundary == null || endBoundary == null) {\n          log.warn(\n            \"external asset file check: unset start or end localtime boundary\",\n            { capturedAts, startBoundary, endBoundary }\n          )\n        } else {\n          qb1 = qb1.orWhereBetween(\"AssetFile.capturedAtLocal\", [\n            startBoundary,\n            endBoundary\n          ])\n        }\n        // also look at exact-match image hashes:\n        return qb1\n          .orWhereIn(\"AssetFile.meanHash\", uniqFields(\"meanHash\"))\n          .orWhereIn(\"AssetFile.diffHash\", uniqFields(\"diffHash\"))\n          .orWhereIn(\"AssetFile.dctHash\", uniqFields(\"dctHash\"))\n      })\n  )\n\n  log.info(\n    \"asset file candidates for adoption: \",\n    externalAssetFiles.map(ea => ea.posixPathFromGrandparent)\n  )\n\n  const similarAssetFiles = []\n\n  for (const af of externalAssetFiles) {\n    try {\n      // Update the asset files to make sure isSimilarAssetFile has the\n      // correct information:\n      await af.updateFromFile_()\n      // NOTE: we aren't upserting yet, unless it's _actually_ a similar variation\n      if (isSimilarAssetFile(af, bestAcceptedAF)) {\n        log.info(\"adopting similar asset file\", { af })\n        assetIdsToUpdate.add(af.assetId!)\n        af.shown = false\n        asset.addAssetFile(af)\n        af.upsert()\n        similarAssetFiles.push(af)\n      }\n    } catch (error) {\n      log.warn(\n        \"Error updating external asset file. Leaving asset file record as-is.\",\n        { af, error }\n      )\n    }\n  }\n\n  log.info(\"fetched expansion\", {\n    retainAFs: retainAFs.map(ea => ea.id),\n    rejectAFs: rejectAFs.map(ea => ea.id),\n    externalAssetFiles: externalAssetFiles.map(\n      ea => ea.posixPathFromGrandparent\n    ),\n    similarAssetFiles: similarAssetFiles.map(ea => ea.posixPathFromGrandparent)\n  })\n\n  // We may have pulled in asset files from other assets that weren't able to\n  // be updated. Try to backfill if needed.\n  await backfillUpdate([...retainAFs, ...similarAssetFiles])\n\n  if (ctx.skipPreviews && ctx.skipAssetTagging) {\n    log.info(\"skipping previews and tagging\", ctx)\n    asset.upsert()\n  } else {\n    await assetPostUpsertTasks_(asset, ctx)\n  }\n\n  const assetChanged = !eql(originalAsset, asset)\n  const primaryAssetFileChanged = !eql(originalPrimaryAF, asset.getShown())\n\n  const skipped =\n    !assetChanged &&\n    !primaryAssetFileChanged &&\n    !ctx.forceRebuildPreviews &&\n    !ctx.forceSync\n\n  return log.tap({\n    msg: \"updateAsset() result\",\n    level: \"info\",\n    result: {\n      asset,\n      // Tell the other asset ids that they need to be updated:\n      assetIdsToUpdate: Array.from(assetIdsToUpdate),\n      assetFiles: asset.assetFiles!,\n      skipped\n    },\n    meta: {\n      ctx,\n      assetChanged,\n      primaryAssetFileChanged\n    }\n  })\n}\n\nasync function backfillUpdate(assetFiles: AssetFile[]) {\n  const [upd, notUpd] = partition(assetFiles, ea => ea.isVersionUpToDate())\n\n  // Can we back-fill the asset files with existing ones?\n  for (const dest of notUpd) {\n    const sibling = upd.find(ea => ea.sha === dest.sha)\n    if (sibling != null) {\n      mkLogger(\"UpdateAsset(\" + dest.assetId + \")\").info(\"backfilling\", {\n        sibling,\n        dest\n      })\n      const result = await dest.updateFromShaSibling_(sibling)\n      if (result != null) {\n        result.upsert()\n      }\n    }\n  }\n}\n","import { sortAssetFiles } from \"../../core/asset-file/AssetFileSorter\"\nimport { errorToS } from \"../../core/error/Error\"\nimport { UpdateAssetFileArgs } from \"../../core/event/PhotoStructureEvents\"\nimport { mkLogger } from \"../../core/Logger\"\nimport {\n  forceContextOrSetting,\n  RequiredForceContext\n} from \"../../core/settings/ForceContext\"\nimport {\n  uriEncodingVariants,\n  uriIsEquivalent\n} from \"../../core/uri/UriNormalization\"\nimport { isEmpty, isNotEmpty, uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { pick } from \"../../fe/Object\"\nimport { Asset } from \"../model/Asset\"\nimport { AssetFile } from \"../model/AssetFile\"\nimport { UpdateSuccessResult } from \"./UpdateResult\"\n\nexport interface UpdateAssetFileResult extends UpdateSuccessResult {\n  assetFileId: number\n  nativePath?: string\n  error?: string\n  assetDeleted?: boolean\n}\n\nexport async function updateAssetFile(\n  cmd: UpdateAssetFileArgs\n): Promise<UpdateAssetFileResult> {\n  try {\n    return await _updateAssetFile_({\n      ctx: forceContextOrSetting(cmd),\n      assetFileId: cmd.assetFileId,\n      af: AssetFile.ops().findById(cmd.assetFileId)\n    })\n  } catch (err) {\n    return { id: cmd.assetFileId, ...cmd, error: errorToS(err) }\n  }\n}\n\nexport async function _updateAssetFile_({\n  ctx,\n  assetFileId,\n  af\n}: {\n  ctx: RequiredForceContext\n  assetFileId: number\n  af: Maybe<AssetFile>\n}): Promise<UpdateAssetFileResult> {\n  const l = mkLogger(`updateAssetFile(${assetFileId})`)\n  const f = await af?.posixFile_()\n\n  const result = {\n    id: assetFileId,\n    assetFileId,\n    path: f?.nativePath,\n    uri: af?.uri\n  }\n\n  if (af == null) {\n    return { ...result, error: \"db record not found\" }\n  }\n\n  if (f == null) {\n    return { ...result, error: \"file for URI not found\" }\n  }\n\n  const deleted = await f?.isDeletedUri(af.uri)\n\n  if (deleted == null) {\n    l.info(\"no-op: file URI points to an unmounted volume\", result)\n    return { ...result, skipped: true }\n  }\n\n  const rejected = await af.whyRejected()\n  if (deleted || !blank(rejected)) {\n    const ea = { ...result, rejected, deleted }\n    l.warn(\"file was deleted or rejected. Deleting.\", ea)\n    af.delete()\n    return ea\n  }\n\n  const newUri = await f.uri_()\n\n  // Has the scheme improved (was a volsha added)?\n  if (!(await uriIsEquivalent(newUri, af.uri))) {\n    const r = await handleAssetFileUriChange(af, newUri, ctx.forceSync)\n    if (r != null) {\n      return { ...result, ...r }\n    }\n  }\n\n  // If we're on the latest asset file version, we're OK:\n  if (!ctx.forceSync && (await af.matchesFile())) {\n    l.info(\"no-op: file already matches db record\", result)\n    af.touch()\n    return { ...result, skipped: true }\n  }\n\n  return { ...result, ...(await updateAssetFileIfNeeded(af, ctx.forceSync)) }\n}\n\nexport async function handleAssetFileUriChange(\n  af: AssetFile,\n  newUri: string,\n  forceSync: boolean\n) {\n  const l = mkLogger(`handleAssetFileUriChange(${af.id})`)\n\n  // DON'T remove all \"semantic equivalents\": only remove the *same* URI.\n\n  const variants = uniq([\n    ...uriEncodingVariants(af.uri),\n    ...uriEncodingVariants(newUri)\n  ])\n\n  l.warn(\"URI is changing. Avoiding duplicate keys.\", {\n    priorUri: af.uri,\n    variants\n  })\n\n  // If there is another AssetFile with this URI, one of us needs to win:\n  const afsWithNewUri = AssetFile.ops().allf(q =>\n    q.whereIn(\"uri\", variants).andWhereNot({ id: af.id })\n  )\n\n  if (isNotEmpty(afsWithNewUri)) {\n    l.warn(\"Found other AssetFiles with equivalent URIs.\", {\n      afIds: afsWithNewUri.map(ea => ea.id)\n    })\n    const arr = [af, ...afsWithNewUri]\n    const firstExistsWins = sortAssetFiles(arr)\n\n    if (isEmpty(firstExistsWins)) {\n      l.warn(\"sortAssetFiles returned undefined\", {\n        arr: arr.map(ea => pick(ea, \"id\", \"uri\")),\n        variants\n      })\n      return { error: \"sortAssetFiles returned undefined\" }\n    }\n\n    const afIds = arr.map(ea => ea.id!)\n\n    // The first AF to exist should win:\n    for (const winner of firstExistsWins) {\n      if (await winner.exists()) {\n        // Delete the losers:\n        AssetFile.dbl.runf(q =>\n          q\n            .whereIn(\n              \"id\",\n              afIds.filter(ea => ea !== winner.id)\n            )\n            .delete()\n        )\n        const result = updateAssetFileIfNeeded(winner, forceSync)\n        Asset.dbl.runf(q =>\n          q\n            .update({ version: 0, updatedAt: Date.now() })\n            .whereIn(\"id\", uniq(arr.map(ea => ea.assetId)))\n        )\n        return result\n      }\n    }\n  }\n  l.info(\"no-op, no duplicate URIs.\")\n  return\n}\n\nexport async function updateAssetFileIfNeeded(\n  af: AssetFile,\n  forceSync: boolean\n) {\n  const updated = await af.upsertIfNeeded_(undefined, forceSync)\n  if (updated != null) {\n    Asset.touch([af.assetId!])\n  }\n  return { assetFileId: af.id! }\n}\n","import { InternalErrorFlag } from \"../../core/error/ErrorFlags\"\nimport { AssetPreviewInfo } from \"../../core/img/AssetPreviews\"\nimport { buildAssetPreviews_, Previews } from \"../../core/img/Previews\"\nimport { mkLogger } from \"../../core/Logger\"\nimport {\n  ForceContext,\n  forceContextOrSetting\n} from \"../../core/settings/ForceContext\"\nimport { uriIsEquivalent } from \"../../core/uri/UriNormalization\"\nimport { isEmpty } from \"../../fe/Array\"\nimport { defer } from \"../../fe/Defer\"\nimport { eql } from \"../../fe/Eql\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { pick } from \"../../fe/Object\"\nimport { toA } from \"../../fe/toA\"\nimport { Asset } from \"../model/Asset\"\nimport { AssetFile } from \"../model/AssetFile\"\n\nconst logger = defer(() => mkLogger(\"sync-file.UpdateAssetPreviews\"))\n\nexport async function updateAssetPreviews_(\n  args: {\n    assetId?: number\n    asset?: Asset\n    assetFiles?: AssetFile[]\n    ac?: AbortSignal\n  } & Partial<ForceContext>\n): PromiseMaybe<AssetPreviewInfo & { noop?: boolean }> {\n  const assetId =\n    args.assetId ??\n    args.asset?.id ??\n    toA(args.assetFiles).find(ea => gt0(ea.assetId))?.assetId\n  const fc = forceContextOrSetting(args)\n  const log = logger().addContext(\".Asset:\" + assetId)\n\n  if (fc.skipPreviews) {\n    log.warn(\"skipPreviews is true: no-op\")\n    return\n  }\n\n  if (!gt0(assetId)) {\n    return log.throw(\"invalid assetId\", { assetId })\n  }\n\n  const asset = args.asset ?? Asset.ops().findById(assetId)\n  if (asset == null) {\n    return log.throw(\"Asset:\" + assetId + \" not found\")\n  }\n\n  log.throwIfAborted(args.ac)\n\n  try {\n    // assetPreviews assumes it can get native paths:\n    const assetFiles = await asset.getExistingAssetFiles()\n    if (isEmpty(assetFiles)) {\n      log.warn(\"no existing assetFiles\", { asset })\n      return\n    }\n\n    const ap = Previews.instance()!.ap(assetId)\n    const priorInfo = await ap.readInfo()\n\n    log.throwIfAborted(args.ac)\n\n    // We use buildAssetPreviews_ here instead of ap.build() because\n    // buildAssetPreviews_ may be shimmed to run on a worker process:\n    const newInfo: AssetPreviewInfo = await buildAssetPreviews_({\n      ...fc,\n      assetId,\n      assetFiles\n    })\n\n    // Make sure the \"shown\" asset file variant is stored:\n    const primaryAssetFile =\n      assetFiles.find(ea => ea.id === newInfo?.assetFileId) ??\n      assetFiles.find(ea => uriIsEquivalent(newInfo?.uri, ea.uri))\n\n    log.info(\"buildAssetPreviews_()\", { result: newInfo, primaryAssetFile })\n    const primaryPosixFile = await primaryAssetFile?.posixFile_()\n\n    if (\n      primaryAssetFile == null ||\n      primaryPosixFile == null ||\n      true !== (await primaryPosixFile?.exists())\n    ) {\n      return log.throw(\n        \"buildAssetPreviews_() returned invalid assetFileId\" +\n          InternalErrorFlag,\n        {\n          newInfo,\n          assetFiles: assetFiles.map(ea => pick(ea, \"id\", \"uri\")),\n          primaryAssetFile,\n          primaryPosixFile\n        }\n      )\n    }\n\n    const eqlsPrior = eql(priorInfo, newInfo)\n    const noop = newInfo == null || eqlsPrior\n\n    return { ...newInfo, noop }\n  } catch (error) {\n    log.warn(\"Failed to update previews. Un-showing asset \" + assetId, {\n      error\n    })\n    asset.markUnshownAndUpsert()\n    throw error\n  }\n}\n","import { blank, notBlank } from \"../../fe/Blank\"\nimport { gt0 } from \"../../fe/Number\"\n\nexport interface UpdateErrorResult {\n  id: string\n  nativePath?: string\n  details?: string\n  error: Error | string\n}\n\nexport interface UpdateSuccessResult {\n  id: number\n  nativePath?: string\n  details?: string\n  deleted?: boolean\n  rejected?: string | string[]\n  skipped?: boolean\n  assetIdsToUpdate?: number[]\n}\n\nexport type UpdateResult = UpdateErrorResult | UpdateSuccessResult\n\nexport function isUpdateErrorResult(obj: any): obj is UpdateErrorResult {\n  return obj != null && notBlank(obj.error)\n}\n\nexport function isUpdateSuccessResult(obj: any): obj is UpdateSuccessResult {\n  return obj != null && gt0(obj.id) && blank(obj.error)\n}\n","import { Task } from \"batch-cluster\"\nimport { parseJSON } from \"../../core/JSON\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { time } from \"../../core/async/PromiseTimer\"\nimport { isNonRetriableError } from \"../../core/error/ErrorTypes\"\nimport {\n  UpdateAssetArgs,\n  UpdateAssetFileArgs\n} from \"../../core/event/PhotoStructureEvents\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { stringify } from \"../../fe/JSON\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { toS } from \"../../fe/toS\"\nimport { isErrorResult } from \"./ImportResult\"\nimport { updateAsset } from \"./UpdateAsset\"\nimport { updateAssetFile } from \"./UpdateAssetFile\"\nimport { UpdateResult, isUpdateSuccessResult } from \"./UpdateResult\"\n\nconst logger = lazy(() => mkLogger(\"sync-file.UpdateTask\"))\n\n// TODO: DELETE ALL THIS STUFF. JUST USE METHODS! THERE AREN'T MULTIPLE\n// IMPLEMENTATIONS! DANG YOU, PRIOR MATT!\n\nexport type UpdateCommand = UpdateAssetArgs | UpdateAssetFileArgs\n\nexport type UpdateProcessor<T extends UpdateCommand = UpdateCommand> = (\n  cmd: T\n) => PromiseMaybe<UpdateResult>\n\nexport function validUpdateCommandOrElse(cmd: any): UpdateCommand {\n  if (!gt0(cmd.assetId ?? cmd.assetFileId)) {\n    logger().throw(\"validUpdateCommand(): missing asset or assetFile id\", {\n      fatal: false,\n      retriable: false,\n      cmd\n    })\n  }\n  return cmd\n}\n\nexport class UpdateTask extends Task<UpdateResult> {\n  private readonly name: string\n\n  constructor(readonly cmd: UpdateCommand) {\n    super(stringify(validUpdateCommandOrElse(cmd)), input => this.parse(input))\n    this.name = `UpdateTask(${stringify(cmd)})`\n  }\n\n  toString() {\n    return this.name\n  }\n\n  private parse(input: string): UpdateResult {\n    for (const line of compactBlanks(toS(input).split(\"\\n\")).reverse()) {\n      const obj = parseJSON(line)\n      if (isUpdateSuccessResult(obj)) return obj\n    }\n    return logger().throw(this.name + \".parse() failed\", { input })\n  }\n}\n\nexport type SyncFileCommand = UpdateCommand | { path: string; force?: boolean }\n\nexport function describeUpdateCommand(cmd: UpdateCommand): string {\n  const o: any = cmd\n  if (gt0(o.assetId)) {\n    return \"updateAsset:\" + o.assetId\n  } else if (gt0(o.assetFileId)) {\n    return \"updateAssetFile:\" + o.assetFileId\n  } else if (gt0(o.assetPreviewId)) {\n    return \"updateAssetPreviews:\" + o.assetPreviewId\n  } else {\n    return \"invalid command: \" + stringify(cmd)\n  }\n}\n\nexport function handleUpdateCommand(cmd: UpdateCommand): Promise<UpdateResult> {\n  logger().info(\"handleUpdateCommand()\", { cmd })\n  const o: any = cmd\n  const result = time(\n    \"sync-file.\" + describeUpdateCommand(cmd),\n    gt0(o.assetId)\n      ? updateAsset(o)\n      : gt0(o.assetFileId)\n      ? updateAssetFile(o)\n      : logger().throw(\"Invalid update command \" + stringify(cmd))\n  )\n  if (isErrorResult(result)) {\n    const maxRetries = Settings.maxRetries.valueOrDefault\n    const isNonRetriable = isNonRetriableError(result.error)\n    if (gt0(maxRetries) && gt0(cmd.retries) && isNonRetriable !== true) {\n      logger().warn(\"Retrying failed command\", { cmd, result })\n      return handleUpdateCommand({\n        ...cmd,\n        retries: (cmd.retries ?? Settings.maxRetries.valueOrDefault) - 1\n      })\n    } else {\n      logger().warn(\"Command failed, and cannot retry\", {\n        result,\n        isNonRetriable,\n        retries: cmd.retries,\n        maxRetries\n      })\n    }\n  }\n  return result\n}\n","try {\n  require(\"source-map-support\").install()\n} catch {\n  //\n}\nimport { CLI } from \"../core/cli/CLI\"\nimport { ColorArgs } from \"../core/cli/ColorArgs\"\nimport { WriteSettingsArg } from \"../core/cli/WriteSettingsArg\"\nimport { isElectron } from \"../core/platform/Platform\"\nimport { Settings } from \"../core/settings/Settings\"\nimport { ServiceNames } from \"../fe/ServiceNames\"\nimport { DropWorkQueuesArg } from \"./cli/DropWorkQueuesArgs\"\nimport { ExitWhenDoneArg } from \"./cli/ExitWhenDoneArg\"\nimport { ForceArg } from \"./cli/ForceArg\"\nimport { LogArgs } from \"./cli/LogArgs\"\nimport { NoFilterArg } from \"./cli/NoFilterArg\"\nimport { RebuildArg } from \"./cli/RebuildArg\"\nimport { SkipUpdateArg } from \"./cli/SkipUpdateArg\"\nimport { SyncService } from \"./sync/SyncService\"\n\nasync function run() {\n  if (isElectron) {\n    new SyncService() // < no CLI within electron\n  } else {\n    const cmd = new CLI(\n      ServiceNames.sync,\n      \"[files-or-directories...]\",\n      \"If paths are provided on the command line, they should be fully-qualified.\\n\\n* Paths to directories will be scanned recursively.\\n* Paths to files will be imported if they pass configured filters.\\n\\nNote that sync will spawn 1 or more `worker` processes to work in parallel.\"\n    )\n      .add(\n        RebuildArg,\n        ForceArg,\n        DropWorkQueuesArg,\n        NoFilterArg,\n        SkipUpdateArg,\n        ExitWhenDoneArg,\n        WriteSettingsArg,\n        LogArgs,\n        ColorArgs\n      )\n      .parse()\n\n    Settings.argvScanPaths.envValue = cmd.args\n    new SyncService()\n  }\n}\n\nvoid run()\n","import { partition } from \"../../core/Array\"\nimport { withBoundedConcurrency } from \"../../core/async/Promises\"\nimport { time } from \"../../core/async/PromiseTimer\"\nimport { UpdateAssetArgs } from \"../../core/event/PhotoStructureEvents\"\nimport { submitTask_ } from \"../../core/event/SharedState\"\nimport { BaseFile } from \"../../core/fs/BaseFile\"\nimport {\n  isSimpleFile,\n  SimpleFile,\n  toNativePath_\n} from \"../../core/fs/SimpleFile\"\nimport { SyncFileStates, syncReport } from \"../../core/fs/SyncReport\"\nimport { l } from \"../../core/licensing/Licensing\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { sum } from \"../../core/math/Vector\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { isAssetFileExt, isVideoExt } from \"../../core/tags/FileTypes\"\nimport { mkAssetUrl } from \"../../core/web/WebUrls\"\nimport { compact, compactBlanks, isEmpty, isNotEmpty } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport { PS_LIBRARY_SCHEME } from \"../../fe/URI\"\nimport { AssetFile } from \"../model/AssetFile\"\nimport { QueueItem } from \"../stats/QueueItem\"\nimport { FileProcessor } from \"../sync-file/ImportResult\"\nimport { WorkQueue } from \"../WorkQueue\"\nimport { precheckFiles } from \"./PrecheckFiles\"\n\n/**\n * AssetFileQueue manages receiving files (presumably from DirectoryIterator),\n * pushing those files onto work queues, and popping files off when the\n * work iterator says there's free CPU. Those files are then imported by\n * AssetFileImporter.\n */\nexport class AssetFileQueue {\n  private readonly logger = mkLogger(\"AssetFileQueue\")\n\n  private readonly imgQueue: WorkQueue\n  private readonly vidQueue: WorkQueue\n\n  static async for(rootDir: SimpleFile | string, fileProcessor: FileProcessor) {\n    return new AssetFileQueue(toNativePath_(rootDir), fileProcessor)\n  }\n\n  private constructor(rootNativePath: string, _fileProcessor: FileProcessor) {\n    this.imgQueue = WorkQueue.mk({\n      queueNames: [\"img:\" + rootNativePath],\n      processItem: qi => _fileProcessor(qi.contents)\n    })\n    this.vidQueue = WorkQueue.mk({\n      queueNames: [\"vid:\" + rootNativePath],\n      processItem: qi => _fileProcessor(qi.contents),\n      concurrent: false\n    })\n  }\n\n  async waitForCompletion() {\n    await Promise.all([this.imgQueue.awaitDrain(), this.vidQueue.awaitDrain()])\n  }\n\n  clearRecentlyProcessed() {\n    this.imgQueue.recentlyProcessed.clear()\n    this.vidQueue.recentlyProcessed.clear()\n  }\n\n  get currentPaths() {\n    return [\n      ...this.imgQueue.currentQueueContents(),\n      ...this.vidQueue.currentQueueContents()\n    ]\n  }\n\n  get currentBaseFiles() {\n    return this.currentPaths.map(ea => BaseFile.for(ea))\n  }\n\n  hasPath(nativePath: string) {\n    for (const path of this.currentPaths) {\n      if (nativePath === path) return true\n    }\n    return false\n  }\n\n  get currentVideoJobCount(): number {\n    return this.vidQueue.currentWorkCount()\n  }\n\n  get processedCount(): number {\n    return this.processedImageCount + this.processedVideoCount\n  }\n\n  get processedImageCount(): number {\n    return this.imgQueue.processedCount()\n  }\n\n  get processedVideoCount(): number {\n    return this.vidQueue.processedCount()\n  }\n\n  get avgImageProcessingTime() {\n    return this.imgQueue.processMs.p84\n  }\n\n  get avgVideoProcessingTime() {\n    return this.vidQueue.processMs.p84\n  }\n\n  async stats() {\n    return {\n      pendingCount: await this.pendingCount(),\n      processedImageCount: this.processedImageCount,\n      processedVideoCount: this.processedVideoCount,\n      avgImageProcessingTime: this.avgImageProcessingTime,\n      avgVideoProcessingTime: this.avgVideoProcessingTime\n    }\n  }\n\n  currentCounterState() {\n    return {\n      processedImageCount: this.processedImageCount,\n      processedVideoCount: this.processedVideoCount\n    }\n  }\n\n  private itemQuery(queueIds: number[]) {\n    // DON'T GET THIS NEAR ASYNC (knex will try to execute the query)\n    return QueueItem.query().whereIn(\"queueId\", queueIds)\n  }\n\n  private async queueIds() {\n    return [...this.imgQueue.queueIds(), ...this.vidQueue.queueIds()]\n  }\n\n  /**\n   * The count of enqueued and currently-being-processed items.\n   */\n  async pendingCount() {\n    return QueueItem.dbl.pluckFirst<number>(\n      this.itemQuery(await this.queueIds()).count(\"id\")\n    )\n  }\n\n  async pendingContent(limit = 10) {\n    const queueIds = await this.queueIds()\n    return QueueItem.dbl.pluckAll<string>(\n      this.itemQuery(queueIds).select(\"contents\").limit(limit)\n    )\n  }\n\n  pendingImagesCount() {\n    return this.imgQueue.pendingWorkCount()\n  }\n\n  pendingVideoCount() {\n    return this.vidQueue.pendingWorkCount()\n  }\n\n  async etaMs() {\n    return sum([this.imgQueue.etaMs(), this.vidQueue.etaMs()])\n  }\n\n  // fmtProgressEvent(pe: ProgressEvtWithPath) {\n  //   const p = BaseFile.for(pe.path).baseWithGrandparent\n  //   return pe.done === true\n  //     ? \"Processed \" + p\n  //     : compactBlanks([p, mapNotBlank(pe.op, ea => `(${ea})`)]).join(\" \")\n  // }\n\n  /**\n   * Try to give a taste of what we're working on.\n   * @override\n   */\n  recentFileProgress(): Maybe<string[]> {\n    return compact([\n      this.imgQueue.recentlyProcessed.last()?.contents,\n      this.vidQueue.recentlyProcessed.last()?.contents\n    ])\n  }\n\n  async enqueueWork(input: (SimpleFile | string)[]) {\n    if (isEmpty(input)) return\n    const [videos, images] = partition(input.filter(isAssetFileExt), isVideoExt)\n    this.logger.info(\"enqueueWork()\", {\n      input: input.map(toS),\n      videos: videos.map(toS),\n      images: images.map(toS)\n    })\n    this.imgQueue.enqueueWork(\n      images.map(ea => ({ contents: toNativePath_(ea) }))\n    )\n    this.vidQueue.enqueueWork(\n      videos.map(ea => ({ contents: toNativePath_(ea) }))\n    )\n  }\n\n  async enqueueOrTouchAssetFiles(assetFiles: AssetFile[]) {\n    const freshAssetFileIds: number[] = []\n    const copyToLibrary =\n      Settings.copyAssetsToLibrary.valueOrDefault && !(await l())\n    const staleFiles: SimpleFile[] = []\n    await withBoundedConcurrency({\n      name: \"enqueueOrTouchAssetFiles\",\n      laters: assetFiles.map(af => async () => {\n        const pf = await af.posixFile_()\n        const syncProgress = {\n          path: pf?.nativePath ?? af.uri,\n          url: mkAssetUrl(af.assetId)?.toString()\n        }\n        if (true === (await af.isFileDeleted())) {\n          af.delete()\n          const obj: UpdateAssetArgs = {\n            assetId: af.assetId!,\n            forceRebuildPreviews: isTrue(af.shown)\n          }\n          void submitTask_(\"repairAsset\", obj)\n          syncReport().onProgress({\n            ...syncProgress,\n            from: \"enqueueOrTouch()\",\n            details: \"file no longer exists\",\n            state: SyncFileStates.deleted\n          })\n        }\n        if (pf == null) {\n          this.logger.warn(\"Failed to decode URI to existing file\", { af })\n          return\n        }\n        const whyStale = await af.whyNotMatchesFile()\n        const needToCopy =\n          copyToLibrary &&\n          isTrue(af.shown) &&\n          !af.uri.startsWith(PS_LIBRARY_SCHEME)\n        if (notBlank(whyStale) || needToCopy) {\n          // Are we the shown assetfile, but we're supposed to be copying assets\n          // to the library?\n          syncReport().onProgress({\n            ...syncProgress,\n            from: \"enqueueOrTouch()\",\n            state: SyncFileStates.enqueued,\n            details: compactBlanks([\n              whyStale,\n              needToCopy\n                ? \"PS_COPY_ASSETS_TO_LIBRARY is true and this primary variant isn't in the library\"\n                : \"\"\n            ]).join(\"; \")\n          })\n          staleFiles.push(pf)\n        } else {\n          syncReport().onProgress({\n            ...syncProgress,\n            from: \"enqueueOrTouch()\",\n            details: \"DB AssetFile is already in sync\",\n            state: SyncFileStates.noop\n          })\n          freshAssetFileIds.push(af.id!)\n        }\n      })\n    })\n    AssetFile.touch(freshAssetFileIds)\n    await this.enqueueWork(staleFiles)\n    this.logger.info(\"enqueueOrTouchAssetFiles()\", {\n      freshAssetFileIds,\n      staleFiles\n    })\n  }\n\n  async enqueueSimpleFiles(arr: SimpleFile[]) {\n    if (isNotEmpty(arr)) {\n      for (const ea of arr) {\n        syncReport().onProgress({\n          path: toNativePath_(ea),\n          from: \"AssetFileQueue\",\n          state: SyncFileStates.enqueued\n        })\n      }\n      await this.enqueueWork(arr)\n    }\n  }\n\n  /**\n   * Give this method to DirectoryIterator's constructor\n   */\n  readonly fileListener = async (possibleAssets: (SimpleFile | string)[]) => {\n    const arr = possibleAssets.map(ea =>\n      isSimpleFile(ea) ? ea : BaseFile.for(ea)\n    )\n    this.logger.debug(\"fileListener()\", arr)\n    if (Settings.forceSync.valueOrDefault) {\n      return this.enqueueSimpleFiles(arr)\n    } else {\n      const updateFreshFiles = true\n      const { fresh, stale } = await time(\"sync.precheckFiles\", () =>\n        precheckFiles(arr, updateFreshFiles)\n      )\n      this.logger.debug(\"fileListener()\", { fresh, stale })\n      return this.enqueueSimpleFiles(stale)\n    }\n  }\n}\n","import { parseJSON } from \"../../core/JSON\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { forceContextOrSetting } from \"../../core/settings/ForceContext\"\nimport { toGt0 } from \"../../fe/Number\"\nimport { WorkQueue } from \"../WorkQueue\"\nimport { Asset } from \"../model/Asset\"\nimport { QueueItem } from \"../stats/QueueItem\"\nimport { assetPostUpsertTasks_ } from \"../sync-file/AssetPostUpsertTasks\"\n\nexport const AssetPostUpsertQueueName = \"AssetPostUpsertTasks\"\n\nconst logger = lazy(() => mkLogger(\"sync.AssetPostUpsertQueue\"))\n\nexport function mkAssetPostUpsertQueue() {\n  return WorkQueue.mk({\n    queueNames: [AssetPostUpsertQueueName],\n    concurrent: true,\n    async processItem(qi: QueueItem) {\n      const obj = parseJSON(qi.contents)\n      const assetId = toGt0(obj?.assetId) ?? toGt0(qi.contents)\n      if (assetId == null) {\n        logger().error(\"invalid assetId\", { qi })\n        return\n      }\n      const asset = Asset.ops().findById(assetId)\n      if (asset == null) {\n        logger().error(\"asset not found\", { assetId })\n        return\n      }\n      return assetPostUpsertTasks_(\n        asset,\n        forceContextOrSetting({ skipAssetTagging: false, skipPreviews: false })\n      )\n    }\n  })\n}\n","import { parseJSON } from \"../../core/JSON\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { compactBlanks, isEmpty } from \"../../fe/Array\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toInt } from \"../../fe/Number\"\nimport { UpdateResult } from \"../sync-file/UpdateResult\"\nimport { WorkQueue } from \"../WorkQueue\"\nimport { enqueueAssetUpdates } from \"./UpdateQueue\"\n\n/**\n * Only used by ModelDbUpdater\n */\nexport async function mkAssetUpdateQueue(\n  processor: (assetId: number) => PromiseMaybe<UpdateResult>\n): PromiseMaybe<WorkQueue> {\n  if (Settings.noAssetUpdates.valueOrDefault) return\n  const queueNames = compactBlanks(await enqueueAssetUpdates())\n  if (isEmpty(queueNames)) return\n\n  return WorkQueue.mk({\n    queueNames,\n    concurrent: false,\n    processItem(qi) {\n      const obj = parseJSON(qi.contents)\n      return processor(obj?.assetId ?? toInt(qi.contents)!)\n    },\n    endWhenDone: true\n  })\n}\n","import { Knex } from \"knex\"\nimport { DoneWrapper } from \"../../core/async/Done\"\nimport { end, EndableRanks, ending } from \"../../core/async/Endable\"\nimport { lazyAsync } from \"../../core/async/LazyAsync\"\nimport { BoundedList } from \"../../core/BoundedList\"\nimport { DirectoryEntry } from \"../../core/fs/DirectoryEntry\"\nimport { DirectoryWalker } from \"../../core/fs/DirectoryWalker\"\nimport { containedByNativePath } from \"../../core/fs/Path\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { recentSyncReports, syncReport } from \"../../core/fs/SyncReport\"\nimport { unprocessedPaths_ } from \"../../core/fs/SyncReportReader\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { ETA } from \"../../core/math/ETA\"\nimport { sum } from \"../../core/math/Vector\"\nimport { isTest } from \"../../core/NodeEnv\"\nimport { mapGt0 } from \"../../core/Number\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { capitalize } from \"../../core/String\"\nimport { isPaused } from \"../../core/work/IsPaused\"\nimport { maxConcurrentImports } from \"../../core/work/MaxCpus\"\nimport { Percents } from \"../../fe/api/ProgressState\"\nimport { compactBlanks, isEmpty } from \"../../fe/Array\"\nimport { firstNotBlank, mapNotBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { secondMs } from \"../../fe/Date\"\nimport { Latch } from \"../../fe/Latch\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { round, sigFigs, toInt } from \"../../fe/Number\"\nimport { fmt, plur } from \"../../fe/Units\"\nimport { AssetFile } from \"../model/AssetFile\"\nimport { Progress, ProgressUpdatePojo } from \"../model/Progress\"\nimport { ProgressMetaNames, ProgressMetaRecord } from \"../model/ProgressMeta\"\nimport { FileProcessor } from \"../sync-file/ImportResult\"\nimport { AssetFileQueue } from \"./AssetFileQueue\"\nimport { Sync } from \"./Sync\"\n\n// For rusty's volume2, there were 739197 folders in 4899456376 bytes.\n// That's ~800K folders in ~5TB of data: 4899456376 / 739197 = 6628 bytes\n// per folder. That seems OKish?\n\n// const DirectoryContentsEstimateBytes = 5 * KB\n\n/**\n * Manages a DirectoryWalker, AssetProcessor, and cleanup queue, and restoring\n * previous state when available.\n *\n * Also assembles Progress reports.\n */\nexport class DirectorySync extends DoneWrapper implements Sync {\n  static async for({\n    root,\n    rootUri,\n    fileProcessor\n  }: {\n    root: PosixFile\n    rootUri: string\n    fileProcessor: FileProcessor\n  }): PromiseMaybe<DirectorySync> {\n    if (!(await root.clear().isDirectory())) {\n      mkLogger(\"sync.DirectorySync\").warn(\n        \"Cannot sync \" + root + \": it's not a directory (or not readable)\",\n        {\n          root,\n          rootUri\n        }\n      )\n      return\n    }\n    return new DirectorySync(\n      root,\n      rootUri,\n      await AssetFileQueue.for(root, fileProcessor)\n    )\n  }\n\n  readonly start = Date.now()\n  private _isScanning = true // assume we start scanning\n  private readonly eta = new ETA()\n  readonly recentlyScannedDirs = new BoundedList<string>(10)\n  scannedDirsCount = 0\n  private directoryWalker: Maybe<DirectoryWalker>\n\n  /**\n   * We need two flags here: a public \"done\" latch (that we get from\n   * DoneWrapper), and a private \"we're almost done, but we need to do some\n   * final cleanup\" latch, which is this:\n   */\n  readonly preDone = new Latch()\n\n  private priorProcessedImageCount = 0\n  private priorProcessedVideoCount = 0\n\n  protected constructor(\n    readonly root: PosixFile,\n    readonly rootUri: string,\n    readonly afq: AssetFileQueue\n  ) {\n    super(\n      \"sync.DirectorySync(\" + root + \")\",\n      () => this.onEnd(),\n      EndableRanks.first\n    )\n    void this.doneLatch.observe(this.run())\n  }\n\n  private async onEnd() {\n    await end(this.directoryWalker)\n    await this.saveSyncProgress.refresh()\n    await syncReport.prior()?.close()\n  }\n\n  // NO TTL! This must be the same instance for the same directory sync run.\n  readonly _progress = lazy(() =>\n    Progress.insertNew({ uri: this.rootUri, volume: this.root.nativePath })\n  )\n\n  readonly forceDirectoryScan = lazy(() => {\n    const forceSync = Settings.forceSync.valueOrDefault\n    const isArgvPath = Settings.argvScanPaths.values.some(ea =>\n      this.root.eql(ea)\n    )\n    return this.logger.tap({\n      msg: \"forceDirectoryScan\",\n      result: forceSync || isArgvPath,\n      meta: { forceSync, isArgvPath }\n    })\n  })\n\n  readonly initialMeta = lazy<PromiseMaybe<ProgressMetaRecord>>(async () =>\n    this.forceDirectoryScan() ? undefined : this._progress().getMetaAsRecord()\n  )\n\n  // lazy to throttle:\n  readonly saveSyncProgress = lazy(\n    () => Progress.saveSyncState(this),\n    isTest ? 100 : secondMs\n  )\n\n  // lazy to throttle:\n  readonly saveLastScannedDirectory = lazy(\n    async () => {\n      const p = this._progress()\n      p.setMeta(\n        ProgressMetaNames.scannedDirectoryCount,\n        this.scannedDirsCount.toString()\n      )\n      const lastScannedDirectory = this.recentlyScannedDirs.at(-1)\n      if (lastScannedDirectory != null) {\n        p.setMeta(ProgressMetaNames.lastScannedDirectory, lastScannedDirectory)\n      }\n    },\n    isTest ? 100 : secondMs\n  )\n\n  readonly directoryListener = (dir: DirectoryEntry) => {\n    return mapNotBlank(dir?.nativePath, ea => {\n      this.scannedDirsCount++\n      this.recentlyScannedDirs.push(ea)\n      this.logger.debug(\"directoryListener()\", {\n        scannedDirsCount: this.scannedDirsCount,\n        dir: dir.nativePath\n      })\n      return this.saveLastScannedDirectory()\n    })\n  }\n\n  readonly earliestStartTime = lazy(async () => {\n    const times = await Progress.times()\n    const priorTimes = times.find(ea => ea.uri === this.rootUri)\n    return priorTimes?.lastStartedAt ?? Date.now()\n  }) // cache forever\n\n  async #maybeRunDirectorySync_() {\n    const forceDirectoryScan = this.forceDirectoryScan()\n    const initialMeta = await this.initialMeta()\n\n    if (!forceDirectoryScan && isTrue(initialMeta?.completedDirectoryScan)) {\n      return this.logger.tap({\n        msg: \"#maybeRunDirectorySync_(): no-op\",\n        result: undefined,\n        meta: { forceDirectoryScan, initialMeta }\n      })\n    }\n\n    const progress = this._progress()\n    this.scannedDirsCount = toInt(initialMeta?.scannedDirectoryCount) ?? 0\n\n    this.directoryWalker = new DirectoryWalker(\n      (await this.root.directoryEntry())!,\n      this.afq.fileListener,\n      this.directoryListener,\n      initialMeta?.lastScannedDirectory\n    )\n    await this.directoryWalker.awaitEnd()\n    this.logger.info(\"maybeRunDirectorySync_() completed directoryWalker\", {\n      scannedDirsCount: this.scannedDirsCount\n    })\n    progress.setMeta(ProgressMetaNames.completedDirectoryScan, \"true\")\n    return\n  }\n\n  private async maybeEnqueueStaleAssetFiles() {\n    if (\n      !Settings.forceSync.valueOrDefault &&\n      isTrue((await this.initialMeta())?.enqueuedStaleFiles)\n    ) {\n      this.logger.info(\n        \"maybeEnqueueStaleAssetFiles() no-op: prior enqueuedStaleFiles.\"\n      )\n    } else {\n      const progress = this._progress()\n      const earliestStartTime = await this.earliestStartTime()\n\n      this.logger.info(\"maybeEnqueueStaleAssetFiles() starting enqueue\", {\n        assetFileQueuePendingCount: await this.afq.pendingCount()\n      })\n      AssetFile.ops().batched({\n        onResults: async (arr: AssetFile[]) =>\n          this.afq.enqueueOrTouchAssetFiles(arr),\n        qb: (qb: Knex.QueryBuilder) =>\n          qb\n            .whereLike(\"uri\", this.rootUri + \"%\")\n            .andWhere(\"updatedAt\", \"<\", earliestStartTime)\n      })\n      this.logger.info(\"maybeEnqueueStaleAssetFiles() finished enqueue\", {\n        assetFileQueuePendingCount: await this.afq.pendingCount()\n      })\n      progress.setMeta(ProgressMetaNames.enqueuedStaleFiles, \"true\")\n    }\n    return\n  }\n\n  private readonly retryEnqueued = lazy(async () => {\n    const recent = await recentSyncReports()\n    if (isEmpty(recent)) {\n      this.logger.warn(\"retryEnqueued(): no-op: no recent sync reports\")\n      return\n    }\n    const stuck = await unprocessedPaths_({\n      syncReportJsons: recent,\n      acceptPath: ea =>\n        containedByNativePath({\n          ancestor: this.root,\n          descendant: ea\n        })\n    })\n    this.logger.info(\n      \"retryEnqueued(): parsed prior sync reports to find stuck paths.\",\n      {\n        stuck_length: stuck.length,\n        stuck\n      }\n    )\n    await this.afq.enqueueWork(stuck)\n  })\n\n  private readonly run = lazy(async () => {\n    const meta = await this.initialMeta()\n\n    this.logger.info(\"setup()\", {\n      meta\n    })\n\n    // Restore prior state:\n\n    map(meta?.lastScannedDirectory, ea => this.recentlyScannedDirs.push(ea))\n    mapGt0(\n      meta?.processedImageCount,\n      ea => (this.priorProcessedImageCount = ea)\n    )\n    mapGt0(\n      meta?.processedVideoCount,\n      ea => (this.priorProcessedVideoCount = ea)\n    )\n\n    await this.#maybeRunDirectorySync_()\n\n    this.logger.info(\"setup() setting isScanning to false.\")\n    this._isScanning = false\n\n    await this.afq.waitForCompletion()\n\n    if (1 > 2 || Settings.retryEnqueued.valueOrDefault) {\n      this.afq.clearRecentlyProcessed()\n      await this.retryEnqueued()\n      await this.afq.waitForCompletion()\n    }\n\n    await this.maybeEnqueueStaleAssetFiles()\n\n    // We don't need to short-circuit this. We either have work to do or we\n    // don't.\n\n    await this.afq.waitForCompletion()\n\n    // We're complete! Let's do some cleanup if we're not shutting down:\n    if (!this.ended) {\n      this.logger.info(\"DONE! Marking Progress as complete and updating meta.\")\n      await this.preDone.resolve()\n      const p = await this.progress.refresh()\n      p!.setMeta(\"completedDirectorySync\", \"true\")\n      p!.upsert({ completedAt: Date.now() })\n      await this.end()\n    }\n  })\n\n  get processedImageCount() {\n    return this.priorProcessedImageCount + this.afq.processedImageCount\n  }\n\n  get processedVideoCount() {\n    return this.priorProcessedVideoCount + this.afq.processedVideoCount\n  }\n\n  processedCount() {\n    return this.processedImageCount + this.processedVideoCount\n  }\n\n  pendingCount() {\n    return this.afq.pendingCount()\n  }\n\n  get isScanning() {\n    return this._isScanning\n  }\n\n  /**\n   * Terrible hack to just give *some* progress without requiring statting every\n   * file for it's size (which is excruciatingly slow over NASes).\n   *\n   * NEVER SHOW THIS NUMBER TO THE USER. IT IS BOGUS.\n   */\n  async estimatedScannedPct(): Promise<number> {\n    if (!this.isScanning) return 100\n    // this will be undefined for UNC directories:\n    // const estTotFiles = await this.estimatedTotalFileCount\n    // const scanDirEst =\n    //   gte0(estTotFiles) && this.scannedDirsCount <= estTotFiles\n    //     ? (100 * this.scannedDirsCount) / estTotFiles\n    //     : undefined\n    // https://www.desmos.com/calculator/jwzkxpulmt\n    const bogusEst = 100 / -(this.scannedDirsCount / 500 + 1) + 100\n    // const result = clamp(0, 100, avg([scanDirEst, bogusEst])!)\n    return sigFigs(bogusEst, 4)\n  }\n\n  readonly progress = lazyAsync({\n    desc: this.name + \".progress\",\n    timeoutMs: secondMs,\n    ttlMs: 250,\n    later: async () => {\n      const done = this.isDone() || this.preDone.isResolved()\n      const paused = isPaused() || ending()\n      const state = done ? \"done\" : paused ? \"paused\" : \"processing\"\n\n      const dek: string[] = []\n      if (!done && !paused) {\n        mapNotBlank(this.afq.recentFileProgress(), ea => dek.push(ea))\n        if (this.isScanning) {\n          dek.push(\n            \"Scanning \" +\n              firstNotBlank(\n                this.recentlyScannedDirs.shiftOrFirst(),\n                this.root.nativePath\n              )\n          )\n        }\n      }\n\n      const msg: string[] = []\n\n      let counts =\n        \"Processed \" +\n        plur(this.processedImageCount, \"photo\") +\n        \" and \" +\n        plur(this.processedVideoCount, \"video\") +\n        \".\"\n\n      if (this.processedImageCount + this.processedVideoCount > 0) {\n        msg.push(counts)\n      }\n\n      const pendingCount = await this.pendingCount()\n      if (!done && pendingCount > 0) {\n        msg.push(\n          this.isScanning ? \"At least\" : \"\",\n          fmt(pendingCount),\n          \"remain to be processed\"\n        )\n        counts += ` ${this.isScanning ? \"At least\" : \"\"} ${fmt(\n          pendingCount\n        )} to do.`\n      }\n      if (pendingCount < 10) {\n        dek.push((await this.afq.pendingContent()).join(\", \"))\n      }\n      dek.push(compactBlanks(msg).join(\" \"))\n      if (pendingCount < 10) {\n        dek.push()\n      }\n\n      const hed: string[] = []\n      hed.push(capitalize(state))\n      if (!done) map(this.eta.fmtEstimate(), ea => hed.push(ea))\n\n      const p = this._progress()\n\n      if (this.processedImageCount > 1) {\n        p.setMeta(\n          ProgressMetaNames.processedImageCount,\n          String(this.processedImageCount)\n        )\n      }\n      if (this.processedVideoCount > 1) {\n        p.setMeta(\n          ProgressMetaNames.processedVideoCount,\n          String(this.processedVideoCount)\n        )\n      }\n\n      const pcts = await this.percents()\n\n      const obj: ProgressUpdatePojo = {\n        state,\n        hed: hed.join(\", \"),\n        dek,\n        updatedAt: Date.now(),\n        ...pcts\n      }\n\n      if (state === \"done\") {\n        obj.completedAt = Date.now()\n      }\n\n      return this.logger.tap({\n        msg: \".progress()\",\n        level: \"info\",\n        result: p.assignFromPojo(obj)\n      })\n    }\n  })\n\n  async percents(): Promise<Percents> {\n    if (this.isDone()) {\n      return {\n        completePct: 100,\n        incompletePct: 0,\n        scanningPct: 0\n      }\n    }\n\n    // How much has already been scanned:\n    const scannedPct = round(await this.estimatedScannedPct())\n\n    // How much remains to be scanned:\n    const scanningPct = 100 - scannedPct\n\n    const processed = this.processedCount()\n    const pending = await this.pendingCount()\n\n    const completePct =\n      pending === 0 && processed === 0\n        ? 0\n        : round(scannedPct * (processed / (pending + processed)))\n    const incompletePct = 100 - (completePct + scanningPct)\n    const p = { completePct, incompletePct, scanningPct }\n    this.logger.debug(\"percents(): \", { scannedPct, processed, pending, p })\n\n    if (sum([p.completePct, p.incompletePct, p.scanningPct]) !== 100) {\n      this.logger.warn(\"percents(): BUGGED\", {\n        p,\n        processed,\n        pending,\n        scannedPct,\n        scanningPct,\n        incompletePct,\n        completePct\n      })\n    }\n    if (scannedPct === 100 && processed > 7) {\n      const afq = this.afq\n      const imgConcurrency = maxConcurrentImports()\n      const imgCount = afq.pendingImagesCount()\n      const vidCount = afq.pendingVideoCount()\n\n      const imgMs =\n        imgCount === 0\n          ? undefined\n          : map(afq.avgImageProcessingTime, ms =>\n              sigFigs((imgCount * ms) / imgConcurrency, 2)\n            )\n\n      const vidMs =\n        vidCount === 0\n          ? undefined\n          : map(afq.avgVideoProcessingTime, ms => sigFigs(vidCount * ms, 2))\n\n      const eta = sum([imgMs, vidMs])\n\n      if (eta > 0) {\n        this.logger.info(\"ETA\", {\n          eta,\n          imgMs,\n          vidMs,\n          imgCount,\n          imgConcurrency,\n          vidCount\n        })\n        this.eta.push(eta)\n      }\n    }\n    return p\n  }\n}\n","import { Knex } from \"knex\"\nimport { lazy } from \"../../core/Lazy\"\nimport { EndableRanks, ending } from \"../../core/async/Endable\"\nimport { EndableWrapper } from \"../../core/async/EndableWrapper\"\nimport { thenOrElse } from \"../../core/async/Promise\"\nimport { ETA } from \"../../core/math/ETA\"\nimport { max } from \"../../core/math/Vector\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { mapNotBlankOr } from \"../../fe/Blank\"\nimport { Latch } from \"../../fe/Latch\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { groupBy } from \"../../fe/MultiMap\"\nimport { clamp } from \"../../fe/Number\"\nimport { fmt } from \"../../fe/Units\"\nimport { RebuildingURI } from \"../../fe/api/ProgressState\"\nimport { TagRoots } from \"../../fe/api/Tag\"\nimport { addFileUriTagsToAsset } from \"../curators/FilePathTagger\"\nimport { Asset } from \"../model/Asset\"\nimport { AssetFile } from \"../model/AssetFile\"\nimport { Operation } from \"../model/Operation\"\nimport { Progress } from \"../model/Progress\"\nimport { Sync } from \"./Sync\"\n\nexport class DirectoryTaggerOperation extends EndableWrapper implements Sync {\n  readonly start = Date.now()\n  private readonly _eta = new ETA()\n  readonly _done = new Latch()\n  private doneCount: Maybe<number>\n  private todoCount: Maybe<number>\n\n  constructor(readonly priorProgress?: Progress) {\n    super(\"TagAssetsWithFiles\", () => null, EndableRanks.first)\n    void this._done.observeQuietly(\n      Operation.applyOnce(\n        { name: \"applyNewTagger\", value: TagRoots.fs, version: 1 },\n        () => this._run()\n      )\n    )\n  }\n\n  isDone() {\n    return !this._done.isPending()\n  }\n\n  donePromise() {\n    return this._done.promise\n  }\n\n  readonly _progress = lazy(\n    () =>\n      thenOrElse(this.priorProgress, () =>\n        Progress.insertNew({ uri: RebuildingURI, volume: \"🔄\" })\n      )\n    // NO TTL! This needs to be the same instance for the same process.\n  )\n\n  async progress() {\n    if (this.isDone()) {\n      return (await this._progress()).assignFromPojo({\n        state: \"done\",\n        hed: \"Finished rebuilding your library 🎉\",\n        dek: [],\n        completePct: 100,\n        incompletePct: 0,\n        scanningPct: 0\n      })\n    }\n    const eta = this.eta()\n    if (eta == null || this.doneCount == null || this.todoCount == null) return\n\n    const p = await this._progress()\n\n    const complete = this.doneCount / (this.todoCount + this.doneCount)\n    const completePct = clamp(0, 100, Math.round(100 * complete))\n    const est = this._eta.fmtEstimate()\n    const hed =\n      `Adding ${TagRoots.fs} tags to your library` +\n      mapNotBlankOr(est, ea => \", \" + ea, \"…\")\n    return p.assignFromPojo({\n      state: \"processing\",\n      hed,\n      dek: [\n        `Tagged ${fmt(this.doneCount)} URIs, ${fmt(this.todoCount)} remain.`\n      ],\n      completePct,\n      incompletePct: 100 - completePct,\n      scanningPct: 0 // everything's been scanned, so 0.\n    })\n  }\n\n  eta() {\n    if (\n      this.todoCount == null ||\n      this.doneCount == null ||\n      this.todoCount === 0\n    )\n      return undefined\n    const elapsedMs = Date.now() - this.start\n    const msPerItem = elapsedMs / this.doneCount\n    const msRemaining = msPerItem * this.todoCount\n    this._eta.push(msRemaining)\n    return this._eta.avg()\n  }\n\n  private async _run() {\n    this.todoCount = AssetFile.dbl.pluckFirstf<number>(q =>\n      onlyShownAssetFiles(q.countDistinct(\"AssetFile.id\"))\n    )\n    this.doneCount = 0\n    return AssetFile.dbl.batched<{\n      assetId: number\n      assetFileId: number\n      uri: string\n    }>({\n      onResults: arr => {\n        for (const byAsset of groupBy(arr, ea => ea.assetId).values()) {\n          if (ending()) return\n          addFileUriTagsToAsset(\n            byAsset[0].assetId,\n            byAsset.map(ea => ea.uri)\n          )\n          this.doneCount! += byAsset.length\n          this.todoCount! -= byAsset.length\n        }\n      },\n      qb: (qb, priors) => {\n        qb = onlyShownAssetFiles(\n          qb.select({\n            assetId: \"AssetFile.assetId\",\n            assetFileId: \"AssetFile.id\",\n            uri: \"AssetFile.uri\"\n          })\n        )\n        if (isNotEmpty(priors)) {\n          qb = qb.andWhere(\n            \"AssetFile.id\",\n            \">\",\n            max(priors.map(ea => ea.assetFileId))!\n          )\n        }\n        return qb\n      }\n    })\n  }\n}\n\nfunction onlyShownAssetFiles(qb: Knex.QueryBuilder) {\n  return Asset.shownUnhidden(\n    qb.from(\"AssetFile\").join(\"Asset\", \"Asset.id\", \"AssetFile.assetId\")\n  )\n}\n","import { Deferred } from \"../../core/async/Deferred\"\nimport { thenOrElse } from \"../../core/async/Promise\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { lazy } from \"../../core/Lazy\"\nimport { Progress } from \"../model/Progress\"\nimport { Sync } from \"./Sync\"\n\n/**\n * FileSync doesn't save progress to the db.\n */\nexport class FileSync implements Sync {\n  private _ended = false\n  readonly name: string\n  readonly sync: Deferred<any>\n\n  constructor(\n    readonly root: PosixFile,\n    sync: Promise<any>\n  ) {\n    this.name = \"FileSync(\" + root + \")\"\n    this.sync = new Deferred(this.name).observe(sync)\n  }\n\n  get ended() {\n    return this._ended\n  }\n\n  end() {\n    this._ended = true\n  }\n\n  isDone() {\n    return this.sync.isSettled\n  }\n\n  donePromise() {\n    return this.sync.promise\n  }\n\n  readonly uri = lazy(() =>\n    thenOrElse(this.root.uri_(), () => \"file:///\" + this.root.posixPath)\n  )\n\n  get volume() {\n    return this.root.nativePath\n  }\n\n  readonly _progress = lazy(async () =>\n    Progress.insertNew({ uri: await this.uri(), volume: this.volume })\n  )\n\n  async progress() {\n    const p = await this._progress()\n    return p.assignFromPojo({\n      state: this.sync.isPending ? \"processing\" : \"done\"\n    })\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { EndableRanks, endAll, ending } from \"../../core/async/Endable\"\nimport { EndableWrapper } from \"../../core/async/EndableWrapper\"\nimport { onError } from \"../../core/error/OnError\"\nimport { ETA } from \"../../core/math/ETA\"\nimport { isNotEmpty, uniq } from \"../../fe/Array\"\nimport { mapNotBlankOr } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Latch } from \"../../fe/Latch\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, sigFigs } from \"../../fe/Number\"\nimport { fmt } from \"../../fe/Units\"\nimport { RebuildingURI } from \"../../fe/api/ProgressState\"\nimport { toS } from \"../../fe/toS\"\nimport { Library } from \"../Library\"\nimport { WorkQueue } from \"../WorkQueue\"\nimport { Asset } from \"../model/Asset\"\nimport { Progress } from \"../model/Progress\"\nimport { isUpdateSuccessResult } from \"../sync-file/UpdateResult\"\nimport { UpdateProcessor } from \"../sync-file/UpdateTask\"\nimport { mkAssetPostUpsertQueue } from \"./AssetPostUpsertQueue\"\nimport { mkAssetUpdateQueue } from \"./AssetUpdateQueue\"\nimport { Sync } from \"./Sync\"\nimport { outdatedAssetCount } from \"./UpdateQueue\"\n\n/**\n * Updating file metadata...\n * Refreshing assets and previews...\n */\nexport class ModelDbUpdater extends EndableWrapper implements Sync {\n  readonly _done = new Latch()\n  readonly eta = new ETA()\n  readonly updatedAssetIds = new Set<number>()\n\n  private assetFileUpdateQueue: Maybe<WorkQueue>\n  // private afq = new SimpleAssetFileUpdater() // TODO: use this instead?\n  private postUpsertQueue: Maybe<WorkQueue>\n  private assetUpdateQueue: Maybe<WorkQueue>\n\n  constructor(\n    readonly opts: {\n      processor: UpdateProcessor\n    }\n  ) {\n    super(\"ModelDbUpdater\", () => this.onEnd(), EndableRanks.first)\n    void this.run()\n  }\n\n  readonly _progress = lazy(\n    () => Progress.insertNew({ uri: RebuildingURI, volume: \"🔄\" })\n    // NO TTL! This needs to be the same instance for the same process.\n  )\n\n  readonly saveSyncProgress = lazy(\n    () => Progress.saveSyncState(this),\n    // lazy with 1s db write throttle:\n    secondMs\n  )\n\n  private async run() {\n    try {\n      if (this.ended || ending()) return\n\n      // this should be a no-op (SyncService.setup should have awaited it\n      // already):\n      await Library.instanceRequired().ready\n\n      // this.afq =  await mkAssetFileUpdateQueue(this.opts.processor)\n      this.assetFileUpdateQueue?.ee.on(\"processed\", this.saveSyncProgress)\n\n      this.logger.info(\"Starting asset file updates\", {\n        afqName: this.assetFileUpdateQueue?.name,\n        afqEnded: this.assetFileUpdateQueue?.ended,\n        afqRunnable: this.assetFileUpdateQueue?.isRunnable(),\n        workStats: this.assetFileUpdateQueue?.p?.stats()\n      })\n\n      await this.assetFileUpdateQueue?.awaitDrain()\n\n      this.logger.info(\"Completed asset file updates\", {\n        afqName: this.assetFileUpdateQueue?.name,\n        afqEnded: this.assetFileUpdateQueue?.ended,\n        afqRunnable: this.assetFileUpdateQueue?.isRunnable(),\n        workStats: this.assetFileUpdateQueue?.p?.stats()\n      })\n\n      await this.assetFileUpdateQueue?.end()\n\n      this.eta.clear()\n      await this.saveSyncProgress()\n\n      if (this.ended || ending()) return\n\n      // pq will be getting jobs from aq, so it needs to be started first...\n      this.postUpsertQueue = mkAssetPostUpsertQueue()\n      this.postUpsertQueue?.ee.on(\"processed\", this.saveSyncProgress)\n\n      this.assetUpdateQueue = await mkAssetUpdateQueue(assetId =>\n        this.assetUpdater(assetId)\n      )\n      this.assetUpdateQueue?.ee.on(\"processed\", this.saveSyncProgress)\n\n      this.logger.info(\"Starting asset updates\", {\n        aqName: this.assetUpdateQueue?.name,\n        aqEnded: this.assetUpdateQueue?.ended,\n        workStats: this.assetFileUpdateQueue?.p?.stats()\n      })\n\n      this.logger.info(\"run(): waiting for asset updates to complete...\")\n      await this.assetUpdateQueue?.awaitDrain()\n      await this.saveSyncProgress()\n\n      await this.assetUpdateQueue?.end()\n\n      // At this point the AssetUpdateQueue will have enqueued all necessary preview work. Wait for it to empty out, and then end.\n      this.logger.info(\"run(): waiting for asset previews to complete...\")\n      await this.postUpsertQueue.awaitDrain()\n      await this.postUpsertQueue.end()\n\n      // Make sure the \"we're done now\" progress gets persisted:\n      await this.saveSyncProgress.refresh()\n\n      this.logger.info(\"run(): finished\")\n\n      if (!this.ended) {\n        // We only mark _done on completion:\n        void this._done.resolve()\n        await Progress.saveSyncState(this)\n      }\n    } catch (err: any) {\n      onError(\"ModelDbUpdater.run() failed\", err)\n      void this._done.reject(err)\n    }\n  }\n\n  private readonly _outdatedAssetCount = lazy(() => outdatedAssetCount())\n\n  outdatedAssetCount() {\n    return (\n      this.assetUpdateQueue?.pendingWorkCount() ?? this._outdatedAssetCount()\n    )\n  }\n\n  private async assetUpdater(assetId: number) {\n    this.updatedAssetIds.add(assetId)\n    const result = await this.opts.processor({\n      assetId,\n      skipPreviews: true,\n      skipAssetTagging: true\n    })\n    this.logger.info(\"ModelDbUpdater.assetUpdater(\" + assetId + \")\", { result })\n\n    if (isUpdateSuccessResult(result)) {\n      // not true that it was skipped === skipped was false\n      this.postUpsertQueue!.enqueueWork([{ contents: stringify({ assetId }) }])\n\n      const assetIdsToUpdate = result?.assetIdsToUpdate\n      if (isNotEmpty(assetIdsToUpdate)) {\n        // Don't update the same asset on the same rebuild run:\n        const newIds = assetIdsToUpdate.filter(\n          id => !this.updatedAssetIds.has(id)\n        )\n        if (isNotEmpty(newIds)) {\n          Asset.dbl.runf(q => q.whereIn(\"id\", newIds).update({ version: 0 }))\n        }\n        if (this.assetUpdateQueue == null || this.assetUpdateQueue.ended) {\n          this.logger.warn(\n            \"non-empty assetIdsToUpdate, and AssetQueue is null/ended\"\n          )\n        } else {\n          this.assetUpdateQueue.enqueueWork(\n            newIds.map(ea => ({ contents: toS(ea) }))\n          )\n        }\n      }\n    }\n\n    return result\n  }\n\n  private async onEnd() {\n    // NOTE: DO NOT resolve this._done here! end() does not mean done!\n    await endAll(\n      this.assetFileUpdateQueue,\n      this.postUpsertQueue,\n      this.assetUpdateQueue\n    )\n    this.assetFileUpdateQueue =\n      this.postUpsertQueue =\n      this.assetUpdateQueue =\n        undefined\n  }\n\n  isNoOp() {\n    return (\n      !gt0(this.assetFileUpdateQueue?.processedCount()) &&\n      !gt0(this.postUpsertQueue?.processedCount()) &&\n      !gt0(this.assetUpdateQueue?.processedCount())\n    )\n  }\n\n  isDone() {\n    return !this._done.isPending()\n  }\n\n  donePromise() {\n    return this._done.promise\n  }\n\n  async progress() {\n    // We might not need to have done anything. If the queues are empty, return\n    // undefined.\n    if (this.ended || this.isNoOp()) return\n    const p = this._progress()\n\n    if (this.isDone()) {\n      return [\n        p.assignFromPojo({\n          state: \"done\",\n          hed: \"Finished rebuilding your library 🎉\",\n          dek: [],\n          completePct: 100,\n          incompletePct: 0,\n          scanningPct: 0\n        })\n      ]\n    }\n    const scanningPct = 0 // everything's been scanned, so 0.\n\n    const afq = this.assetFileUpdateQueue\n    if (afq != null && !afq.isDone()) {\n      const done = afq.processedCount()\n      const assetFilesPending = afq.pendingWorkCount()\n      if (gt0(afq.processRate.msPerEvent)) {\n        this.eta.push(\n          ((await this.outdatedAssetCount()) + assetFilesPending) *\n            afq.processRate.msPerEvent\n        )\n      }\n      const { completePct } = afq.percents()\n      const est = this.eta.fmtEstimate()\n      const hed =\n        \"Rebuilding your library\" + mapNotBlankOr(est, ea => \", \" + ea, \"…\")\n\n      return [\n        p.assignFromPojo({\n          state: \"processing\",\n          hed,\n          dek: [\n            `Updating file metadata (${fmt(done)} processed, ${fmt(\n              assetFilesPending\n            )} remain)`\n          ],\n          completePct: 0,\n          incompletePct: completePct,\n          scanningPct\n        })\n      ]\n    } else if (this.assetUpdateQueue != null && this.postUpsertQueue != null) {\n      const aqPending = this.assetUpdateQueue.pendingWorkCount()\n      // Ignore PQ: AQ is the critical path.\n      this.eta.push(\n        aqPending * (this.assetUpdateQueue.processRate.msPerEvent ?? secondMs)\n      )\n\n      const todo = aqPending\n      const done = this.assetUpdateQueue.processedCount()\n      const complete = done / (todo + done)\n      const completePct = sigFigs(100 * complete, 2)\n      const est = this.eta.fmtEstimate()\n      const hed =\n        \"Rebuilding your library\" + mapNotBlankOr(est, ea => \", \" + ea, \"…\")\n      return p.assignFromPojo({\n        state: \"processing\",\n        hed,\n        dek: uniq([\n          `Refreshing assets and previews (${fmt(done)} processed, ${fmt(\n            aqPending\n          )} remain)`\n        ]),\n        completePct,\n        incompletePct: 100 - completePct,\n        scanningPct\n      })\n    }\n    return\n  }\n}\n","import { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { filterAsync, thenMapOr } from \"../../core/async/Promise\"\nimport { libraryOriginalsDirPosixFile } from \"../../core/dir/LibraryDirs\"\nimport { ee } from \"../../core/event/EventEmitter\"\nimport { isReadableDirectory } from \"../../core/fs/Stat\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { nativePath2uri } from \"../../core/uri/FileURI\"\nimport { isExcludedMountpoint } from \"../../core/volumes/PosixVolumes\"\nimport { volumes } from \"../../core/volumes/Volumes\"\nimport { later } from \"../../fe/Delay\"\nimport { gt0 } from \"../../fe/Number\"\nimport { thenCollect } from \"../../fe/Promise\"\nimport { toA } from \"../../fe/toA\"\nimport { nativePathBlocklist } from \"./SyncPaths\"\nimport {\n  UriPath,\n  nativePathToUriPath,\n  posixFileToUriPath,\n  toUriPath\n} from \"./UriPath\"\n\nexport const logger = lazy(() => mkLogger(\"sync.PathsToSync\"))\n\nconst volumeUriPaths = lazy(() =>\n  thenCollect(volumes(), vol =>\n    vol.ignorable !== true &&\n    gt0(vol.size) &&\n    !isExcludedMountpoint(vol.mountpoint)\n      ? toUriPath(vol.mountpoint, nativePath2uri(vol.mountpoint, vol))\n      : undefined\n  )\n)\n\nexport async function scanPaths() {\n  const noUriPaths: string[] = []\n  const result: UriPath[] = []\n  for (const scanDir of toA(Settings.scanPaths.value)) {\n    if (!(await isReadableDirectory(scanDir))) {\n      logger().warn(\n        \"Ignoring scanPath element: not readable directory\",\n        scanDir\n      )\n    } else {\n      const uriPath = await nativePathToUriPath(scanDir)\n      if (uriPath == null) {\n        noUriPaths.push(scanDir)\n        logger().warn(\n          \"Ignoring scanPath element: failed to create URI path\",\n          scanDir\n        )\n      } else {\n        result.push(uriPath)\n      }\n    }\n  }\n  return { result, noUriPaths }\n}\n\nlater(() => {\n  ee().on(\"volumesChanged\", () => {\n    volumeUriPaths.unset()\n  })\n})\n\nexport async function pathsToSync(): Promise<UriPath[]> {\n  const arr: UriPath[] = []\n  arr.push(...(await scanPaths()).result)\n  if (Settings.scanAllDrives.valueOrDefault) {\n    arr.push(...(await volumeUriPaths()))\n  }\n\n  const lp = await thenMapOr(\n    libraryOriginalsDirPosixFile(),\n    posixFileToUriPath,\n    () =>\n      logger().throw(\"libraryOriginalsDir was null\", {\n        libraryDir: Settings.libraryDir.valueOrDefault,\n        originalsDir: Settings.originalsDir.value\n      })\n  )\n\n  if (Settings.scanLibraryFirst.valueOrDefault) {\n    arr.unshift(lp!)\n  }\n\n  if (Settings.scanLibraryLast.valueOrDefault) {\n    arr.push(lp!)\n  }\n\n  const result = await filterAsync({\n    name: \"pathsToSync\",\n    arr,\n    f: ea =>\n      !nativePathBlocklist.has(ea.nativePath) &&\n      isReadableDirectory(ea.nativePath)\n  })\n\n  logger().info(\"pathsToSync\", result)\n  return result\n}\n","import { batches } from \"../../core/Array\"\nimport { SimpleFile } from \"../../core/fs/SimpleFile\"\nimport { SyncFileStates, syncReport } from \"../../core/fs/SyncReport\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { nativePath2uri } from \"../../core/uri/FileURI\"\nimport { uriEncodingVariants } from \"../../core/uri/UriNormalization\"\nimport { mkAssetUrl } from \"../../core/web/WebUrls\"\nimport { blank } from \"../../fe/Blank\"\nimport { fmtHMS } from \"../../fe/Date\"\nimport { groupBy } from \"../../fe/MultiMap\"\nimport { gte } from \"../../fe/Number\"\nimport { AssetFile } from \"../model/AssetFile\"\n\n/**\n * Remove the files in `files` that are already in sync with the library.\n */\nexport async function precheckFiles(\n  files: SimpleFile[],\n  updateFreshFiles = true\n) {\n  const uri2file = new Map<string, SimpleFile>()\n  const byDir = groupBy(files, ea => ea.dir)\n  for (const [dir, arr] of byDir.entries()) {\n    const uri = await nativePath2uri(dir)\n    for (const file of arr) {\n      for (const ea of uriEncodingVariants(uri + \"/\" + file.base)) {\n        uri2file.set(ea, file)\n      }\n    }\n  }\n\n  const fresh: { path: string; assetId: number; assetFileId: number }[] = []\n  const inSyncAssetFileIds: number[] = []\n\n  const maxUpdatedDeltaTs =\n    Date.now() - Settings.syncChangedIntervalMs.valueOrDefault\n\n  for (const uris of batches([...uri2file.keys()], 256)) {\n    const priors = AssetFile.ops().allf(q => q.whereIn(\"uri\", uris))\n\n    for (const af of priors) {\n      const de = uri2file.get(af.uri)!\n      if (de == null) {\n        syncReport().onProgress({\n          path: (await af.posixFile_())?.nativePath ?? af.uri,\n          from: \"Precheck\",\n          state: SyncFileStates.failed,\n          details:\n            \"Failed to correlate prior AssetFile with requested DirectoryEntry\"\n        })\n      } else if (gte(af.updatedAt, maxUpdatedDeltaTs)) {\n        syncReport().onProgress({\n          path: de.nativePath,\n          from: \"Precheck\",\n          state: SyncFileStates.noop,\n          details: \"synced \" + fmtHMS(Date.now() - af.updatedAt!) + \" ago\",\n          url: mkAssetUrl(af.assetId)?.toString()\n        })\n        fresh.push({\n          path: de.nativePath,\n          assetId: af.assetId!,\n          assetFileId: af.id!\n        })\n      } else {\n        const why = await af.whyNotNoop()\n        if (blank(why)) {\n          syncReport().onProgress({\n            path: de.nativePath,\n            from: \"Precheck\",\n            state: SyncFileStates.noop,\n            details: \"in sync\",\n            url: mkAssetUrl(af.assetId)?.toString()\n          })\n          inSyncAssetFileIds.push(af.id!)\n          fresh.push({\n            path: de.nativePath,\n            assetId: af.assetId!,\n            assetFileId: af.id!\n          })\n        } else {\n          syncReport().onProgress({\n            path: de.nativePath,\n            from: \"Precheck\",\n            state: SyncFileStates.enqueued,\n            details: \"update needed: \" + why,\n            url: mkAssetUrl(af.assetId)?.toString()\n          })\n        }\n      }\n    }\n  }\n\n  if (updateFreshFiles) AssetFile.touch(inSyncAssetFileIds)\n\n  const freshPaths = new Set(fresh.map(ea => ea.path))\n\n  return {\n    fresh,\n    stale: files.filter(ea => !freshPaths.has(ea.nativePath))\n  }\n}\n","import { ending } from \"../../core/async/Endable\"\nimport { EndableInterval } from \"../../core/async/EndableInterval\"\nimport { broadcastEvent_ } from \"../../core/event/BroadcastEvent\"\nimport { isPaused } from \"../../core/work/IsPaused\"\nimport { sortBy } from \"../../fe/ArraySort\"\nimport { eql } from \"../../fe/Eql\"\nimport { MaybeSyncOrAsync } from \"../../fe/SyncOrAsync\"\nimport { Progress, ProgressPojo, ProgressRateMs } from \"../model/Progress\"\nimport { runTagMaintenance } from \"../tag/TagSql\"\nimport { Sync } from \"./Sync\"\n\nexport class ProgressUpdater extends EndableInterval {\n  private prior: ProgressPojo[] = []\n  constructor(readonly sync: () => MaybeSyncOrAsync<Sync>) {\n    super({\n      name: \"ProgressUpdater\",\n      callback: () => this.onInterval(),\n      intervalMs: ProgressRateMs()\n    })\n  }\n\n  async onInterval() {\n    if (ending() || isPaused()) {\n      this.prior = []\n      return\n    }\n    const s = await this.sync()\n    if (s == null) {\n      this.prior = []\n      return\n    }\n    const arr = await Progress.saveSyncState(s)\n    const current = sortBy(arr, ea => ea.uri).map(ea => ea.toSyncState())\n    if (!eql(this.prior, current)) {\n      void broadcastEvent_(\"updateProgress\")\n      await runTagMaintenance()\n      this.prior = current\n    }\n  }\n}\n","export const SyncCompleted = { syncCompleted: true }\n","import { greatestBy, leastBy } from \"../../core/Array\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { isSyncService } from \"../../core/ServiceNames\"\nimport { ShortCommandTimeoutMs } from \"../../core/ShortCommandTimeoutMs\"\nimport { TTLSet } from \"../../core/TTLSet\"\nimport { tsToLocal } from \"../../core/date/Localtime\"\nimport { libraryOriginalsDirPosixFile } from \"../../core/dir/LibraryDirs\"\nimport { ee } from \"../../core/event/EventEmitter\"\nimport { LogLevels } from \"../../core/log/LogLevel\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { compact } from \"../../fe/Array\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { fmtDuration } from \"../../fe/FmtDuration\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { closeTo, gt } from \"../../fe/Number\"\nimport { Operation, OperationNames } from \"../model/Operation\"\nimport { Progress, ProgressTimes } from \"../model/Progress\"\nimport { pathsToSync } from \"./PathsToSync\"\nimport { UriPath } from \"./UriPath\"\n\nconst logger = lazy(() => mkLogger(\"sync.SyncPaths\"))\n\nexport const nativePathBlocklist = new TTLSet(10 * minuteMs)\n\nexport type UriPathTimes = UriPath & Partial<Exclude<ProgressTimes, \"uri\">>\n\nexport async function pathsAndTimesToSync(): Promise<UriPathTimes[]> {\n  const todo = await pathsToSync()\n  const times = Settings.forceSync.valueOrDefault ? [] : await Progress.times()\n  return logger().tap({\n    msg: \"pathsAndTimesToSync()\",\n    level: LogLevels.info,\n    result: todo.map(path => ({\n      ...path,\n      ...times.find(ea => ea.uri === path.uri)\n    }))\n  })\n}\n\nexport async function restartSyncAt() {\n  const arr = await pathsAndTimesToSync()\n  return (\n    Math.min(...compact([Date.now(), ...arr.map(ea => ea.lastCompletedAt)])) +\n    Settings.syncNewIntervalMs.valueOrDefault\n  )\n}\n\nexport async function bestPathToSync() {\n  return bestStable(await pathsAndTimesToSync())\n}\n\nexport const getStaleCompletedAt = lazy(async () => {\n  // A sync is \"stale\" if the user has asked for a full-resync and it hasn't\n  // completed:\n  const op = Operation.getFirstPendingOp({\n    name: OperationNames.forceRestartSync\n  })\n\n  return (\n    op?.createdAt ??\n    // Or it's been more than syncIntervalHours since now since the last sync:\n    Date.now() - Settings.syncNewIntervalMs.valueOrDefault\n  )\n}, ShortCommandTimeoutMs)\n\nlater(() => ee().on(\"clearCache\", () => getStaleCompletedAt.unset()))\n\n/**\n * This algorithm tries to keep a stable \"best\" pick, until the best is done.\n */\nexport async function bestStable(arr: UriPathTimes[]) {\n  const staleCompletedAt = await getStaleCompletedAt()\n  const incomplete = arr.filter(\n    ea => ea.lastCompletedAt == null || ea.lastCompletedAt < staleCompletedAt\n  )\n\n  logger().info(\"bestStable()\", {\n    paths: arr.map(ea => ({\n      ...ea,\n      lastStarted: map(ea.lastStartedAt, tsToLocal),\n      lastCompleted: map(ea.lastCompletedAt, tsToLocal),\n      lastUpdated: map(ea.lastUpdatedAt, tsToLocal),\n      incomplete:\n        ea.lastCompletedAt == null || ea.lastCompletedAt < staleCompletedAt,\n      staleMs: staleCompletedAt - (ea.lastCompletedAt ?? 0)\n    })),\n    stalePaths: incomplete.map(ea => ea.nativePath),\n    stale: tsToLocal(staleCompletedAt)\n  })\n\n  // 1. If we're currently syncing a volume, keep at that until it's done.\n  {\n    const mostRecentlyUpdated = greatestBy(incomplete, ea => ea.lastUpdatedAt)\n    // Only return this if we touched it in the last 15 minutes.\n    if (\n      mostRecentlyUpdated != null &&\n      gt(mostRecentlyUpdated.lastUpdatedAt, Date.now() - 15 * minuteMs)\n    ) {\n      logger().info(\n        \"bestStable(): returning most recently updated\",\n        mostRecentlyUpdated\n      )\n      return { ...mostRecentlyUpdated, why: \"recently updated\" }\n    }\n    // Otherwise, there's no need to be \"stable\":\n  }\n\n  // ** Assume order of arr matters **\n\n  // If there are any volumes we've never done before, start those:\n  {\n    const neverStartedBefore = incomplete.find(ea => ea.lastStartedAt == null)\n    if (neverStartedBefore != null) {\n      logger().info(\n        \"bestStable(): returning neverStartedBefore\",\n        neverStartedBefore\n      )\n      return { ...neverStartedBefore, why: \"never synced before\" }\n    }\n  }\n\n  {\n    // If any volumes haven't been completed, start those:\n    const neverCompletedBefore = incomplete.find(\n      ea => ea.lastCompletedAt == null\n    )\n    if (neverCompletedBefore != null) {\n      logger().info(\n        \"bestStable(): returning neverCompletedBefore\",\n        neverCompletedBefore\n      )\n      return { ...neverCompletedBefore, why: \"never completed before\" }\n    }\n  }\n\n  {\n    // They've all been completed at least once. Return the least completed:\n    const leastRecentlyCompleted = leastBy(incomplete, ea => ea.lastCompletedAt)\n    if (leastRecentlyCompleted != null) {\n      logger().info(\n        \"bestStable(): returning leastRecentlyCompleted\",\n        leastRecentlyCompleted\n      )\n      return { ...leastRecentlyCompleted, why: \"least recently synced\" }\n    }\n  }\n\n  logger().info(\n    \"bestPathToSync(): all paths have been recently completed (yay).\"\n  )\n\n  // This is called by `info`: don't mark completed if we're not `sync`!\n  if (isSyncService()) {\n    logger().info(\"bestPathToSync(): Marking sync as complete.\")\n    Operation.markOpCompleted({ name: OperationNames.forceRestartSync })\n  }\n\n  return\n}\n\nfunction uptToStatus(info: UriPathTimes, staleCompletedAt: number) {\n  return info.lastStartedAt == null\n    ? \"new\"\n    : gt(info.lastUpdatedAt, Date.now() - 10 * secondMs) &&\n      !closeTo(info.lastCompletedAt, info.lastUpdatedAt, 5 * secondMs)\n    ? \"syncing\"\n    : gt(info.lastCompletedAt, staleCompletedAt)\n    ? \"synced\"\n    : \"stale\"\n}\n\nfunction tsToISO(ts: Maybe<number>) {\n  return ts == null ? undefined : new Date(ts).toISOString()\n}\n\nfunction tsToAgo(ts: Maybe<number>) {\n  if (ts == null) return\n  const dur = Date.now() - ts\n  return dur < 2 * secondMs ? \"just now\" : fmtDuration(dur) + \" ago\"\n}\n\nexport async function syncPathsForUI() {\n  const arr = await pathsAndTimesToSync()\n  const best = await bestStable(arr)\n  const staleCompletedAt = await getStaleCompletedAt()\n  const libraryDir = libraryOriginalsDirPosixFile()?.nativePath\n\n  return arr.map(info => ({\n    path: info.nativePath,\n    library: libraryDir === info.nativePath,\n    status: uptToStatus(info, staleCompletedAt),\n    isNext: info.nativePath === best?.nativePath,\n    lastStartedISO: tsToISO(info.lastStartedAt),\n    lastStarted: tsToAgo(info.lastStartedAt),\n    lastCompletedISO: tsToISO(info.lastCompletedAt),\n    lastCompleted: tsToAgo(info.lastCompletedAt)\n  }))\n}\n","import { end, EndableRanks } from \"../../core/async/Endable\"\nimport { EndableWrapper } from \"../../core/async/EndableWrapper\"\nimport { thenMap } from \"../../core/async/Promise\"\nimport { ee } from \"../../core/event/EventEmitter\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { clearReaddirCaches } from \"../../core/fs/Readdir\"\nimport { Latch } from \"../../fe/Latch\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { FileProcessor } from \"../sync-file/ImportResult\"\nimport { runTagMaintenance } from \"../tag/TagSql\"\nimport { DirectorySync } from \"./DirectorySync\"\nimport { Sync } from \"./Sync\"\nimport { bestPathToSync, nativePathBlocklist, UriPathTimes } from \"./SyncPaths\"\n\n/**\n * Manages running Sync jobs for all valid volumes or scan paths.\n */\nexport class SyncRunner extends EndableWrapper implements Sync {\n  private readonly _doneLatch = new Latch()\n\n  private currentSyncUri: Maybe<UriPathTimes>\n  private currentSync: Maybe<Sync>\n\n  constructor(readonly fileProcessor: FileProcessor) {\n    super(\"SyncRunner\", () => this.endCurrentSync(), EndableRanks.first)\n    void this.maybeSetupNextSync()\n  }\n\n  async progress() {\n    return thenMap(this.currentSync, ea => ea.progress())\n  }\n\n  isDone(): boolean {\n    return this._doneLatch.isSettled()\n  }\n\n  donePromise() {\n    return this._doneLatch.promise\n  }\n\n  private endCurrentSync(): Promise<void> {\n    const s = this.currentSync\n    this.currentSync = undefined\n    this.currentSyncUri = undefined\n    return end(s)\n  }\n\n  private async setSyncPath(upt: UriPathTimes) {\n    if (this.ended) return\n\n    await clearReaddirCaches()\n\n    // Make sure we don't fight the fs cache:\n    ee().emit(\"clearCache\")\n\n    const s = DirectorySync.for({\n      root: PosixFile.for(upt.nativePath),\n      rootUri: upt.uri,\n      fileProcessor: this.fileProcessor\n    })\n\n    void this.syncAndRunNext(upt, s)\n  }\n\n  async syncAndRunNext(\n    upt: UriPathTimes,\n    maybeDirSync: PromiseMaybe<DirectorySync>\n  ) {\n    try {\n      const sync = (this.currentSync = await maybeDirSync)\n      this.currentSyncUri = sync == null ? undefined : upt\n      if (sync != null) {\n        this.logger.info(\"syncAndRunNext(): waiting for completion...\", upt)\n        await sync.donePromise()\n        this.logger.info(\"syncAndRunNext(): done\", upt)\n      } else {\n        nativePathBlocklist.add(upt.nativePath)\n        this.logger.error(\"syncAndRunNext(): no-op (CHECK ME!)\", upt)\n      }\n    } catch (error) {\n      this.logger.error(\"syncAndRunNext(): caught\", { error })\n    }\n    return this.maybeSetupNextSync()\n  }\n\n  /**\n   * Make sure we're working on the \"best\" directory.\n   */\n  async maybeSetupNextSync() {\n    if (this.ended || this._doneLatch.isResolved()) {\n      this.logger.info(\"maybeSetupNextSync(): no-op\", {\n        this_ended: this.ended,\n        doneLatch_state: this._doneLatch.state()\n      })\n      return { newPath: null, msg: \"ended\" }\n    }\n\n    const newBest = await bestPathToSync()\n    if (newBest == null) {\n      void this._doneLatch.resolve()\n      this.logger.info(\n        \"maybeSetupNextSync(): bestPathToSync() returned null, so we're done.\"\n      )\n      await this.endCurrentSync()\n      await runTagMaintenance()\n      return { newPath: null, msg: \"all paths are synced\" }\n    }\n\n    const currentSyncPath = this.currentSyncUri?.nativePath\n    // If we're already working on the best, no-op\n    if (currentSyncPath != null && currentSyncPath === newBest.nativePath) {\n      return {\n        newPath: currentSyncPath,\n        msg: \"no-op, current path is already the best\"\n      }\n    } else {\n      this.logger.info(\n        \"maybeSetupNextSync(): bestPathToSync() returned a different sync: switching to newBest\",\n        {\n          currentSync: this.currentSyncUri,\n          newBest\n        }\n      )\n      await this.setSyncPath(newBest)\n      return { newPath: newBest.nativePath, msg: newBest.why }\n    }\n  }\n}\n","import { end, EndableRanks, ending } from \"../../core/async/Endable\"\nimport { EndableInterval } from \"../../core/async/EndableInterval\"\nimport { EndableWrapper } from \"../../core/async/EndableWrapper\"\nimport { exit } from \"../../core/async/Exit\"\nimport { rejected } from \"../../core/async/Promise\"\nimport { Promises } from \"../../core/async/Promises\"\nimport { thenOrTimeout } from \"../../core/async/ThenOrTimeout\"\nimport { errorToS } from \"../../core/error/Error\"\nimport { isRetriableError } from \"../../core/error/ErrorTypes\"\nimport { InternalError } from \"../../core/error/InternalError\"\nimport { onError } from \"../../core/error/OnError\"\nimport { toWrappedError, WrappedError } from \"../../core/error/WrappedError\"\nimport { ee } from \"../../core/event/EventEmitter\"\nimport { setIsSyncing } from \"../../core/event/IsSyncing\"\nimport { StoredTask, TaskName } from \"../../core/event/PhotoStructureEvents\"\nimport { SharedState } from \"../../core/event/SharedState\"\nimport { addTaskProcessor, TaskProcessor } from \"../../core/event/TaskProcessor\"\nimport { splitLines } from \"../../core/fs/CRLF\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { SyncFileStates } from \"../../core/fs/SyncReport\"\nimport { HealthCheck } from \"../../core/health/HealthCheck\"\nimport { lazy } from \"../../core/Lazy\"\nimport { r } from \"../../core/licensing/AutoRefreshLicense\"\nimport { m } from \"../../core/licensing/Licensing\"\nimport { LogLevels } from \"../../core/log/LogLevel\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { isTest } from \"../../core/NodeEnv\"\nimport { onProgressEvt } from \"../../core/progress/ProgressObserver\"\nimport { serviceName } from \"../../core/ServiceNames\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { ShortCommandTimeoutMs } from \"../../core/ShortCommandTimeoutMs\"\nimport { stdoutWrite } from \"../../core/StdoutWrite\"\nimport { commandTimeoutMs } from \"../../core/volumes/VolumeTtls\"\nimport { setupShimDelegates } from \"../../core/worker/ShimDelegation\"\nimport { compactBlanks, isNotEmpty } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { dayMs, hourMs, minuteMs, secondMs } from \"../../fe/Date\"\nimport { delay } from \"../../fe/Delay\"\nimport { isHealthCheckLevelFatal } from \"../../fe/HealthChecks\"\nimport { stringify } from \"../../fe/JSON\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { lt } from \"../../fe/Number\"\nimport { parseJSON } from \"../../fe/ParseMaybe\"\nimport { stripPrefixSuffix } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\nimport { UnwrapPromiseLike } from \"../../fe/UnwrapPromiseLike\"\nimport { cleanup_, imageCacheCleanup, readdirCleanup } from \"../Cleanup\"\nimport { forceRebuildLibrary } from \"../ForceRebuildLibrary\"\nimport { libraryHealthCheckSetup } from \"../health/LibraryHealthChecks\"\nimport { Library } from \"../Library\"\nimport { Operation } from \"../model/Operation\"\nimport { installBadShaShim, listenForInvalidFiles } from \"../model/ShaBlocklist\"\nimport { checkPendingOperations } from \"../operations/CheckPendingOperations\"\nimport { Service } from \"../Service\"\nimport { setVolumesTTL } from \"../SetVolumesTTL\"\nimport { QueueItem } from \"../stats/QueueItem\"\nimport { rmStatDbDirs } from \"../StatsDbDir\"\nimport { importFileToResult } from \"../sync-file/AssetFileImporter\"\nimport {\n  FileProcessor,\n  ImportResult,\n  isErrorResult\n} from \"../sync-file/ImportResult\"\nimport { handleUpdateCommand } from \"../sync-file/UpdateTask\"\nimport {\n  forceRunTagMaintenance,\n  runTagMaintenance,\n  updateAllTagCounts\n} from \"../tag/TagSql\"\nimport { DirectoryTaggerOperation } from \"./DirectoryTaggerOperation\"\nimport { ModelDbUpdater } from \"./ModelDbUpdater\"\nimport { ProgressUpdater } from \"./ProgressUpdater\"\nimport { SyncCompleted } from \"./SyncCompleted\"\nimport { SyncRunner } from \"./SyncRunner\"\nimport { Syncs } from \"./Syncs\"\n\nexport interface SyncServiceOptions {\n  setupExecutor: boolean\n}\n\nexport type SyncServiceStatus = UnwrapPromiseLike<\n  ReturnType<SyncService[\"status\"]>\n>\n\nexport const HandledTasks: TaskName[] = [\n  \"runTagMaintenance\",\n  \"checkOperations\",\n  \"repairAsset\",\n  \"repairAssetFile\"\n]\n\n/**\n * SyncService hosts the AllDrivesSync or DirectorySync instances, and feeds a\n * batch-cluster-managed set of sync-file processes (which do the actual work\n * of importing files into PhotoStructure)\n */\nexport class SyncService {\n  private readonly logger = mkLogger(\"SyncService\")\n  readonly service: Service\n  readonly exitWhenDone: boolean\n  private readonly progressUpdater = lazy(\n    () => new ProgressUpdater(() => this.sync())\n  )\n  #processCount = 0 // used for tmp file cleanups\n\n  #work = new Promises(\"SyncService\")\n\n  /**\n   * @param importPath if provided, will override the library settings for\n   * what drives or directories to import.\n   */\n  constructor() {\n    this.exitWhenDone =\n      Settings.exitWhenDone.valueOrDefault ||\n      Settings.argvScanPaths.isNotEmpty()\n\n    addTaskProcessor(this.taskListeners)\n\n    this.service = new Service({\n      name: \"sync\",\n      stdinReceiver: this.#stdinReceiver\n    })\n\n    void this.#setup().catch(cause =>\n      onError(\n        new WrappedError(\"SyncService.setup() failed\", {\n          cause,\n          fatal: true\n        })\n      )\n    )\n  }\n\n  readonly #stdinReceiver = async (stdin: string) => {\n    this.logger.info(\"stdinReceiver\", { stdin })\n    for (const input of compactBlanks(splitLines(stdin))) {\n      const cmd = parseJSON(input) as any\n      // ubuntu adds single quotes when drag-and-dropping: strip those.\n      const path = stripPrefixSuffix(\n        toS(cmd?.path ?? cmd?.file ?? cmd?.nativePath ?? cmd).trim(),\n        { prefix: \"'\", suffix: \"'\" }\n      )\n      if (notBlank(path)) {\n        stdoutWrite(\n          await this.service.promises.enqueue({\n            name: \"processFile\",\n            l: () => this.processFile(path)\n          })\n        )\n      }\n    }\n  }\n\n  async done(): Promise<boolean> {\n    const s = await this.sync()\n    return s == null || s.isDone()\n  }\n\n  #onProcessed() {\n    this.#processCount++\n    if (this.#processCount % 50 === 0) {\n      void cleanup_()\n    }\n  }\n\n  async status() {\n    const s = await this.sync.prior()\n    return {\n      libraryDir: Settings.libraryDir.value,\n      ending: ending(),\n      done: await this.done(),\n      sync: s?.name,\n      progress: await s?.progress(),\n      summary: HealthCheck.summary(),\n      jobs: this.service.promises.stats(),\n      processCount: this.#processCount\n    }\n  }\n\n  readonly processFile: FileProcessor = async (\n    nativePath: string\n  ): Promise<ImportResult> => {\n    const currentProcessing = this.#work.pendingWithName(\"processFile\")\n    this.logger.info(\"processFile()\", {\n      nativePath,\n      currentPaths: currentProcessing.map(ea => ea.payload)\n    })\n    return (\n      // We're not _asking)/enqueuing, we're _just pushing_ so cleanup tasks\n      // know that we're still working on something.\n\n      // Job throttling happens before this method gets called.\n      this.#work.push(\n        \"processFile\",\n        () => this.#processFile(nativePath, Settings.maxRetries.valueOrDefault),\n        nativePath\n      )\n    )\n  }\n\n  async #processFile(\n    nativePath: string,\n    retries: number\n  ): Promise<ImportResult> {\n    this.logger.info(\"#processFile()\", { nativePath, retries })\n\n    // WorkQueue will already be promise-throttling this.\n    try {\n      const result = await importFileToResult(PosixFile.for(nativePath))\n      if (isTest) {\n        stdoutWrite(result)\n      }\n\n      if (isErrorResult(result)) {\n        this.logger.warn(\"#processFile() error result\", {\n          nativePath,\n          result,\n          retries\n        })\n\n        return false !== isRetriableError(result.error) && retries > 0\n          ? this.#processFile(nativePath, retries - 1)\n          : result\n      } else {\n        return result\n      }\n    } catch (error: any) {\n      this.logger.error(\"#processFile() caught error\", {\n        nativePath,\n        retries,\n        error\n      })\n      const we = toWrappedError(error, { path: nativePath })\n\n      if (false !== error.retriable && retries > 0) {\n        await delay(Settings.minDelayBetweenRetriesMs.valueOrDefault)\n        return this.#processFile(nativePath, retries - 1)\n      } else {\n        onError(\"Failed to process file \" + nativePath, { we })\n        return {\n          path: nativePath,\n          state: SyncFileStates.failed,\n          error: errorToS(we)\n        }\n      }\n    } finally {\n      this.#onProcessed()\n    }\n  }\n\n  async #handleTask(task: StoredTask<any>) {\n    // IMPORTANT! If we're using enqueue here, we don't want anything to\n    // subsequently work.enqueue or work.push, as that could cause deadlocks.\n    this.logger.info(\"enqueueing task\", { task })\n\n    return this.#work.enqueue({\n      name: \"#handleTask(\" + task?.name + \")\",\n      l: async () => {\n        await Library.instanceReady()\n        this.logger.info(\"handling task\", { task })\n\n        switch (task.name) {\n          case \"runTagMaintenance\":\n            await runTagMaintenance()\n            return \"success\"\n\n          case \"checkOperations\":\n            await checkPendingOperations()\n            return \"success\"\n\n          case \"repairAsset\":\n            const ra: StoredTask<\"repairAsset\"> = task\n            await handleUpdateCommand({\n              forceSync: true,\n              skipPreviews: false,\n              forceRebuildPreviews: true,\n              ...ra.args[0]\n            })\n            return \"success\"\n\n          case \"repairAssetFile\":\n            const raf: StoredTask<\"repairAssetFile\"> = task\n            await handleUpdateCommand({\n              forceSync: true,\n              ...raf.args[0]\n            })\n            return \"success\"\n\n          default:\n            throw new InternalError(\"unexpected task: \" + stringify(task))\n        }\n      }\n    })\n  }\n\n  readonly taskListeners: TaskProcessor = {\n    name: \"SyncService\",\n    accept: (task: StoredTask<any>) => HandledTasks.includes(task.name),\n    apply: async (task: StoredTask<any>) => {\n      try {\n        return this.logger.tap({\n          msg: \"task complete\",\n          level: LogLevels.warn,\n          result: await this.#handleTask(task),\n          meta: { task }\n        })\n      } catch (error) {\n        this.logger.warn(\"task failed\", { task, error })\n        throw error\n      }\n    }\n  }\n\n  readonly #setup = lazy(async () => {\n    // setTimeoutHandler(onTimeout)\n    // Note that if the library path changes, we're expecting `main` to shut\n    // us down--we don't need to do anything.\n    ee().on(\"updateReadyToInstall\", () => {\n      this.logger.warn(\"We're about to upgrade: shut down ASAP!\")\n      // This is our exit(), not node's exit--it will end Endables:\n      void exit({\n        reason: \"Upgrade is ready--exiting now.\",\n        status: 0\n      })\n    })\n\n    if (await rejected(this.service.ready)) {\n      this.logger.warn(\"setup(): service.ready was rejected, exitting.\")\n      return\n    }\n\n    this.logger.info(\"setup()\", {\n      library: Settings.libraryDir.valueOrDefault,\n      exitWhenDone: this.exitWhenDone,\n      argvScanPaths: Settings.argvScanPaths.value,\n      scanPaths: Settings.scanPaths.value,\n      argv: process.argv\n    })\n\n    await libraryHealthCheckSetup()\n\n    // Just by invoking these lazy instances, the cleanup intervals will get\n    // scheduled:\n    imageCacheCleanup()\n    readdirCleanup()\n\n    await setupShimDelegates()\n    installBadShaShim()\n\n    await m()\n    // If we *can* refresh the license, let's not start before we've got it...\n    await thenOrTimeout(r(), commandTimeoutMs())\n\n    const library = Library.instanceRequired()\n\n    await library.ready\n\n    // Are all the health checks ok?\n    const summary = await HealthCheck.awaitSettled()\n    if (isHealthCheckLevelFatal(summary.level, serviceName())) {\n      await exit({\n        reason: \"Health check failed: \" + summary.msg.join(\": \"),\n        status: 1\n      })\n    }\n\n    // before we start sync, let's also wait for the janitorial tasks to\n    // complete.\n\n    await runTagMaintenance()\n\n    listenForInvalidFiles()\n\n    if (Settings.forceRebuildLibrary.valueOrDefault) {\n      this.logger.info(\n        \"setup(): forceRebuildLibrary is true: setting all assets to require updates...\"\n      )\n      forceRebuildLibrary()\n    }\n\n    if (Settings.forceSync.valueOrDefault) {\n      await rmStatDbDirs()\n      ee().emit(\"clearCache\")\n      Operation.ensurePendingOp({ name: \"forceRestartSync\", value: \"\" })\n    }\n\n    if (Settings.dropWorkQueues.valueOrDefault) {\n      this.logger.warn(\"Deleting all prior work queues...\")\n      QueueItem.dbl.runf(q => q.delete())\n      ee().emit(\"clearCache\")\n    }\n\n    await SharedState.instance()?.setup()\n\n    // Wait for any pending operations, but not for too long:\n    await thenOrTimeout(checkPendingOperations(), minuteMs)\n\n    await this.sync()\n\n    // Now we can set up the progress updater:\n    this.progressUpdater()\n\n    // Only add this handler once we've got a sync to play with. This overrides\n    // the default status handler.\n    this.service.setInputHandler(\"--force-rebuild-library\", async () => {\n      this.logger.warn(\"--force-rebuild-library requested\")\n      await end(this.modelDbUpdater.clear())\n      await end(this.sync.clear())\n      forceRebuildLibrary()\n      await this.sync()\n      stdoutWrite({ forceRebuildLibrary: \"started\" })\n    })\n    this.service.setInputHandler(\"--recount-tags\", () => updateAllTagCounts())\n    this.service.setInputHandler(\"--check-sync\", async () =>\n      stdoutWrite({ checkSync: await this.maybeRestartSyncOnVolumeChange() })\n    )\n\n    this.service.setInputHandler(\"--cleanup\", async () => cleanup_())\n    this.service.setInputHandler(\"--clear-cache\", async () =>\n      ee().emit(\"clearCache\")\n    )\n\n    if (isTest) {\n      onProgressEvt.setShim(async ea => console.log(stringify(ea)))\n    }\n\n    ee().on(\"volumesChanged\", () => this.maybeRestartSyncOnVolumeChange())\n\n    new EndableInterval({\n      name: \"SyncService.maybeRestartSync()\",\n      callback: () => this.maybeRestartSync(),\n      intervalMs: hourMs,\n      initialDelayMs: hourMs,\n      rank: EndableRanks.first\n    })\n\n    new EndableInterval({\n      name: \"SyncService.setVolumesTTL()\",\n      callback: () => setVolumesTTL(),\n      intervalMs: dayMs / 4,\n      initialDelayMs: 5 * minuteMs,\n      rank: EndableRanks.first\n    })\n\n    new EndableWrapper(\n      \"SyncService end status\",\n      async () => this.logger.info(\"end status\", await this.status()),\n      EndableRanks.first\n    )\n  })\n\n  async cancelSync() {\n    const s = await this.sync()\n    if (s != null && !s.isDone()) {\n      this.logger.info(\"cancelSync(): ending current sync...\")\n      await s.end()\n    } else {\n      this.logger.info(\"cancelSync(): No sync to end.\")\n    }\n  }\n\n  #wrapWork<T extends { donePromise(): Promise<any> }>(\n    name: string,\n    t: Maybe<T>,\n    reTag = false\n  ): Maybe<T> {\n    if (t == null) return\n    void this.#work\n      .push(name, t.donePromise())\n      .then(\n        () => {\n          this.logger.info(name + \" completed.\")\n        },\n        err => onError(name + \" failed\", err)\n      )\n      .finally(async () => {\n        if (reTag)\n          await this.#work.push(\n            \"forceRunTagMaintenance\",\n            forceRunTagMaintenance()\n          )\n        void this.sync.refresh()\n      })\n    return t\n  }\n\n  private readonly modelDbUpdater = lazy(() => {\n    if (Settings.noModelUpdates.valueOrDefault) {\n      this.logger.info(\"modelDbUpdater: skipUpdates is set.\")\n      return\n    } else {\n      return this.#wrapWork(\n        \"modelDbUpdater\",\n        new ModelDbUpdater({\n          // WorkQueue will already be promise-throttling this:\n          processor: handleUpdateCommand\n        }),\n        true\n      )\n    }\n  })\n\n  private readonly directoryTaggerOp = lazy(() =>\n    this.#wrapWork(\"directoryTaggerOp\", new DirectoryTaggerOperation())\n  )\n\n  async restartSync() {\n    await end(this.sync.clear(), minuteMs) // in case it's in the middle of a sync-file\n    return this.sync()\n  }\n\n  async maybeRestartSyncOnVolumeChange() {\n    const s = await this.sync.prior()\n    if (s == null || s instanceof SyncRunner) {\n      // if the sync runner is done, make a new one:\n      if (s == null || s.ended || s.isDone()) {\n        this.logger.info(\n          \"maybeRestartSyncOnVolumeChange(): prior sync ended, restarting...\"\n        )\n        await this.sync.refresh()\n        return \"refresh\"\n      } else {\n        this.logger.info(\n          \"maybeRestartSyncOnVolumeChange(): calling maybeSetupNextSync()...\"\n        )\n        const result = await s.maybeSetupNextSync()\n        return stringify(result)\n      }\n    } else {\n      this.logger.info(\n        \"maybeRestartSyncOnVolumeChange(): no-op, current sync is \" + s.name\n      )\n      return \"noOp:\" + s.name\n    }\n  }\n\n  async maybeRestartSync() {\n    const lastSetAgoMs = this.sync.lastSetAgoMs()\n    if (lt(lastSetAgoMs, ShortCommandTimeoutMs)) {\n      this.logger.info(\"maybeRestartSync(): sync was touched recently.\", {\n        lastSetAgoMs\n      })\n      return\n    }\n    const s = await this.sync.prior()\n    if (s instanceof SyncRunner && s.ended) {\n      this.logger.info(\"maybeRestartSync(): SyncRunner ended. Restarting.\")\n      // if the sync runner is done, make a new one:\n      void this.sync.refresh()\n    } else {\n      this.logger.info(\n        \"maybeRestartSync(): We're busy doing something else or the current SyncRunner hasn't ended. no-op.\"\n      )\n    }\n  }\n\n  readonly sync = lazy(async () => {\n    setIsSyncing(true)\n    await Library.instanceRequired().ready\n\n    if (Settings.argvScanPaths.isEmpty()) {\n      const mdu = this.modelDbUpdater()\n      if (false === mdu?.isDone()) {\n        return mdu\n      }\n      const dto = this.directoryTaggerOp()\n      if (false === dto?.isDone()) {\n        return dto\n      }\n    }\n\n    // If we're given argv scan paths, give those to Syncs to handle--they\n    // know how to handle files and directories.\n\n    const argvPaths = Settings.argvScanPaths.value\n\n    const result = isNotEmpty(argvPaths)\n      ? Syncs.forPaths(argvPaths, this.processFile)\n      : new SyncRunner(this.processFile)\n    void this.waitForSyncAndCleanup(result)\n\n    return result\n  })\n\n  async waitForSyncAndCleanup(s: Maybe<Syncs | SyncRunner>) {\n    try {\n      // Let sync spin up: TODO SITS WHY\n      await delay(secondMs)\n      await s?.donePromise()\n\n      // Allow scheduled work to complete:\n      await delay(secondMs)\n      await this.service.promises.awaitSettled()\n      await this.#work.awaitSettled()\n      await forceRunTagMaintenance()\n      if (isTest) stdoutWrite(SyncCompleted)\n      // don't do this in a finally: it won't get called!\n      setIsSyncing(false)\n      if (this.exitWhenDone) {\n        await exit({\n          reason: \"Finished\",\n          status: 0\n        })\n      }\n    } catch (err) {\n      setIsSyncing(false)\n      if (this.exitWhenDone) {\n        await exit({\n          reason: \"Error: \" + err,\n          status: 13\n        })\n      } else {\n        this.logger.error(\"Sync error\", err)\n      }\n    }\n  }\n}\n","import { end, EndableRanks } from \"../../core/async/Endable\"\nimport { EndableWrapper } from \"../../core/async/EndableWrapper\"\nimport { MaybeLaterMaybe } from \"../../core/async/Later\"\nimport { onError } from \"../../core/error/OnError\"\nimport { PosixFile } from \"../../core/fs/PosixFile\"\nimport { syncReport } from \"../../core/fs/SyncReport\"\nimport { lazy } from \"../../core/Lazy\"\nimport { blank } from \"../../fe/Blank\"\nimport { Latch } from \"../../fe/Latch\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toA } from \"../../fe/toA\"\nimport { FileProcessor } from \"../sync-file/ImportResult\"\nimport { DirectorySync } from \"./DirectorySync\"\nimport { FileSync } from \"./FileSync\"\nimport { Sync } from \"./Sync\"\nimport { posixFileToUriPath } from \"./UriPath\"\n\nexport async function syncForPath(\n  nativePath: string,\n  fileProcessor: FileProcessor\n): PromiseMaybe<Sync> {\n  if (blank(nativePath)) return\n\n  const root = PosixFile.for(nativePath)\n\n  if (await root.isDirectory()) {\n    const up = await posixFileToUriPath(root)\n    if (up == null) {\n      syncReport().onProgress({\n        path: nativePath,\n        from: \"syncForPath()\",\n        state: \"failed\",\n        details: \"Cannot import: URI path could not be built for that path.\"\n      })\n      await syncReport().close()\n      return\n    } else {\n      return DirectorySync.for({\n        root,\n        rootUri: up.uri,\n        fileProcessor\n      })\n    }\n  } else {\n    return new FileSync(root, fileProcessor(nativePath))\n  }\n}\n\n/**\n * Expose multiple Sync instances as a Sync\n */\nexport class Syncs extends EndableWrapper implements Sync {\n  static forPaths(paths: string[], fileProcessor: FileProcessor): Syncs {\n    return new Syncs(\n      \"import paths fs sync\",\n      toA(paths).map(path => () => syncForPath(path, fileProcessor))\n    )\n  }\n\n  private currentSync: Maybe<Sync>\n  private readonly _done = new Latch()\n  constructor(\n    name: string,\n    private readonly laters: MaybeLaterMaybe<Sync>[]\n  ) {\n    super(`Syncs(${name})`, () => end(this.currentSync), EndableRanks.first)\n    void this.run()\n  }\n\n  // only run once:\n  private run = lazy(async () => {\n    try {\n      for (const later of this.laters) {\n        const next = await later()\n        if (next == null) continue\n        this.currentSync = next\n        await next.donePromise()\n      }\n      void this._done.resolve()\n    } catch (err: any) {\n      onError(\"Syncs.run() failed\", err)\n      void this._done.reject(err)\n    }\n  })\n\n  isDone(): boolean {\n    return !this._done.isPending()\n  }\n\n  donePromise(): Promise<void> {\n    return this._done.promise\n  }\n\n  async progress() {\n    return map(this.currentSync, ea => ea.progress())\n  }\n}\n","import { Knex } from \"knex\"\nimport { mkLogger } from \"../../core/Logger\"\nimport {\n  AssetFileVersion,\n  AssetVersion\n} from \"../../core/PhotoStructureVersions\"\nimport { max } from \"../../core/math/Vector\"\nimport { nativePath2uri } from \"../../core/uri/FileURI\"\nimport { PSLIB_ROOT_URI } from \"../../core/uri/pslib\"\nimport { volumes } from \"../../core/volumes/Volumes\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { thenCollect } from \"../../fe/Promise\"\nimport { toS } from \"../../fe/toS\"\nimport { Asset } from \"../model/Asset\"\nimport { AssetFile } from \"../model/AssetFile\"\nimport { Operation, OperationNames } from \"../model/Operation\"\nimport {\n  Queue,\n  assetFileUpdatesQueueName2uri,\n  assetUpdatesUri2QueueName\n} from \"../stats/Queue\"\n\nfunction addIdsToQueue(q: Queue, ids: number[]) {\n  return q.upsertWorkItems(ids.map(ea => ({ contents: toS(ea) })))\n}\n\nexport async function currentUriRoots(): Promise<string[]> {\n  const uris = await thenCollect(volumes(), async vol =>\n    nativePath2uri(vol.mountpoint, vol)\n  )\n  return [...uris, PSLIB_ROOT_URI].map(toS)\n}\n\nexport async function enqueueAssetFileUpdates(): Promise<string[]> {\n  return thenCollect(currentUriRoots(), enqueueAssetFileUpdatesForUri)\n}\n\nasync function enqueueAssetFileUpdatesForUri(uri: string) {\n  const log = mkLogger(\"enqueueAssetFileUpdatesForUri(\" + uri + \")\")\n  // Always make the queue:\n  const queue = Queue.ops().upsertOne({\n    name: assetFileUpdatesQueueName2uri(uri)\n  })\n  // Only enqueue new files once:\n  await Operation.applyOnce(\n    {\n      name: OperationNames.enqueueAssetFileUpdates,\n      version: AssetFileVersion,\n      value: uri\n    },\n    () => {\n      log.info(\"starting\", { queue: queue.name })\n      AssetFile.dbl.pluckBatched({\n        onResults: (arr: number[]) => addIdsToQueue(queue, arr),\n        qb: (qb: Knex.QueryBuilder, priors: Maybe<number[]>) => {\n          qb = qb\n            .select(\"id\")\n            .orderBy(\"id\", \"asc\")\n            .where(\"version\", \"<\", AssetFileVersion)\n            .andWhereLike(\"uri\", uri + \"%\")\n          if (isNotEmpty(priors)) {\n            qb = qb.andWhere(\"id\", \">\", max(priors)!)\n          }\n          return qb\n        }\n      })\n    }\n  )\n  // Only return the queue if there's work previously enqueued, or were just enqueued:\n  const assetFileCount = queue.itemCount()\n  log.log(\n    assetFileCount === 0 ? \"debug\" : \"info\",\n    \"Added outdated assetFiles:\",\n    {\n      queue: queue.name,\n      assetFileCount\n    }\n  )\n\n  return assetFileCount ? queue.name : undefined\n}\n\nexport async function outdatedAssetCount() {\n  const uris = await currentUriRoots()\n  return Asset.dbl.pluckFirstf<number>(q =>\n    q\n      .count(\"Asset.id\")\n      .distinct()\n      .leftJoin(\"AssetFile\", \"AssetFile.assetId\", \"Asset.id\")\n      .where(\"Asset.version\", \"<\", AssetVersion)\n      .andWhere(q2 =>\n        uris.forEach(uri => q2.whereLike(\"AssetFile.uri\", uri + \"%\"))\n      )\n  )\n}\n\nexport async function enqueueAssetUpdates() {\n  return thenCollect(currentUriRoots(), enqueueAssetUpdatesForUri)\n}\n\nexport async function enqueueAssetUpdatesForUri(uri: string) {\n  const log = mkLogger(\"enqueueAssetUpdatesForUri(\" + uri + \")\")\n  const queue = Queue.ops().upsertOne({\n    name: assetUpdatesUri2QueueName(uri)\n  })\n\n  await Operation.applyOnce(\n    {\n      name: OperationNames.enqueueAssetUpdates,\n      version: AssetVersion,\n      value: uri\n    },\n    () => {\n      log.info(\"starting\", { queue })\n      return Asset.dbl.pluckBatched({\n        onResults: arr => addIdsToQueue(queue, arr),\n        qb: (qb: Knex.QueryBuilder, priors: Maybe<number[]>) => {\n          qb = qb\n            .select(\"Asset.id\")\n            .distinct()\n            .leftJoin(\"AssetFile\", \"AssetFile.assetId\", \"Asset.id\")\n            .orderBy(\"Asset.id\", \"asc\")\n            .where(\"Asset.version\", \"<\", AssetVersion)\n            .andWhereLike(\"AssetFile.uri\", uri + \"%\")\n          if (isNotEmpty(priors)) {\n            qb = qb.andWhere(\"Asset.id\", \">\", max(priors)!)\n          }\n          return qb\n        }\n      })\n    }\n  )\n  const assetCount = queue.itemCount()\n  if (assetCount === 0) return\n\n  log.info(\"Added outdated assets:\", {\n    queue: queue.name,\n    assetCount\n  })\n  return queue.name\n}\n","import { PosixFile } from \"../../core/fs/PosixFile\"\nimport { nativePath2uri } from \"../../core/uri/FileURI\"\nimport { URI } from \"../../core/uri/URI\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { MaybeSyncOrAsync } from \"../../fe/SyncOrAsync\"\n\nexport interface UriPath {\n  nativePath: string\n  uri: string\n}\n\nexport async function toUriPath(\n  nativePath: string,\n  maybeUri: MaybeSyncOrAsync<URI>\n): PromiseMaybe<UriPath> {\n  const uri = await maybeUri\n  if (uri == null) return\n  return {\n    nativePath,\n    uri: uri.toString()\n  }\n}\n\nexport async function posixFileToUriPath(f: PosixFile): PromiseMaybe<UriPath> {\n  return toUriPath(f.nativePath, await f.uriObject_())\n}\n\nexport async function nativePathToUriPath(\n  nativePath: string\n): PromiseMaybe<UriPath> {\n  return toUriPath(nativePath, nativePath2uri(nativePath))\n}\n","import { TagSep } from \"../../core/tags/TagPaths\"\nimport { toS } from \"../../fe/toS\"\n\nexport function tag_fts_root(tag_path: string) {\n  const s = toS(tag_path)\n  const idx = s.indexOf(TagSep)\n  return idx === -1 ? \"\" : tag_path.substring(0, idx)\n}\n\nexport function tag_fts_path(tag_path: string) {\n  return toS(tag_path)\n    .split(TagSep)\n    .filter(ea => ea != null && ea.trim() !== \"\")\n    .join(\" \")\n}\n","import _path from \"path\"\nimport { lazy } from \"../../core/Lazy\"\nimport { mkLogger } from \"../../core/Logger\"\nimport { rateLimited } from \"../../core/RateLimited\"\nimport { memoizeAsync } from \"../../core/async/MemoizedAsyncFunc\"\nimport { time, timeSync } from \"../../core/async/PromiseTimer\"\nimport { ee } from \"../../core/event/EventEmitter\"\nimport { hostname } from \"../../core/net/Hostname\"\nimport {\n  ForceContext,\n  RequiredForceContext,\n  forceContextOrSetting\n} from \"../../core/settings/ForceContext\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { TagSep } from \"../../core/tags/TagPaths\"\nimport { volsha } from \"../../core/uri/volsha\"\nimport { lazyFsAsync } from \"../../core/volumes/LazyFsAsync\"\nimport { mountpoints } from \"../../core/volumes/Mountpoints\"\nimport { volumeMetadataTtlMs } from \"../../core/volumes/VolumeTtls\"\nimport { volumes } from \"../../core/volumes/Volumes\"\nimport { compact, isEmpty, isNotEmpty, uniq } from \"../../fe/Array\"\nimport { notBlank, notBlankOr } from \"../../fe/Blank\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { fmtDuration } from \"../../fe/FmtDuration\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, lt } from \"../../fe/Number\"\nimport { gt } from \"../../fe/Primitive\"\nimport { randomChars } from \"../../fe/Random\"\nimport { stripPrefixSuffix } from \"../../fe/String\"\nimport { LibraryTagName, TagRoots } from \"../../fe/api/Tag\"\nimport { DbRequest } from \"../db/DbRequest\"\nimport { knex } from \"../db/Knex\"\nimport { prepQueries } from \"../db/SqlQuery\"\nimport { AssetFile } from \"../model/AssetFile\"\nimport { ChangedTag, ChangedTagPojo } from \"../model/ChangedTag\"\nimport { modelDb } from \"../model/ModelDb\"\nimport { Tag } from \"../model/Tag\"\nimport { TagFts } from \"../model/TagFts\"\n\nconst logger = lazy(() => mkLogger(\"tag.TagSql\"))\n\nconst dbr = lazy(() => new DbRequest(modelDb, \"Tag\"))\n\nexport const tagFtsRebuild = lazy(\n  () => time(\"db.rebuildTagFts\", () => TagFts.rebuild()),\n  minuteMs\n)\n\n/**\n * This should only be run by integration tests or at the end of a sync.\n */\nexport async function forceRunTagMaintenance(\n  args: ForceContext = { forceSync: true, recountAllTags: true }\n) {\n  logger().info(\"forceRunTagMaintenance()\")\n  return await runTagMaintenance.force(args)\n}\n\nconst MinCallDelayMs = 5 * secondMs\n\nexport const runTagMaintenance = rateLimited({\n  name: \"runTagMaintenance\",\n  minCallDelayMs: MinCallDelayMs,\n  f: async (_ctx?: ForceContext) => {\n    const ctx = forceContextOrSetting(_ctx)\n    const start = Date.now()\n    const log = logger().addContext(\".runTagMaintenance()\")\n    log.info(\"starting\", { ctx })\n    try {\n      log.info(\"validating all tags...\")\n      Tag.validate_()\n\n      log.info(\"updating tag mountpoints...\")\n      await updateTagMountpoints()\n\n      log.info(\"vacuuming orphan tags...\")\n      await vacuumOrphanTags()\n\n      let countedTags = false\n      if (ctx.recountAllTags) {\n        if (ctx.forceSync || updateAllTagCounts.isStale()) {\n          log.info(\"recounting all tags...\")\n          updateAllTagCounts.refresh()\n          countedTags = true\n        }\n      }\n      if (!countedTags) {\n        log.info(\"recounting changed tags...\")\n        const updatedTagIds = updateChangedTagCounts(ctx)\n        countedTags = isNotEmpty(updatedTagIds)\n      }\n\n      if (countedTags) {\n        log.info(\"rebuilding tag search index...\")\n        await tagFtsRebuild()\n      }\n    } catch (err: any) {\n      logger().warn(\"runTagMaintenance() failed\", err)\n    }\n    const elapsedMs = Date.now() - start\n    // We want to run this often, but not so often as to cause no other work\n    // to be done.\n    const newMinCallDelayMs = clamp(MinCallDelayMs, minuteMs, elapsedMs * 5)\n    runTagMaintenance.setMinCallDelayMs(newMinCallDelayMs)\n    logger().info(\"runTagMaintenance(): complete.\", {\n      newMinCallDelayMs,\n      elapsedMs\n    })\n  }\n})\n\nfunction updateChangedTagCounts(ctx: RequiredForceContext, lagtimeMs?: number) {\n  // return timeSync(\"db.updateChangedTagCounts\", () => {\n  const nullTagIds = Tag.withNullAssetCount()\n  logger().info(\"updateChangedTagCounts()\", { nullTagIds })\n  const changedTags = ChangedTag.getAllChangedTags(0)\n  logger().info(\"updateChangedTagCounts()\", { changedTags })\n  const changedTagsById = new Map<number, ChangedTagPojo | null>(\n    nullTagIds.map(ea => [ea, null])\n  )\n  for (const ct of changedTags) {\n    changedTagsById.set(ct.tagId, ct)\n  }\n  const maxUpdatedAt =\n    Date.now() - (lagtimeMs ?? (ctx.forceSync ? 0 : minuteMs))\n\n  // TODO: figure out what the correct value is (not just \"20\")\n  if (changedTagsById.size > 20 && updateAllTagCounts.isStale()) {\n    logger().warn(\n      \"updateChangedTagCounts(): too many changed tags. Rebuilding everything.\"\n    )\n    updateAllTagCounts()\n  } else {\n    for (const tagId of changedTagsById.keys()) {\n      Tag.updateAssetCount(tagId)\n    }\n  }\n\n  for (const changedTag of compact(changedTagsById.values())) {\n    if (changedTag != null && lt(changedTag.updatedAt, maxUpdatedAt)) {\n      const result = ChangedTag.deleteChangedTag(changedTag)\n      logger().debug(\"updateChangedTagCounts(): removing updated tag\", {\n        changedTag,\n        result\n      })\n    }\n  }\n  return [...changedTagsById.keys()]\n  // })\n}\n\n// only exported for tests\nexport function updateTagCountSql(rnd = randomChars(6)) {\n  // closure tree table without a depth/level column:\n  const ct = `temp.closure_tree_${rnd}`\n\n  // tag counts table\n  const tc = `temp.tag_counts_${rnd}`\n\n  // This takes 6 seconds on nuc test library:\n  // CREATE TABLE ${ct} AS\n  // SELECT\n  // DISTINCT t.id AS parentId,\n  // kid.id AS childId\n  // FROM\n  // Tag t\n  // JOIN Tag kid ON kid._path LIKE (t._path || '%');\n\n  // The CTE takes 0.161 seconds on nuc test library (!!)\n\n  return prepQueries(`\nCREATE TABLE ${ct} AS \nWITH RECURSIVE cte AS (\n  SELECT\n    id AS anc_id,\n    id AS id\n    -- ,0 AS LEVEL\n  FROM\n    Tag\n  UNION\n  ALL\n  SELECT\n    prev.anc_id,\n    curr.id AS id\n    -- ,prev.level + 1 AS LEVEL\n  FROM\n    Tag curr\n    JOIN cte AS prev\n  WHERE\n    curr.id <> prev.id\n    AND curr.parentId = prev.id\n)\nSELECT\n  *\nFROM\n  cte;\n\nCREATE INDEX ${ct}_idx ON ${ct.replace(/^temp\\./, \"\")}(id);\n\n-- NOTE: creating a temp table for shown assets with a covering index didn't speed up the next create table\n\nCREATE TABLE ${tc} AS\nSELECT\n  anc_id AS tagId,\n  count(DISTINCT assetId) AS assetCount\nFROM\n  ${ct}\n  JOIN AssetTag ON AssetTag.tagId = ${ct}.id\n  JOIN Asset ON Asset.id = AssetTag.assetId\nWHERE\n  Asset.shown = 1\n  AND Asset.hidden = 0\n  AND Asset.excludedAt IS NULL\n  AND Asset.deletedAt IS NULL\nGROUP BY\n  1;\n\nCREATE INDEX ${tc}_idx ON ${tc.replace(/^temp\\./, \"\")}(tagId, assetCount);\n\n-- We now have a comprehensive set of counts. Wipe prior counts:\n\nUPDATE Tag SET \n  assetCount = NULL;\n\nUPDATE Tag\nSET\n  assetCount = ${tc}.assetCount\nFROM ${tc}\nWHERE ${tc}.tagId = Tag.id;\n\n-- Clean up:\n\nDELETE FROM ChangedTag; -- we just rebuilt everything!\n\nDROP INDEX IF EXISTS ${ct}_idx;\nDROP INDEX IF EXISTS ${tc}_idx;\nDROP TABLE ${ct};\nDROP TABLE ${tc};\n`)\n}\n\nexport const updateAllTagCounts = lazy(\n  () =>\n    timeSync(\"db.updateAllTagCounts\", () => {\n      if (dbr().db() == null) {\n        logger().throw(\"updateAllTagCounts(): modelDb is unset\", {\n          retriable: false\n        })\n      }\n      try {\n        const rnd = randomChars(6)\n        const ignorable = \"_\" + rnd\n        const start = Date.now()\n        dbr().runScript(updateTagCountSql(rnd), ignorable)\n        const elapsedMs = Date.now() - start\n        const newTTL = clamp(7 * secondMs, 5 * minuteMs, elapsedMs * 20)\n        logger().info(\"updateAllTagCounts() done\", {\n          elapsedMs,\n          newTTL\n        })\n      } catch (err) {\n        logger().warn(\"updateAllTagCounts() failed\", err)\n      }\n    }),\n  minuteMs // < we shouldn't have to rebuild everything more than once a minute\n)\n\nexport async function vacuumOrphanTags(\n  minCreatedAt = Date.now() - 10 * minuteMs\n) {\n  const deleted: number[] = []\n  for (let iter = 0; iter < 6; iter++) {\n    const arr = await vacuumLeafTags(minCreatedAt)\n    if (isEmpty(arr)) break\n    else deleted.push(...arr)\n  }\n  return uniq(deleted)\n}\n\nexport async function vacuumLeafTags(minCreatedAt: number) {\n  const candidates = Tag.dbl.pluckAllf<number>(\n    q =>\n      q\n        .select(\"Tag.id\")\n        .leftOuterJoin(\"AssetTag\", \"AssetTag.tagId\", \"Tag.id\")\n        .leftOuterJoin(knex().raw(\"Tag AS child ON child.parentId = Tag.id\"))\n        .whereNull(\"AssetTag.assetId\")\n        .andWhere(q2 => q2.whereNull(\"child.id\"))\n        .andWhere(q2 => q2.whereNull(\"Tag.assetCount\"))\n        .andWhere(\"Tag.createdAt\", \"<\", minCreatedAt)\n        .orderBy(\"Tag._path\", \"asc\") // leaves first\n  )\n  logger().debug(\"vacuumLeafTags()\", { candidates })\n  for (const ea of candidates) {\n    try {\n      Tag.dbl.runf(q => q.where({ id: ea }).delete())\n    } catch (err) {\n      logger().info(\"vacuumLeafTags(): failed to delete\", { tagId: ea, err })\n    }\n  }\n  logger().info(\"vacuumLeafTags() complete.\", { candidates })\n  return candidates\n}\n\nconst updateTagMountpoints = lazyFsAsync(\"updateTagMountpoints\", async () => {\n  const fileRoot = Tag.findByPath([TagRoots.fs])\n  if (fileRoot == null) {\n    mkLogger(\"updateTagMountpoints()\").info(\n      \"No root filesystem tag (new db, I hope?)\"\n    )\n    return\n  }\n\n  fileRoot.maybeUpsertDisplayName(Settings.tagDisplayNameFS.valueOrDefault)\n\n  for (const t of fileRoot.getChildren()) {\n    await fixFileRootTag(t)\n  }\n})\n\nfunction _reset() {\n  tagFtsRebuild.unset()\n  // if (!isProd) updateAllTagCounts.clear()\n  updateTagMountpoints.unset()\n}\n\nlater(() => {\n  ee().on(\"clearCache\", _reset)\n  Settings.libraryDir.watchLater(_reset)\n})\n\nexport async function fixFileRootTag(t: Maybe<Tag>) {\n  // Is this an actual file root tag?\n  if (t == null || t.depth !== 2 || !t._path.startsWith(TagRoots.fs + TagSep)) {\n    // no-op\n    return\n  }\n\n  const log = mkLogger(\"fixFileRootTag(\" + t + \")\")\n  if (t.name === LibraryTagName) {\n    if (t.ordinal !== 1) {\n      log.info(\"fixing library ordinal\", { id: t.id, path: t.path })\n      t.upsert({ ordinal: 1 })\n      Tag.clear()\n    }\n    return\n  }\n\n  // Was this updated recently?\n  if (\n    forceContextOrSetting().forceSync &&\n    notBlank(t.displayName) &&\n    gt(t.updatedAt, Date.now() - volumeMetadataTtlMs())\n  ) {\n    log.info(\"no-op: tag recently updated\", {\n      id: t.id,\n      path: t.path,\n      updated: fmtDuration(Date.now() - t.updatedAt!) + \" ago\"\n    })\n    return\n  }\n\n  const displayName = await displayNameForVolsha(t.name)\n\n  if (notBlank(displayName)) {\n    t.maybeUpsertDisplayName(displayName)\n    log.info(\"updated tag\", { id: t.id, path: t.path, displayName })\n    Tag.clear()\n  } else {\n    log.debug(\"cannot update tag: no current volume.\", {\n      id: t.id,\n      path: t.path\n    })\n  }\n}\n\nexport const displayNameForVolsha = memoizeAsync(\n  async (volumeSHA: string) => {\n    const log = mkLogger(\"displayNameForVolsha(\" + volumeSHA + \")\")\n    const vols = await volumes()\n    if (vols != null) {\n      const vol = vols.find(ea => volsha(ea.uuid) === volumeSHA)\n      log.info(\"find()\", { vol })\n      if (vol != null) {\n        if (\n          Settings.tagDisplayNameFSLabels.valueOrDefault &&\n          notBlank(vol.label)\n        ) {\n          return vol.label.trim()\n        }\n\n        if (vol.mountpoint === \"/\") {\n          return (\n            Settings.tagDisplayNameFSRoot.valueOrDefault +\n            (Settings.tagDisplayNameFSRootWithHostname.valueOrDefault\n              ? \" on \" + hostname()\n              : \"\")\n          )\n        }\n\n        return notBlankOr(\n          // We don't want \"C:\\\" (because the UI renders the path separators)\n          stripPrefixSuffix(vol.mountpoint, {\n            prefix: _path.sep,\n            suffix: _path.sep\n          }),\n          _path.sep // < handle \"/\"\n        )\n      } else {\n        return AssetFile.dbl.pluckFirstf<string>(q =>\n          q\n            .select(\"mountpoint\")\n            .whereLike(\"uri\", \"psfile://\" + volumeSHA + \"/%\")\n            .limit(1)\n        )\n      }\n    }\n    return\n  },\n  {\n    name: \"tag.displayNameForVolsha\",\n    maxSize: 64,\n    timeoutMs: volumeMetadataTtlMs()\n  }\n)\n\nlater(() => {\n  mountpoints.watch(() => displayNameForVolsha.clear())\n})\n","module.exports = require(\"@iarna/toml\");","module.exports = require(\"@parcel/watcher\");","module.exports = require(\"@photostructure/tz-lookup\");","module.exports = require(\"@sentry/node\");","module.exports = require(\"assert\");","module.exports = require(\"axios\");","module.exports = require(\"batch-cluster\");","module.exports = require(\"better-sqlite3\");","module.exports = require(\"commander\");","module.exports = require(\"events\");","module.exports = require(\"exiftool-vendored\");","module.exports = require(\"fast-xml-parser\");","module.exports = require(\"file-type\");","module.exports = require(\"fs-extra\");","module.exports = require(\"he\");","module.exports = require(\"knex\");","module.exports = require(\"luxon\");","module.exports = require(\"ml-kmeans\");","module.exports = require(\"papaparse\");","module.exports = require(\"picomatch\");","module.exports = require(\"platform-folders\");","module.exports = require(\"plist\");","module.exports = require(\"process\");","module.exports = require(\"punycode\");","module.exports = require(\"semver\");","module.exports = require(\"sharp\");","module.exports = require(\"source-map-support\");","module.exports = require(\"trash\");","module.exports = require(\"type-detect\");","module.exports = require(\"util\");","module.exports = require(\"util/types\");","module.exports = require(\"utimes\");","module.exports = require(\"child_process\");","module.exports = require(\"cluster\");","module.exports = require(\"crypto\");","module.exports = require(\"dns\");","module.exports = require(\"fs\");","module.exports = require(\"fs/promises\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"node:fs/promises\");","module.exports = require(\"node:os\");","module.exports = require(\"node:path/posix\");","module.exports = require(\"node:process\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"stream\");","module.exports = require(\"stream/promises\");","module.exports = require(\"timers\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the module cache\n__webpack_require__.c = __webpack_module_cache__;\n\n","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// module cache are used so entry inlining is disabled\n// startup\n// Load entry module and return exports\nvar __webpack_exports__ = __webpack_require__(__webpack_require__.s = 54620);\n"],"names":["CODES","PasetoNotSupported","PasetoDecryptionFailed","PasetoInvalid","PasetoVerificationFailed","PasetoClaimInvalid","PasetoError","Error","constructor","message","super","this","name","code","captureStackTrace","module","exports","decode","parsePayload","token","parse","TypeError","version","purpose","payload","footer","length","split","result","undefined","sigLength","raw","subarray","ms","audience","expiresIn","iat","issuer","jti","kid","notBefore","now","Date","subject","getTime","unix","exp","nbf","aud","iss","sub","ignoreExp","ignoreNbf","ignoreIat","maxTokenAge","clockTolerance","tolerance","encode","input","toString","Buffer","from","assertion","isBuffer","isObject","JSON","stringify","applyOptions","options","Object","keys","deepClone","key","x","y","export","format","yB","sign","concat","alloc","assert","assertPayload","post","buffer","complete","m","f","pre","h","slice","crypto","util","pae","pack","timingSafeEqual","webcrypto","subtle","hkdf","promisify","EK_INFO","AK_INFO","EMPTY","hmac","data","createHmac","update","digest","ctr","async","op","iv","counter","importKey","then","encrypt","bind","decrypt","verify","k","n","randomBytes","salt","ek","ak","Promise","all","c","preAuth","t","t2","i","tmp","n2","KeyObject","isKeyObject","obj","Number","isSafeInteger","up","dn","buf","allocUnsafe","writeUInt32LE","hour","minute","REGEX","str","matched","exec","value","parseFloat","toLowerCase","Math","round","second","day","header","byteLength","le64","pieces","filter","Boolean","accumulator","piece","len","strict","parsed","alg","eo","m2","sig","createSecretKey","startsWith","type","symmetricKeySize","TSE","paddedBuffer","copy","a","b","max","s","errors","V1","V2","V3","V4","checkKey","checkFooter","checkPayload","generateKey","generateKeyPair","generateSecretKey","keyobject","privateKey","publicKey","modulusLength","secretKey","constants","RSA_PKCS1_PSS_PADDING","padding","RSA_PSS_SALTLEN_DIGEST","saltLength","createPrivateKey","der","asymmetricKeyType","asymmetricKeyDetails","createPublicKey","bytesToKeyObject","keyObjectToBytes","_generateKey","v","bytes","keyObject","equals","_keyObjectToBytes","d","args","_checkPrivateKey","strictEqual","_checkPublicKey","checkAssertion","compressPk","namedCurve","dsaEncoding","SimpleAppName","SimpleShortAppName","SimpleAppNameLC","AppName","lazy","isProd","nodeEnv","AppNameVersion","allDefined","arr","defined","every","intersection","valueOf","primitiveValueOfOrElse","Set","map","ea","has","_uniqCount","sortedArr","lastElem","lastIndexOf","count","zip","arrarr","times","leastIndex","leastIndexBy","greatestIndex","greatestIndexBy","estIndex","lt","gt","leastBy","isEmpty","cmp","estIndexCtx","index","batches","batchsize","stepRange","everyAsync","diff","remove","minuend","subtrahend","some","eb","eql","objects","notBlank","toA","r","err","thunks","isNotEmpty","predicate","fromIndex","arrs","Array","isArray","elem","push","element","moved","sortBy","stringifySorted","idx","findIndex","splice","copyArrayTo","uniqBy","accept","reject","indexOf","sort","compact","Map","reduce","prev","curr","min","arr_length","results","j","ctx","batchSize","batchArr","lastPass","tap","prior","find","ea2","ea3","outer","resultArr","pred","maxDelta","before","after","mm","set","mapOr","get","entries","minLength","pad","unshift","BatchClusterObserver","EndableWrapper","rank","EndableRanks","service","end","commandTimeoutMs","ShortCommandTimeoutMs","bce","on","bp","pid","logger","info","renice","catch","onError","addPid","ppid","cmd","timeoutMs","maxProcAgeMillis","minuteMs","TimeoutError","error","lastStartError","task","errorToS","match","onTimeout","lastTaskError","command","FatalErrorFlag","lastInternalError","stdout","stderr","proc","streamFlushMillis","secondMs","warn","new","stout","toS","child_pid","cp","gt0","Pids","instance","onKill","reason","ended","ending","isIgnorableError","maxProcs","loggerName","maxIdleMsPerProcess","isWin","maxTasksPerProcess","Settings","valueOrDefault","spawnTimeoutMillis","minDelayBetweenSpawnMillis","minDelayBetweenSpawnMs","streamFlushMs","cleanupChildProcs","mkLogger","maxLength","toValue","sortedArray","SortedSet","toArray","vacuum","store","retainLastN","add","addAll","BoundedList","_length","_firstIndex","mapIndex","trunc","at","last","l","clamp","clear","Symbol","iterator","self","iter","items","item","pop","reverse","shift","shiftOrFirst","callbackfn","forEach","initialValue","acc","floor","to","swap","start","ByteOrderMarks","bom","encoding","debom","bufferStartsWith","prefix","CaseInsensitiveMap","initialContents","normalizer","DefaultNormalizer","lookup","delete","size","values","toStringTag","pick","synonyms","MultiMap","o","uniq","getFirst","lookupNearest","minDiceCoeff","exact","best","bestCoeff","coeff","diceCoeff","newBest","lc","colorEnabled","noColor","withAsciiEscape","off","msg","reset","bold","dim","italic","underline","overline","inverse","hidden","strikethrough","black","red","green","yellow","blue","magenta","cyan","lightGrey","darkGrey","redBright","greenBright","yellowBright","blueBright","magentaBright","cyanBright","white","bgBlack","bgRed","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgLightGrey","bgDarkGrey","bgRedBright","bgGreenBright","bgYellowBright","bgBlueBright","bgMagentaBright","bgCyanBright","bgWhite","CountingSet","incr","countSum","sum","keyAvg","avg","Average","isNumber","toJSON","toRecord","entriesByCountDesc","mapNumericOr","abs","top","topKeys","averageCounts","sortedByKey","join","valuesToA","fill","DefaultSensitiveEnvRegexPattern","EditionType","isElectron","isDocker","EditionName","listener","ts","elapsed","log","elapsedMs","map2Or","a1","a2","examples","PosixFile","for","examplesNativePath_","exampleParentDir","ancestorWithChildren","__dirname","joinNativePath","Function","_self","FifoCache","maxSize","clearEveryMs","setsSinceLastSpill","expireListeners","clearInterval","setUnrefInterval","spill","priorCache","currentCache","el","create","inspect","custom","visit","union","v2","visitor","deleteIf","orElse","getOrSet","valueThunk","_event","__uid","__start","opts","cache","mergeStats","stats","cacheHitsSync","cacheHitsAsync","cacheMisses","rejections","timeouts","get_","Deferred","isRejected","isPending","promise","getOrSetAsync","later","observe","setTimeout","FifoSet","delegate","next","IndexedHeader","text","isString","greedyLeft","toEntry","row","substring","leftIdx","rightIdx","trim","headers","table","warnIfMissingHeaders","Fixed","skippedHeaders","rows","splitLines","headerRow","maxLen","max_","blankColumns","range","blank","extractHeaders","fromEntries","firstBlankColumn","fromIdx","toIdx","re","RegExp","escapeRegExp","priorLastIndex","skippedOver","debug","m_index","lastIndex","left","indexOfNonSpace","right","lastIndexOfNonSpace","priorRightBoundary","leftmost","lastHeader","DefaultBitDepth","toNearestBitDepth","bitDepth","validLat","latitude","within","validLon","longitude","validLatLon","geohash","geohashNumeric","GeoRadix","loc","lat","lon","GeoHashBitZip","BitZip","ungeohash_num","geohashNum","unzip","geoHashToLocation","geohashString","distanceMeters","phi1","PI","phi2","deltaPhi","deltaLambda","sin","cos","atan2","sqrt","geohash1","geohash2","halted","halt","HashBits","isSuspended","parseJSON","FixDateTimeToJSON","defer","DateTime","prototype","compactValues","_ctor","toMillis","zone","zoneName","DateTimeReviver","fromJSON","fromMillis","addDefaultJsonRevivers","addJsonRevivers","ExifDateTime","ExifDate","ExifTime","CapturedAt","DateInterval","FuzzyDate","BinaryField","WrappedError","ttlMs","LazyClass","ExtensibleFunction","thunk","watchers","_call","isStale","onSetResult","priorP","currentP","_prior","current","setUnrefTimeout","unset","lastSetTs","refresh","ttl","setTTL","watchLater","watcher","watch","lastSetAgoMs","hasPrior","ROLazy","_","DefaultLocale","extractLocale","e","env","LC_ALL","LC_MESSAGES","LANG","LANGUAGE","toLocale","locale","lastValue","envLocale","lazyAsync","desc","lc2locale","localeWin","isMac","localeMac","localePosix","regex","equalsIgnoreCase","g","groups","lang","country","thenMap","PowerShell","executeJson","Name","stdout_","parseEnvTokens","lowerCaseKeys","logStartup","serviceName","StartTs","argv","arch","platform","os","osFullName","isPacked","versions","settings","logLevel","httpPort","libraryDir","psenv","rootLoggers","ConsoleLogger","consoleLogger","context","ContextualLogger","compactMap","iterable","retainIfTrue","callCount","memoryUsageBytes","mem","memoryUsage","external","heapUsed","arrayBuffers","memoryUsageRssBytes","rss","sigFigs","MB","toBoolean","process","PS_LOG_COLOR","isTrue","NO_COLOR","includes","TERM","MaybeTestArgRe","_nodeEnv","NODE_ENV","isDev","isTest","SINGLE_SPEC_TESTS","_isSupportedNode","nodeVersion","node","satisfies","requiredNodeRange","isSupportedNode","mapGte0","mapInt","mapGt0","toInt","flatten","toFloat","defaultValue","mapNumeric","numstartRe","extractFloat","String","substr","extractInt","prepHammBigInts","leftPad","hammRatioBinaryString","matching","map2Numeric","columns","col","s1","s2","charAt","bitsPerValue","BigInt","bitsPerCell","total","Try","toErr","primitiveEntries","isPrimitive","isDate","mapEntries","val","fieldNames","field","fieldName","first","errIfMissing","propertyIsEnumerable","defaults","sources","assign","dest","src","keysToRetain","maxKeys","keyCount","valpath","ciFieldPath","nextDot","fieldRemains","ciField","sortedKeys","sortIgnoreCase","deepDelete","keysToDelete","caseInsensitiveKeyName","osNameDefault","release","osArch","osNameLinux","osNameMac","osNameWin","osName","OsReleaseFiles","isDebian","osDistributionLinux","isUbuntu","isFedora","isAlpine","osReleaseTokens","isLinux","filename","readFileSync","pretty_name","version_id","id","MacCodenames","WinReleaseToVersions","versionToCodename","ver","codenames","major","minor","majorMinor","macProductVersion","execSync","productVersion","mapNotBlankOr","macCodename","codename","CPUs","uniqCount","cpuInfo","model","whyOsNotSupported","test","loose","debianVersionToSemver","AssetFileVersion","AssetVersion","pids","pidExists","untilTrue","intervalMs","AllowableStartSlopMs","matchesPidfileInfo","entry","entryStartTime","fileStartTime","startTime","killPidWinTaskkill","force","execFile","killPid","rewritePidfileOnForce","execute","identity","killPidWin","kill","killPidWithNode","pidsDir","recentPids","vacuumOldWip","rateLimited","minCallDelayMs","minMtime","old","childFiles","isJsonExt","isHiddenBasename","base","mtimeMs","unlink","killOldProcs","everything","pidfiles","killed","endPromises","pidEntries","pidInfos","pidfile","json","readJson","pidEntry","timeoutAt","everythingBefore","toISOString","allSettled","opt","parseNativePath","getOrElse","writeJson_","children","ext","priorInfo","ago","configDir","dir","BaseFile","ProcCleaner","timers","predb","PriorityClasses","strEnum","PriorityClassToPosix","freeze","Normal","BelowNormal","Low","Idle","PriorityClassToNode","AboveNormal","priority","PRIORITY_ABOVE_NORMAL","PRIORITY_NORMAL","PRIORITY_BELOW_NORMAL","PRIORITY_LOW","isFinite","shortProcessNames","short","isMainService","title","isProcEntry","pe","existingPids","collectBatchedAsync","pidInfoWin","pidInfoPosix","meta","win2pe","Id","pwshJsonDate","StartTime","ProcessName","procs","psWinWmic","executeJsonToA","PsWinCmd","PsWinSelectObj","psWin","psStdout2ProcEntry","stdoutOpts","psPosix","alive","pidToS","maxBuffer","ignoreExitCode","ignoreStderr","processIdClause","stdoutResult_","wmic","onlyReqValued","parseFixed","ProcessId","wmiDate","CreationDate","CommandLine","PID","STARTED","COMMAND","radix","TokenRadix","decuss","randomChars","randomUid","chars","splitEveryN","sepChar","nullOnBusy","priorResult","nextArgs","running","delayNextRunUntil","ceil","doneLatches","isRateLimited","afterRunDelay","delay","resolve","cause","postRun","run","donePromise","Latch","status","needToDelay","minNextDelayMs","setMinCallDelayMs","RegExpEscaped","source","replace","global","flags","ignoreCase","multiline","RegExpOptional","concatRegexp","ee","reniced","niceableCmds","basename","ffmpegPath","ensureSuffix","compactBlanks","nodeReniceWorks","TTLSet","priorityClass","priorityPosixToClass","processPriority","setPriority","permissionDenied","errno","pc","reniceWin","nice","renicePosix","MainServices","isWebService","ServiceNames","web","isWorkerService","worker","isSyncService","sync","isTestService","isTestNotWorker","isStatsDbService","processName","main","desktop","DbServices","list","billing","StatsDbServices","isDbJanitorService","asSet","onAdd","console","setupLogger","impl","shim","time","setShim","hasShim","toKey","emit","cacheDelete","findValueIndex","low","high","mid","midV","found","shiftLte","deleteCount","optionalParams","quiet","stdoutEnded","crlf","streamEnded","envValue","stdoutWrite","ready","writeTTY","stream","write","FailStr","isFatalError","isHealthCheckError","ReadyStr","addToEnv","migrationFile","migration","StdoutWrite","shutdownSync","restartSync","forceRestartSync","rebuildLibrary","shutdown","splitFirst","ellipsize","ensurePrefix","stripPrefix","stripSuffix","wrap","he","suffix","endsWith","padChar","strslice","haystack","needle","fromPosition","countChars","maxSplits","sliceTimes","matchedIndex","captured","uncaptured","unmatched","startsWithIgnoreCase","sfx","maxPre","maxPost","charsOmitted","toLocaleLowerCase","toLocaleUpperCase","CapRE","compareIgnoreCase","localeCompare","sensitivity","normalize","as","bs","uniqBy2","nn","hn","nl","hl","patterns","greatestBy","Smart2Dumb","dumbquote","smart","dumb","quoted","SingleQuoteWrappedRE","DoubleQuoteWrappedRE","splitKeep","splitUp","flatZip","nonSeparators","separators","NonRetriableErrorFlag","pos","sortNaturalBy","line","escape","cb","lines","rev","parseInt","fromCharCode","CommentRE","sep","replacement","dedupeRe","delim","snake2camel","toUpperCase","stringShaToBuffer","msbits","createHash","shortStringSha","Radix58","encodeBuffer","lcs","Array2D","z","ret","hamming","_hamming","an","bn","A","B","firstThunk","aGrams","bigrams","bGrams","nonUniqIntersection","uniqIntersections","diffWithoutCommonPrefix","cpc","commonPrefixLength","longestNumericString","digits","lnsDiff","b1","notAlphaNumRe","radixDiff","stripDiacritics","RadixAlphaNum","positionalDiff","aChar","charCodeAt","bChar","pref","ham","dice","lns","minLen","TTLArray","expirationListeners","pushUniq","onExpire","oldestEntryAge","priorLength","minTime","firstGoodIndex","TTLMap","deleteAll","getOrMaybeSet","lastSetOrGetTs","valuesByRecency","scheduleExpirationTimers","addIfMissing","onMissing","ctime","expired","TestLibraryDirPrefix","lastTime","UidRadix","uidForTs","uidSuffix","uidRe","tsFromUid","uid","username","gte0","userid","userids","geteuid","getuid","userInfo","groupids","getegid","getgid","gid","groupid","usernameFromEnv","getEnv","usernameFromUserInfo","toNotBlank","userNameFromWhoami","userNameFromWindowsAccessToken","isRootUser","versionMajor","versionMinor","versionPatch","versionPrerelease","gitSha","gitDate","WeakCache","findEntry","deleteValueIf","w","deref","WeakRef","wmi","year","mon","sec","micros","offset","UTC","WinDateRe","flatMap","dayMs","sorted","sortAssetFiles","assetAggregation","AggregateTypes","clusterSome","clusterEvery","isSimilarAssetFile","whyInequal","af1","af2","mapNotBlank","lc2","whyExifUidNotEql","ne","findInequalFields","aKey","aValue","whyNotSimilarAssetFile","allKeysDefined","definedAndEql","sha","af1IsVideo","isVideoMimeType","mimetype","af2IsVideo","VideoImageMismatchMsg","uri","af1ca","fromAssetFile","af2ca","capturedAtIsFuzzy","isFuzzy","allowFuzzyDateImageHashMatches","ih1","toImageHash","ih2","isSimilarImageHash","rotationsToCheck","validRotations","overlaps","toISOStringWithPrecision","fieldDiff","dist","geohashDistanceMeters","fields","cameraId","imageId","lensId","exposureSettings","whyExposureSettingsNotSimilar","closeGeoHash","gpsErrorMeters","fmt","mismatched","useImageHashes","ihc","compareImageHashes","isSimilar","whyNotSimilar","minMatchesWithoutImageHashes","siblings","why","sib","assetFileUriFields_","nativePath","uri_","mountpoint","throw","assetFileStatFields_","stat","stat_","sidecareStats","mtime","fileSize","imageHashToAssetFileImageHashFields","ih","DominantColor","toModeData","dominantColors","assetFileImageHashFields_","imageHash_","mkSortableAssetFile_","assetFileMetadata_","sha_","shim1","readTags","caFields","capturedAt","toAssetFileFields","dimensions","rotation","make","Make","Model","rating","geohashNumericShort","GPSLatitude","GPSLongitude","durationMs","duration","fps","VideoFrameRate","saf","UriSchemes","PS_NETWORK_FILESYSTEM_SCHEME","PS_LOCAL_FILE_SCHEME","PS_LIBRARY_SCHEME","dim2sort","width","height","sortScale","pow","variantSortCriteriaPower","mtime2sort","MetadataFields","files","sameSha","groupBy","maxMtime","assetFileSortCriteria","assetFileSortCriteriaPojo","af","parsedURI","URI","scheme","path","uri_scheme","uri_path","schemeIdx","parsedFile","parsePosixPath","metadataFields","resolution","capturedAtPrecision","capturedAtPrecisionMs","weekMs","metadataCoverage","isBrowserSupported","isSupportedByCurrentBrowserExt","isCover","includesIgnoreCase","copySuffixCountFromName","CmpReverseFlag","parentBasename","toReqValued","assetFileSortFields","variantSortCriteria","uriExists","uri2nativePath","AbortError","lastTimeout","clearTimeout","setTimeoutMs","toAsyncIterable","race","startedAt","PromiseStates","pending","serialId","toLogJSON","state","omit","settledAt","observeQuietly","p","isPromise","maybeResolve","maybeReject","unref","stateStr","isResolved","isSettled","resolved","rejected","settledMs","asError","finally","onfulfilled","onrejected","firstback","DoneWrapper","doneLatch","isDone","endablesByRank","vacuumEndables","DefaultTimeoutMs","endable","validOrElse","_ending","endTimeoutMs","getDevEnvFlag","firstGt0","trace","thenOrTimeoutError","filterInPlace","entriesArray","endEndables","isSingleSpecTests","EndableInterval","callback","onEnd","onEnds","setIntervalMs","initialDelayMs","hasTimer","hasTimeout","timingOpts","maybeScheduleInterval","setInterval","awaitSettled","addEndable","awaitEnd","exit","LogLevels","toWrappedError","fatal","stderrWrite","onFatalHandlers","exitOnStdStream","streamName","eventName","maxConcurrency","maxCpus","Promises","signal","aborted","enqueue","fn","abort","ac","AbortController","serial","res","rej","settledCount","setResult","priorD","resultD","resultIdAtStart","onChange","FifoCacheAsync","runLaterIfBusy","undefinedIfBusy","runAgain","postrun","setImmediate","isRunning","thenCompact","thenCollectSerial","thenCollectParallel","maxConcurrent","promises","array","PermissivePromises","func","enqueueAll","tol","batchInput","objP","withinMs","isFalse","DefaultTryAllTimeoutMs","thenOrTimeout","err_","finally_","caught","isFunction","defaultIfNull","objP1","objP2","o1","o2","ifUndefined","predicatePromise","promiseThunks","unsorted","normalizeName","PromiseTimer","expectedTime","p98","slowTimer","tot","entriesBySumDesc","namePrefix","merged","agg","merge","mkElapsed","Elapsed","weightedAvg","weightedSampleAvg","errorCounts","callCounts","weightedAvgs","mapFinite","report","sumSec","pushTime","pt","mapCompactObj","mapNotEmpty","EventEmitter","lastWorkTs","settleMsAvg","lastPushedNames","awaitAll","lastPushMsAgo","freeSlots","unsettledCount","runningNames","pendingNames","totalWorkCount","laterPop","laters","promiseOrLater","maybePopPendingWork","maxJobsToStart","isIdle","jobsToStart","runningSerialIds","blockedBySerialId","isTaskRunning","taskName","maybeRun","runningCount","hasPending","isFull","deferreds","pendingWithName","payloadsWithName","pendingPromises","awaitAllByName","_name","timeoutStacks","onSuccess","asPromise","_resolved","timedOut","timeoutHandler","_soft","soft","until","acceptable","timeoutResult","sentSoftTimeout","delayCount","delayMs","SettingsKeys","sensitiveEnvRE","sensitiveEnvRegExp","sanitizedEnv","allSettings","RequiredPosixEnv","RequiredWindowsEnv","requiredEnv","caseInsensitiveEnv","isPosix","pathWithDefaults","childProcEnvSettings","forWorker","PS_IS_CHILD_PROCESS","PS_IS_DOCKER","ELECTRON_RUN_AS_NODE","persistedSettings","hasValue","addToEnvMaybe","maybeOpts","childEnv","overrides","forceCLocale","detached","shell","childEnvLogged","childProcLocale","transientSettings","deleteFromEnv","isLogged","ps","nonPs","partition","getSettingByNameOrKey","cp2log","endProcess","closeStreams","killResult","childGotSigterm","waitForPidExit","newProc","niceable","ReniceAfterMs","AddPidAfterMs","spawnOptions","disconnect","stdoutChunks","stderrChonks","exitCode","endStream","stdin","stderrEnded","isIgnorableFunc","causes","maxAgeMs","spawn","level","trimLastNewline","pathToService","cmdBase","root","projectRoot","currDir","cwd","paths","isNonEmptyFile","KB","randomInt","ChildService","mk","pathTo","nodeArgs","restartCount","serviceExitTimeoutMs","spawnArgs","spawnOpts","wc","WatchedChild","childFactory","onPreRestart","execPath","endableRank","onStdout","onStderr","ignoreStopErrors","exitCommand","ChildServiceExitCommand","startMs","startTs","onData","stop","restart","notRunning","toStdin","retries","childProc","writable","syncExitTimeoutMs","_stopped","startRate","Rate","mutex","ignorable","lastError","dataSep","maxErrorsPerMinute","fatalErrorRatePerMinute","restartOnExit","denull","stopped","isErrorRateExceeded","eventsPerMinute","startRatePerMin","maxErrorsPerMin","msSinceLastEvent","minTimeBetweenServiceRestartsMs","errorsPerMinute","msSinceLastStart","isRecentMs","probationMs","currentPid","onRestart","onEvent","sout","onDataChunked","serr","stableBasename","stripCopySuffixFromName","aggressive","pf","sibling","isSelfOrDescendantOf","path_posix","posixPathFrom","origDir","originalsDir","anc","findAncestor","baseWithGrandparent","additionalDescription","plugins","setServiceName","verifyUidGid","addFooter","program","description","cliWrap","CliDesc","arguments","beforeParse","option","joinLines","DescriptionFooter","isMainElectron","afterParse","logcat","logtail","maxLineLen","ColorArgs","isEnvTrue","logColor","color","getFullYear","__is_daemon","daemon","whyMismatched","envKey","actual","toGt0","whyUidGidMismatched","WriteSettingsArg","writeSettings","systemSettingsFile","writeSystemSettings_","checkedDirectories","osConfigDirs","librarySettingsFile","writeLibrarySettings_","colorToTuple","rgb","normalizeRgbHex","lab","rgbhex2Lab","labhash","toLabhash","ModeBits","closeLabhashes","closeRgb","capitalize","bestLabName","colors","ColorNames","ciede2000_delta_e","CrayonColors","CrayonSupplements","DarkWikipediaColors","LightWikipediaColors","Greys","rgb2lab","bestLabhashName","rgbhex2Labhash","labhashToColor","unlabhash","lab2rgbhex","srgb2xyz","xyz2srgb","xyz2lab","rgb2xyz","lab2rgb","clampRGB","xyz2rgb","lab2xyz","clampLab","srgb","matXvec","rgbHex","rgbhex2triplet","rgbTriplet2hex","RefWhite","X","Y","Z","epsilon","kappa","xyz","fx","fy","fz","vecXvec","fx3","fz3","xr","yr","zr","LabBitZip","rgb2hsv","delta","hh","rgb2hsl","hsv2hsl","hsv","hsl2hsv","hsl","s0","hsv2rgb","mod6","hash","_unlabhash","minLabhash","zipMin","maxLabhash","zipMax","rgbhex","lab1","lab2","L1","L2","b2","dL","dA","dB","c1","dC","deltaH","MinCie","MaxCie","kL","kC","kH","std","smp","lStd","aStd","bStd","cStd","lSmp","aSmp","bSmp","cAvg","G","apStd","apSmp","cpStd","cpSmp","hpStd","hpSmp","dhp","dH","Lp","Cp","hp","Lpm50","T","Sl","Sc","Sh","deltaTheta","Rc","Rt","fmtPct","pct","fromModeData","md","ModeCount","fromLabhash","labhashBits","fromCentroid","totalPixels","centroid","toGreyscale","other","closeTo","_impl","totalCoverage","totalMatch","nearest","delta_e","scaled","scaled_delta_e","_match","DeltaEMatchPoints","lerp2d","labs","timeSync","runs","dominantColorKmeansRuns","cs","maybeFilterGrey","minK","distFunc","DeltaEImpls","dominantColorDeltaE","kActual","dominantColorMergeThreshold","setKActual","maxK","kmeansResults","Seeds","seed","km","kmeans","KmeansDefaults","mergeNearCentroids","centroids","score","leastByCtx","p84","centroidDeltaP84","kIn","kOut","kMerged","iterations","uniqColors","bestResult","dominantColorsFromModes","totalColors","iters","dominantColorsToRgbHex","pixelCount","dominantColorScore","_extractDominantColors","closest","cie76","cie76_delta_e","cie94","cie94_delta_e","ciede2000","maxIterations","initialization","distanceFunction","thresh","greyThreshold","dominantColorGreyThreshold","filtered","filteredCount","labhashCountingSet","mergeLabhashes","mergedColors","lh","cnt","pctOmitted","sumf","threshold","winners","minSize","greyscaleColorThreshold","clamped","stdDev","mode0","mode0pct","ModeDataKeys","RgbHexRe","maxMsDelta","aTime","bTime","timeMs","deltaMs","Duration","toFormat","hourMs","iso","dt","fromISO","isValid","dou","fromObject","invalidExplanation","dateIntervalRE","Fields","defaultZone","parseExifDateTime","splits","hasZone","setZone","middle","plus","milliseconds","month","millisecond","edtField","precisionMs","datedToPrecisionMs","toDate","contains","datedOverlap","aContainsB","aOverlapsB","isDated","isDateTime","isDateObject","datedToStartTs","datedToMillis","datedToDateTime","toDateTime","fromJSDate","dateObjectToExifDateTime","hasTime","getMillisecond","getSecond","getMinute","getHour","getDay","getMonth","monthMs","yearMs","maybeCall","isoToDated","NoOverlap","aPrecisionMs","bPrecisionMs","aZone","getZoneName","bZone","a0","b0","toObject","DefaultDateTimeFormats","decCache","decodeDuration","parseDuration","encCache","fmtFullDuration","isDigits","captures","units","parseUnit","lt0","Units","unit","parseExifDateTimeRe","isEmptyObj","_k","fuzzyDateParsing","subsec","tzoffsetMinutes","timezoneOffsetFromRegExpMatch","zoneOffsetToName","rawValue","UnsetZone","Info","normalizeZone","UnsetZoneOffsetMinutes","fromDateTime","fromFormat","unsetMilliseconds","fromRFC2822","ymd_hmsRegExp","nonNumericLookbackRE","yearRE","monthRE","dayRE","hourRE","minuteRE","secondRE","subsecRE","TimezoneOffsetRE","zoneToTzOffsetMinutes","edt","fmtDateTime","dateTime","DATETIME_MED","mapValidDate","setLocale","toLocaleString","BadMsRE","isoToDateTime","locale2dtf","shortDateTimeFormat","Intl","DateTimeFormat","isoDate","isValidDate","toJSDate","timestamp","formatted","tsDate","fmtDate","pad2","getDate","getHours","getMinutes","getSeconds","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","ISO_YMD_RE","ISO_YMD_LAX_RE","minValidYear","fd","localToday","toFuzzyDate","validYMD","toLocal","datedToLocal","following","toExifDateTime","getYear","ignorableSubpaths","subpath","offsetMinutes","includeUTCPrefix","rounded","hours","minutes","includeOffset","datedToYMD","ExifFmt","ExifFmtWithZone","separator","diffMillis","aMs","bMs","datedToEXIF","dis","dat","lte","maxDiffMs","zoneA","keepLocalTime","dated","date","priorZone","toUTC","FuzzyDateParser","extractDateFromPath","parseYMD","yearishRE","monthishRE","dayishRE","seps","optSeps","PatternToRE","yyyy","yy","MMMM","MM","M","dd","HH","H","ss","ZZ","token2re","formatRegexCache","regexFromDateFormat","dateFormat","extractDateTime","parseExifDateTimeFormat","parseDated","includeDate","includeFuzzyDate","descPredicate","stripDSC","parseExifDateTimeFromRFC2822","extraDateTimeFormats","fromEXIF","parser","allParsers","apply","parsers","divideEqually","isExifDateTime","ymdParsers","ymParsers","yParsers","fuzzyYearParsing","parseYM","parseY","usePathsToInferDates","ignorableDCF","reversePath","Parser","hasDay","hasMonth","allMonthsRE","monthNames","monthName2index","monthname","getMilliseconds","datesBeforeAreEstimated","isoToLocal","tsToLocal","datedToLocalSec","getCentisecond","localToDateObject","local","pop2","localToDateTime","dateObjectToDateTime","agoLocal","agoMs","localCs","localToDate","flavorOfTheMonth","dtf","monthName","setupLuxon","throwOnInvalid","twoDigitCutoffYear","defaultLocale","offsetToMinutes","MaxTzOffsetHours","ValidTimezoneOffsets","AllZoneOffsetMinutes","normalizeZoneOffsetMinutes","allowedSlopMinutes","isValidZone","ZuluPrimitives","isUTCPrimitive","isInvalidNumber","FixedOffsetZone","utcInstance","isoToOffsetMinutes","ianaZoneToOffsetMinutes","UnsetZoneName","fmtOffsetMinutes","mins","utcRE","signRE","negativeRE","paddedHourRE","minRE","utc","tzHour","tzSign","tzMinutes","IanaZonePrefixRE","IanaTimezoneOffsetRE","iana","tz","badDates","badDatesISO","datedToISO","badDatesLocal","badDatesTs","whyNotValidDate","isNaN","minYear","maxYear","maxMonth","validYear","validMonth","gte","validDay","AutoVacuumModes","schema","Schemas","models","libraryUidStore","NoLibraryErrorFlag","libraryUid","readUid_","cacheDir_","mkdirp_","readme","writeTextfile_","cacheDbFile_","cacheDbDir_","SqliteBase","forceLocalDbReplica","libraryDb","pathToDb","setupLibraryDataDir_","assertDirSQLiteReadWrite_","parent","db","useReplica","cacheDbFile","CheckpointTypes","srcDbFile","destDir","wips","sqliteFiles","wip","copyFile_","unwip_","onRetry","maxBusyDbMs","isRetriableError","isSqliteBusyError","pageSizeBytes","dbPageSizeBytes","log2","dbBusyTimeoutMs","logSql","verbose","mkdirpSync_","dirname","partialPath","posixPathFromGrandparent","ll","defaultLogLevel","sql","dbFileSize","nativePathSizeSync","dbFileSizeMb","MiB","minDbCacheSizeMb","dbCacheSizeMb","minRamMb","maxMemoryMb","fileMustExist","readonly","timeout","pragma","dbSynchronousMode","dbWalAutoCheckpoint","dbAutoVacuumMode","tapThunk","RepairModes","dbFile","SQLiteSuffixes","existsSync","isDirSQLiteReadWrite","dirNativePath","child","mkdb_","prepare","close","pluck","rm","dirs","sqliteVersion_","libraryVersion","sqliteNativePath","sqliteNativePath_","fullToolVersion","toolVersion","pathToDbDir","dataDir","SqliteExt","SynchronousModes","tmpCacheDirs","preexistingDir","tmpDir","cacheDirs","XDG_CACHE_HOME","DefaultDockerLibraryDir","homeDir","cacheSubDir","filterDirs","defaultCacheDir","firstDir","addSettingsListener","setSettingsDefaults","cacheDir","resetCacheDir","refreshEnvValue","broadcastChange","mkNoMedia_","envConfigDir","dockerConfigDirs","desktopConfigDir","desktopConfigDirs","ReadPhotoLibraryDir","isReadable","isReadableDirectory","isReadWriteableDirectorySync","XDG_DATA_HOME","XDG_CONFIG_HOME","fromEnv","mkdirpSync","isDirectorySync","homedir","toPathnames","libraryDataDir","libraryPreviewsDir","containedByNativePath","descendant","ancestor","acceptSelf","libraryDirOverride","resolveMaybe","previewsDir","README","libraryDirPosixFile","forMaybe","libraryDataDirPosixFile","mkdirRW_","neverIndex","assertReadWriteExecutable","touch","readmeFile","libraryOriginalsDirPosixFile","setupLibraryOriginalsDir_","libraryPreviewsDirPosixFile","setupLibraryPreviewsDir_","librarySyncReportsDir","syncReportsDir","setupLibrarySyncReportsDir_","setupLibraryDbDir_","imageCacheDir_","defaultLogDirs","defaultLogDir_","logDir","readTomlFileSync","ld","picturesDirWindows","picturesDir","defaultPicturesDir","XDG_PICTURES_DIR","PS_ENV_KEYS","delimiter","SensitiveEnvRE","file","tokens","DevEnvFlags","DevEnvKeys","IgnorableEnvKeys","EnvKeys","splitCompactLines","onEnvChange","SensitiveEnvRegexPattern","camel2snake","firstNotBlank","PS_SENSITIVE_ENV_REGEX_PATTERN","sensitiveEnvRegexPattern","CaseInsensitiveValued","splitErrorMessage","errs","messages","getErrorDescriptions","isError","errorName","errorCode","stripAnsiEsc","ErrorDelimiter","uniqSubstrings","normalizeErrorMessages","IgnoredErrorNames","joinErrorMessages","trimmed","trailingChars","sortErrorFlags","extractErrorFlags","stripErrorFlags","errorRate","fatalErrorRate","internalErrorRate","lastInternalErrors","MissingError","maxMsgLen","maxStackLines","shortStack","stack","ErrorCodes","errorErrno","err2desc","UNKNOWN","OK","EOF","EADDRINFO","EACCES","EAGAIN","EADDRINUSE","EADDRNOTAVAIL","EAFNOSUPPORT","EALREADY","EBADF","EBUSY","ECONNABORTED","ECONNREFUSED","ECONNRESET","EDESTADDRREQ","EFAULT","EHOSTUNREACH","EINTR","EINVAL","EISCONN","EMFILE","EMSGSIZE","ENETDOWN","ENETUNREACH","ENFILE","ENOBUFS","ENOMEM","ENOTDIR","EISDIR","ENONET","ENOTCONN","ENOTSOCK","ENOTSUP","ENOENT","ENOSYS","EPIPE","EPROTO","EPROTONOSUPPORT","EPROTOTYPE","ETIMEDOUT","ECHARSET","EAIFAMNOSUPPORT","EAISERVICE","EAISOCKTYPE","ESHUTDOWN","EEXIST","ESRCH","ENAMETOOLONG","EPERM","ELOOP","EXDEV","ENOTEMPTY","ENOSPC","EIO","EROFS","ENODEV","ESPIPE","ECANCELED","ErrorFlags","IgnorableErrorFlag","PleaseSendErrorFlag","HealthCheckErrorFlag","DoNotSendErrorFlag","RetriableErrorFlag","HealthCheckWarningFlag","InternalErrorFlag","DbSetupErrorFlag","NonFatalErrorFlag","ErrorFlagsRE","FatalErrorPatterns","FatalErrorRe","InternalErrorRe","event2log","event","ExtraEventsForPlease","ErrorStore","datedRoot","rmrf","msg2file","eventsFrom","when","fmtDuration","eventCount","eventQuotaExceeded","pleaseSend","recentEventCount","maxErrorsPerDay","maybeSendEvent","eventFile","writeEvent_","applyIfEmpty_","fn_","minSizeBytes","returnUndefinedIfNotEmpty","isPleaseSendError","notIgnorablePatternRE","ignorablePatternsRE","orRegExpPatterns","BusyErrorRe","isSqliteDisconnectedError","isSqliteConstraintError","isNonRetriableError","retriable","doNotSendPatterns","doNotSend","internalError","InternalError","isInternalError","isFatalErrorAllowed","postProbation","lowErrorRate","acceptsFatalErrors","isServiceThatAcceptsFatalErrors","fatalErrorRatePerMin","errorRatePerMin","fatalErrorRatePerMinuteSetting","mkMessage","mkCtx","toErrs","codes","splitUniq","syscall","maybeAnd","isDoNotSendError","dedupeNeedle","broadcastEvent_","SharedState","broadcastExit","target","eventsToRetain","omniListeners","priorEvents","once","addOmniListener","watchEvent","removeOmniListener","emitDebounced","listeners","removeAllListeners","mkEE","setMaxListeners","CapturingEventEmitter","syncing","EventNames","updateReadyToInstall","clearCache","clearDbCache","clearToolCache","_msg","_err","_ctx","_error","nonFatal","fileChanged","_nativePath","invalidFile","mountpointsChanged","reloadLicenses","pause","resume","_isSyncing","progress","_p","updateProgress","settingsChanged","showAbout","taskResult","_result","timing","_elapsedMs","vacuuming","_isVacuuming","volumesChanged","TaskNames","checkOperations","repairAsset","_arg","repairAssetFile","runTagMaintenance","syncDir","isUID","EventNameToLevel","TaskNameToLevel","isStateFile","isWip","isSharedStateFileOrDir","isPsLockFileOrDir","isFreshEvent","evt","fresh","isStoredEvent","EventTimeoutMs","dedupeStoredEvents","uniqByLast","isBoolean","paused","events","tasks","eventEmitter","processors","taskProcessors","sharedStateTaskTimeoutMs","handledEventUids","handledTaskUids","setup","read","DirWatcher","save","oneAtATime","currentState","jsonFile","sharedStatePollMs","clearThisAndParent","isMtimeRecent","toNativePath_","readFileMaybe","updated","unfilteredTasks","taskExpireTs","taskTimeoutMs","sortUniqBy","isStoredTask","sendEvents","withFsLock","isPaused","isSyncing","maybeSave","broadcast","canHandleTaskLocally","submitTask_","logCurrentState","done","syncingPids","syncingPid","setIsSyncing","isTaskResult","withLock_","noopIfContested","processor","sharedStateDir","expectedDir","nativePathsEqlSync","visitDescendants","rmdir","getUid","getGids","getgroups","canAccessSync","mode","accessSync","isStatRWX","R_OK","W_OK","access","isStatRX","processUid","processGid","gids","isRoot","isUser","isGroup","foundNearest","selfAndAncestorG","statMaybe","isDirectory","actualPath_","actualPathCache","FileCache","pathIsRoot","actualDir","readdir_","ancestors","ancestorG","childrenSync","readdirSync","hasChildrenSync","childNames","object","isSimpleFile","dirent","bflog","directoryEntry","de","posixPath","native2posix","withFastestAccess","msArr","shaMs","forPosix","posixPathOrFile","forDirectoryEntry","nativePathOrFile","fromPath","forChildDirent","DirectoryEntry","fromSimpleDirent","forSiblingDirent","pathnames","that","thatNativePath","isUNC","baseWithParent","ellipsizePath","baseWithParentNoExt","StatDirent","directoryEntrySync","statSync","childDirectoryEntries","dirents","_directoryEntryChild","resolve_","children_","filterInPlaceAsync","isFile","childDirectories","trapSync","childFilesSync","withFileTypes","hasChildren","actualChildNames","includesAll","hasNoChildren","descendants","someDescendant","depth","descendantsSync","thisDe","visitDescendantsSync","siblingDirectoryEntries","selfAndSiblings","firstExistingSelfOrAncestor","exists","splitNativePath","pathsForDateParsing","pathnamesWithoutDrive","bname","pathDepth","isAncestorOf","maybeDescendant","isDescendantOf","maybeAncestor","parentsAndSelf","parents","selfAndParents","actualPath","withPrefix","withNameSuffix","withSuffix","siblingOf","possibleSibling","isAbsolute","joinYMD","map3","pathElements","trap","methodName","errLogLevel","trapOr","thenDefined","notExists","thenNot","isDeleted","maxDepth","parentIsDeleted","mtimeSec","unixtime","lastModifiedUtc","toUTCString","statTimes","maxStatMs","maxStatDate","minStatMs","minStatDate","size_","isExecutable","isNotReadable","isReadWritable","isNotReadWritable","isReadWriteExecutable","isReadWriteExecutableSync","isReadWriteExecutable_","isReadWriteDirectory","userDesc","maybeReadWriteDirectory","bytesConsideredEmpty","isNonEmpty","isEmptyFile","modifiedGTE","thisMtime","modifiedCloseTo","thisMtimeMs","isRecent","modifiedGT","thenMapOr","isNotDirectory","nearestDir","isFileSync","isDefined","_fse","recursive","maxRetries","retryDelay","rmdirSync","mkdirp","fileSha_","fileShaMeta_","autoInvalidate","readJson_","readFile","readJsonSync","readFileSync_","readFile_","readTextFile_","bufferToString","readTextFile","zReadFile_","zCopyToBuffer_","zcat","readLines","writeText_","txt","writeTextSync_","writeFile_","writeJson","writeFile","replacer","spaces","matchesContent","touch_","ensureFile","utimes","unlink_","unlinkSync","rmrf_","retryOnReject","errorIsRetriable","gunzip","createGunzip","gzip","createGzip","compressBrotli","createBrotliCompress","ensureFile_","ensureFileSync_","ensureFileSync","ensureNewNativePath","ensureNewNativePath_","ensureNew_","ensureNewSync_","ensureNewNativePathSync_","chmod_","chmod","chmodSync","zreadline","createReadStream","pipe","LineReader","siblingWithSameContents","childWithSameContents","targetSize","withSameName","sameSize","isNameHidden","targetSha","firstMatchingLine","newlineRe","contemporary","thenMap2Or","arr1","arr2","watchUntil","persistent","_useFsWatch","interval","sibs","transform","pipeline","autoClose","createWriteStream","attrTTL","ProjectPath","Root","extFilter","extType","respectFileExtensions","isExtType","excludedBasenames","isBrowserExtension","ExtTypes","SupportedByCurrentBrowser","isVideoExtension","Video","isAssetFileExtension","AssetFile","Newline","CACHEDIR_TAG","CACHEDIR_TAG_CONTENT","isCachedirTagFile","readFilePart_","position","dirPath","DefaultMacOSPaths","DefaultPosixPaths","DefaultDockerPaths","DefaultWinPaths","SYSTEMROOT","DefaultPaths","path2stat","subscribe","filterAsync","WipPrefix","statEql","subscription","unsubscribe","isSimpleDirent","Stats","for_","fse","parentAndBase","readdir","visitDescendantFiles","filterDescendantFiles","rmdir_","Done","Undone","DirectoryIterator","rootDir","pathFromRoot","nextTimeout","statTimeoutMs","details","whyExcludedDirectory","isPosixMountpoint","cancel","SyncDirStates","skipped","syncReport","onProgress","SyncFileStates","sidecars","nonSidecars","isSidecarExt","scanning","canceled","untilTs","runMs","Timeout","timeoutCount","failed","startAtNativePath","cmpArr","toAdd","whyReject","whyRejectFileSimple","fileHandler","sidecar","tagAlbumFilenames","note","isSidecarOf","andList","mkFolderUrl","noSeed","with","query","url","scanned","plur","directoryListener","DirectoryWalker","runChunk","IntervalMs","highPriority","doNotRun","cpuBusyPercent","DefaultEnsureNewOptions","emptyIsNew","maxVersions","requireNumber","startIndex","arg","isEmptyFileSync","path2formattedPathForGlobCache","EndWithSepRe","formatPathForGlob","sf","isDir","Glob","pattern","exclude","given","makeRe","nocase","globsCaseInsensitive","dot","posixSlashes","valid","glob","bundle","pairToObject","GlobSet","globs","pushNativePath","HiddenFileGlob","HiddenDirGlob","defaultExcludeGlobs","addIgnorableSubdirs","subdirs","varDirs","clearCaches","excludeGlobs","excludeBundles","clearNotExcludedDirs","notExcludedDirs","watchSettings","excludeGlobsOmitDefaults","excludeGlobsAdd","excludeGlobsOmit","scanPaths","argvScanPaths","defaultDirPredicates","notSymlinkLoop","notInHiddenPhotoStructureDir","notNoMedia","notHidden","defaultFilePredicates","addGlob","omitGlob","ifDisabled","disableAllFilters","ifBlank","notExcludedFilePredicates","whyExcludedFile","SyncPredicates","whyRejected","notExcludedDirPredicates","Predicates","seemsLikeSymlinkLoop","hasNoMedia","isHidden","inHiddenPhotoStructureDir","doNotPassDirs","isCacheableFile","InstanceCacheMaxSize","rootNativePath","staleMs","isPrunable","scheduleInterval","cleanup","minFreshTs","victimDirs","prunedFiles","prunedDirs","isNoMediaName","pruned_file_count","pruned_dir_count","ShortExtRe","normalizeExt","Dirent","JpegExts","isExt","exts","SidecarFiletypes","SidecarExts","extAliases","regexCache","BadMimes","fromBuffer","mime","normalizeMimetype","readRawField","mimetypeExt","defaultFsAdvisoryLockDir","lockNames","lockDir","locks","lockName","FsLock","shortFsStringSha","lock","acquire_","LastNumberRe","PsLockExt","newUid","pidFromLockfile","lockfile","pidFromBasename","postdb","tryAcquire_","lockdir","fsLockFileBasename","startRefreshTimer_","fsLockDir","randomFloat","acquired","selfAndSiblingNames_","siblingNames","iAmLast_","iAmOnly_","lockfileRefreshMs","stopRefreshTimer","releaseOnFailure","dirty","skipFsLock","survivors","names","staleAt","childMtimeMs","internalErrors","ownerPid","lockfiles","success","basenameIsPsLockFileOrDir","ensurePrefixSuffix","DefaultWatchedStatFields","WatchMgr","path2watcher","id2watchers","vacuumEnded","registeredPaths","watchedPaths","oldPaths","unwatchedPaths","np","maybeWatch","watchersForPath","or","fsw","registerWatcher","debouncedCheck","FsWatcher","maxPollIntervalMs","applyOnChangeAtSetupIfExists","debounce","check","watchDebounceMs","partialStatPrior","statNow","applyOnChangeIfTargetMissing","partialStatNow","changed","newMaxPollIntervalMs","debounceMs","forcedCheck","CopiesRe","Copies2Re","_stripCopySuffixFromName","initialName","ymdIsoRE","strippedName","strip","stripped","burstRe","coverRe","dscPrefixRe","GrepReader","Transform","objectMode","autoDestroy","_transform","chunk","_encoding","output","WritableToBuffer","out","actualExt","expectedExt","matcherForExtOrCompressedExt","extMatchers","fileStats_","shimmedFileSha_","uncachedFileSha_","streamSha_","transforms","hashAlgorithm","pwshQuote","Mode","isHiddenWin","isHiddenMac","DevMounts","MacSystemVolumes","MacPrivate","MacOsInstall","MacNotDmg","isPhotoStructureDmg","whyIgnorableMountpoint","isExcludedMountpoint","mkObject","onWrite","read_","write_","_flush","ap","nomediaRe","NoMedia","variants","NoMediaNames","noMediaDirsCache","Halt","cached","readdirCached","someIsNoMedia","_dirHasNoMediaChild","_readdirHasNoMediaChild","dirHasNoMediaChild","isCachedirTagDirectory","someSelfOrAncestor","driveRe","drive","upcaseDriveLetters","posix2native","fileish","pathlike1","pathlike2","CompressedExtRE","spliceCapture","splitLast","filePaths","lhs","rhs","basename_","srcNativePath","destNativePath","move","overwrite","mountpoints","MinBinarySize","KiB","isRXFile","fallbackPathDirectories","systemRoot","systemDrive","pathDirectories","PATH","tool","alternativePath","fsutil","nslookupWin","pingWin","arpWin","contextFilter","sortFiles","_idx","NoOp","pflog","uriObject_","nativePath2uri","fileuri","normalizedPathUri_","etag","isMountpoint","existingSidecars","unlock","forUri","bestMountpoint","isDeletedUri","_uri","notBlankOr","toURI","isRootPath","pathBase","expectedBase","uriBase","schemeDiscount","httpHeaders","ETag","hide","hide_","mkNoMedia","hasNoMediaRecursive","isSidecar","existingExifSidecars","defaultSidecarExt","defaultSidecar","jsonSidecars","thisOrSidecareMaxMtimeMs","writeStream_","readable","ByteCounter","destroy","skipWip","initiallyNotEmpty","applyWip_","wipIsRecent","WipTimeoutMs","unwipBase","mv_","destFileOrDir","onlyNativeFileCopy","maybeVerifySameOrThrow_","verifyFileCopies","zCopyFile_","zpipe_","copyTimeoutMs","MinIoRate","destOrDestDir","destOrDir","renameYMDHMS_","fmtYMDHMS","subdir","renameWithNameSuffix_","nameSuffix","saveIfNewOrDelete","move_","equalsUri_","uriIsEquivalent","obs","copyDest","copyFile","COPYFILE_FICLONE","PullProgressObserver","approximates","expectedSize","actualSize","btimeMs","birthtimeMs","wipDest","reference","mkTagFilter","readRawTags","notDimensionsTooSmall","minVideoDimension","minImageDimension","readMimeType","extractSizeInfoFromFile","ImageWidth","ImageHeight","notVideoTooShort","minVideoDurationSec","extractDurationSec","notVideoTooLong","maxVideoDurationSec","notMissingMimeType","notRejectedRating","rejectRatingsLessThan","Rating","notExcludedKeyword","keywordBlocklist","rawTagKeywords","leafIsExcluded","notMissingMakeAndModelTags","requireMakeModel","MIMEType","notFileMissing","isBaseFile","notFileTooSmall","minAssetFileSizeBytes","notFileTooBig","maxAssetFileSizeBytes","simpleFileFiltersFor","isSupportedFileExtension","expensiveFileFiltersFor","supportedMimeType","isAssetFileMimeType","whyRejectFile","whyExcludedDirectoryRecursive","requiredExifTags","allNotBlank","hasBrowserImgMimeType","accepted","isExcludedDirectory","hostname","posix","execDir","projectDirs","uniqInPlace","npx","Bin","Data","ICC","Migrations","Public","Tools","Views","isInDMG","projectPathRoot","fs","bufLen","open","ReadableBuffer","Readable","ReadDirCacheName","readdirCacheDir","clearReaddirCaches","path2cache","clearCachedReaddir","readdirUncached_","quickResult","fsCacheSlowMs","readdirSizeCacheThresh","slowDirs","toNotTimeout","thenOrTimeoutAt","_readdir_","readdirCacheMs","maxDuplicatePathElements","winDriveRE","firstSelfOrAncestor","statToType","statFieldToComparable","whyStatNotEql","aType","bType","aVal","bVal","isEmptyStats","minFileSize","throwIfNoEntry","nativePathExistsSync","Chunker","filterBlanks","incompleteChunk","onChunk","destroyed","writableEnded","writableFinished","PassthroughStream","Duplex","_write","closable","remoteFamily","remoteAddress","remotePort","AssetFileSyncStates","FileDoneStates","FileStateDescriptions","enqueued","started","noop","deleted","synced","copied","unknown","DirStateDescriptions","recordToBullets","WarnStates","syncReportDir","syncReportReadme","SyncReportHeaders","ensureSyncReportReadme","min_mtime","isCsvExt","SyncReport","outputFiles","outputNativePath","rowCount","rowObj","unparse","syncReportMaxRows","wrap_","filestamp","mkSyncReportPath","DefaultOptions","skipEmptyLines","content","readLines_","EnqueueStream","settled","fileDoneStates","syncReportJsons","acceptPath","NODE_STREAM_INPUT","toolsDir","pathToTool_","firstDefinedLater","pathIfExists","platformName","devPathToTool","systemPathToTool","dcrawEmuNativePath_","rawIdentifyNativePath_","jpegtranNativePath_","toMs","rStat","atimeMs","retainFileBirthtimes","atime","btime","mkuid","safeRandomUid","UIDStore","JsonFileStore","createdAt","SystemUIDStore","LibraryUIDStore","fsp","trashOrUnlinkNativePath_","nativePathIsFile","unlinked","trySoftDeletes","mapAsyncSerial","Writable","deferred","_buf","writeFileSync_","writeFileSync","zcat_","outputStream","createBrotliDecompress","readJsonGz_","outputJsonGz_","exiftoolHealthCheck","HealthCheck","section","pendingMsg","ev","exiftoolVersion_","tt","exiftool","exiftoolPath","exiftoolVersion","externalDirsHealthCheck","rejectIsWarn","getHomeFolder","getPicturesFolder","getVideosFolder","getDesktopFolder","defaultApplePhotosLibrary","valueCount","li","sortByCaseInsensitive","tuples","HealthCheckLevelToLogLevel","ok","disabled","HealthCheckLevelOrder","summaryForLevel","buttons","restartResetOrShutdownButtons","links","DockerVolumeLink","method","icon","WhatIsALibraryLink","UnreachableCaseError","traceLater_","onResultChange","priorRunStates","allCritical","addError","addLoadingMsg","normalizeMsg","unseenOrOldestPendingTrace","shownCounts","findById","loadingMsg","runState","summary","enableAll","disableAll","skipHealthCheckIds","HealthCheckIds","testResults","testResultsCritical","errorResults","notOkResults","levelIsNotOK","summaryFromResults","allResults","expectedChecks","rerunSetup","ordinal","okLinks","warnLinks","noLibraryLinks","errorLinks","onReset","HealthCheckSections","toResultSyncMaybe","settledAtLeastOnce","isSkipped","toLevelSync","toResultSync","resultOrTimeout","thenOrTimeoutAs","partitionLinks","pendingIds","pendingCount","BaseHealthCheckSummary","HealthCheckLevels","RunStates","hcWithLevel","hcNotOK","linkIds","checks","fmtDateShort","resetDebounced","testHealthCheck","PS_TEST_HEALTH_CHECK_LEVEL","healthCheckSetup","heifHealthCheck","libraryDirectoriesCheck","libraryFreeSpaceCheck","settingsEnvHealthCheck","settingsSystemHealthCheck","settingsLibraryHealthCheck","memoryHealthCheck","nodejsHealthCheck","notInDMGHealthCheck","osHealthCheck","powershellHealthCheck","securityHealthCheck","sqliteHealthCheck","systemLoadHealthCheck","videoHealthCheck","volumeHealthCheck","versionHealthCheck","lastLibraryHasSettings","libraryHasSettings","newValue","td","getHeifSupportDetails","isSupportedVersion","verifyLibraryDirs_","setupLibraryDirs_","testDockerLibraryDir","toEnvLine","testLibraryDir","minDiskFreeGb","toCheck","vol","bestVolumeForPath","minFreeBytes","GB","descriptions","fmtBytes","available","setting","asTest","thresholdBytes","memoryUsageTest","totalmem","memoryUsageMb","memoryUsageIsHigh","checkboxLabel","checkPowerShell_","PUID","PS_FAIL_SECURITY_HEALTH_CHECK","_envValue","sensitive","toEnvValue","warnings","verifyPsEnvSettings","validateSettingsToml","flavor","importFileSettings_","busyPct","CpuUsage","tooBusy","isTooBusy","checkVersion_","getVideoToolDetails_","vols","volumes","localVolumes","getLocalVolumesWin_","dfPosixRawLocal_","fmtAgo","notOk","remote","badShaCache","fp","isBadSha","_sha","AssetPreviewBuilder","assetFiles","assetId","forceContextOrSetting","ctor","build_","getAssetFileNativePath","_build","infoForBest_","throwIfInvalidFile_","filesize","fits","fitSizes","assetFileId","uris","sqWidths","ImageSize","sq","outputSize","fitWidths","priorIfValid_","forceSync","forceRebuildPreviews","readInfo","priorFits","currFits","equivalentFitSizes","leftovers","fitname","fitsize","victim","fileForWidth","reducer","writeInfo","srcFile","PushProgressObserver","fit","priorExistingFiles","existingFiles","origSharpReadable","sharpReadable_","minDim","largestFit","origSharp","toSharp","isHeifMimeType","rotate","previewTagFiles","sqDim","sqSharp","lsq","largestSq","bestFitNameForSq","megapixels","origDim","fitSharp","clone","fitDim","inputDim","resize","dmegapixels","Fit","includePreviewTags","toJpeg","sh","fmtDim","positioned","squareThumbStrategy","includePreviewTags_","unwipped","epilog","mkDownloadableTitle","imageOrVideo","previewsRoot","ReducerNames","getCI","pi","map2","dimToSize","extname","href","assetImgLink","infoJson","id2id","paddedId","assetPath","splitEvery","parentNotExists","existingJpgs","previewInfos","sortByAsync","fileForSuffix","mp4","filesForReducer","smallestFileForReducer","extractPreviewInfo","largestFileForReducer","widths","posterLink","imgAttrs","lazyLoad","assetImgAttrs","assetSqImgAttrs","CropStrategies","SAMPLE_SIZE","SQRT","initSQRT","COS","cosines","initCOS","dctPixels","pixels","dct","matrix","N","F","u","applyDCT","totalSum","img","greyscale","toBuffer","rgb2labArray","aspectRatio","roundAspectRatio","rotateDimensions","Megapixels","aspect_ratio","widthF","targetRatio","Rotations","isSharp","metadata","FitAlways","QVGA","QQVGA","old2new","sizes","smallestDim","isMimeTypeSupportedByBrowser","oldArr","newArr","extractHeifConvertVersion","helptext","isHeifSupported","sipsPath","heifConvertPath","hasApt","pkgs","aptInstalledVersion","pkg","sips2jpeg_","heif2png_","isHeifConvertSupported","withImageCache_","_heif2png_","HeifMimeTypeRE","ImageCacheName","watchCacheDir","cachedImageFile_","ciSafePath","imgCacheSubdir","tag","bits","_imageHash_","sizeInfo","fitToResolution","dominantColorPixels","s1dims","jpeg","toFile","removeAlpha","background","outside","withoutEnlargement","rgbInfo","resolveWithObject","channels","labTriplets","rgb2labTriplets","dc","extractDominantColors","isGreyscale","labsAreGreyscale","meanDiff","meanDiffHash","meanDiffHashCIELAB","phashBits","dctHash","dctHashCIELAB","meanHash","b64encodeBits","diffHash","dominantColorsDescription","__imageHash_","isImageHash","isModeData","omitModeData","HashDim","imageCorr","colorCorr","aRotation","diffs","diffCIECorr","closestLab","GreyscaleRE","isGreyscaleMeanHash","splitbits","b64","b64decode","dim2","hammRatio","bRotation","m_a","m_b","hammRatioIntArrays","rotateSquareMatrix","isSimilarImage","imageHash","a_","b_","forceColor","forceGreyscale","meanHashCorr","diffHashCorr","dctHashCorr","dominantColorCorrelation","mimeMatches","aAspectRatio","bAspectRatio","maybeDimSwap","aspectRatioMismatches","isCloseAspectRatio","imageCoeffDelta","colorCoeffDelta","imageHashFuzzyDateDelta","imageHashDifferentMimetypesDelta","imageHashGreyscaleDelta","minImageCorr","clamp01","minImageCoeffPct","minColorCorr","minColorCoeffPct","fmtAspectRatio","failingImageHashes","hashAvg","onlyMeanHash","colorPass","hashCorrAvg","pickCompact","isVerySimilarComparison","deg","b64encode","Square","previewResolutions","maxWidth","maxHeight","rotational","maxDim","maxMP","maxPixels","minDimension","inputSize","isPortrait","dimSwap","previewSharpen","sharpen","sharpRenderOptions","UHD8k","UHD5k","UHD","QHD","FHD","HD","WVGA","S480","S240","S120","S60","includedPreviewTags","writeTags","ca","assignFields","asExifTag","FocalLength","focalLength","FNumber","aperture","ExposureTime","shutterSpeed","ISO","Source","overwriteTags_","mhash","dhash","hashSize","_prepFileForBrowser","readFileType_","userAgent","sr","prepFileForBrowser","Previews","apb","AssetPreviews","buildAssetPreviews_","roundToNearestRatio","ratioOrDimension","RatioEpsilon","mapGt0f","ratio","StandardAspectRatios","similarRatios","absdiff","nearestAspectRatio","Ratios","rawInfo_","parseRawInfoOutput_","Filename","SharpFits","lteBoth","cover","ltBoth","fitInside","Reducers","sharpFromRawBuffer","quality","previewQuality","progressive","previewProgressive","mozjpeg","previewMinimized","SharpFailOns","setupSharp","simd","enableSIMD","enableVipsCache","concurrency","sharpThreadsPerProcess","_imgFromExif_","useBuffer","extractBinaryTagToBuffer","extractImageForThumbs_","imgFromExif_","tags","fileAspectRatio","maxEmbeddedBuffer","failOn","imageFailOn","renderedAspectRatio","sharp","tmpImageFile_","extractBinaryTag","skipEmbedded","addParameterContext","mt","_strategies","addStrategy","rot","isVideo","isRaw","isLibrawMimeType","sid","map2Gt0","fileDimensions","isFilePortrait","isSharpMimeAndNoMinDim","isSharpMimeType","isMirrorOrientation","orientationRequiresMirroring","orientation","includeSidecars","tagsToExtract","embeddedPreviews","embeddedThumbnails","minBytes","sizeSortedTagNames","heif2img","raw2tiff_","isVideoSupported","extractVideoFrame_","_sharpReadable_","MinSyncFileTimeoutMs","BytesPerSecond","ImagePoints","p0","p1","RawPoints","syncFileTimeoutForFile","isVideoExt","readMeta","syncFileTimeout","dbMs","tagMs","copyMs","lerpPoints","thumbMs","rawDecodeMs","isRawImageExt","fileOrPath","whyInvalidFile","validateJpegImages","validateRawImages","validateVideos","validVideo_","validJpeg_","validateMimetypeSkiplist","failOnError","toSharpFailOnError","tiff","validationErrorAllowlist","validationErrorBlocklist","mkLog","ignoreffmpeg","ffmpegVersion_","extractMaxBitrate","rawTags","bitrateKbps","extractBitrateKbps","transcodeBitrateUHD","videoBitrateKbps","bitrateKps","transcodeBitrateQVGA","_extractVideoFrame_","__extractVideoFrame_","forceImpl","useFfmpeg","isFFmpegSupported","srcMtime","extractRotation","srcDim","extractSizeInfoFromTags","destStat","destDim","startAtSec","videoFrameAtSec","destWip","ffmpegFrame_","deleteAllTags_","isVideoTranscodingSupported","transcodeVideos","needsTranscoding","audioCodecs","AudioFormat","isSafeAudioCodec","doNotTranscodeAudioCodecs","videoCodecs","VideoCodec","CompressorID","CompressorName","isSafeVideoCodec","doNotTranscodeVideoCodecs","isSafeMimeType","doNotTranscodeMimeTypes","currentTranscodes","guessExpectedSize","durationSec","priorSrc","srcTags","destRawTags","srcRawTags","srcDurationSec","destDurationSec","isTranscodeOf","expectedFilesize","transcodeMaxDim","srcMaxDim","roundEven","original","ffmpegTranscode_","_transcode_","ffmpegValidVideo_","versionRe","_ffmpegVersion_","ffmpegVersionDescription","hwaccel","ffmpegHwaccel","isDisabled","avcArgs","ffmpegAvcTranscodeArgs","ffmpegScaleType","vfIdx","videoBitrateArgs","framerateArgs","transcodeFrameRate","mapGte0f","toFixed","isIgnorableValidationError","ffmpegThreads","devnull","rotate_","degrees","isRotation","readableToFile_","dcraw_emu_","TiffOutput","WriteToStdout","Colorspace","IgnoreOrientation","maybeHalfSize","dcrawEmuArgs","expectedElapsedMs","dcrawTimeout","rolazy","fsl_","cuid","uids","sids","body","coupon","req","response","request","writeLicense","brotliDecompressSync","email","_l","_sids","matchedUids","matchedSchemeIds","getScheme","matchedSchemes","prefix2scheme","uidsOK","mat","dateOK","cmpVal","S","v_","V","utcIsoToTs","toGte0","L","rawFromDir","UserTimeoutMs","ud","someOrTimeout","rawLicenseFromSettings","isValidUid","GenericUUIDs","UidLength","pfx","uidRE","schemeCounts","addUids","fileGrep_","cpuinfoSerial","toUID","oemRe","readFiles","linuxMachineUid","lm","linuxProductUid","lp","linuxBoardSerial","lb","macUids","ia","mp","mac_IOPlatformUUID_","win_machineGuid_","MachineGuid","winMachineUid","wm","cpuModel","cm","boardModel","bm","systemUid","si","networkMacUids","networkMacAddresses","nm","volumeIds","vl","uuid","priorSids","sidFuncs","sortUids","licensesInDirectory","vok","saveIfBetter","pl","recentLogFiles","maxEntriesPerLevel","writeRecentLogEntries","entriesByLevel","BoundedGreatestSet","logEntrySorter","oldestTs","withBoundedConcurrency","lr","LogReader","hasErrors","le","procColors","colorProcessName","_inspectOptions","logLevels","inspectOptions","showHidden","customInspect","maxArrayLength","logContextLimit","breakLength","defaultProcessName","formatMeta","prepMeta","formatLogEntry","contextColor","logFilter","highlight","enabled","pushLogEntries","flush","loggers","addContext","param","throwIfAborted","msTolevel","tapAsync","errorLevel","errorMsg","LogWriter","DefaultLogFormatter","PlaintextLogFormatter","defaultFrom","_service","_pid","extractFrom","pidStr","logEntry","level2syslog","host","short_message","full_message","errorToVerbose","mkConsoleLogger","nul","logBroadcaster","server","portStr","logServer","port","parseLogServerSetting","LogBroadcaster","socket","logFormatter","GelfLogFormatter","LogFilterImpl","logServerLevel","createConnection","DefaultLogFlushMs","fmtIsoDate","LogDirCleanup","isBillingService","FileCleanup","sortByInPlace","SimpleLogFilter","minLogLevel","silent","defaultLevelIndex","levelIndex","LogLevelRe","contexts","contextOverride","co","TraceLevelIndex","LogLevel2SyslogLevel","errorMs","PromisePlaceholder","levels","limit","meth","isPromiseLike","mapNullEntries","omittedKeys","errorHandler","fileStream","isExtOrCompressedExt","peek","chunkToLogEntry","LowWatermark","DefaultLogEntryWriter","consoleLog","LogTail","writer","filenameMutexes","file2pos","lastReadFiles","readSystemSettings","logdir","scan","ignorableFilename","setLogTailEnabled","flushTimeout","scanTimeout","popExpiredLogEntries","watchDir","ifLog","watchListener","consoleError","firstTime","nowish","currentLogDir","datedLogDir","currentSize","priorSize","readLogEntries","_logTailEnabled","logEntries","flushEveryMs","pendingWrites","_linesSinceRotate","_nextForcedRotateTs","nextMidnightTs","_startIndex","logOpts","maxLinesPerFile","errorLogger","recentLogEntries","clearRecentLogEntries","shouldRotate","_logfile","toFlush","remainingCapacity","logCompression","gzip_","paddedLogLevels","rightPad","isLogEntry","SentLogLevels","recentLogEntriesByLevel","bl","setupLogFormatter","fl","currentFileLogger","logStdout","tailLogs","setColorEnabled","currentIsColored","ColoredLogFormatter","settingIsColored","vec","pushAll","maxSamples","samples","_n","_min","_max","_m","_s","_samples","_weightedTotalAvg","priorM","sigfigs","empty","mean","sd","p16","p29","p38","p99","variance","sampleMode","sampleModes","sampleVariance","sampleStdDev","sampleAvg","sampleSlope","slope","weightedTotalAvg","sigmasFromMean","mu","sigma","splitBits","ea1","dims","clampValue","randomValue","bit","dimIndex","dIdx","isBitSet","BitShiftMax","disableBitshifting","bitsSetBig","setBits","remainingMs","fmtEstimate","eta","plural","singular","ml_kmeans","lerp","v0","v1","nearest2","dx","submatrixForEach","rowFrom","rowTo","colFrom","colTo","submatrixMagnitude","submatrixStdDev","submatrixMode","vector","rowIdx","colIdx","quarterMagnitudes","fromDim","toDim","colDelta","rowDelta","rowStart","colStart","prng","factors","y1","y2","primeSeeds","encodeDigits","PrimesPerBin","PrimeBins","primes","idColumn","primeInt","memoize","SeedCount","numericSha","zero","Radix","numerals","decodePreparser","digitsToNumerals","num","negate","encodeBigInt","bi","decodeBigInt","MAX_SAFE_INTEGER","ch","tokenEql","normalizeToken","Hex","Base64","AlphaRadix","NumericRadix","eventsPerSecond","RomanNumerals","normalizeRotation","SquareMatrix","ary","index_a","index_b","transpose","reverseRows","reverseCols","UUIDRegExp","modes","topN","Mean","l2norm","strength","normMin","normMax","xMin","xRange","normRange","x_mean","y_mean","denom","carryForward","vectors","finiteOrElse","hex","base64","gunzipSync","gzipSync","gz64decodeString","hammRatioBigInt","_hostname","dataChunks","setEncoding","statusCode","statusMessage","myExternalIpAddresses","myIpAddresses","isLoopback","networkInterfaces","address","mac","loopbackPatterns","parseQuad","octetRE","ipv4Re","friendlyname","memoizeAsync","ipOrName","nslookup","loopbackRE","octets","nameOrIp","resolve4","firstNonBlank","aAddrs","bAddrs","ping","ipAddrFromPing","DebPackageNameRe","dpkgSearch","aptCachePolicyVersion","semver","packageName","__filename","_platform","inspectFlag","NODE_INSPECT","isCI","isWinPortable","PORTABLE_EXECUTABLE_DIR","isLinux_x64","isArm","isLinux_arm","isLinuxAppImage","APPIMAGE","APPDIR","isLinuxSnap","SNAP_USER_DATA","containsRpiModel","cpuinfoPath","isRaspberryPi","procDeviceModel","camel2words","_logger","predicates","explain","notApplicable","negateFilterName","firstFalse","logged","firstTrue","firstDefined","DefaultThrottleMs","recentProgress","recentDone","isProgressEvt","onProgressEvt","throttleMs","onInterval","completed","emitProgressEvt","incrProgress","incremental","ConvertToCompressedJson","clearMockResults","ensureInstance","bco","mockResults","BatchCluster","processFactory","powerShellArgs","versionCommand","powerShellCulture","pass","fail","powerShellProcs","taskTimeoutMillis","setMaxProcs","pwsh","versionPojo","Major","Minor","Build","spawnedProcCount","pushMockJsonResult","pushMockResult","passed","thenElapsed","enqueueTask","Task","fixed","which","AssetFileSortCriteria","BooleanSetting","Setting","toEnv","notBlankToS","BoundedFloatSetting","addToJSON","BoundedIntegerSetting","ColorDistanceFunctions","DominantColorKmeansRunsDefault","DominantColorPixelsDefault","DurationSetting","encodeDuration","userValue","humanValue","fileValue","OptionalDurationSetting","FloatSetting","ForceContextKeys","IntegerSetting","mergeAndArchiveSystemSettingsDir_","priorConfigDir_","currentConfigDir_","priorResolvedConfigDir","currentResolvedConfigDir","SettingsToml","settingsToObj","persistedSystemSettings","srcDir","cfgDir","getSettingValue","setStrictDeduping","strictDeduping","minExposureSettingsCoeffPct","allowFilesystemSleep","imported","setQuickSyncMode","quickSyncMode","disableExternalNetworkRequests","scanMyPictures","newPath","priorValues","assetSubdirectoryDatestampFormat","assetPathnameFormat","syncIntervalHours","syncNewIntervalMs","syncChangedIntervalMs","dbBackupIntervalMinutes","dbBackupIntervalMs","enableSiblingInference","siblingInference","TagInferenceSettingValues","never","quickSyncSettings","argonDefaults","argon2TimeCost","argon2MemoryCostMB","argon2Parallelism","argonQuick","quick","tmpValueIfUnset","tmpValue","argon","autoUpdateCheck","allowUserAgent","reportErrors","MinValidYear","OptionalFileSetting","OptionalStringSetting","OptionalFloatSetting","OptionalIntegerSetting","esc","replaceAll","withZone","grandParentBasename","readFromEnv","optsOverrides","getState","user","_userValue","_fileValue","_tmpValue","dump","isUnset","setState","normalizeValue","shallowClone","maybeBroadcastChange","valueOrThrow","civ","setFromEnv","environment","setValueIfDefined","unWatch","mutateFunc","_names","_setName","aliases","_key","envFromName","_keys","envAliases","altKeys","category","categoryType","LibraryCategories","transient","advanced","envValueOrDefault","resetDefaultValue","exampleValue","overrideValue","cie","toCommentedLines","deprecated","WrapComments","maybeAddList","pluralize","orList","toTomlLines","wrapTomlToLines","prepend","SettingCategories","Auth","Color","Db","Deduping","Events","Filters","HealthChecks","Parsing","Privacy","Reporting","Sidecars","Subscriptions","Sync","Tagging","Updates","Volumes","Web","SystemCategories","exposeNetworkWithoutAuth","DefaultMaxEmbeddedBuffer","Paths","copyAssetsToLibrary","StringSetting","scanAllDrives","StringArraySetting","pidFile","Cache","imageCacheMs","Logging","logWebRequests","logWebDir","useFsWatch","Filesystem","excludedFilesystemTypes","DefaultExcludedFilesystemTypes","excludedRootDirectories","DefaultExcludedLinuxRoots","excludedMountpointPaths","DefaultExcludedLinuxMountpointPaths","excludedMountpointBasenames","validateMountpoints","mountpointsTtlMs","remoteFilesystemTypes","volumeUuidFilePaths","readVolumeUuidFiles","writeVolumeUuidFiles","writeVolumeUuidMountpointBlocklist","volumeMetadataTtlMs","Networking","localhost","trustProxy","Security","cspReportOnly","upgradeInsecureRequests","cspDirective","disabledHelmetMiddleware","StringEnumsSetting","HelmetPlugins","Processes","BatchClusterOptions","minDelayBetweenRetriesMs","exiftoolProcsPerChild","timeoutThrottleCoeff","maxConcurrentImports","maxConcurrentImportsWhenRemote","StringEnumSetting","enableArchive","enableDelete","enableEmptyTrash","enableRemove","enableRemoveAssets","dbRetries","dbBackupRetentionCount","INCREMENTAL","dbWalCheckpointType","TRUNCATE","dbInvalidFKThreshold","NORMAL","dbRepairMode","dbBatchSelectSize","dbBatchUpsertSize","dbForceRecover","dbBackupRemoteOnSuspend","ffmpegScaleTypes","transcodeTimeoutBps","showFileInFolderUsesThunar","showFileInFolderUsesFileUri","showFileInFolderCommand","dcraw_emuPath","toolPaths","autoHideMenuBar","Desktops","hideOnLaunch","pauseSyncOnBattery","updateChannel","channel","UpdateChannels","optOut","minStreamCorrPct","lazyLoadExtraVh","hiddenHomeTags","openGraphTargetWidth","placeholderThumbs","fastForwardEmptyTags","defaultHomepagePath","scanLibraryFirst","scanLibraryLast","progressRetentionDays","progressStaleDays","copyToLibraryMimeTypes","writeSourceTagToLibraryCopies","startPaused","retryEnqueued","forceRebuildLibrary","dropWorkQueues","noModelUpdates","exitWhenDone","overwriteOriginal","noAssetFileUpdates","noAssetUpdates","resyncAssetOnVisit","cpuCount","excludeNoMediaAssetsOnRebuild","matchSidecarsCaseInsensitively","matchSidecarsFuzzily","defaultSidecarType","writeMetadataToSidecarsIfImage","sidecarTagBlocklist","writeMetadataToSidecarsIfVideo","writeMetadataToSidecarsIfSidecarExists","checkBasenameMatches","maxContemporaryAdoptionAssets","minCapturedAtPrecisionDifferentMimetypes","minCapturedAtPrecisionStat","fuzzyDatePrecisionCoeff","iccProfileMappings","attention","FitSizes","skipPreviews","DefaultIncludedPreviewTags","truncated","capturedAtTags","DefaultCapturedAtTagsConst","useMWG","capturedAtTagsFallback","ProblematicCapturedAtTags","defaultVideosToUTC","defaultCopyright","likeRating","lensMakes","DefaultLensMakes","useStatToInferDates","useLibraryDirsToInferDates","backfillTimezones","inferTimezoneFromDatestamps","auto","siblingInferenceBasenameCoeff","writeInferredTagsToLibraryCopies","recountAllTags","tagCamera","tagLens","tagFullLensModel","tagYMD","DateTagFormats","ym","tagDateFromStat","tagKeywordsFromPath","tagKeywordsFromMetadata","keywordTags","keywordReparenting","KeywordReparentingStrategies","rootTagAlbumsAliases","rootTagKeywordsAliases","rootTagWhoAliases","keywordDelimiters","keywordPathSeparators","tagFileType","tagJsonFaces","tagFaceRegions","whoTags","tagNamesFormatter","NameTagFormats","tagNamesDefaultFamily","tagNamesCapitalizedAsFamily","tagNamesOrder","NameTagOrders","tagNamesSurnamePrefixes","tagNamesSurnames","tagNamesGiven","tagNamesFamilySurrounds","tagNamesGivenSurrounds","tagNamesLexical","excludedRootTags","tagDisplayNameFS","tagDisplayNameFSRoot","tagDisplayNameFSRootWithHostname","tagDisplayNameFSLabels","tagAlbumTitle","tagAlbumTitleHierarchies","tagAlbumDescription","tagAlbumDate","tagAlbumsExcluded","omitAncestorTags","subscriptionTimeoutMs","pickPlanOnWelcome","autoRefreshLicense","license","withDefaultPaths","settingsSorter","SuggestedDirsEnvKey","persistedLibrarySettings","SettingsByNameOrKey","ciSettings","DefaultSharedStateDir","defaultLibraryDir","defaultOriginalsDir","settingsFile","_readSettings","savedLibraryDir","readTomlFile_","systemSettingsVersion","readSettingsVersion","librarySettingsVersion","onSettingsChange","_libraryHasSettings","lsf","readSettings","readLibrarySettings","VersionRE","writeToml_","wrapComments","versionForSettings","priorCat","cat","trimRight","_writeToml_","nonDefaults","st","tomlMap","toNotEmpty","handleMetaSettings","handleDeprecatedSettings","UnclearableSettings","clearSettings","baseVersion","extra","extraLines","valueToS","_join","splitStringArray","compactBlankish","_split","toValidValue","toValidValues","dv","parseStringEnum","trimQuotes","parseTomlBuffer","stringifyToml","kvToToml","parseBitrateKbps","pat","fac","stripCounts","trimLeftPadding","capturedAtSrcFromTags","capturedAtSrcFromStat","capturedAtLocal","capturedAtOffset","capturedAtSrc","datedToOffsetMinutes","spread","toExifString","exifOffsetMinutes","isFromTags","isInferred","localIsFuzzy","fmtMs","hasTz","isUTC","hasMillis","offsetMinutesToZoneName","OffsetTime","SubSecDateTimeOriginal","DateTimeOriginal","fuzzyPrecisionMs","localBoundaries","datedToStartDateTime","minus","extMimetype","capturedAtFromTags","_capturedAtFromTags","OverrideUTCZoneTags","skipInference","uniqPath","skipPathInference","cannotUseDateFromPath","inferred","extractStatBname","extractStatPathTime","inferCapturedAtFromSiblings","capturedAtFromBasename","capturedAtFromPath","capturedAtFromStat","tzSource","localSec","least","overlapsWithLeast","earliest","IgnoredCapturedAtTags","MediaDuration","TrackDuration","toGt0f","pathOrFile","_addInstanceIdsToTags","shutdownExiftool","_exiftool","ExifTool","batchClusterOptions","et","gracefully","tagname","tagsCache","rawTagsCache","mimetypeCache","readSidecarTags","IgnoredSidecarFields","_readTags","moveOriginal","writeTagArgs","writeTagDest","tagName","srcMimeType","isImageMimeType","useSidecar","fileTags","_readRawTags","pickedFileTags","file2tags","readJsonSidecar","histories","sidecarTags","safeTags","assignNullishFields","getInferredHistoricValues","pickedResult","parseTags","fuzzy","skipSiblingInference","canInferForDir","tzMeta","maybeInferTimezone","assignUndefinedFields","extractMakeAndModel","inferMakeAndModel","isExifUnset","Copyright","lensMakeModel","extractLensMakeModel","extractCapturedAt","extractExposureSettings","extractTitleDescription","cameraIdFromTags","imageIdFromTags","lensIdFromLensInfo","extractRating","__parsedBy__","definedValues","_parseTags","IgnoredTypedFields","FileFormat","FileIndex","FileName","FileNumber","FileNumberMemory","FileNumberSequence","FileSize","FileType","FileTypeExtension","FileVersion","SourceFile","ExifToolVersion","RAFVersion","Directory","ExifByteOrder","FileAccessDate","FileCreateDate","FileIndex2","FileInfoVersion","FileInodeChangeDate","FileModifyDate","FilePermissions","eqlAsync","readRaw","pluckCaseInsensitive","path2entries","tagEntries","pickedTags","problems","Warning","safeUUID","ImageNumberSynonyms","CameraSerialNumberSynonyms","TagSynonymGroups","stringifyExifUid","normalizeString","renderExifUidId","uniqSynonymValues","blankish","zeroesRe","group","Tag2SynonymGroup","splitToEntry","keyColonValue","decodeExifUid","compactBlankValues","whyDefinedNotApproximate","minCoeff","lensMake","lensInfo","mli","Tag2Synonyms","aObj","bObj","commonSimpleFields","bValue","bKey","aPick","bPick","aValues","bValues","includesAny","firstDefinedThunk","extractFraction","NotSetRe","firstNonZero","ISOSpeed","SonyISO","Fnumber","ApertureValue","Aperture","SonyFNumber","ShutterSpeed","ShutterSpeedValue","SonyExposureTime","reqValuedOrElse","BrowserFiletypes","SharpImageFiletypes","HeifFiletypes","RawImageFiletypes","VideoFiletypes","AllFiletypes","AssetFiletypes","ExifFiletypes","Ext2mime","ExtAliases","getExtAliases","AllFileExts","AssetFileExts","OldBrowserMimetypes","CurrentBrowserMimetypes","ext2types","Sharp","HEIF","RawImage","Sidecar","Exif","SupportedByOldBrowser","extTypes","ext1","ext2","mkHistoryRecords","action","mkHistoryRecord","Action","Changed","Parameters","When","SoftwareAgent","Actions","InferAction","tagsContainHistory","History","valueFromResourceEvent","inferredToTags","isFirstCharAZ","Title","Description","luxonTzOffsetToOffsetMinutes","ensureHistoryRecords","historyRecords","additionalTags","sidecarPath","newHistoryRecords","hr","infer","tagsToWrite","sidecarFile","history","oldestFirst","_maybeInferTimezone","zoneFromLatLon","eqlSubset","inferTzOffsetMinutesFromFilename","nearestSiblingTzOffset","basenameDT","parseDateTime","toDated","rawTzoffsetMinutes","normalizedOffsetMinutes","parseTimestamp","geoData","geoDataExif","GPSAltitude","altitude","alt","favorited","peopleNames","people","person","creationTime","modificationTime","photoTakenTime","imageViews","googlePhotosOrigin","splitKeyword","delimRe","splitKeywords","catToS","Category","pathSepRe","BlankCategoryRE","parseCategories","xml","XMLParser","textNodeName","Categories","kwtags","KnownLensBrands","nikkor","zuiko","ZeissBatisHackRe","nonZeroish","LensMake","LensInfo","DNGLensInfo","LensSpec","LensModel","LensID","justLengthAndAperture","lensModels","LensType","LensType2","LensType3","Lens","lensModel","etc","lcLensModel","replacementLensMake","mfg","cleanBogusPrecision","mmRangeRE","apertureRE","significant","m1","Lower2Camel","companyCased","Constants","ignorables","ignorableSep","IgnorableMakePatterns","IgnorableModelPatterns","samsungPatterns","lgPatterns","onePlusPatterns","CommonNamesByMake","Samsung","LG","OnePlus","GoProRe","rawMake","stripQuotes","makeFromSoftware","Software","CreatorTool","HandlerDescription","goProMakeMaybe","toExifDefined","CameraModelName","CameraModel","SoftwarePatterns","Acer","Canon","Daisy","Fujifilm","GE","Kodak","Kyocera","Minolta","Nikon","Olympus","Pentax","Ricoh","RIM","rawSoftware","AncientSamsungModel","cleanMake","rawModel","commonName","intToRoman","isBaseRevision","isPrimitiveRevision","isPrimary","sourceIsPrimary","shown","sourceModifiedTime","resourceEvent","createdAtTs","revision","InstanceID","revisions","addRevision","addTag","revs","priorValue","MimetypeAliases","isMimeTypeIncluded","isChrome","isFirefox","escRE","matchQuotes","lifespanRE","modifierRE","uppercaseWordsRE","ignorableNameRE","parseName","compoundName","lifespan","modifier","givenNames","givenNameEnds","familyNames","givenNameSurroundREs","minFamilyNameIndex","onCapture","familyNameSurroundREs","commaIndex","givenNameCount","familyNameCount","western","cleanupNames","renderName","family","fam_given","suff","notEmptyOr","fam","TagRoots","Who","orientationToRotation","Orientation","CameraOrientation","Rotation","ExifOrientationToRotation","Rotation2ExifOrientation","rotationToExifOrientation","nr","clampRating","RatingPercent","cachedTags","strEql","isJson","srcName","sidecarName","mkExtsRegExp","srcEa","stripExt","sidecarEa","commonIdx","commonPrefixIgnoreCase","suffixOK","AllowedUncommonSuffixRe","aSuffixOK","bSuffixOK","isJsonFuzzyMatch","sizeInfoCache","_extractSizeInfoFromFile","defaultTags","rawInfo","_rawInfo","isDimensions","MaxSiblingsChecked","isSlowDir","isCachedDir","firstWithCapturedAt","nearestN","zipSibling","nearestSiblings","fromSibling","definedAndNotEql","beforeAfterCapturedAt","slots","bacaCache","younger","older","myIndex","findFileIndex","minMatch","youngerDE","olderDE","firstWithZoneName","fromName","dateFromPath","tagRefToS","tagref","tagPathToStringArray","tagPath","joinTagPath","_sep","TagSep","splitTagPath","tagPathToLowerStr","tagPathLeaf","isTagPathDescendant","des","tp","ancestry","displayName","bPaths","excluded","leaf","tagPaths","not","CameraID","nativePath2uris","nativePath2pslib","nativePath2psfile","nativePath2psnet","nativePath2uriVariants","uriEncodingVariants","isUri","fsPath","psfile2nativePath","psnet2nativePath","pslib2nativePath","volume","_schemePattern","_singleSlashStart","_doubleSlashStart","_empty","_slash","_regexp","thing","authority","fragment","schemeOrData","_strict","toURLSearchParams","_schemeFix","_referenceResolution","_validateUri","uriToFsPath","change","Uri","percentDecode","fixedPath","components","joinPath","pathFragment","win32","findLast","skipEncoding","_asFormatted","_pathSepMarker","_formatted","_fsPath","$mid","encodeTable","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","encodeURIComponent","escaped","encodeURIComponentMinimal","keepDriveLetterCasing","encoder","userinfo","q","decodeURIComponentGraceful","decodeURIComponent","_rEncodedAsHex","toUnicode","uriPrefixes","uriEqlSync","au","bu","joinMountpoint","fullPath","volPath","volsha","notMySep","mountpointMatchesPlatform","volshaVolume","bestVolumeForVolsha","PSLIB_ROOT_URI","libDir","relativePath","orig","lib","remoteHost","remoteShare","_path","share","isEquivalentHost","extractUpdateChannel","versionMajorMinor","DebianVersionRE","SemVer","patch","toSemver","semverSortBy","ord","prerelease","semverLatest","optionsOrLoose","includePrerelease","stable","systemUserAgent","channelVersions","getChannelVersions_","installedVersion","myChannel","channelCandidates","eligibleForChannel","versionCandidates","latestVersion","latestChannel","currentVerMsg","latestVerMsg","advice","updatedAt","lastCheckedMsg","msgs","semverGte","channelVersionsCache","httpGetJson_","config","preCacheTransform","updatedByVersion","isUpdateChannelVersion","fromCache","currentVolumeRoots","lazyFsAsync","DefaultExcludedLinuxMountpointNames","localMountpoints","dfPosixRaw","localsOnly","acceptPosixVolume","notAssetMountpoint","mightBeAssetMountpoint","excludedFS","filesystem","isExcludedFilesystem","excludedMP","excludedDir","isReadableDirectorySync","locals","isGioSupported","gioVolumes","dfVol","gioVol","assignMissingPrimitives","kibToBytes","parseDfVolumes","parseDfVolume","used","volumeInfoWin","DriveLetterRE","cleanDriveLetter","driveLetter","normalizeDriveLetter","getPsDriveCommand","parseGetPsDriveRow","Free","Used","label","DisplayRoot","parseRemoteName","getVolumeCommand","uuidRE","toDefinedAndNotEql","parseGetVolumeRow","DriveLetter","FileSystemLabel","notOkStatus","HealthStatus","OperationalStatus","Size","SizeRemaining","FileSystem","UniqueId","driveLetters","mountpointsWin","psDrivesJson","mapAsync","psDriveVols","getVolumesJson","getVolumesVols","unhealthy","healthyMountpoints","GioCommand","GioMountMonitorArgs","fuseDirs","thenFlatten","readProcMounts","gvfsFuseDirectories","remoteInfo","getRemoteInfo","setupVolumeTTL","URL","pathname","lsblk","localVolumes_lsblk_","blkid","localVolumes_blkid_","df","VersionRe","lsblkVersion","lsblkOutput","cols","fsused","fsavail","DEVNAME","PARTLABEL","LABEL","PARTUUID","UUID","mnt2uuidMac","uuids","diskDevices","diskRE","stdouts","dev","AllDisksAndPartitions","APFSVolumes","MountPoint","OSInternal","DeviceIdentifier","VolumeName","VolumeUUID","unsetMountpoints","mountpoints_","setMountpointsTTL","onMountpointsChanged","localMountpointSetup","diskUtilActivity","maybeWatchProcMounts","gioMountMonitor","isFindmntSupported","findmntPoll","priorMountpoints","mountpointsPosix","mkBasicWatchedChild","gioVols","ProcMounts","defaultFilesystemTypePredicate","fsType","defaultMountpointPredicate","procMounts","filesystemTypePredicate","mountpointPredicate","unoctal","fsOK","mpOK","mountpointsWinPwsh","mountpointsWinFsutil","driveletterRe","LinuxDevMapperRE","LinuxVarSnapRE","LinuxRunUserGVFSRE","LinuxDockerRE","whyExcludedMountpoint","smbRe","smbHostnameTrimmerRe","parseRemote","smb","nfs","nfsRe","netInfos","netInfoWin","toMap","netInfo","netuseCmd","UNC_RE","driveLetterRE","remoteName","_netInfoWinWmic","RemoteName","LocalName","Status","NetInfoCmd","ConnectionState","volumeUuidNotExpected","toVolumeUUID","clean","stripComments","readUuidFile_","readVolumeUUID","volUuidFile","savedUUID","writeVolumeUuid","thenOrOnTimeout","addVolumeUUID","mount2vol","mount2volsha","volsha2vol","replaceIfNewer","cacheVolume","volumeCacheDirs","mountpointToVolsha","loadCachedVolumes","deleteFileCache","cachedVolumes","readCachedVolumes","writeVolumesToCache","priorWriteVolumesToCacheLatch","fromHost","cleanHostname","name2vol","vol_mountpoints","priorVolumesIfMountpointsMatch","priorIsStale","priorIsMissingMountpoints","eqlPrimitiveUnordered","vp","bestMountpointForDir","bestRemoteVolume","withCorrectShare","withExactHostname","friendlyRemoteHost","asyncFind","canWriteVolumesToCache","withCurrentMountpoints","currentMountpoints","volumesImpl","shim0","hangMs","PS_VOLUMES_HANG_MS","rawDfVols","dfWin","dfPosix","dfVols","addRemoteVolumeInfoWin","addRemoteVolumeInfoPosix","addLocalVolumeInfoMac","addLocalVolumeInfoLinux","addVolumeUUIDs","rootPath","mounts","mount","volumeSha","volumeUuidSubpath","HttpStatusIs","HttpStatus","Accepted","MovedPermanently","Found","SeeOther","BadRequest","Unauthorized","Forbidden","NotFound","InternalServerError","NotImplemented","ServiceUnavailable","redirect","clientError","serverError","LibraryTagName","myWebUrls","hostnames","myExternalIp4Addresses","myWebUrl","uriToTagPath","mkTagUri","CussNativePath","loadCuss","words","cussTrie","asTrie","trie","small","TriePrefixLength","getCuss","naughtyWords","stripEmoji","unl33t","smol","bad","isCussy","a2l","l2a","origPrefix","prefixes","suffixes","cpus","availableParallelism","cpuInfoLength","logTooBusy","currentBusyPct","reasonableMaxCpuPct","singleThreadMode","CpuTimes","busyPctFromLoad","idlePct","busyMs","idleMs","sys","irq","idle","totalMs","loadavg","whyDoNotRun","estimatedFreeMem","freemem","intFromFileSync","cgroupMem","newPausedValue","clearMaxWorkCaches","timeoutRate","maxProcsForMem","worstCaseMemPerProc","estFreeMemMb","worstCaseMemPerProcMb","timeoutPenalization","timeoutsPerMinute","targetCpuLoadPct","cpuPortion","timeoutsPerSecond","penalization","resultBeforePenalization","resultAfterPenalization","upperBound","cpuLoadPct","refreshEveryMinute","rateStats","RequestTask","buff","errorFromJson","defaultTimeouts","WorkRequestMethods","onChild","bc","WorkerCluster","WorkerFunctions","workerMethodTimeouts","clearShims","_AllWorkerFunctions","closeChildProcesses","pingReq","workerEnv","healthCheckCommand","pretendMemUsageIsHigh","toPrimitive","isPrimitiveArray","eqlArray","keepIfTrue","toIndex","step","needles","vArr","cmp_","notBlankish","strings","expense","allowedDelta","newPos","currentExpense","newExpense","finalJoin","destination","deepSortBy","isIterable","mkSrcSet","toQuery","params","mergeURLSearchParams","URLSearchParams","append","assetUrl","assembleFullPath","assetImgActualLink","attrs","fmtLocalToShort","laterLoad","isSafari","ua","loading","srcSetArr","SqWidths","numericOr","globalThis","window","devicePixelRatio","onRetryWaitUntil","retry","retryCount","markdown","replaceAllMatches","BlankishRE","shortDateFormat","hms","includeMs","millis","pad3","setHours","fmtElapsedMs","dateParts","timeParts","toFixedStr","type_detect","memoizeCompare","leftHandOperand","rightHandOperand","memoizeMap","memoizeSet","leftHandMap","WeakMap","_deepEqual","comparator","extensiveDeepEqual","simpleResult","simpleEqual","memoizeResultLeft","memoizeResultRight","comparatorResult","leftHandType","keysEqual","iterableEqual","regexpEqual","getGeneratorEntries","generatorEqual","Uint8Array","leftHandItems","rightHandItems","entriesEqual","objectEqual","extensiveDeepEqualByType","getIteratorEntries","hasIteratorFunction","iteratorError","generator","generatorResult","getEnumerableKeys","getEnumerableSymbols","allKeys","getOwnPropertySymbols","getOwnPropertyDescriptor","enumerable","leftHandKeys","rightHandKeys","mapSymbols","leftHandEntries","rightHandEntries","applied","isNode","isBrowser","withinRatio","space","pixels2size","swappableRotation","dateComparator","functionComparator","deepEql","objComparators","fieldComparators","FramesToIgnoreRE","errorToArr","maxLines","inputAspectRatio","largestUnitIndex","remaining","fmtList","joinWord","HealthCheckEmoji","Summary","Library","System","OkLevels","HealthCheckLevelToEmoji","HealthCheckLevelDescription","emoji","FitSizeValues","SqSizes","decycle","stringifyPretty","indent","Revivers","parseJSON_","retrocycle","reviver","dateToJson","errorToJson","derez","nu","_value","$ref","hasOwnProperty","call","$","px","rez","eval","_state","_resolve","_reject","onfinally","Lazy","t1","t3","addUniq","flatValues","findKeyByTuple","filterKeysByTuple","document","numeralRE","nonNumericRE","isBigInt","mapPredicate","isToNumber","toNumber","nton","MIN_SAFE_INTEGER","ston","toPrecision","decimalPlaces","numerator","denominator","expected","mustBeGreaterThan","orElseF","decimals","fractionDigits","log10","maxValid","rnd","notEmptyObj","pairs","mapFields","isReqValued","block","omitKeys","assignNullish","srcKeys","compactValuesDeep","keyNames","pickDeep","flat","deepKeysByLocalField","keysToOmit","methods","Reflect","getPrototypeOf","ownKeys","lckey","flattenObject","NoneImpl","zip1","zip2","zip3","None","Some","isOpt","ec","ed","pads","char","padNumeric","irregular","es","consonant_y","vowel_y","is","irr","primitiveTypes","TypeLevel","a_str","b_str","shorterArrayIsLessThan","eaP","ifTrue","rndInt","random","randomInts","excludeSet","slotsRemaining","candidate","randomChar","RandomChars","trueRatio","NumericChars","LowercaseChars","nonZeroes","rand","mod","valueToIndex","dict","mapValid","isBMP","codePointAt","_graphemeSegmenter","graphemeSegmenter","Segmenter","granularity","sliceIterable","segment","charArr","leftIndexOf","countIterable","stripPrefixes","leftSliceAt","rightSliceAt","searchValue","replaceValue","fmtHMS","timeoutAtTs","latch","runTs","onComplete","isThrottled","PS_LIBRARY_PROTOCOL","PS_LOCAL_FILE_PROTOCOL","PS_NETWORK_FILESYSTEM_PROTOCOL","PS_EXAMPLES_SCHEME","isURLSearchParams","queries","numberFormat","NumberFormat","thousandsSep","decimalSep","TB","GiB","TiB","byteUnits","mebiUnits","mag","megabytes","MP","SizeDescriptions","navigator","chromeRE","safariRE","firefoxRE","ipadRE","iphoneRE","matches","tagId","SyncStatuses","RebuildingURI","EmptyDeletedURI","EmptyRemovedURI","ProgressWithAssetsProps","ThumbsPerSample","BeforeAfterStreamLimit","crit","TagGalleryProps","tagIds","NotInfoPanelTags","Camera","Type","rootNameOrTag","ensureSeed","forceNewSeed","usp","urlSeed","mkTagFullPath","prngSeed","objs","toStr","DefaultToString","joinChar","fileCleanups","imageCacheCleanup","readdirCleanup","sharedFileCleanup","previewWipCleanup","advisoryLockWipCleanup","library","forceRunTagMaintenance","dbModelSetup_","runDbBackup","vacuumStatDbDirs","scheduleFileAndProcCleanups","Asset","dbl","runf","Operation","where","OperationNames","enqueueAssetFileUpdates","orWhere","enqueueAssetUpdates","priorDir","priorWasOpen","isReadySync","priorEnded","priorInstance","endPriorInstance","instanceReady","instanceRequired","readyLatch","throwIfEnding","statsDbDir_","previewsVol","isDbService","dbModelJanitor","previews","statsDb","libraryHealthCheckSetup","assetFileRepository","AssetFileRepository","libraryDbFile","dbFsLock","fslock","modelDb","DbModelJanitor","statsDbJanitor","statsDbFile","isPendingSetup","backup_","validateFile","notBlocklistedSha","isValidFile","sentryEnabled","sendToSentry","Sentry","captureException","init","dsn","shutdownTimeout","maxBreadcrumbs","integrations","beforeSend","eventFilter","onFatalError","EventFilter","hint","extractMessage","annotateEvent","getCurrentHub","getClient","sentryExceptionsToS","exception","originalException","sentryExceptionToS","getEmail","breadcrumbs","mkBreadcrumbs","serviceEnding","runtimeMs","memoryUsageRssMb","systemMemory","ffmpeg","allRecentLogEntries","logEntryToBreadcrumb","logLevelToSeverity","level2sev","setupEventHandlers","inputHandlers","rl","onLine","addDefaultInputHandlers","isReady","exitted","setInputHandler","knownCommands","stdinReceiver","canContinue","setProcessTitle","mergeUserDataDirs_","isLibraryRequiredService","addErrorFlags","isWorker","installSentry","calcVolumesTTL","volFree","minFreeDefaultBytes","free","minFree","excessFree","secondsUntilFull","newTTL","durationHMS","defaultTTL","statDbDirs","CacheDirPrefix","createIfMissing","LibraryUID","SystemUID","rmStatDbDir","currentCacheDir","newestTs","WorkQueue","queueNames","processItem","concurrent","endWhenDone","_processItem","processRate","processMs","recentlyProcessed","queues","Queue","ops","upsert","queueIds","queueItemCount","QueueItem","pluckFirstf","qb","countDistinct","whereIn","pendingWorkCount","throttle","doNotStartMoreWork","awaitDrain","isRunnable","findQueue_","queueName","enqueueWork","queue","upserted","upsertWorkItems","postProcessItem","recentFileProgress","contents","processedCount","currentWorkCount","percents","todo","completePct","incompletePct","currentQueueItems","currentQueueContents","currentQueueItemIds","etaMs","currentWork","pendingWork","next10","recentlyProcessedLast10","priorDone","allf","distinct","andWhere","q1","whereNotIn","orderBy","DropWorkQueuesArg","dropQueues","ExitWhenDone","ExitWhenDoneArg","ForceArg","supportsTail","LogArgs","maybeLogStdout","isDaemon","tail","NoFilterArg","RebuildArg","rebuild","SkipUpdateArg","skipUpdates","albumFromFile","albumFromTags","titlePath","whyExclude","firstSubstringIgnoreCase","Albums","parseJsonDate","releasedAt","tagAsset","primaryVariation","priorTagPaths","capturedAts","cameraTagFile","lensTagFile","dateTagFile","whoTagFiles","keywordTagFiles","typeTagFiles","tagAssetPaths","tagFilesWithAlbums","normalizeTagRoot","tagDeltas","asset","getExistingAssetFiles","existing_uris","existingPrimaryAssetFile","primaryVariant","posixFile_","priorPrimaryAF","getShown","newPrimary","priorPrimary","setShown_","thenCollect","getAssetFiles","getTagPaths","getCapturedAts","tagResult","excludedTag","blocklistShas","unlinkAssetFiles","excludedAt","addTags","removeTags","updateFromFiles","cameraTag","localeSync","months","yearToOrdinal","monthToOrdinal","oneIndexedMonth","dayToOrdinal","yearTagRef","monthTagRef","dayTagRef","dateTag","monthTagOrdinal","bestCapturedAt","addFileUriTagsToAsset","displayNameForVolsha","pluckAllf","select","delimSpaceRe","extractDashDashTags","extractPathnameTags","UrlRE","normalizeKeywordPaths","urls","arr3","paths1","kws1","pathNames","uniqIgnoreCase","kws","retain","Keywords","kw","dedupeKeywordPaths","lcdiff","processKeywords","keywords","rawKwWhoTags","nonWhoKws","isWhoTag","kwWhoTags","nameTag","whoNames","stripTagRoot","lensTag","WhenRoot","AlbumsRoot","WhoRoot","KwRoot","Roots","rootNamesLowerCase","hasTagRoot","albumRootsLowerCased","kwRootsLowerCased","whoRootsLowerCased","tagDiff","tagPathsInclude","mimetypes","mimeTypeToTag","Cases","friendlySubtype","Subtypes","subtype","fullMimeType","fixCase","regionList","RegionList","region","renderNameTag","closeDb","maxUpdatedAt","migrate_","repaired","dbSetupError","verifyDb_","repair_","Migration","appliedMigrations","apply_","tableInfo_","localTableInfo","inTransaction","priorWasNull","verify_","assertHeartbeat_","handleDbRetries","checkpoint_","repairDbFile_","isDestDirRW","isRW","hotDestDb","dbBackupCold_","tablenames","escStr","destFile","backup","remainingPages","totalPages","NoWriteLock","Contested","dbFslock","libraryDbObjects_","retentionCount","backupsDir","fslockRelease","vacuumBackups","victims","forceBackup_","hasDbSetupErrors","dbSetupErrors","me","owner","runMaintenanceTasks","newMaxUpdatedAt","destDbFile","teardownLock","libraryDbInfoFromDbFile","isUpdateReadyToInstall","fsLockForDb","libraryDbInfoJsonFile","assertValidDbInfo_","infoJsonFile","expectedLiveDbFile","liveDbFile","addDbSetupError","libraryDbLockObjects_","liveDbInfo","getLiveDbDir_","clearDbSetupErrors","MaxBatchSize","tableName","cachedStatements","knex","prep","toSqlQuery","stmt","database","sqlQuery","sqlQueryToS","bindings","runScript","mapRun","firstf","mapAll","batched","onResults","pluckFirst","pluckAll","pluckBatched","schemaJsonFile","actualTableInfo","actualTableNames","expectedTableInfo","tableInfo","expectedTableNames","missing","diffEql","dbModelHealthCheck","_dbSetupErrors","notifyListeners","isDbValue","isDbValued","mergeTags_","leafs","winner","losers","winnerId","parentTagPath","winnerTagPath","parentId","loserIds","like","fromParentPath","iterate","dupes","ids","client","useNullAsDefault","fsMigrations_","migrationsDir","ensureMigrationTable_","unknownMigrations_","migrationsInDatabase_","migrationNameToDate","assertKnownMigrations_","unknownMigrations","pendingMigrationFiles_","inDb","onBeforeMigrate","applyMigration_","addMigrationStmt","codeMigration","disableForeignKeys","foreignKeyCheck_","psnetRe","plucklabmodeb6","labModes","splitLabs","tag_path_suffix","isoToPrecisionMs","lowercase_psnet_function","broken","lowercase_psnet_hostname","function","deterministic","numeric_captured_at","spread_modes","normalize_asset_file_uris","normalizeURI","afs","dedupe_tag_paths","dedupeTags_","suffix_tag_paths","normalize_tag_paths","badTags","correctPath","normalizeTagPath","drop_tc_tables","tables","rebuild_rotated_heic","rebuild_videos","copy_asset_duration","pragmaOrThrow_","okResult","simple","dbToPath","quickCheck_","integrityCheck_","badRows","dbInvalidForeignKeyThreshold","badRowsCount","rowid","verifyDbFile_","withDbSync","destDb","withDb","_backupDbFile_","checkpointType","AUTO","busy","IgnorableDumpErrorRe","srcDbPath","sqliteSizeBytes","dumpProc","load","isSqlQuery","toSQL","parseTableInfo","notnull","pk","dbfile","dbRepairLink","tryRepair","assertValidDbSchema_","Heartbeat","assertPing_","addDbSetupErrorListener","syncHealthCheck","volumeUuidHealthCheck","pathsToSync","posixFiles","findAsync","acceptParentAndFileAndSimple","noUriPaths","duplicateUUIDVolumes","missingUUIDs","unhealthyVolumes","scannedVolumes","Unhidden","TimestampedModel","assetIdish","updateCount","mergedTags","posixFile","AssetRevision","MergedTags","shownUnhidden","findUnhiddenById","shownRemovable","whereNotNull","shownCount","deletePreviews","upsertToShaBlockslist","AssetTag","deletedMeta","trashOrUnlinkFileUris_","assetFileMeta","dbResult","deletedPreviews","nextOutdated","findOne","nextOutdateds","outdatedCount","findFirstByFile","uniqTagPaths","Tag","findOrCreate","addTagsToAsset","findByPath","removeTagsFromAsset","unshownAssetIds","archive","markUnshownAndUpsert","markShownAndUpsert_","shownAssetFile","priorShownId","previouslyShown","skipUpsert","toAssetId","renderCaption","fmtLocalDateShort","whenApiTag","toApiTag","addTagPaths","findAssetFileByUri","addAssetFile","assetFileForFile_","upsertIfNeeded_","setFile_","getTags","orderByRaw","getStreams","streams","getAssetStream","coalesceStreams","getAncestors","getBeforeAfterId","sameIds","clearSelect","afterId","beforeId","findBy","afId","changes","r2","runResult","shownAF","getShownNativePath","getNativePath","link","sqAttrs","getImgAttrs","skipFs","poster","fitAttrs","videoAttrs","controls","autoplay","videoSources","firstExistingAF","assetVideoLink","getPosixFiles","findOrCreateByFile","partialSimpleAsset","liked","deletedAt","column","order","$tableName","$uniqueColumnName","$booleanFields","uriObj","isShaBlockslisted","isFileDeleted","outdatedQuery","q2","orWhereLike","shownAssetFileId","primaryForAssetId","uriRoot","andWhereLike","recentAssetIdsByUriRoot","since","assetFileCountByMimeType","assetFileCount","assetCount","assetFileCountWithMimeType","mimeRootOrType","assetFileCountByMimeTypeRoots","mimeRootOrTypes","mimeTypeRoot","uriParent","whereLike","sameShaInLibrary","sameAssetFileInLibrary","whereNot","librarySiblings","getAsset","capturedAtLocale","assignAllFields","whyNotMatchesFile","outdated","fileUri","ff","fileFields_","matchesFile","whyNot","whyNotInSyncWithFile","inSyncWithFile","whyNotInSync","isNoop","whyNotNoop","whyNotMatches","mayCopyAssetsToLibrary","repo","whyNotCopyFile","existingLibraryAssetFile","syncState","isVersionUpToDate","siblingCount","andWhereNot","updateFromFile_","updateFileFields_","mkAssetFile_","updateFromShaSibling_","whySiblingIsInvalid","$transientFields","originalDownloadable","brief","downloadables","shownSha","previewToDownloadable","pathInfo","_pathInfo_","toApiPathElements","tagLineage","nativePathSuffix","pathSep","lastTagName","isLibraryUri","thisVolSha","tagVolSha","toApi","createdAtLocale","fmtMillis","updatedAtLocale","insert","_priorValueJson","_newValueJson","$pk","ChangedTag","upsertChangedTagIds","onConflict","ignore","$useCache","onAssetRemoval","getAllChangedTags","lagtimeMs","compressWhitespace","deleteChangedTag","monthQuery","dayQuery","getMonthTags","andWhereRaw","normalizeMonthTag","tagRef","ordinalToMonth","changeName","maybeUpsertDisplayName","upsertOne","fromDb","findOneBy","_normalizeDateTags","progressVacuum","normalizeDateTags","Progress","$instanceId","$ctor","$schema","queryBy","constraint","queryOneBy","_ops","ModelOps","truncate","$ops","class","$ucn","$uid","$toShallowJSON","Obj","$_toJSON","encodeBool","$toDbJSON","colNames","boolToInt","includeCtor","includeTransient","$clone","_get","mc","columnNames","insertOne","assignFromJSON","$afterUpsert","$beforeUpsert","reload","reloadOne","ldd","ctor2class","addModelClass","caller","updatableColumnNames","immutableColumnNames","ucnFieldNames","ucn","DbRequest","$cache","$cachedByJson","$pickModelUcn","$cachedById","dbOpen","toDbValued","dbv","fromJSONs","pojos","findByIds","uncachedIds","findWhereIn","countf","modelSupportsUpsert","insertOrUpdateOne","updateOne","dbJson","runInfo","lastInsertRowid","unsetField","updateRecord","ucnConstraint","onConflictClause","skip","doUpdate","onConflictArr","bk","skipReturn","maxId","jsons","setKeys","incomplete","whereNull","ensurePendingOp","getFirstPendingOp","markOpCompleted","completedAt","applyIfPending","applyOnce","priorCompleted","ProgressRateMs","ProgressTimesQuery","defaultMinCreatedAt","victimIds","metaVictimIds","ProgressMeta","minCreatedAt","saveSyncState","insertNew","dekJSON","dek","toSyncState","hed","scanningPct","assignFromPojo","getThisMeta","progressId","getPriorIncompleteProgress","getPriorIncompleteMeta","getMeta","thisMeta","priorMeta","setMeta","deleteMeta","deleteAllMeta","getMetaAsRecord","ProgressMetaNames","dbr","upsertFileToShaBlockslist","shas","listenForInvalidFiles","installBadShaShim","builder","AssetCountForTag","displayPath","getParent","ancestorIds","firstNonInterstitialTagId","directAssetCount","getChildrenCount","getChildren","roots","_upsertDefaultRoots","validate_","whereRaw","parentPath","expectedParentPath","cacheTags","cacheTag","withNullAssetCount","selfAndAncestorIds","updateAssetCount","findByIdOrPath","getPagedAssets","getPagedAssetIds","newTag","assets","relatedAssets","siblingPath","changePath","_displayName","finallyClear","priorPath","existingSibling","$childrenQuery","$assetsQuery","$selectAssetIdColumns","$assetIdsQuery","setAncestors","getAncestorsAndSelf","toPathTag","toStringId","getPagedChildren","begin","childTag","rootName","ancestorsAndSelf","_getAncestors","getAssets","assetCountDesc","getAssetCount","$assetStreamQuery","same","TaggedAssetStream","getRelatedAssetIds","prngOrderByClause","TagFts","insertFts","tag_fts_root","tag_fts_path","tn","cmpAssetAsc","cmpAssetDesc","retainFirstN","assetIdsAfter","assetIdsBefore","mergeWith","tas","pushUniqBy","beforeIds","afterIds","streamCoeff","minStreamCorr","prefilter","gtOrElse","createdAtDate","updatedAtDate","applyRemovable","assetIds","dbAssetFileCount","mkDek","deletedFiles","maybeUpdateProgress","maybeApplyExcluded","maybeApplyDeleted","assetFileUpdatesUri2QueueName","assetUpdatesUri2QueueName","StatsModel","itemCountForQueues","thenOrElse","queueId","itemCount","workItems","qi","dbDir","isStatsDbMigrator","AssetFileFinder","alreadySynced","AssetIdCreationMutex","SerialLaterQueue","timedLazy","priorIfSynced","newAssetFile_","tags_","dominantLabhashes","capturedAt_","mapSibling","assetFile","newAssetFileForAsset","withExistingAsset","byExistingAsset_","strategies","byUri","assetByNormalizedPathUri","assetBySha","assetByCapturedAtOrImageHash","maybeAsset","firstSimilarAsset","bounds","firstSimilarAssetByQuery","whereBetween","whereILike","wideBounds","orWhereIn","thisAF","cal","whyNotSameAsset","AssetFileImporter","libraryFileFiltersFor","uaa","assetFile_","srcAssetFile","newAssetFile","postResult","assetPostUpsertTasks_","newAssetFileUris","shouldCopy","candidates","priorAssetId","findLibraryFileWithSameContents","importFile_","maybeCopyToLibrary_","copiedSidecars","copiedInferredMetadata","upsertNeeded","mkAssetUrl","destAF","readCapturedAt","pathToLibraryAsset","existing","uniqDest","srcSidecar","destSidecar","sidecarEql","copyTo","ensureInferredHistoryRecords","lastOneInWins","LastOneInWins","skipAssetTagging","previewsUpdated","transcoded","libAf","updateAssetPreviews_","primary","bestExistingAssetFile","primaryOrShownAssetFile_","tagAndUpsertAsset_","primaryPosixFile","transcode_","_postUpsertAssetTasks_","upsertError","isImportResult","isErrorResult","backfillUpdate","upd","notUpd","originalAsset","originalPrimaryAF","_updateAssetFile_","sortedAssetFiles","bestAcceptedAF","assetIdsToUpdate","retainAFs","rejectAFs","partitionAsync","rejectClusters","aggregateAssetFiles","rejectAsset","rejectAssetId","rejectCluster","uniqFields","boundaries","startBoundary","endBoundary","externalAssetFiles","qb1","orWhereBetween","similarAssetFiles","assetChanged","primaryAssetFileChanged","_updateAsset_","newUri","handleAssetFileUriChange","updateAssetFileIfNeeded","priorUri","afsWithNewUri","afIds","firstExistsWins","fc","newInfo","primaryAssetFile","eqlsPrior","validUpdateCommandOrElse","UpdateTask","isUpdateSuccessResult","describeUpdateCommand","assetPreviewId","handleUpdateCommand","updateAsset","updateAssetFile","isNonRetriable","SyncService","CLI","AssetFileQueue","fileProcessor","_fileProcessor","fileListener","possibleAssets","enqueueSimpleFiles","updateFreshFiles","stale","precheckFiles","imgQueue","vidQueue","waitForCompletion","clearRecentlyProcessed","currentPaths","currentBaseFiles","hasPath","currentVideoJobCount","processedImageCount","processedVideoCount","avgImageProcessingTime","avgVideoProcessingTime","currentCounterState","itemQuery","pendingContent","pendingImagesCount","pendingVideoCount","videos","images","isAssetFileExt","enqueueOrTouchAssetFiles","freshAssetFileIds","copyToLibrary","staleFiles","syncProgress","whyStale","needToCopy","AssetPostUpsertQueueName","DirectorySync","rootUri","afq","_isScanning","ETA","recentlyScannedDirs","scannedDirsCount","preDone","priorProcessedImageCount","priorProcessedVideoCount","_progress","forceDirectoryScan","isArgvPath","initialMeta","saveSyncProgress","saveLastScannedDirectory","scannedDirectoryCount","lastScannedDirectory","earliestStartTime","priorTimes","lastStartedAt","recent","recentSyncReports","stuck","unprocessedPaths_","stuck_length","maybeEnqueueStaleAssetFiles","isScanning","counts","pcts","directoryWalker","enqueuedStaleFiles","assetFileQueuePendingCount","estimatedScannedPct","bogusEst","scannedPct","processed","imgConcurrency","imgCount","vidCount","imgMs","vidMs","completedDirectoryScan","DirectoryTaggerOperation","priorProgress","_eta","_done","_run","doneCount","todoCount","est","msRemaining","onlyShownAssetFiles","byAsset","priors","_ended","ModelDbUpdater","updatedAssetIds","_outdatedAssetCount","outdatedAssetCount","assetFileUpdateQueue","afqName","afqEnded","afqRunnable","workStats","postUpsertQueue","mkAssetPostUpsertQueue","assetUpdateQueue","mkAssetUpdateQueue","assetUpdater","aqName","aqEnded","newIds","endAll","isNoOp","assetFilesPending","msPerEvent","aqPending","volumeUriPaths","toUriPath","scanDir","uriPath","nativePathToUriPath","posixFileToUriPath","nativePathBlocklist","uri2file","byDir","inSyncAssetFileIds","maxUpdatedDeltaTs","freshPaths","ProgressUpdater","SyncCompleted","syncCompleted","pathsAndTimesToSync","bestStable","staleCompletedAt","getStaleCompletedAt","lastCompletedAt","lastStarted","lastCompleted","lastUpdated","lastUpdatedAt","stalePaths","mostRecentlyUpdated","neverStartedBefore","neverCompletedBefore","leastRecentlyCompleted","uptToStatus","tsToISO","tsToAgo","dur","isNext","lastStartedISO","lastCompletedISO","SyncRunner","endCurrentSync","_doneLatch","maybeSetupNextSync","currentSync","currentSyncUri","setSyncPath","upt","syncAndRunNext","maybeDirSync","this_ended","doneLatch_state","bestPathToSync","currentSyncPath","HandledTasks","progressUpdater","stripPrefixSuffix","processFile","currentProcessing","taskListeners","setupShimDelegates","isHealthCheckLevelFatal","rmStatDbDirs","checkPendingOperations","modelDbUpdater","updateAllTagCounts","checkSync","maybeRestartSyncOnVolumeChange","cleanup_","maybeRestartSync","setVolumesTTL","directoryTaggerOp","mdu","dto","argvPaths","Syncs","forPaths","waitForSyncAndCleanup","addTaskProcessor","Service","jobs","processCount","cancelSync","importFileToResult","we","ra","raf","reTag","syncForPath","FileSync","addIdsToQueue","currentUriRoots","enqueueAssetFileUpdatesForUri","assetFileUpdatesQueueName2uri","enqueueAssetUpdatesForUri","leftJoin","maybeUri","tag_path","tagFtsRebuild","MinCallDelayMs","updateTagCountSql","ct","tc","prepQueries","vacuumOrphanTags","vacuumLeafTags","leftOuterJoin","updateTagMountpoints","countedTags","updatedTagIds","nullTagIds","changedTags","changedTagsById","changedTag","updateChangedTagCounts","newMinCallDelayMs","fileRoot","fixFileRootTag","_reset","volumeSHA","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","nmd","__webpack_exports__"],"sourceRoot":""}